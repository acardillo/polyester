{
  "metadata": {
    "python_version": "3.12",
    "module_count": 194,
    "function_count": 1471,
    "extracted_at": "2026-02-09T11:53:24.503890"
  },
  "data": [
    {
      "id": "stdlib.abc.ABC",
      "name": "ABC",
      "module": "abc",
      "type": "class",
      "signature": "()",
      "description": "Helper class that provides a standard way to create an ABC using\ninheritance.",
      "relationships": []
    },
    {
      "id": "stdlib.abc.ABCMeta",
      "name": "ABCMeta",
      "module": "abc",
      "type": "class",
      "signature": "(name, bases, namespace, /, **kwargs)",
      "description": "Metaclass for defining Abstract Base Classes (ABCs).\n\nUse this metaclass to create an ABC.  An ABC can be subclassed\ndirectly, and then acts as a mix-in class.  You can also register\nunrelated concrete classes (even built-in classes) and unrelated\nABCs as 'virtual subclasses' -- these and their descendants will\nbe considered subclasses of the registering ABC by the built-in\nissubclass() function, but the registering ABC won't show up in\ntheir MRO (Method Resolution Order) nor will method\nimplementations defined by the registering ABC be callable (not\neven via super()).",
      "relationships": [
        {
          "target": "stdlib.builtins.type",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.abc.abstractclassmethod",
      "name": "abstractclassmethod",
      "module": "abc",
      "type": "class",
      "signature": "(callable)",
      "description": "A decorator indicating abstract classmethods.\n\nDeprecated, use 'classmethod' with 'abstractmethod' instead:\n\n    class C(ABC):\n        @classmethod\n        @abstractmethod\n        def my_abstract_classmethod(cls, ...):\n            ...",
      "relationships": [
        {
          "target": "stdlib.builtins.classmethod",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.abc.abstractmethod",
      "name": "abstractmethod",
      "module": "abc",
      "type": "function",
      "signature": "(funcobj)",
      "description": "A decorator indicating abstract methods.\n\nRequires that the metaclass is ABCMeta or derived from it.  A\nclass that has a metaclass derived from ABCMeta cannot be\ninstantiated unless all of its abstract methods are overridden.\nThe abstract methods can be called using any of the normal\n'super' call mechanisms.  abstractmethod() may be used to declare\nabstract methods for properties and descriptors.\n\nUsage:\n\n    class C(metaclass=ABCMeta):\n        @abstractmethod\n        def my_abstract_method(self, arg1, arg2, argN):\n            ...",
      "relationships": []
    },
    {
      "id": "stdlib.abc.abstractproperty",
      "name": "abstractproperty",
      "module": "abc",
      "type": "class",
      "signature": "(fget=None, fset=None, fdel=None, doc=None)",
      "description": "A decorator indicating abstract properties.\n\nDeprecated, use 'property' with 'abstractmethod' instead:\n\n    class C(ABC):\n        @property\n        @abstractmethod\n        def my_abstract_property(self):\n            ...",
      "relationships": [
        {
          "target": "stdlib.builtins.property",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.abc.abstractstaticmethod",
      "name": "abstractstaticmethod",
      "module": "abc",
      "type": "class",
      "signature": "(callable)",
      "description": "A decorator indicating abstract staticmethods.\n\nDeprecated, use 'staticmethod' with 'abstractmethod' instead:\n\n    class C(ABC):\n        @staticmethod\n        @abstractmethod\n        def my_abstract_staticmethod(...):\n            ...",
      "relationships": [
        {
          "target": "stdlib.builtins.staticmethod",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.abc.update_abstractmethods",
      "name": "update_abstractmethods",
      "module": "abc",
      "type": "function",
      "signature": "(cls)",
      "description": "Recalculate the set of abstract methods of an abstract class.\n\nIf a class has had one of its abstract methods implemented after the\nclass was created, the method will not be considered implemented until\nthis function is called. Alternatively, if a new abstract method has been\nadded to the class, it will only be considered an abstract method of the\nclass after this function is called.\n\nThis function should be called before any use is made of the class,\nusually in class decorators that add methods to the subject class.\n\nReturns cls, to allow usage as a class decorator.\n\nIf cls is not an instance of ABCMeta, does nothing.",
      "relationships": []
    },
    {
      "id": "stdlib.aifc.Aifc_read",
      "name": "Aifc_read",
      "module": "aifc",
      "type": "class",
      "signature": "(f)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.aifc.Aifc_write",
      "name": "Aifc_write",
      "module": "aifc",
      "type": "class",
      "signature": "(f)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.aifc.open",
      "name": "open",
      "module": "aifc",
      "type": "function",
      "signature": "(f, mode=None)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.antigravity.geohash",
      "name": "geohash",
      "module": "antigravity",
      "type": "function",
      "signature": "(latitude, longitude, datedow)",
      "description": "Compute geohash() using the Munroe algorithm.\n\n>>> geohash(37.421542, -122.085589, b'2005-05-26-10458.68')\n37.857713 -122.544543",
      "relationships": []
    },
    {
      "id": "stdlib.argparse.Action",
      "name": "Action",
      "module": "argparse",
      "type": "class",
      "signature": "(option_strings, dest, nargs=None, const=None, default=None, type=None, choices=None, required=False, help=None, metavar=None)",
      "description": "Information about how to convert command line strings to Python objects.\n\nAction objects are used by an ArgumentParser to represent the information\nneeded to parse a single argument from one or more strings from the\ncommand line. The keyword arguments to the Action constructor are also\nall attributes of Action instances.\n\nKeyword Arguments:\n\n    - option_strings -- A list of command-line option strings which\n        should be associated with this action.\n\n    - dest -- The name of the attribute to hold the created object(s)\n\n    - nargs -- The number of command-line arguments that should be\n        consumed. By default, one argument will be consumed and a single\n        value will be produced.  Other values include:\n            - N (an integer) consumes N arguments (and produces a list)\n            - '?' consumes zero or one arguments\n            - '*' consumes zero or more arguments (and produces a list)\n            - '+' consumes one or more arguments (and produces a list)\n        Note that the difference between the default and nargs=1 is that\n        with the default, a single value will be produced, while with\n        nargs=1, a list containing a single value will be produced.\n\n    - const -- The value to be produced if the option is specified and the\n        option uses an action that takes no values.\n\n    - default -- The value to be produced if the option is not specified.\n\n    - type -- A callable that accepts a single string argument, and\n        returns the converted value.  The standard Python types str, int,\n        float, and complex are useful examples of such callables.  If None,\n        str is used.\n\n    - choices -- A container of values that should be allowed. If not None,\n        after a command-line argument has been converted to the appropriate\n        type, an exception will be raised if it is not a member of this\n        collection.\n\n    - required -- True if the action must always be specified at the\n        command line. This is only meaningful for optional command-line\n        arguments.\n\n    - help -- The help string describing the argument.\n\n    - metavar -- The name to be used for the option's argument with the\n        help string. If None, the 'dest' value will be used as the name.",
      "relationships": [
        {
          "target": "stdlib.argparse._AttributeHolder",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.argparse.ArgumentDefaultsHelpFormatter",
      "name": "ArgumentDefaultsHelpFormatter",
      "module": "argparse",
      "type": "class",
      "signature": "(prog, indent_increment=2, max_help_position=24, width=None)",
      "description": "Help message formatter which adds default values to argument help.\n\nOnly the name of this class is considered a public API. All the methods\nprovided by the class are considered an implementation detail.",
      "relationships": [
        {
          "target": "stdlib.argparse.HelpFormatter",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.argparse.ArgumentError",
      "name": "ArgumentError",
      "module": "argparse",
      "type": "class",
      "signature": "(argument, message)",
      "description": "An error from creating or using an argument (optional or positional).\n\nThe string value of this exception is the message, augmented with\ninformation about the argument that caused it.",
      "relationships": [
        {
          "target": "stdlib.builtins.Exception",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.argparse.ArgumentParser",
      "name": "ArgumentParser",
      "module": "argparse",
      "type": "class",
      "signature": "(prog=None, usage=None, description=None, epilog=None, parents=[], formatter_class=<class 'argparse.HelpFormatter'>, prefix_chars='-', fromfile_prefix_chars=None, argument_default=None, conflict_handler='error', add_help=True, allow_abbrev=True, exit_on_error=True)",
      "description": "Object for parsing command line strings into Python objects.\n\nKeyword Arguments:\n    - prog -- The name of the program (default:\n        ``os.path.basename(sys.argv[0])``)\n    - usage -- A usage message (default: auto-generated from arguments)\n    - description -- A description of what the program does\n    - epilog -- Text following the argument descriptions\n    - parents -- Parsers whose arguments should be copied into this one\n    - formatter_class -- HelpFormatter class for printing help messages\n    - prefix_chars -- Characters that prefix optional arguments\n    - fromfile_prefix_chars -- Characters that prefix files containing\n        additional arguments\n    - argument_default -- The default value for all arguments\n    - conflict_handler -- String indicating how to handle conflicts\n    - add_help -- Add a -h/-help option\n    - allow_abbrev -- Allow long options to be abbreviated unambiguously\n    - exit_on_error -- Determines whether or not ArgumentParser exits with\n        error info when an error occurs",
      "relationships": [
        {
          "target": "stdlib.argparse._AttributeHolder",
          "type": "base_class"
        },
        {
          "target": "stdlib.argparse._ActionsContainer",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.argparse.BooleanOptionalAction",
      "name": "BooleanOptionalAction",
      "module": "argparse",
      "type": "class",
      "signature": "(option_strings, dest, default=None, type=<object object at 0x100108ac0>, choices=<object object at 0x100108ac0>, required=False, help=None, metavar=<object object at 0x100108ac0>)",
      "description": "Information about how to convert command line strings to Python objects.\n\nAction objects are used by an ArgumentParser to represent the information\nneeded to parse a single argument from one or more strings from the\ncommand line. The keyword arguments to the Action constructor are also\nall attributes of Action instances.\n\nKeyword Arguments:\n\n    - option_strings -- A list of command-line option strings which\n        should be associated with this action.\n\n    - dest -- The name of the attribute to hold the created object(s)\n\n    - nargs -- The number of command-line arguments that should be\n        consumed. By default, one argument will be consumed and a single\n        value will be produced.  Other values include:\n            - N (an integer) consumes N arguments (and produces a list)\n            - '?' consumes zero or one arguments\n            - '*' consumes zero or more arguments (and produces a list)\n            - '+' consumes one or more arguments (and produces a list)\n        Note that the difference between the default and nargs=1 is that\n        with the default, a single value will be produced, while with\n        nargs=1, a list containing a single value will be produced.\n\n    - const -- The value to be produced if the option is specified and the\n        option uses an action that takes no values.\n\n    - default -- The value to be produced if the option is not specified.\n\n    - type -- A callable that accepts a single string argument, and\n        returns the converted value.  The standard Python types str, int,\n        float, and complex are useful examples of such callables.  If None,\n        str is used.\n\n    - choices -- A container of values that should be allowed. If not None,\n        after a command-line argument has been converted to the appropriate\n        type, an exception will be raised if it is not a member of this\n        collection.\n\n    - required -- True if the action must always be specified at the\n        command line. This is only meaningful for optional command-line\n        arguments.\n\n    - help -- The help string describing the argument.\n\n    - metavar -- The name to be used for the option's argument with the\n        help string. If None, the 'dest' value will be used as the name.",
      "relationships": [
        {
          "target": "stdlib.argparse.Action",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins._AttributeHolder",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.argparse.FileType",
      "name": "FileType",
      "module": "argparse",
      "type": "class",
      "signature": "(mode='r', bufsize=-1, encoding=None, errors=None)",
      "description": "Factory for creating file object types\n\nInstances of FileType are typically passed as type= arguments to the\nArgumentParser add_argument() method.\n\nKeyword Arguments:\n    - mode -- A string indicating how the file is to be opened. Accepts the\n        same values as the builtin open() function.\n    - bufsize -- The file's desired buffer size. Accepts the same values as\n        the builtin open() function.\n    - encoding -- The file's encoding. Accepts the same values as the\n        builtin open() function.\n    - errors -- A string indicating how encoding and decoding errors are to\n        be handled. Accepts the same value as the builtin open() function.",
      "relationships": []
    },
    {
      "id": "stdlib.argparse.HelpFormatter",
      "name": "HelpFormatter",
      "module": "argparse",
      "type": "class",
      "signature": "(prog, indent_increment=2, max_help_position=24, width=None)",
      "description": "Formatter for generating usage messages and argument help strings.\n\nOnly the name of this class is considered a public API. All the methods\nprovided by the class are considered an implementation detail.",
      "relationships": []
    },
    {
      "id": "stdlib.argparse.MetavarTypeHelpFormatter",
      "name": "MetavarTypeHelpFormatter",
      "module": "argparse",
      "type": "class",
      "signature": "(prog, indent_increment=2, max_help_position=24, width=None)",
      "description": "Help message formatter which uses the argument 'type' as the default\nmetavar value (instead of the argument 'dest')\n\nOnly the name of this class is considered a public API. All the methods\nprovided by the class are considered an implementation detail.",
      "relationships": [
        {
          "target": "stdlib.argparse.HelpFormatter",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.argparse.Namespace",
      "name": "Namespace",
      "module": "argparse",
      "type": "class",
      "signature": "(**kwargs)",
      "description": "Simple object for storing attributes.\n\nImplements equality by attribute names and values, and provides a simple\nstring representation.",
      "relationships": [
        {
          "target": "stdlib.argparse._AttributeHolder",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.argparse.RawDescriptionHelpFormatter",
      "name": "RawDescriptionHelpFormatter",
      "module": "argparse",
      "type": "class",
      "signature": "(prog, indent_increment=2, max_help_position=24, width=None)",
      "description": "Help message formatter which retains any formatting in descriptions.\n\nOnly the name of this class is considered a public API. All the methods\nprovided by the class are considered an implementation detail.",
      "relationships": [
        {
          "target": "stdlib.argparse.HelpFormatter",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.argparse.RawTextHelpFormatter",
      "name": "RawTextHelpFormatter",
      "module": "argparse",
      "type": "class",
      "signature": "(prog, indent_increment=2, max_help_position=24, width=None)",
      "description": "Help message formatter which retains formatting of all help text.\n\nOnly the name of this class is considered a public API. All the methods\nprovided by the class are considered an implementation detail.",
      "relationships": [
        {
          "target": "stdlib.argparse.RawDescriptionHelpFormatter",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.HelpFormatter",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.ast.ExtSlice",
      "name": "ExtSlice",
      "module": "ast",
      "type": "class",
      "signature": "(dims=(), **kwargs)",
      "description": "Deprecated AST node class. Use ast.Tuple instead.",
      "relationships": [
        {
          "target": "stdlib.ast.slice",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.AST",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.ast.Index",
      "name": "Index",
      "module": "ast",
      "type": "class",
      "signature": "(value, **kwargs)",
      "description": "Deprecated AST node class. Use the index value directly instead.",
      "relationships": [
        {
          "target": "stdlib.ast.slice",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.AST",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.ast.NodeTransformer",
      "name": "NodeTransformer",
      "module": "ast",
      "type": "class",
      "signature": "()",
      "description": "A :class:`NodeVisitor` subclass that walks the abstract syntax tree and\nallows modification of nodes.\n\nThe `NodeTransformer` will walk the AST and use the return value of the\nvisitor methods to replace or remove the old node.  If the return value of\nthe visitor method is ``None``, the node will be removed from its location,\notherwise it is replaced with the return value.  The return value may be the\noriginal node in which case no replacement takes place.\n\nHere is an example transformer that rewrites all occurrences of name lookups\n(``foo``) to ``data['foo']``::\n\n   class RewriteName(NodeTransformer):\n\n       def visit_Name(self, node):\n           return Subscript(\n               value=Name(id='data', ctx=Load()),\n               slice=Constant(value=node.id),\n               ctx=node.ctx\n           )\n\nKeep in mind that if the node you're operating on has child nodes you must\neither transform the child nodes yourself or call the :meth:`generic_visit`\nmethod for the node first.\n\nFor nodes that were part of a collection of statements (that applies to all\nstatement nodes), the visitor may also return a list of nodes rather than\njust a single node.\n\nUsually you use the transformer like this::\n\n   node = YourTransformer().visit(node)",
      "relationships": [
        {
          "target": "stdlib.ast.NodeVisitor",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.ast.NodeVisitor",
      "name": "NodeVisitor",
      "module": "ast",
      "type": "class",
      "signature": "()",
      "description": "A node visitor base class that walks the abstract syntax tree and calls a\nvisitor function for every node found.  This function may return a value\nwhich is forwarded by the `visit` method.\n\nThis class is meant to be subclassed, with the subclass adding visitor\nmethods.\n\nPer default the visitor functions for the nodes are ``'visit_'`` +\nclass name of the node.  So a `TryFinally` node visit function would\nbe `visit_TryFinally`.  This behavior can be changed by overriding\nthe `visit` method.  If no visitor function exists for a node\n(return value `None`) the `generic_visit` visitor is used instead.\n\nDon't use the `NodeVisitor` if you want to apply changes to nodes during\ntraversing.  For this a special visitor exists (`NodeTransformer`) that\nallows modifications.",
      "relationships": []
    },
    {
      "id": "stdlib.ast.copy_location",
      "name": "copy_location",
      "module": "ast",
      "type": "function",
      "signature": "(new_node, old_node)",
      "description": "Copy source location (`lineno`, `col_offset`, `end_lineno`, and `end_col_offset`\nattributes) from *old_node* to *new_node* if possible, and return *new_node*.",
      "relationships": []
    },
    {
      "id": "stdlib.ast.dump",
      "name": "dump",
      "module": "ast",
      "type": "function",
      "signature": "(node, annotate_fields=True, include_attributes=False, *, indent=None)",
      "description": "Return a formatted dump of the tree in node.  This is mainly useful for\ndebugging purposes.  If annotate_fields is true (by default),\nthe returned string will show the names and the values for fields.\nIf annotate_fields is false, the result string will be more compact by\nomitting unambiguous field names.  Attributes such as line\nnumbers and column offsets are not dumped by default.  If this is wanted,\ninclude_attributes can be set to true.  If indent is a non-negative\ninteger or string, then the tree will be pretty-printed with that indent\nlevel. None (the default) selects the single line representation.",
      "relationships": []
    },
    {
      "id": "stdlib.ast.fix_missing_locations",
      "name": "fix_missing_locations",
      "module": "ast",
      "type": "function",
      "signature": "(node)",
      "description": "When you compile a node tree with compile(), the compiler expects lineno and\ncol_offset attributes for every node that supports them.  This is rather\ntedious to fill in for generated nodes, so this helper adds these attributes\nrecursively where not already set, by setting them to the values of the\nparent node.  It works recursively starting at *node*.",
      "relationships": [
        {
          "target": "stdlib.ast.iter_child_nodes",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ast.get_docstring",
      "name": "get_docstring",
      "module": "ast",
      "type": "function",
      "signature": "(node, clean=True)",
      "description": "Return the docstring for the given node or None if no docstring can\nbe found.  If the node provided does not have docstrings a TypeError\nwill be raised.\n\nIf *clean* is `True`, all tabs are expanded to spaces and any whitespace\nthat can be uniformly removed from the second line onwards is removed.",
      "relationships": []
    },
    {
      "id": "stdlib.ast.get_source_segment",
      "name": "get_source_segment",
      "module": "ast",
      "type": "function",
      "signature": "(source, node, *, padded=False)",
      "description": "Get source code segment of the *source* that generated *node*.\n\nIf some location information (`lineno`, `end_lineno`, `col_offset`,\nor `end_col_offset`) is missing, return None.\n\nIf *padded* is `True`, the first line of a multi-line statement will\nbe padded with spaces to match its original position.",
      "relationships": [
        {
          "target": "stdlib.ast._splitlines_no_ff",
          "type": "calls"
        },
        {
          "target": "stdlib.ast._pad_whitespace",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ast.increment_lineno",
      "name": "increment_lineno",
      "module": "ast",
      "type": "function",
      "signature": "(node, n=1)",
      "description": "Increment the line number and end line number of each node in the tree\nstarting at *node* by *n*. This is useful to \"move code\" to a different\nlocation in a file.",
      "relationships": [
        {
          "target": "stdlib.ast.walk",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ast.iter_child_nodes",
      "name": "iter_child_nodes",
      "module": "ast",
      "type": "function",
      "signature": "(node)",
      "description": "Yield all direct child nodes of *node*, that is, all fields that are nodes\nand all items of fields that are lists of nodes.",
      "relationships": [
        {
          "target": "stdlib.ast.iter_fields",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ast.iter_fields",
      "name": "iter_fields",
      "module": "ast",
      "type": "function",
      "signature": "(node)",
      "description": "Yield a tuple of ``(fieldname, value)`` for each field in ``node._fields``\nthat is present on *node*.",
      "relationships": []
    },
    {
      "id": "stdlib.ast.literal_eval",
      "name": "literal_eval",
      "module": "ast",
      "type": "function",
      "signature": "(node_or_string)",
      "description": "Evaluate an expression node or a string containing only a Python\nexpression.  The string or node provided may only consist of the following\nPython literal structures: strings, bytes, numbers, tuples, lists, dicts,\nsets, booleans, and None.\n\nCaution: A complex expression can overflow the C stack and cause a crash.",
      "relationships": [
        {
          "target": "stdlib.ast.parse",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ast.main",
      "name": "main",
      "module": "ast",
      "type": "function",
      "signature": "()",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.ast.parse",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.dump",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ast.parse",
      "name": "parse",
      "module": "ast",
      "type": "function",
      "signature": "(source, filename='<unknown>', mode='exec', *, type_comments=False, feature_version=None)",
      "description": "Parse the source into an AST node.\nEquivalent to compile(source, filename, mode, PyCF_ONLY_AST).\nPass type_comments=True to get back type comments where the syntax allows.",
      "relationships": []
    },
    {
      "id": "stdlib.ast.unparse",
      "name": "unparse",
      "module": "ast",
      "type": "function",
      "signature": "(ast_obj)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.ast.walk",
      "name": "walk",
      "module": "ast",
      "type": "function",
      "signature": "(node)",
      "description": "Recursively yield all descendant nodes in the tree starting at *node*\n(including *node* itself), in no specified order.  This is useful if you\nonly want to modify nodes in place and don't care about the context.",
      "relationships": [
        {
          "target": "stdlib.ast.iter_child_nodes",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.base64.a85decode",
      "name": "a85decode",
      "module": "base64",
      "type": "function",
      "signature": "(b, *, foldspaces=False, adobe=False, ignorechars=b' \\t\\n\\r\\x0b')",
      "description": "Decode the Ascii85 encoded bytes-like object or ASCII string b.\n\nfoldspaces is a flag that specifies whether the 'y' short sequence should be\naccepted as shorthand for 4 consecutive spaces (ASCII 0x20). This feature is\nnot supported by the \"standard\" Adobe encoding.\n\nadobe controls whether the input sequence is in Adobe Ascii85 format (i.e.\nis framed with <~ and ~>).\n\nignorechars should be a byte string containing characters to ignore from the\ninput. This should only contain whitespace characters, and by default\ncontains all whitespace characters in ASCII.\n\nThe result is returned as a bytes object.",
      "relationships": [
        {
          "target": "stdlib.base64._bytes_from_decode_data",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.base64.a85encode",
      "name": "a85encode",
      "module": "base64",
      "type": "function",
      "signature": "(b, *, foldspaces=False, wrapcol=0, pad=False, adobe=False)",
      "description": "Encode bytes-like object b using Ascii85 and return a bytes object.\n\nfoldspaces is an optional flag that uses the special short sequence 'y'\ninstead of 4 consecutive spaces (ASCII 0x20) as supported by 'btoa'. This\nfeature is not supported by the \"standard\" Adobe encoding.\n\nwrapcol controls whether the output should have newline (b'\\n') characters\nadded to it. If this is non-zero, each output line will be at most this\nmany characters long, excluding the trailing newline.\n\npad controls whether the input is padded to a multiple of 4 before\nencoding. Note that the btoa implementation always pads.\n\nadobe controls whether the encoded byte sequence is framed with <~ and ~>,\nwhich is used by the Adobe implementation.",
      "relationships": [
        {
          "target": "stdlib.base64._85encode",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.base64.b16decode",
      "name": "b16decode",
      "module": "base64",
      "type": "function",
      "signature": "(s, casefold=False)",
      "description": "Decode the Base16 encoded bytes-like object or ASCII string s.\n\nOptional casefold is a flag specifying whether a lowercase alphabet is\nacceptable as input.  For security purposes, the default is False.\n\nThe result is returned as a bytes object.  A binascii.Error is raised if\ns is incorrectly padded or if there are non-alphabet characters present\nin the input.",
      "relationships": [
        {
          "target": "stdlib.base64._bytes_from_decode_data",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.base64.b16encode",
      "name": "b16encode",
      "module": "base64",
      "type": "function",
      "signature": "(s)",
      "description": "Encode the bytes-like object s using Base16 and return a bytes object.\n    ",
      "relationships": []
    },
    {
      "id": "stdlib.base64.b32decode",
      "name": "b32decode",
      "module": "base64",
      "type": "function",
      "signature": "(s, casefold=False, map01=None)",
      "description": "Decode the base32 encoded bytes-like object or ASCII string s.\n\nOptional casefold is a flag specifying whether a lowercase alphabet is\nacceptable as input.  For security purposes, the default is False.\n\nRFC 3548 allows for optional mapping of the digit 0 (zero) to the\nletter O (oh), and for optional mapping of the digit 1 (one) to\neither the letter I (eye) or letter L (el).  The optional argument\nmap01 when not None, specifies which letter the digit 1 should be\nmapped to (when map01 is not None, the digit 0 is always mapped to\nthe letter O).  For security purposes the default is None, so that\n0 and 1 are not allowed in the input.\n\nThe result is returned as a bytes object.  A binascii.Error is raised if\nthe input is incorrectly padded or if there are non-alphabet\ncharacters present in the input.",
      "relationships": [
        {
          "target": "stdlib.base64._b32decode",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.base64.b32encode",
      "name": "b32encode",
      "module": "base64",
      "type": "function",
      "signature": "(s)",
      "description": "Encode the bytes-like objects using base32 and return a bytes object.",
      "relationships": [
        {
          "target": "stdlib.base64._b32encode",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.base64.b32hexdecode",
      "name": "b32hexdecode",
      "module": "base64",
      "type": "function",
      "signature": "(s, casefold=False)",
      "description": "Decode the base32hex encoded bytes-like object or ASCII string s.\n\nOptional casefold is a flag specifying whether a lowercase alphabet is\nacceptable as input.  For security purposes, the default is False.\n\nThe result is returned as a bytes object.  A binascii.Error is raised if\nthe input is incorrectly padded or if there are non-alphabet\ncharacters present in the input.",
      "relationships": [
        {
          "target": "stdlib.base64._b32decode",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.base64.b32hexencode",
      "name": "b32hexencode",
      "module": "base64",
      "type": "function",
      "signature": "(s)",
      "description": "Encode the bytes-like objects using base32hex and return a bytes object.",
      "relationships": [
        {
          "target": "stdlib.base64._b32encode",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.base64.b64decode",
      "name": "b64decode",
      "module": "base64",
      "type": "function",
      "signature": "(s, altchars=None, validate=False)",
      "description": "Decode the Base64 encoded bytes-like object or ASCII string s.\n\nOptional altchars must be a bytes-like object or ASCII string of length 2\nwhich specifies the alternative alphabet used instead of the '+' and '/'\ncharacters.\n\nThe result is returned as a bytes object.  A binascii.Error is raised if\ns is incorrectly padded.\n\nIf validate is False (the default), characters that are neither in the\nnormal base-64 alphabet nor the alternative alphabet are discarded prior\nto the padding check.  If validate is True, these non-alphabet characters\nin the input result in a binascii.Error.\nFor more information about the strict base64 check, see:\n\nhttps://docs.python.org/3.11/library/binascii.html#binascii.a2b_base64",
      "relationships": [
        {
          "target": "stdlib.base64._bytes_from_decode_data",
          "type": "calls"
        },
        {
          "target": "stdlib.base64._bytes_from_decode_data",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.base64.b64encode",
      "name": "b64encode",
      "module": "base64",
      "type": "function",
      "signature": "(s, altchars=None)",
      "description": "Encode the bytes-like object s using Base64 and return a bytes object.\n\nOptional altchars should be a byte string of length 2 which specifies an\nalternative alphabet for the '+' and '/' characters.  This allows an\napplication to e.g. generate url or filesystem safe Base64 strings.",
      "relationships": []
    },
    {
      "id": "stdlib.base64.b85decode",
      "name": "b85decode",
      "module": "base64",
      "type": "function",
      "signature": "(b)",
      "description": "Decode the base85-encoded bytes-like object or ASCII string b\n\nThe result is returned as a bytes object.",
      "relationships": [
        {
          "target": "stdlib.base64._bytes_from_decode_data",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.base64.b85encode",
      "name": "b85encode",
      "module": "base64",
      "type": "function",
      "signature": "(b, pad=False)",
      "description": "Encode bytes-like object b in base85 format and return a bytes object.\n\nIf pad is true, the input is padded with b'\\0' so its length is a multiple of\n4 bytes before encoding.",
      "relationships": [
        {
          "target": "stdlib.base64._85encode",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.base64.decode",
      "name": "decode",
      "module": "base64",
      "type": "function",
      "signature": "(input, output)",
      "description": "Decode a file; input and output are binary files.",
      "relationships": []
    },
    {
      "id": "stdlib.base64.decodebytes",
      "name": "decodebytes",
      "module": "base64",
      "type": "function",
      "signature": "(s)",
      "description": "Decode a bytestring of base-64 data into a bytes object.",
      "relationships": [
        {
          "target": "stdlib.base64._input_type_check",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.base64.encode",
      "name": "encode",
      "module": "base64",
      "type": "function",
      "signature": "(input, output)",
      "description": "Encode a file; input and output are binary files.",
      "relationships": []
    },
    {
      "id": "stdlib.base64.encodebytes",
      "name": "encodebytes",
      "module": "base64",
      "type": "function",
      "signature": "(s)",
      "description": "Encode a bytestring into a bytes object containing multiple lines\nof base-64 data.",
      "relationships": [
        {
          "target": "stdlib.base64._input_type_check",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.base64.main",
      "name": "main",
      "module": "base64",
      "type": "function",
      "signature": "()",
      "description": "Small main program",
      "relationships": []
    },
    {
      "id": "stdlib.base64.standard_b64decode",
      "name": "standard_b64decode",
      "module": "base64",
      "type": "function",
      "signature": "(s)",
      "description": "Decode bytes encoded with the standard Base64 alphabet.\n\nArgument s is a bytes-like object or ASCII string to decode.  The result\nis returned as a bytes object.  A binascii.Error is raised if the input\nis incorrectly padded.  Characters that are not in the standard alphabet\nare discarded prior to the padding check.",
      "relationships": [
        {
          "target": "stdlib.base64.b64decode",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.base64.standard_b64encode",
      "name": "standard_b64encode",
      "module": "base64",
      "type": "function",
      "signature": "(s)",
      "description": "Encode bytes-like object s using the standard Base64 alphabet.\n\nThe result is returned as a bytes object.",
      "relationships": [
        {
          "target": "stdlib.base64.b64encode",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.base64.urlsafe_b64decode",
      "name": "urlsafe_b64decode",
      "module": "base64",
      "type": "function",
      "signature": "(s)",
      "description": "Decode bytes using the URL- and filesystem-safe Base64 alphabet.\n\nArgument s is a bytes-like object or ASCII string to decode.  The result\nis returned as a bytes object.  A binascii.Error is raised if the input\nis incorrectly padded.  Characters that are not in the URL-safe base-64\nalphabet, and are not a plus '+' or slash '/', are discarded prior to the\npadding check.\n\nThe alphabet uses '-' instead of '+' and '_' instead of '/'.",
      "relationships": [
        {
          "target": "stdlib.base64._bytes_from_decode_data",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.b64decode",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.base64.urlsafe_b64encode",
      "name": "urlsafe_b64encode",
      "module": "base64",
      "type": "function",
      "signature": "(s)",
      "description": "Encode bytes using the URL- and filesystem-safe Base64 alphabet.\n\nArgument s is a bytes-like object to encode.  The result is returned as a\nbytes object.  The alphabet uses '-' instead of '+' and '_' instead of\n'/'.",
      "relationships": [
        {
          "target": "stdlib.base64.b64encode",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.bdb.Bdb",
      "name": "Bdb",
      "module": "bdb",
      "type": "class",
      "signature": "(skip=None)",
      "description": "Generic Python debugger base class.\n\nThis class takes care of details of the trace facility;\na derived class should implement user interaction.\nThe standard debugger class (pdb.Pdb) is an example.\n\nThe optional skip argument must be an iterable of glob-style\nmodule name patterns.  The debugger will not step into frames\nthat originate in a module that matches one of these patterns.\nWhether a frame is considered to originate in a certain module\nis determined by the __name__ in the frame globals.",
      "relationships": []
    },
    {
      "id": "stdlib.bdb.Breakpoint",
      "name": "Breakpoint",
      "module": "bdb",
      "type": "class",
      "signature": "(file, line, temporary=False, cond=None, funcname=None)",
      "description": "Breakpoint class.\n\nImplements temporary breakpoints, ignore counts, disabling and\n(re)-enabling, and conditionals.\n\nBreakpoints are indexed by number through bpbynumber and by\nthe (file, line) tuple using bplist.  The former points to a\nsingle instance of class Breakpoint.  The latter points to a\nlist of such instances since there may be more than one\nbreakpoint per line.\n\nWhen creating a breakpoint, its associated filename should be\nin canonical form.  If funcname is defined, a breakpoint hit will be\ncounted when the first line of that function is executed.  A\nconditional breakpoint always counts a hit.",
      "relationships": []
    },
    {
      "id": "stdlib.bdb.Tdb",
      "name": "Tdb",
      "module": "bdb",
      "type": "class",
      "signature": "(skip=None)",
      "description": "Generic Python debugger base class.\n\nThis class takes care of details of the trace facility;\na derived class should implement user interaction.\nThe standard debugger class (pdb.Pdb) is an example.\n\nThe optional skip argument must be an iterable of glob-style\nmodule name patterns.  The debugger will not step into frames\nthat originate in a module that matches one of these patterns.\nWhether a frame is considered to originate in a certain module\nis determined by the __name__ in the frame globals.",
      "relationships": [
        {
          "target": "stdlib.bdb.Bdb",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.bdb.bar",
      "name": "bar",
      "module": "bdb",
      "type": "function",
      "signature": "(a)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.bdb.checkfuncname",
      "name": "checkfuncname",
      "module": "bdb",
      "type": "function",
      "signature": "(b, frame)",
      "description": "Return True if break should happen here.\n\nWhether a break should happen depends on the way that b (the breakpoint)\nwas set.  If it was set via line number, check if b.line is the same as\nthe one in the frame.  If it was set via function name, check if this is\nthe right function and if it is on the first executable line.",
      "relationships": []
    },
    {
      "id": "stdlib.bdb.effective",
      "name": "effective",
      "module": "bdb",
      "type": "function",
      "signature": "(file, line, frame)",
      "description": "Return (active breakpoint, delete temporary flag) or (None, None) as\nbreakpoint to act upon.\n\nThe \"active breakpoint\" is the first entry in bplist[line, file] (which\nmust exist) that is enabled, for which checkfuncname is True, and that\nhas neither a False condition nor a positive ignore count.  The flag,\nmeaning that a temporary breakpoint should be deleted, is False only\nwhen the condiion cannot be evaluated (in which case, ignore count is\nignored).\n\nIf no such entry exists, then (None, None) is returned.",
      "relationships": [
        {
          "target": "stdlib.bdb.checkfuncname",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.bdb.foo",
      "name": "foo",
      "module": "bdb",
      "type": "function",
      "signature": "(n)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.bdb.bar",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.bdb.set_trace",
      "name": "set_trace",
      "module": "bdb",
      "type": "function",
      "signature": "()",
      "description": "Start debugging with a Bdb instance from the caller's frame.",
      "relationships": []
    },
    {
      "id": "stdlib.bdb.test",
      "name": "test",
      "module": "bdb",
      "type": "function",
      "signature": "()",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.bz2.BZ2File",
      "name": "BZ2File",
      "module": "bz2",
      "type": "class",
      "signature": "(filename, mode='r', *, compresslevel=9)",
      "description": "A file object providing transparent bzip2 (de)compression.\n\nA BZ2File can act as a wrapper for an existing file object, or refer\ndirectly to a named file on disk.\n\nNote that BZ2File provides a *binary* file interface - data read is\nreturned as bytes, and data to be written should be given as bytes.",
      "relationships": [
        {
          "target": "stdlib._compression.BaseStream",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.BufferedIOBase",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins._BufferedIOBase",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.IOBase",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins._IOBase",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.bz2.compress",
      "name": "compress",
      "module": "bz2",
      "type": "function",
      "signature": "(data, compresslevel=9)",
      "description": "Compress a block of data.\n\ncompresslevel, if given, must be a number between 1 and 9.\n\nFor incremental compression, use a BZ2Compressor object instead.",
      "relationships": []
    },
    {
      "id": "stdlib.bz2.decompress",
      "name": "decompress",
      "module": "bz2",
      "type": "function",
      "signature": "(data)",
      "description": "Decompress a block of data.\n\nFor incremental decompression, use a BZ2Decompressor object instead.",
      "relationships": []
    },
    {
      "id": "stdlib.bz2.open",
      "name": "open",
      "module": "bz2",
      "type": "function",
      "signature": "(filename, mode='rb', compresslevel=9, encoding=None, errors=None, newline=None)",
      "description": "Open a bzip2-compressed file in binary or text mode.\n\nThe filename argument can be an actual filename (a str, bytes, or\nPathLike object), or an existing file object to read from or write\nto.\n\nThe mode argument can be \"r\", \"rb\", \"w\", \"wb\", \"x\", \"xb\", \"a\" or\n\"ab\" for binary mode, or \"rt\", \"wt\", \"xt\" or \"at\" for text mode.\nThe default mode is \"rb\", and the default compresslevel is 9.\n\nFor binary mode, this function is equivalent to the BZ2File\nconstructor: BZ2File(filename, mode, compresslevel). In this case,\nthe encoding, errors and newline arguments must not be provided.\n\nFor text mode, a BZ2File object is created, and wrapped in an\nio.TextIOWrapper instance with the specified encoding, error\nhandling behavior, and line ending(s).",
      "relationships": []
    },
    {
      "id": "stdlib.cProfile.label",
      "name": "label",
      "module": "cProfile",
      "type": "function",
      "signature": "(code)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.cProfile.main",
      "name": "main",
      "module": "cProfile",
      "type": "function",
      "signature": "()",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.cProfile.runctx",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.cProfile.run",
      "name": "run",
      "module": "cProfile",
      "type": "function",
      "signature": "(statement, filename=None, sort=-1)",
      "description": "Run statement under profiler optionally saving results in filename\n\nThis function takes a single argument that can be passed to the\n\"exec\" statement, and an optional file name.  In all cases this\nroutine attempts to \"exec\" its first argument and gather profiling\nstatistics from the execution. If no file name is present, then this\nfunction automatically prints a simple profiling report, sorted by the\nstandard name string (file/line/function-name) that is presented in\neach line.",
      "relationships": []
    },
    {
      "id": "stdlib.cProfile.runctx",
      "name": "runctx",
      "module": "cProfile",
      "type": "function",
      "signature": "(statement, globals, locals, filename=None, sort=-1)",
      "description": "Run statement under profiler, supplying your own globals and locals,\noptionally saving results in filename.\n\nstatement and filename have the same semantics as profile.run",
      "relationships": []
    },
    {
      "id": "stdlib.calendar.Calendar",
      "name": "Calendar",
      "module": "calendar",
      "type": "class",
      "signature": "(firstweekday=0)",
      "description": "Base calendar class. This class doesn't do any formatting. It simply\nprovides data to subclasses.",
      "relationships": []
    },
    {
      "id": "stdlib.calendar.Day",
      "name": "Day",
      "module": "calendar",
      "type": "class",
      "signature": "(*values)",
      "description": "Enum where members are also (and must be) ints",
      "relationships": [
        {
          "target": "stdlib.enum.IntEnum",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.int",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.ReprEnum",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Enum",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.calendar.HTMLCalendar",
      "name": "HTMLCalendar",
      "module": "calendar",
      "type": "class",
      "signature": "(firstweekday=0)",
      "description": "This calendar returns complete HTML pages.",
      "relationships": [
        {
          "target": "stdlib.calendar.Calendar",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.calendar.IllegalMonthError",
      "name": "IllegalMonthError",
      "module": "calendar",
      "type": "class",
      "signature": "(month)",
      "description": "Inappropriate argument value (of correct type).",
      "relationships": [
        {
          "target": "stdlib.builtins.ValueError",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.IndexError",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.LookupError",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Exception",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.calendar.IllegalWeekdayError",
      "name": "IllegalWeekdayError",
      "module": "calendar",
      "type": "class",
      "signature": "(weekday)",
      "description": "Inappropriate argument value (of correct type).",
      "relationships": [
        {
          "target": "stdlib.builtins.ValueError",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Exception",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.calendar.LocaleHTMLCalendar",
      "name": "LocaleHTMLCalendar",
      "module": "calendar",
      "type": "class",
      "signature": "(firstweekday=0, locale=None)",
      "description": "This class can be passed a locale name in the constructor and will return\nmonth and weekday names in the specified locale.",
      "relationships": [
        {
          "target": "stdlib.calendar.HTMLCalendar",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Calendar",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.calendar.LocaleTextCalendar",
      "name": "LocaleTextCalendar",
      "module": "calendar",
      "type": "class",
      "signature": "(firstweekday=0, locale=None)",
      "description": "This class can be passed a locale name in the constructor and will return\nmonth and weekday names in the specified locale.",
      "relationships": [
        {
          "target": "stdlib.calendar.TextCalendar",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Calendar",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.calendar.Month",
      "name": "Month",
      "module": "calendar",
      "type": "class",
      "signature": "(*values)",
      "description": "Enum where members are also (and must be) ints",
      "relationships": [
        {
          "target": "stdlib.enum.IntEnum",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.int",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.ReprEnum",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Enum",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.calendar.TextCalendar",
      "name": "TextCalendar",
      "module": "calendar",
      "type": "class",
      "signature": "(firstweekday=0)",
      "description": "Subclass of Calendar that outputs a calendar as a simple plain text\nsimilar to the UNIX program cal.",
      "relationships": [
        {
          "target": "stdlib.calendar.Calendar",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.calendar.different_locale",
      "name": "different_locale",
      "module": "calendar",
      "type": "class",
      "signature": "(locale)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.calendar.format",
      "name": "format",
      "module": "calendar",
      "type": "function",
      "signature": "(cols, colwidth=20, spacing=6)",
      "description": "Prints multi-column formatting for year calendars",
      "relationships": [
        {
          "target": "stdlib.calendar.formatstring",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.calendar.formatstring",
      "name": "formatstring",
      "module": "calendar",
      "type": "function",
      "signature": "(cols, colwidth=20, spacing=6)",
      "description": "Returns a string formatted from n strings, centered within n columns.",
      "relationships": []
    },
    {
      "id": "stdlib.calendar.isleap",
      "name": "isleap",
      "module": "calendar",
      "type": "function",
      "signature": "(year)",
      "description": "Return True for leap years, False for non-leap years.",
      "relationships": []
    },
    {
      "id": "stdlib.calendar.leapdays",
      "name": "leapdays",
      "module": "calendar",
      "type": "function",
      "signature": "(y1, y2)",
      "description": "Return number of leap years in range [y1, y2).\nAssume y1 <= y2.",
      "relationships": []
    },
    {
      "id": "stdlib.calendar.main",
      "name": "main",
      "module": "calendar",
      "type": "function",
      "signature": "(args)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.calendar._validate_month",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.calendar.monthrange",
      "name": "monthrange",
      "module": "calendar",
      "type": "function",
      "signature": "(year, month)",
      "description": "Return weekday of first day of month (0-6 ~ Mon-Sun)\nand number of days (28-31) for year, month.",
      "relationships": [
        {
          "target": "stdlib.calendar._validate_month",
          "type": "calls"
        },
        {
          "target": "stdlib.calendar.weekday",
          "type": "calls"
        },
        {
          "target": "stdlib.calendar.isleap",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.calendar.setfirstweekday",
      "name": "setfirstweekday",
      "module": "calendar",
      "type": "function",
      "signature": "(firstweekday)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.calendar.timegm",
      "name": "timegm",
      "module": "calendar",
      "type": "function",
      "signature": "(tuple)",
      "description": "Unrelated but handy function to calculate Unix timestamp from GMT.",
      "relationships": []
    },
    {
      "id": "stdlib.calendar.weekday",
      "name": "weekday",
      "module": "calendar",
      "type": "function",
      "signature": "(year, month, day)",
      "description": "Return weekday (0-6 ~ Mon-Sun) for year, month (1-12), day (1-31).",
      "relationships": []
    },
    {
      "id": "stdlib.cgi.FieldStorage",
      "name": "FieldStorage",
      "module": "cgi",
      "type": "class",
      "signature": "(fp=None, headers=None, outerboundary=b'', environ=environ({'OSLogRateLimit': '64', 'MallocNanoZone': '0', 'USER': 'anthonycardillo', 'COMMAND_MODE': 'unix2003', '__CFBundleIdentifier': 'com.todesktop.230313mzl4w4u92', 'PATH': '/Users/anthonycardillo/Documents/personal/polyester/.venv/bin:/opt/homebrew/opt/postgresql@16/bin:/Users/anthonycardillo/.bun/bin:/Users/anthonycardillo/.bun/bin:/Users/anthonycardillo/.nvm/versions/node/v22.21.0/bin:/opt/homebrew/bin:/opt/homebrew/sbin:/usr/local/bin:/System/Cryptexes/App/usr/bin:/usr/bin:/bin:/usr/sbin:/sbin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/local/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/appleinternal/bin:/opt/pmk/env/global/bin:/Library/Apple/usr/bin:/opt/homebrew/opt/postgresql@16/bin:/Users/anthonycardillo/.bun/bin:/Users/anthonycardillo/.nvm/versions/node/v22.21.0/bin:/Users/anthonycardillo/.cursor/extensions/ms-python.debugpy-2025.18.0-darwin-arm64/bundled/scripts/noConfigScripts', 'LOGNAME': 'anthonycardillo', 'SSH_AUTH_SOCK': '/private/tmp/com.apple.launchd.fAtscmMPP1/Listeners', 'HOME': '/Users/anthonycardillo', 'SHELL': '/bin/zsh', 'TMPDIR': '/var/folders/6c/95f1yxcd673848zqjnj46_ww0000gn/T/', '__CF_USER_TEXT_ENCODING': '0x1F5:0x0:0x52', 'XPC_SERVICE_NAME': '0', 'XPC_FLAGS': '0x0', 'ORIGINAL_XDG_CURRENT_DESKTOP': 'undefined', 'CURSOR_TRACE_ID': '09c74175785640a8ac5df17c65b4361b', 'SHLVL': '1', 'PWD': '/Users/anthonycardillo/Documents/personal/polyester', 'OLDPWD': '/Users/anthonycardillo/Documents/personal/polyester', 'LANG': 'C.UTF-8', 'HOMEBREW_PREFIX': '/opt/homebrew', 'HOMEBREW_CELLAR': '/opt/homebrew/Cellar', 'HOMEBREW_REPOSITORY': '/opt/homebrew', 'INFOPATH': '/opt/homebrew/share/info:/opt/homebrew/share/info:', 'NVM_DIR': '/Users/anthonycardillo/.nvm', 'NVM_CD_FLAGS': '-q', 'NVM_BIN': '/Users/anthonycardillo/.nvm/versions/node/v22.21.0/bin', 'NVM_INC': '/Users/anthonycardillo/.nvm/versions/node/v22.21.0/include/node', 'BUN_INSTALL': '/Users/anthonycardillo/.bun', 'TERM_PROGRAM': 'vscode', 'TERM_PROGRAM_VERSION': '2.3.40', 'COLORTERM': 'truecolor', 'PYDEVD_DISABLE_FILE_VALIDATION': '1', 'VSCODE_DEBUGPY_ADAPTER_ENDPOINTS': '/Users/anthonycardillo/.cursor/extensions/ms-python.debugpy-2025.18.0-darwin-arm64/.noConfigDebugAdapterEndpoints/endpoint-bfdb369faf213a96.txt', 'BUNDLED_DEBUGPY_PATH': '/Users/anthonycardillo/.cursor/extensions/ms-python.debugpy-2025.18.0-darwin-arm64/bundled/libs/debugpy', 'GIT_ASKPASS': '/Applications/Cursor.app/Contents/Resources/app/extensions/git/dist/askpass.sh', 'VSCODE_GIT_ASKPASS_NODE': '/Applications/Cursor.app/Contents/Frameworks/Cursor Helper (Plugin).app/Contents/MacOS/Cursor Helper (Plugin)', 'VSCODE_GIT_ASKPASS_EXTRA_ARGS': '', 'VSCODE_GIT_ASKPASS_MAIN': '/Applications/Cursor.app/Contents/Resources/app/extensions/git/dist/askpass-main.js', 'VSCODE_GIT_IPC_HANDLE': '/var/folders/6c/95f1yxcd673848zqjnj46_ww0000gn/T/vscode-git-6a534ea802.sock', 'VSCODE_GIT_IPC_AUTH_TOKEN': '202d91e1cac1e6fc0c336e8f97ca643be8b35e2b331169aadb2c67f58384013f', 'VSCODE_INJECTION': '1', 'ZDOTDIR': '/Users/anthonycardillo', 'USER_ZDOTDIR': '/Users/anthonycardillo', 'TERM': 'xterm-256color', 'VSCODE_PROFILE_INITIALIZED': '1', 'PS1': '((.venv) ) %n@%m %1~ %# ', 'VIRTUAL_ENV': '/Users/anthonycardillo/Documents/personal/polyester/.venv', 'VIRTUAL_ENV_PROMPT': '(.venv) ', '_': '/Users/anthonycardillo/Documents/personal/polyester/.venv/bin/python'}), keep_blank_values=0, strict_parsing=0, limit=None, encoding='utf-8', errors='replace', max_num_fields=None, separator='&')",
      "description": "Store a sequence of fields, reading multipart/form-data.\n\nThis class provides naming, typing, files stored on disk, and\nmore.  At the top level, it is accessible like a dictionary, whose\nkeys are the field names.  (Note: None can occur as a field name.)\nThe items are either a Python list (if there's multiple values) or\nanother FieldStorage or MiniFieldStorage object.  If it's a single\nobject, it has the following attributes:\n\nname: the field name, if specified; otherwise None\n\nfilename: the filename, if specified; otherwise None; this is the\n    client side filename, *not* the file name on which it is\n    stored (that's a temporary file you don't deal with)\n\nvalue: the value as a *string*; for file uploads, this\n    transparently reads the file every time you request the value\n    and returns *bytes*\n\nfile: the file(-like) object from which you can read the data *as\n    bytes* ; None if the data is stored a simple string\n\ntype: the content-type, or None if not specified\n\ntype_options: dictionary of options specified on the content-type\n    line\n\ndisposition: content-disposition, or None if not specified\n\ndisposition_options: dictionary of corresponding options\n\nheaders: a dictionary(-like) object (sometimes email.message.Message or a\n    subclass thereof) containing *all* headers\n\nThe class is subclassable, mostly for the purpose of overriding\nthe make_file() method, which is called internally to come up with\na file open for reading and writing.  This makes it possible to\noverride the default choice of storing all files in a temporary\ndirectory and unlinking them as soon as they have been opened.",
      "relationships": []
    },
    {
      "id": "stdlib.cgi.MiniFieldStorage",
      "name": "MiniFieldStorage",
      "module": "cgi",
      "type": "class",
      "signature": "(name, value)",
      "description": "Like FieldStorage, for use when no file uploads are possible.",
      "relationships": []
    },
    {
      "id": "stdlib.cgi.closelog",
      "name": "closelog",
      "module": "cgi",
      "type": "function",
      "signature": "()",
      "description": "Close the log file.",
      "relationships": []
    },
    {
      "id": "stdlib.cgi.dolog",
      "name": "dolog",
      "module": "cgi",
      "type": "function",
      "signature": "(fmt, *args)",
      "description": "Write a log message to the log file.  See initlog() for docs.",
      "relationships": []
    },
    {
      "id": "stdlib.cgi.initlog",
      "name": "initlog",
      "module": "cgi",
      "type": "function",
      "signature": "(*allargs)",
      "description": "Write a log message, if there is a log file.\n\nEven though this function is called initlog(), you should always\nuse log(); log is a variable that is set either to initlog\n(initially), to dolog (once the log file has been opened), or to\nnolog (when logging is disabled).\n\nThe first argument is a format string; the remaining arguments (if\nany) are arguments to the % operator, so e.g.\n    log(\"%s: %s\", \"a\", \"b\")\nwill write \"a: b\" to the log file, followed by a newline.\n\nIf the global logfp is not None, it should be a file object to\nwhich log data is written.\n\nIf the global logfp is None, the global logfile may be a string\ngiving a filename to open, in append mode.  This file should be\nworld writable!!!  If the file can't be opened, logging is\nsilently disabled (since there is no safe place where we could\nsend an error message).",
      "relationships": [
        {
          "target": "stdlib.cgi.log",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.cgi.log",
      "name": "log",
      "module": "cgi",
      "type": "function",
      "signature": "(*allargs)",
      "description": "Write a log message, if there is a log file.\n\nEven though this function is called initlog(), you should always\nuse log(); log is a variable that is set either to initlog\n(initially), to dolog (once the log file has been opened), or to\nnolog (when logging is disabled).\n\nThe first argument is a format string; the remaining arguments (if\nany) are arguments to the % operator, so e.g.\n    log(\"%s: %s\", \"a\", \"b\")\nwill write \"a: b\" to the log file, followed by a newline.\n\nIf the global logfp is not None, it should be a file object to\nwhich log data is written.\n\nIf the global logfp is None, the global logfile may be a string\ngiving a filename to open, in append mode.  This file should be\nworld writable!!!  If the file can't be opened, logging is\nsilently disabled (since there is no safe place where we could\nsend an error message).",
      "relationships": [
        {
          "target": "stdlib.cgi.log",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.cgi.nolog",
      "name": "nolog",
      "module": "cgi",
      "type": "function",
      "signature": "(*allargs)",
      "description": "Dummy function, assigned to log when logging is disabled.",
      "relationships": []
    },
    {
      "id": "stdlib.cgi.parse",
      "name": "parse",
      "module": "cgi",
      "type": "function",
      "signature": "(fp=None, environ=environ({'OSLogRateLimit': '64', 'MallocNanoZone': '0', 'USER': 'anthonycardillo', 'COMMAND_MODE': 'unix2003', '__CFBundleIdentifier': 'com.todesktop.230313mzl4w4u92', 'PATH': '/Users/anthonycardillo/Documents/personal/polyester/.venv/bin:/opt/homebrew/opt/postgresql@16/bin:/Users/anthonycardillo/.bun/bin:/Users/anthonycardillo/.bun/bin:/Users/anthonycardillo/.nvm/versions/node/v22.21.0/bin:/opt/homebrew/bin:/opt/homebrew/sbin:/usr/local/bin:/System/Cryptexes/App/usr/bin:/usr/bin:/bin:/usr/sbin:/sbin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/local/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/appleinternal/bin:/opt/pmk/env/global/bin:/Library/Apple/usr/bin:/opt/homebrew/opt/postgresql@16/bin:/Users/anthonycardillo/.bun/bin:/Users/anthonycardillo/.nvm/versions/node/v22.21.0/bin:/Users/anthonycardillo/.cursor/extensions/ms-python.debugpy-2025.18.0-darwin-arm64/bundled/scripts/noConfigScripts', 'LOGNAME': 'anthonycardillo', 'SSH_AUTH_SOCK': '/private/tmp/com.apple.launchd.fAtscmMPP1/Listeners', 'HOME': '/Users/anthonycardillo', 'SHELL': '/bin/zsh', 'TMPDIR': '/var/folders/6c/95f1yxcd673848zqjnj46_ww0000gn/T/', '__CF_USER_TEXT_ENCODING': '0x1F5:0x0:0x52', 'XPC_SERVICE_NAME': '0', 'XPC_FLAGS': '0x0', 'ORIGINAL_XDG_CURRENT_DESKTOP': 'undefined', 'CURSOR_TRACE_ID': '09c74175785640a8ac5df17c65b4361b', 'SHLVL': '1', 'PWD': '/Users/anthonycardillo/Documents/personal/polyester', 'OLDPWD': '/Users/anthonycardillo/Documents/personal/polyester', 'LANG': 'C.UTF-8', 'HOMEBREW_PREFIX': '/opt/homebrew', 'HOMEBREW_CELLAR': '/opt/homebrew/Cellar', 'HOMEBREW_REPOSITORY': '/opt/homebrew', 'INFOPATH': '/opt/homebrew/share/info:/opt/homebrew/share/info:', 'NVM_DIR': '/Users/anthonycardillo/.nvm', 'NVM_CD_FLAGS': '-q', 'NVM_BIN': '/Users/anthonycardillo/.nvm/versions/node/v22.21.0/bin', 'NVM_INC': '/Users/anthonycardillo/.nvm/versions/node/v22.21.0/include/node', 'BUN_INSTALL': '/Users/anthonycardillo/.bun', 'TERM_PROGRAM': 'vscode', 'TERM_PROGRAM_VERSION': '2.3.40', 'COLORTERM': 'truecolor', 'PYDEVD_DISABLE_FILE_VALIDATION': '1', 'VSCODE_DEBUGPY_ADAPTER_ENDPOINTS': '/Users/anthonycardillo/.cursor/extensions/ms-python.debugpy-2025.18.0-darwin-arm64/.noConfigDebugAdapterEndpoints/endpoint-bfdb369faf213a96.txt', 'BUNDLED_DEBUGPY_PATH': '/Users/anthonycardillo/.cursor/extensions/ms-python.debugpy-2025.18.0-darwin-arm64/bundled/libs/debugpy', 'GIT_ASKPASS': '/Applications/Cursor.app/Contents/Resources/app/extensions/git/dist/askpass.sh', 'VSCODE_GIT_ASKPASS_NODE': '/Applications/Cursor.app/Contents/Frameworks/Cursor Helper (Plugin).app/Contents/MacOS/Cursor Helper (Plugin)', 'VSCODE_GIT_ASKPASS_EXTRA_ARGS': '', 'VSCODE_GIT_ASKPASS_MAIN': '/Applications/Cursor.app/Contents/Resources/app/extensions/git/dist/askpass-main.js', 'VSCODE_GIT_IPC_HANDLE': '/var/folders/6c/95f1yxcd673848zqjnj46_ww0000gn/T/vscode-git-6a534ea802.sock', 'VSCODE_GIT_IPC_AUTH_TOKEN': '202d91e1cac1e6fc0c336e8f97ca643be8b35e2b331169aadb2c67f58384013f', 'VSCODE_INJECTION': '1', 'ZDOTDIR': '/Users/anthonycardillo', 'USER_ZDOTDIR': '/Users/anthonycardillo', 'TERM': 'xterm-256color', 'VSCODE_PROFILE_INITIALIZED': '1', 'PS1': '((.venv) ) %n@%m %1~ %# ', 'VIRTUAL_ENV': '/Users/anthonycardillo/Documents/personal/polyester/.venv', 'VIRTUAL_ENV_PROMPT': '(.venv) ', '_': '/Users/anthonycardillo/Documents/personal/polyester/.venv/bin/python'}), keep_blank_values=0, strict_parsing=0, separator='&')",
      "description": "Parse a query in the environment or from a file (default stdin)\n\nArguments, all optional:\n\nfp              : file pointer; default: sys.stdin.buffer\n\nenviron         : environment dictionary; default: os.environ\n\nkeep_blank_values: flag indicating whether blank values in\n    percent-encoded forms should be treated as blank strings.\n    A true value indicates that blanks should be retained as\n    blank strings.  The default false value indicates that\n    blank values are to be ignored and treated as if they were\n    not included.\n\nstrict_parsing: flag indicating what to do with parsing errors.\n    If false (the default), errors are silently ignored.\n    If true, errors raise a ValueError exception.\n\nseparator: str. The symbol to use for separating the query arguments.\n    Defaults to &.",
      "relationships": [
        {
          "target": "stdlib.cgi.parse_header",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.parse_multipart",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.cgi.parse_header",
      "name": "parse_header",
      "module": "cgi",
      "type": "function",
      "signature": "(line)",
      "description": "Parse a Content-type like header.\n\nReturn the main content-type and a dictionary of options.",
      "relationships": [
        {
          "target": "stdlib.cgi._parseparam",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.cgi.parse_multipart",
      "name": "parse_multipart",
      "module": "cgi",
      "type": "function",
      "signature": "(fp, pdict, encoding='utf-8', errors='replace', separator='&')",
      "description": "Parse multipart input.\n\nArguments:\nfp   : input file\npdict: dictionary containing other parameters of content-type header\nencoding, errors: request encoding and error handler, passed to\n    FieldStorage\n\nReturns a dictionary just like parse_qs(): keys are the field names, each\nvalue is a list of values for that field. For non-file fields, the value\nis a list of strings.",
      "relationships": []
    },
    {
      "id": "stdlib.cgi.print_arguments",
      "name": "print_arguments",
      "module": "cgi",
      "type": "function",
      "signature": "()",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.cgi.print_directory",
      "name": "print_directory",
      "module": "cgi",
      "type": "function",
      "signature": "()",
      "description": "Dump the current directory as HTML.",
      "relationships": []
    },
    {
      "id": "stdlib.cgi.print_environ",
      "name": "print_environ",
      "module": "cgi",
      "type": "function",
      "signature": "(environ=environ({'OSLogRateLimit': '64', 'MallocNanoZone': '0', 'USER': 'anthonycardillo', 'COMMAND_MODE': 'unix2003', '__CFBundleIdentifier': 'com.todesktop.230313mzl4w4u92', 'PATH': '/Users/anthonycardillo/Documents/personal/polyester/.venv/bin:/opt/homebrew/opt/postgresql@16/bin:/Users/anthonycardillo/.bun/bin:/Users/anthonycardillo/.bun/bin:/Users/anthonycardillo/.nvm/versions/node/v22.21.0/bin:/opt/homebrew/bin:/opt/homebrew/sbin:/usr/local/bin:/System/Cryptexes/App/usr/bin:/usr/bin:/bin:/usr/sbin:/sbin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/local/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/appleinternal/bin:/opt/pmk/env/global/bin:/Library/Apple/usr/bin:/opt/homebrew/opt/postgresql@16/bin:/Users/anthonycardillo/.bun/bin:/Users/anthonycardillo/.nvm/versions/node/v22.21.0/bin:/Users/anthonycardillo/.cursor/extensions/ms-python.debugpy-2025.18.0-darwin-arm64/bundled/scripts/noConfigScripts', 'LOGNAME': 'anthonycardillo', 'SSH_AUTH_SOCK': '/private/tmp/com.apple.launchd.fAtscmMPP1/Listeners', 'HOME': '/Users/anthonycardillo', 'SHELL': '/bin/zsh', 'TMPDIR': '/var/folders/6c/95f1yxcd673848zqjnj46_ww0000gn/T/', '__CF_USER_TEXT_ENCODING': '0x1F5:0x0:0x52', 'XPC_SERVICE_NAME': '0', 'XPC_FLAGS': '0x0', 'ORIGINAL_XDG_CURRENT_DESKTOP': 'undefined', 'CURSOR_TRACE_ID': '09c74175785640a8ac5df17c65b4361b', 'SHLVL': '1', 'PWD': '/Users/anthonycardillo/Documents/personal/polyester', 'OLDPWD': '/Users/anthonycardillo/Documents/personal/polyester', 'LANG': 'C.UTF-8', 'HOMEBREW_PREFIX': '/opt/homebrew', 'HOMEBREW_CELLAR': '/opt/homebrew/Cellar', 'HOMEBREW_REPOSITORY': '/opt/homebrew', 'INFOPATH': '/opt/homebrew/share/info:/opt/homebrew/share/info:', 'NVM_DIR': '/Users/anthonycardillo/.nvm', 'NVM_CD_FLAGS': '-q', 'NVM_BIN': '/Users/anthonycardillo/.nvm/versions/node/v22.21.0/bin', 'NVM_INC': '/Users/anthonycardillo/.nvm/versions/node/v22.21.0/include/node', 'BUN_INSTALL': '/Users/anthonycardillo/.bun', 'TERM_PROGRAM': 'vscode', 'TERM_PROGRAM_VERSION': '2.3.40', 'COLORTERM': 'truecolor', 'PYDEVD_DISABLE_FILE_VALIDATION': '1', 'VSCODE_DEBUGPY_ADAPTER_ENDPOINTS': '/Users/anthonycardillo/.cursor/extensions/ms-python.debugpy-2025.18.0-darwin-arm64/.noConfigDebugAdapterEndpoints/endpoint-bfdb369faf213a96.txt', 'BUNDLED_DEBUGPY_PATH': '/Users/anthonycardillo/.cursor/extensions/ms-python.debugpy-2025.18.0-darwin-arm64/bundled/libs/debugpy', 'GIT_ASKPASS': '/Applications/Cursor.app/Contents/Resources/app/extensions/git/dist/askpass.sh', 'VSCODE_GIT_ASKPASS_NODE': '/Applications/Cursor.app/Contents/Frameworks/Cursor Helper (Plugin).app/Contents/MacOS/Cursor Helper (Plugin)', 'VSCODE_GIT_ASKPASS_EXTRA_ARGS': '', 'VSCODE_GIT_ASKPASS_MAIN': '/Applications/Cursor.app/Contents/Resources/app/extensions/git/dist/askpass-main.js', 'VSCODE_GIT_IPC_HANDLE': '/var/folders/6c/95f1yxcd673848zqjnj46_ww0000gn/T/vscode-git-6a534ea802.sock', 'VSCODE_GIT_IPC_AUTH_TOKEN': '202d91e1cac1e6fc0c336e8f97ca643be8b35e2b331169aadb2c67f58384013f', 'VSCODE_INJECTION': '1', 'ZDOTDIR': '/Users/anthonycardillo', 'USER_ZDOTDIR': '/Users/anthonycardillo', 'TERM': 'xterm-256color', 'VSCODE_PROFILE_INITIALIZED': '1', 'PS1': '((.venv) ) %n@%m %1~ %# ', 'VIRTUAL_ENV': '/Users/anthonycardillo/Documents/personal/polyester/.venv', 'VIRTUAL_ENV_PROMPT': '(.venv) ', '_': '/Users/anthonycardillo/Documents/personal/polyester/.venv/bin/python'}))",
      "description": "Dump the shell environment as HTML.",
      "relationships": []
    },
    {
      "id": "stdlib.cgi.print_environ_usage",
      "name": "print_environ_usage",
      "module": "cgi",
      "type": "function",
      "signature": "()",
      "description": "Dump a list of environment variables used by CGI as HTML.",
      "relationships": []
    },
    {
      "id": "stdlib.cgi.print_exception",
      "name": "print_exception",
      "module": "cgi",
      "type": "function",
      "signature": "(type=None, value=None, tb=None, limit=None)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.cgi.print_form",
      "name": "print_form",
      "module": "cgi",
      "type": "function",
      "signature": "(form)",
      "description": "Dump the contents of a form as HTML.",
      "relationships": []
    },
    {
      "id": "stdlib.cgi.test",
      "name": "test",
      "module": "cgi",
      "type": "function",
      "signature": "(environ=environ({'OSLogRateLimit': '64', 'MallocNanoZone': '0', 'USER': 'anthonycardillo', 'COMMAND_MODE': 'unix2003', '__CFBundleIdentifier': 'com.todesktop.230313mzl4w4u92', 'PATH': '/Users/anthonycardillo/Documents/personal/polyester/.venv/bin:/opt/homebrew/opt/postgresql@16/bin:/Users/anthonycardillo/.bun/bin:/Users/anthonycardillo/.bun/bin:/Users/anthonycardillo/.nvm/versions/node/v22.21.0/bin:/opt/homebrew/bin:/opt/homebrew/sbin:/usr/local/bin:/System/Cryptexes/App/usr/bin:/usr/bin:/bin:/usr/sbin:/sbin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/local/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/appleinternal/bin:/opt/pmk/env/global/bin:/Library/Apple/usr/bin:/opt/homebrew/opt/postgresql@16/bin:/Users/anthonycardillo/.bun/bin:/Users/anthonycardillo/.nvm/versions/node/v22.21.0/bin:/Users/anthonycardillo/.cursor/extensions/ms-python.debugpy-2025.18.0-darwin-arm64/bundled/scripts/noConfigScripts', 'LOGNAME': 'anthonycardillo', 'SSH_AUTH_SOCK': '/private/tmp/com.apple.launchd.fAtscmMPP1/Listeners', 'HOME': '/Users/anthonycardillo', 'SHELL': '/bin/zsh', 'TMPDIR': '/var/folders/6c/95f1yxcd673848zqjnj46_ww0000gn/T/', '__CF_USER_TEXT_ENCODING': '0x1F5:0x0:0x52', 'XPC_SERVICE_NAME': '0', 'XPC_FLAGS': '0x0', 'ORIGINAL_XDG_CURRENT_DESKTOP': 'undefined', 'CURSOR_TRACE_ID': '09c74175785640a8ac5df17c65b4361b', 'SHLVL': '1', 'PWD': '/Users/anthonycardillo/Documents/personal/polyester', 'OLDPWD': '/Users/anthonycardillo/Documents/personal/polyester', 'LANG': 'C.UTF-8', 'HOMEBREW_PREFIX': '/opt/homebrew', 'HOMEBREW_CELLAR': '/opt/homebrew/Cellar', 'HOMEBREW_REPOSITORY': '/opt/homebrew', 'INFOPATH': '/opt/homebrew/share/info:/opt/homebrew/share/info:', 'NVM_DIR': '/Users/anthonycardillo/.nvm', 'NVM_CD_FLAGS': '-q', 'NVM_BIN': '/Users/anthonycardillo/.nvm/versions/node/v22.21.0/bin', 'NVM_INC': '/Users/anthonycardillo/.nvm/versions/node/v22.21.0/include/node', 'BUN_INSTALL': '/Users/anthonycardillo/.bun', 'TERM_PROGRAM': 'vscode', 'TERM_PROGRAM_VERSION': '2.3.40', 'COLORTERM': 'truecolor', 'PYDEVD_DISABLE_FILE_VALIDATION': '1', 'VSCODE_DEBUGPY_ADAPTER_ENDPOINTS': '/Users/anthonycardillo/.cursor/extensions/ms-python.debugpy-2025.18.0-darwin-arm64/.noConfigDebugAdapterEndpoints/endpoint-bfdb369faf213a96.txt', 'BUNDLED_DEBUGPY_PATH': '/Users/anthonycardillo/.cursor/extensions/ms-python.debugpy-2025.18.0-darwin-arm64/bundled/libs/debugpy', 'GIT_ASKPASS': '/Applications/Cursor.app/Contents/Resources/app/extensions/git/dist/askpass.sh', 'VSCODE_GIT_ASKPASS_NODE': '/Applications/Cursor.app/Contents/Frameworks/Cursor Helper (Plugin).app/Contents/MacOS/Cursor Helper (Plugin)', 'VSCODE_GIT_ASKPASS_EXTRA_ARGS': '', 'VSCODE_GIT_ASKPASS_MAIN': '/Applications/Cursor.app/Contents/Resources/app/extensions/git/dist/askpass-main.js', 'VSCODE_GIT_IPC_HANDLE': '/var/folders/6c/95f1yxcd673848zqjnj46_ww0000gn/T/vscode-git-6a534ea802.sock', 'VSCODE_GIT_IPC_AUTH_TOKEN': '202d91e1cac1e6fc0c336e8f97ca643be8b35e2b331169aadb2c67f58384013f', 'VSCODE_INJECTION': '1', 'ZDOTDIR': '/Users/anthonycardillo', 'USER_ZDOTDIR': '/Users/anthonycardillo', 'TERM': 'xterm-256color', 'VSCODE_PROFILE_INITIALIZED': '1', 'PS1': '((.venv) ) %n@%m %1~ %# ', 'VIRTUAL_ENV': '/Users/anthonycardillo/Documents/personal/polyester/.venv', 'VIRTUAL_ENV_PROMPT': '(.venv) ', '_': '/Users/anthonycardillo/Documents/personal/polyester/.venv/bin/python'}))",
      "description": "Robust test CGI script, usable as main program.\n\nWrite minimal HTTP headers and dump all information provided to\nthe script in HTML form.",
      "relationships": [
        {
          "target": "stdlib.cgi.print_directory",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.print_arguments",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.print_form",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.print_environ",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.print_environ_usage",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.print_directory",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.print_arguments",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.print_form",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.print_environ",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.print_exception",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.print_exception",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.cgi.valid_boundary",
      "name": "valid_boundary",
      "module": "cgi",
      "type": "function",
      "signature": "(s)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.cgitb.Hook",
      "name": "Hook",
      "module": "cgitb",
      "type": "class",
      "signature": "(display=1, logdir=None, context=5, file=None, format='html')",
      "description": "A hook to replace sys.excepthook that shows tracebacks in HTML.",
      "relationships": []
    },
    {
      "id": "stdlib.cgitb.enable",
      "name": "enable",
      "module": "cgitb",
      "type": "function",
      "signature": "(display=1, logdir=None, context=5, format='html')",
      "description": "Install an exception handler that formats tracebacks as HTML.\n\nThe optional argument 'display' can be set to 0 to suppress sending the\ntraceback to the browser, and 'logdir' can be set to a directory to cause\ntracebacks to be written to files there.",
      "relationships": []
    },
    {
      "id": "stdlib.cgitb.grey",
      "name": "grey",
      "module": "cgitb",
      "type": "function",
      "signature": "(text)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.cgitb.html",
      "name": "html",
      "module": "cgitb",
      "type": "function",
      "signature": "(einfo, context=5)",
      "description": "Return a nice HTML document describing a given traceback.",
      "relationships": [
        {
          "target": "stdlib.cgitb.scanvars",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.small",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.strong",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.small",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.strong",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.small",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.grey",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.strong",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.strong",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.grey",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.strong",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.cgitb.lookup",
      "name": "lookup",
      "module": "cgitb",
      "type": "function",
      "signature": "(name, frame, locals)",
      "description": "Find the value for a given name in the given environment.",
      "relationships": []
    },
    {
      "id": "stdlib.cgitb.reset",
      "name": "reset",
      "module": "cgitb",
      "type": "function",
      "signature": "()",
      "description": "Return a string that resets the CGI and browser to a known state.",
      "relationships": []
    },
    {
      "id": "stdlib.cgitb.scanvars",
      "name": "scanvars",
      "module": "cgitb",
      "type": "function",
      "signature": "(reader, frame, locals)",
      "description": "Scan one logical line of Python and look up values of variables used.",
      "relationships": [
        {
          "target": "stdlib.cgitb.lookup",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.cgitb.small",
      "name": "small",
      "module": "cgitb",
      "type": "function",
      "signature": "(text)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.cgitb.strong",
      "name": "strong",
      "module": "cgitb",
      "type": "function",
      "signature": "(text)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.cgitb.text",
      "name": "text",
      "module": "cgitb",
      "type": "function",
      "signature": "(einfo, context=5)",
      "description": "Return a plain text document describing a given traceback.",
      "relationships": [
        {
          "target": "stdlib.cgitb.scanvars",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.chunk.Chunk",
      "name": "Chunk",
      "module": "chunk",
      "type": "class",
      "signature": "(file, align=True, bigendian=True, inclheader=False)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.cmd.Cmd",
      "name": "Cmd",
      "module": "cmd",
      "type": "class",
      "signature": "(completekey='tab', stdin=None, stdout=None)",
      "description": "A simple framework for writing line-oriented command interpreters.\n\nThese are often useful for test harnesses, administrative tools, and\nprototypes that will later be wrapped in a more sophisticated interface.\n\nA Cmd instance or subclass instance is a line-oriented interpreter\nframework.  There is no good reason to instantiate Cmd itself; rather,\nit's useful as a superclass of an interpreter class you define yourself\nin order to inherit Cmd's methods and encapsulate action methods.",
      "relationships": []
    },
    {
      "id": "stdlib.code.InteractiveConsole",
      "name": "InteractiveConsole",
      "module": "code",
      "type": "class",
      "signature": "(locals=None, filename='<console>')",
      "description": "Closely emulate the behavior of the interactive Python interpreter.\n\nThis class builds on InteractiveInterpreter and adds prompting\nusing the familiar sys.ps1 and sys.ps2, and input buffering.",
      "relationships": [
        {
          "target": "stdlib.code.InteractiveInterpreter",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.code.InteractiveInterpreter",
      "name": "InteractiveInterpreter",
      "module": "code",
      "type": "class",
      "signature": "(locals=None)",
      "description": "Base class for InteractiveConsole.\n\nThis class deals with parsing and interpreter state (the user's\nnamespace); it doesn't deal with input buffering or prompting or\ninput file naming (the filename is always passed in explicitly).",
      "relationships": []
    },
    {
      "id": "stdlib.code.interact",
      "name": "interact",
      "module": "code",
      "type": "function",
      "signature": "(banner=None, readfunc=None, local=None, exitmsg=None)",
      "description": "Closely emulate the interactive Python interpreter.\n\nThis is a backwards compatible interface to the InteractiveConsole\nclass.  When readfunc is not specified, it attempts to import the\nreadline module to enable GNU readline if it is available.\n\nArguments (all optional, all default to None):\n\nbanner -- passed to InteractiveConsole.interact()\nreadfunc -- if not None, replaces InteractiveConsole.raw_input()\nlocal -- passed to InteractiveInterpreter.__init__()\nexitmsg -- passed to InteractiveConsole.interact()",
      "relationships": []
    },
    {
      "id": "stdlib.codecs.BufferedIncrementalDecoder",
      "name": "BufferedIncrementalDecoder",
      "module": "codecs",
      "type": "class",
      "signature": "(errors='strict')",
      "description": "This subclass of IncrementalDecoder can be used as the baseclass for an\nincremental decoder if the decoder must be able to handle incomplete\nbyte sequences.",
      "relationships": [
        {
          "target": "stdlib.codecs.IncrementalDecoder",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.codecs.BufferedIncrementalEncoder",
      "name": "BufferedIncrementalEncoder",
      "module": "codecs",
      "type": "class",
      "signature": "(errors='strict')",
      "description": "This subclass of IncrementalEncoder can be used as the baseclass for an\nincremental encoder if the encoder must keep some of the output in a\nbuffer between calls to encode().",
      "relationships": [
        {
          "target": "stdlib.codecs.IncrementalEncoder",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.codecs.Codec",
      "name": "Codec",
      "module": "codecs",
      "type": "class",
      "signature": "()",
      "description": "Defines the interface for stateless encoders/decoders.\n\nThe .encode()/.decode() methods may use different error\nhandling schemes by providing the errors argument. These\nstring values are predefined:\n\n 'strict' - raise a ValueError error (or a subclass)\n 'ignore' - ignore the character and continue with the next\n 'replace' - replace with a suitable replacement character;\n            Python will use the official U+FFFD REPLACEMENT\n            CHARACTER for the builtin Unicode codecs on\n            decoding and '?' on encoding.\n 'surrogateescape' - replace with private code points U+DCnn.\n 'xmlcharrefreplace' - Replace with the appropriate XML\n                       character reference (only for encoding).\n 'backslashreplace'  - Replace with backslashed escape sequences.\n 'namereplace'       - Replace with \\N{...} escape sequences\n                       (only for encoding).\n\nThe set of allowed values can be extended via register_error.",
      "relationships": []
    },
    {
      "id": "stdlib.codecs.CodecInfo",
      "name": "CodecInfo",
      "module": "codecs",
      "type": "class",
      "signature": "(encode, decode, streamreader=None, streamwriter=None, incrementalencoder=None, incrementaldecoder=None, name=None, *, _is_text_encoding=None)",
      "description": "Codec details when looking up the codec registry",
      "relationships": [
        {
          "target": "stdlib.builtins.tuple",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.codecs.EncodedFile",
      "name": "EncodedFile",
      "module": "codecs",
      "type": "function",
      "signature": "(file, data_encoding, file_encoding=None, errors='strict')",
      "description": "Return a wrapped version of file which provides transparent\nencoding translation.\n\nData written to the wrapped file is decoded according\nto the given data_encoding and then encoded to the underlying\nfile using file_encoding. The intermediate data type\nwill usually be Unicode but depends on the specified codecs.\n\nBytes read from the file are decoded using file_encoding and then\npassed back to the caller encoded using data_encoding.\n\nIf file_encoding is not given, it defaults to data_encoding.\n\nerrors may be given to define the error handling. It defaults\nto 'strict' which causes ValueErrors to be raised in case an\nencoding error occurs.\n\nThe returned wrapped file object provides two extra attributes\n.data_encoding and .file_encoding which reflect the given\nparameters of the same name. The attributes can be used for\nintrospection by Python programs.",
      "relationships": []
    },
    {
      "id": "stdlib.codecs.IncrementalDecoder",
      "name": "IncrementalDecoder",
      "module": "codecs",
      "type": "class",
      "signature": "(errors='strict')",
      "description": "An IncrementalDecoder decodes an input in multiple steps. The input can\nbe passed piece by piece to the decode() method. The IncrementalDecoder\nremembers the state of the decoding process between calls to decode().",
      "relationships": []
    },
    {
      "id": "stdlib.codecs.IncrementalEncoder",
      "name": "IncrementalEncoder",
      "module": "codecs",
      "type": "class",
      "signature": "(errors='strict')",
      "description": "An IncrementalEncoder encodes an input in multiple steps. The input can\nbe passed piece by piece to the encode() method. The IncrementalEncoder\nremembers the state of the encoding process between calls to encode().",
      "relationships": []
    },
    {
      "id": "stdlib.codecs.StreamReader",
      "name": "StreamReader",
      "module": "codecs",
      "type": "class",
      "signature": "(stream, errors='strict')",
      "description": "Defines the interface for stateless encoders/decoders.\n\nThe .encode()/.decode() methods may use different error\nhandling schemes by providing the errors argument. These\nstring values are predefined:\n\n 'strict' - raise a ValueError error (or a subclass)\n 'ignore' - ignore the character and continue with the next\n 'replace' - replace with a suitable replacement character;\n            Python will use the official U+FFFD REPLACEMENT\n            CHARACTER for the builtin Unicode codecs on\n            decoding and '?' on encoding.\n 'surrogateescape' - replace with private code points U+DCnn.\n 'xmlcharrefreplace' - Replace with the appropriate XML\n                       character reference (only for encoding).\n 'backslashreplace'  - Replace with backslashed escape sequences.\n 'namereplace'       - Replace with \\N{...} escape sequences\n                       (only for encoding).\n\nThe set of allowed values can be extended via register_error.",
      "relationships": [
        {
          "target": "stdlib.codecs.Codec",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.codecs.StreamReaderWriter",
      "name": "StreamReaderWriter",
      "module": "codecs",
      "type": "class",
      "signature": "(stream, Reader, Writer, errors='strict')",
      "description": "StreamReaderWriter instances allow wrapping streams which\nwork in both read and write modes.\n\nThe design is such that one can use the factory functions\nreturned by the codec.lookup() function to construct the\ninstance.",
      "relationships": []
    },
    {
      "id": "stdlib.codecs.StreamRecoder",
      "name": "StreamRecoder",
      "module": "codecs",
      "type": "class",
      "signature": "(stream, encode, decode, Reader, Writer, errors='strict')",
      "description": "StreamRecoder instances translate data from one encoding to another.\n\nThey use the complete set of APIs returned by the\ncodecs.lookup() function to implement their task.\n\nData written to the StreamRecoder is first decoded into an\nintermediate format (depending on the \"decode\" codec) and then\nwritten to the underlying stream using an instance of the provided\nWriter class.\n\nIn the other direction, data is read from the underlying stream using\na Reader instance and then encoded and returned to the caller.",
      "relationships": []
    },
    {
      "id": "stdlib.codecs.StreamWriter",
      "name": "StreamWriter",
      "module": "codecs",
      "type": "class",
      "signature": "(stream, errors='strict')",
      "description": "Defines the interface for stateless encoders/decoders.\n\nThe .encode()/.decode() methods may use different error\nhandling schemes by providing the errors argument. These\nstring values are predefined:\n\n 'strict' - raise a ValueError error (or a subclass)\n 'ignore' - ignore the character and continue with the next\n 'replace' - replace with a suitable replacement character;\n            Python will use the official U+FFFD REPLACEMENT\n            CHARACTER for the builtin Unicode codecs on\n            decoding and '?' on encoding.\n 'surrogateescape' - replace with private code points U+DCnn.\n 'xmlcharrefreplace' - Replace with the appropriate XML\n                       character reference (only for encoding).\n 'backslashreplace'  - Replace with backslashed escape sequences.\n 'namereplace'       - Replace with \\N{...} escape sequences\n                       (only for encoding).\n\nThe set of allowed values can be extended via register_error.",
      "relationships": [
        {
          "target": "stdlib.codecs.Codec",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.codecs.getdecoder",
      "name": "getdecoder",
      "module": "codecs",
      "type": "function",
      "signature": "(encoding)",
      "description": "Lookup up the codec for the given encoding and return\nits decoder function.\n\nRaises a LookupError in case the encoding cannot be found.",
      "relationships": []
    },
    {
      "id": "stdlib.codecs.getencoder",
      "name": "getencoder",
      "module": "codecs",
      "type": "function",
      "signature": "(encoding)",
      "description": "Lookup up the codec for the given encoding and return\nits encoder function.\n\nRaises a LookupError in case the encoding cannot be found.",
      "relationships": []
    },
    {
      "id": "stdlib.codecs.getincrementaldecoder",
      "name": "getincrementaldecoder",
      "module": "codecs",
      "type": "function",
      "signature": "(encoding)",
      "description": "Lookup up the codec for the given encoding and return\nits IncrementalDecoder class or factory function.\n\nRaises a LookupError in case the encoding cannot be found\nor the codecs doesn't provide an incremental decoder.",
      "relationships": []
    },
    {
      "id": "stdlib.codecs.getincrementalencoder",
      "name": "getincrementalencoder",
      "module": "codecs",
      "type": "function",
      "signature": "(encoding)",
      "description": "Lookup up the codec for the given encoding and return\nits IncrementalEncoder class or factory function.\n\nRaises a LookupError in case the encoding cannot be found\nor the codecs doesn't provide an incremental encoder.",
      "relationships": []
    },
    {
      "id": "stdlib.codecs.getreader",
      "name": "getreader",
      "module": "codecs",
      "type": "function",
      "signature": "(encoding)",
      "description": "Lookup up the codec for the given encoding and return\nits StreamReader class or factory function.\n\nRaises a LookupError in case the encoding cannot be found.",
      "relationships": []
    },
    {
      "id": "stdlib.codecs.getwriter",
      "name": "getwriter",
      "module": "codecs",
      "type": "function",
      "signature": "(encoding)",
      "description": "Lookup up the codec for the given encoding and return\nits StreamWriter class or factory function.\n\nRaises a LookupError in case the encoding cannot be found.",
      "relationships": []
    },
    {
      "id": "stdlib.codecs.iterdecode",
      "name": "iterdecode",
      "module": "codecs",
      "type": "function",
      "signature": "(iterator, encoding, errors='strict', **kwargs)",
      "description": "Decoding iterator.\n\nDecodes the input strings from the iterator using an IncrementalDecoder.\n\nerrors and kwargs are passed through to the IncrementalDecoder\nconstructor.",
      "relationships": []
    },
    {
      "id": "stdlib.codecs.iterencode",
      "name": "iterencode",
      "module": "codecs",
      "type": "function",
      "signature": "(iterator, encoding, errors='strict', **kwargs)",
      "description": "Encoding iterator.\n\nEncodes the input strings from the iterator using an IncrementalEncoder.\n\nerrors and kwargs are passed through to the IncrementalEncoder\nconstructor.",
      "relationships": []
    },
    {
      "id": "stdlib.codecs.make_encoding_map",
      "name": "make_encoding_map",
      "module": "codecs",
      "type": "function",
      "signature": "(decoding_map)",
      "description": "Creates an encoding map from a decoding map.\n\nIf a target mapping in the decoding map occurs multiple\ntimes, then that target is mapped to None (undefined mapping),\ncausing an exception when encountered by the charmap codec\nduring translation.\n\nOne example where this happens is cp875.py which decodes\nmultiple character to \\u001a.",
      "relationships": []
    },
    {
      "id": "stdlib.codecs.make_identity_dict",
      "name": "make_identity_dict",
      "module": "codecs",
      "type": "function",
      "signature": "(rng)",
      "description": "make_identity_dict(rng) -> dict\n\nReturn a dictionary where elements of the rng sequence are\nmapped to themselves.",
      "relationships": []
    },
    {
      "id": "stdlib.codecs.open",
      "name": "open",
      "module": "codecs",
      "type": "function",
      "signature": "(filename, mode='r', encoding=None, errors='strict', buffering=-1)",
      "description": "Open an encoded file using the given mode and return\na wrapped version providing transparent encoding/decoding.\n\nNote: The wrapped version will only accept the object format\ndefined by the codecs, i.e. Unicode objects for most builtin\ncodecs. Output is also codec dependent and will usually be\nUnicode as well.\n\nIf encoding is not None, then the\nunderlying encoded files are always opened in binary mode.\nThe default file mode is 'r', meaning to open the file in read mode.\n\nencoding specifies the encoding which is to be used for the\nfile.\n\nerrors may be given to define the error handling. It defaults\nto 'strict' which causes ValueErrors to be raised in case an\nencoding error occurs.\n\nbuffering has the same meaning as for the builtin open() API.\nIt defaults to -1 which means that the default buffer size will\nbe used.\n\nThe returned wrapped file object provides an extra attribute\n.encoding which allows querying the used encoding. This\nattribute is only available if an encoding was specified as\nparameter.",
      "relationships": []
    },
    {
      "id": "stdlib.codeop.CommandCompiler",
      "name": "CommandCompiler",
      "module": "codeop",
      "type": "class",
      "signature": "()",
      "description": "Instances of this class have __call__ methods identical in\nsignature to compile_command; the difference is that if the\ninstance compiles program text containing a __future__ statement,\nthe instance 'remembers' and compiles all subsequent program texts\nwith the statement in force.",
      "relationships": []
    },
    {
      "id": "stdlib.codeop.Compile",
      "name": "Compile",
      "module": "codeop",
      "type": "class",
      "signature": "()",
      "description": "Instances of this class behave much like the built-in compile\nfunction, but if one is used to compile text containing a future\nstatement, it \"remembers\" and compiles all subsequent program texts\nwith the statement in force.",
      "relationships": []
    },
    {
      "id": "stdlib.codeop.compile_command",
      "name": "compile_command",
      "module": "codeop",
      "type": "function",
      "signature": "(source, filename='<input>', symbol='single')",
      "description": "Compile a command and determine whether it is incomplete.\n\nArguments:\n\nsource -- the source string; may contain \\n characters\nfilename -- optional filename from which source was read; default\n            \"<input>\"\nsymbol -- optional grammar start symbol; \"single\" (default), \"exec\"\n          or \"eval\"\n\nReturn value / exceptions raised:\n\n- Return a code object if the command is complete and valid\n- Return None if the command is incomplete\n- Raise SyntaxError, ValueError or OverflowError if the command is a\n  syntax error (OverflowError and ValueError can be produced by\n  malformed literals).",
      "relationships": [
        {
          "target": "stdlib.codeop._maybe_compile",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.collections.ChainMap",
      "name": "ChainMap",
      "module": "collections",
      "type": "class",
      "signature": "(*maps)",
      "description": "A ChainMap groups multiple dicts (or other mappings) together\nto create a single, updateable view.\n\nThe underlying mappings are stored in a list.  That list is public and can\nbe accessed or updated using the *maps* attribute.  There is no other\nstate.\n\nLookups search the underlying mappings successively until a key is found.\nIn contrast, writes, updates, and deletions only operate on the first\nmapping.",
      "relationships": [
        {
          "target": "stdlib.collections.abc.MutableMapping",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Mapping",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Collection",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Sized",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Iterable",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Container",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.collections.Counter",
      "name": "Counter",
      "module": "collections",
      "type": "class",
      "signature": "(iterable=None, /, **kwds)",
      "description": "Dict subclass for counting hashable items.  Sometimes called a bag\nor multiset.  Elements are stored as dictionary keys and their counts\nare stored as dictionary values.\n\n>>> c = Counter('abcdeabcdabcaba')  # count elements from a string\n\n>>> c.most_common(3)                # three most common elements\n[('a', 5), ('b', 4), ('c', 3)]\n>>> sorted(c)                       # list all unique elements\n['a', 'b', 'c', 'd', 'e']\n>>> ''.join(sorted(c.elements()))   # list elements with repetitions\n'aaaaabbbbcccdde'\n>>> sum(c.values())                 # total of all counts\n15\n\n>>> c['a']                          # count of letter 'a'\n5\n>>> for elem in 'shazam':           # update counts from an iterable\n...     c[elem] += 1                # by adding 1 to each element's count\n>>> c['a']                          # now there are seven 'a'\n7\n>>> del c['b']                      # remove all 'b'\n>>> c['b']                          # now there are zero 'b'\n0\n\n>>> d = Counter('simsalabim')       # make another counter\n>>> c.update(d)                     # add in the second counter\n>>> c['a']                          # now there are nine 'a'\n9\n\n>>> c.clear()                       # empty the counter\n>>> c\nCounter()\n\nNote:  If a count is set to zero or reduced to zero, it will remain\nin the counter until the entry is deleted or the counter is cleared:\n\n>>> c = Counter('aaabbc')\n>>> c['b'] -= 2                     # reduce the count of 'b' by two\n>>> c.most_common()                 # 'b' is still in, but its count is zero\n[('a', 3), ('c', 1), ('b', 0)]",
      "relationships": [
        {
          "target": "stdlib.builtins.dict",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.collections.UserDict",
      "name": "UserDict",
      "module": "collections",
      "type": "class",
      "signature": "(dict=None, /, **kwargs)",
      "description": "A MutableMapping is a generic container for associating\nkey/value pairs.\n\nThis class provides concrete generic implementations of all\nmethods except for __getitem__, __setitem__, __delitem__,\n__iter__, and __len__.",
      "relationships": [
        {
          "target": "stdlib.collections.abc.MutableMapping",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Mapping",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Collection",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Sized",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Iterable",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Container",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.collections.UserList",
      "name": "UserList",
      "module": "collections",
      "type": "class",
      "signature": "(initlist=None)",
      "description": "A more or less complete user-defined wrapper around list objects.",
      "relationships": [
        {
          "target": "stdlib.collections.abc.MutableSequence",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Sequence",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Reversible",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Collection",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Sized",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Iterable",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Container",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.collections.UserString",
      "name": "UserString",
      "module": "collections",
      "type": "class",
      "signature": "(seq)",
      "description": "All the operations on a read-only sequence.\n\nConcrete subclasses must override __new__ or __init__,\n__getitem__, and __len__.",
      "relationships": [
        {
          "target": "stdlib.collections.abc.Sequence",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Reversible",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Collection",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Sized",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Iterable",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Container",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.collections.namedtuple",
      "name": "namedtuple",
      "module": "collections",
      "type": "function",
      "signature": "(typename, field_names, *, rename=False, defaults=None, module=None)",
      "description": "Returns a new subclass of tuple with named fields.\n\n>>> Point = namedtuple('Point', ['x', 'y'])\n>>> Point.__doc__                   # docstring for the new class\n'Point(x, y)'\n>>> p = Point(11, y=22)             # instantiate with positional args or keywords\n>>> p[0] + p[1]                     # indexable like a plain tuple\n33\n>>> x, y = p                        # unpack like a regular tuple\n>>> x, y\n(11, 22)\n>>> p.x + p.y                       # fields also accessible by name\n33\n>>> d = p._asdict()                 # convert to a dictionary\n>>> d['x']\n11\n>>> Point(**d)                      # convert from a dictionary\nPoint(x=11, y=22)\n>>> p._replace(x=100)               # _replace() is like str.replace() but targets named fields\nPoint(x=100, y=22)",
      "relationships": []
    },
    {
      "id": "stdlib.colorsys.hls_to_rgb",
      "name": "hls_to_rgb",
      "module": "colorsys",
      "type": "function",
      "signature": "(h, l, s)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.colorsys._v",
          "type": "calls"
        },
        {
          "target": "stdlib.colorsys._v",
          "type": "calls"
        },
        {
          "target": "stdlib.colorsys._v",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.colorsys.hsv_to_rgb",
      "name": "hsv_to_rgb",
      "module": "colorsys",
      "type": "function",
      "signature": "(h, s, v)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.colorsys.rgb_to_hls",
      "name": "rgb_to_hls",
      "module": "colorsys",
      "type": "function",
      "signature": "(r, g, b)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.colorsys.rgb_to_hsv",
      "name": "rgb_to_hsv",
      "module": "colorsys",
      "type": "function",
      "signature": "(r, g, b)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.colorsys.rgb_to_yiq",
      "name": "rgb_to_yiq",
      "module": "colorsys",
      "type": "function",
      "signature": "(r, g, b)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.colorsys.yiq_to_rgb",
      "name": "yiq_to_rgb",
      "module": "colorsys",
      "type": "function",
      "signature": "(y, i, q)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.compileall.compile_dir",
      "name": "compile_dir",
      "module": "compileall",
      "type": "function",
      "signature": "(dir, maxlevels=None, ddir=None, force=False, rx=None, quiet=0, legacy=False, optimize=-1, workers=1, invalidation_mode=None, *, stripdir=None, prependdir=None, limit_sl_dest=None, hardlink_dupes=False)",
      "description": "Byte-compile all modules in the given directory tree.\n\nArguments (only dir is required):\n\ndir:       the directory to byte-compile\nmaxlevels: maximum recursion level (default `sys.getrecursionlimit()`)\nddir:      the directory that will be prepended to the path to the\n           file as it is compiled into each byte-code file.\nforce:     if True, force compilation, even if timestamps are up-to-date\nquiet:     full output with False or 0, errors only with 1,\n           no output with 2\nlegacy:    if True, produce legacy pyc paths instead of PEP 3147 paths\noptimize:  int or list of optimization levels or -1 for level of\n           the interpreter. Multiple levels leads to multiple compiled\n           files each with one optimization level.\nworkers:   maximum number of parallel workers\ninvalidation_mode: how the up-to-dateness of the pyc will be checked\nstripdir:  part of path to left-strip from source file path\nprependdir: path to prepend to beginning of original file path, applied\n           after stripdir\nlimit_sl_dest: ignore symlinks if they are pointing outside of\n               the defined path\nhardlink_dupes: hardlink duplicated pyc files",
      "relationships": [
        {
          "target": "stdlib.compileall._walk_dir",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.compile_file",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.compileall.compile_file",
      "name": "compile_file",
      "module": "compileall",
      "type": "function",
      "signature": "(fullname, ddir=None, force=False, rx=None, quiet=0, legacy=False, optimize=-1, invalidation_mode=None, *, stripdir=None, prependdir=None, limit_sl_dest=None, hardlink_dupes=False)",
      "description": "Byte-compile one file.\n\nArguments (only fullname is required):\n\nfullname:  the file to byte-compile\nddir:      if given, the directory name compiled in to the\n           byte-code file.\nforce:     if True, force compilation, even if timestamps are up-to-date\nquiet:     full output with False or 0, errors only with 1,\n           no output with 2\nlegacy:    if True, produce legacy pyc paths instead of PEP 3147 paths\noptimize:  int or list of optimization levels or -1 for level of\n           the interpreter. Multiple levels leads to multiple compiled\n           files each with one optimization level.\ninvalidation_mode: how the up-to-dateness of the pyc will be checked\nstripdir:  part of path to left-strip from source file path\nprependdir: path to prepend to beginning of original file path, applied\n           after stripdir\nlimit_sl_dest: ignore symlinks if they are pointing outside of\n               the defined path.\nhardlink_dupes: hardlink duplicated pyc files",
      "relationships": []
    },
    {
      "id": "stdlib.compileall.compile_path",
      "name": "compile_path",
      "module": "compileall",
      "type": "function",
      "signature": "(skip_curdir=1, maxlevels=0, force=False, quiet=0, legacy=False, optimize=-1, invalidation_mode=None)",
      "description": "Byte-compile all module on sys.path.\n\nArguments (all optional):\n\nskip_curdir: if true, skip current directory (default True)\nmaxlevels:   max recursion level (default 0)\nforce: as for compile_dir() (default False)\nquiet: as for compile_dir() (default 0)\nlegacy: as for compile_dir() (default False)\noptimize: as for compile_dir() (default -1)\ninvalidation_mode: as for compiler_dir()",
      "relationships": [
        {
          "target": "stdlib.compileall.compile_dir",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.compileall.main",
      "name": "main",
      "module": "compileall",
      "type": "function",
      "signature": "()",
      "description": "Script main program.",
      "relationships": [
        {
          "target": "stdlib.compileall.compile_path",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.compile_file",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.compile_dir",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.configparser.BasicInterpolation",
      "name": "BasicInterpolation",
      "module": "configparser",
      "type": "class",
      "signature": "()",
      "description": "Interpolation as implemented in the classic ConfigParser.\n\nThe option values can contain format strings which refer to other values in\nthe same section, or values in the special default section.\n\nFor example:\n\n    something: %(dir)s/whatever\n\nwould resolve the \"%(dir)s\" to the value of dir.  All reference\nexpansions are done late, on demand. If a user needs to use a bare % in\na configuration file, she can escape it by writing %%. Other % usage\nis considered a user error and raises `InterpolationSyntaxError`.",
      "relationships": [
        {
          "target": "stdlib.configparser.Interpolation",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.configparser.ConfigParser",
      "name": "ConfigParser",
      "module": "configparser",
      "type": "class",
      "signature": "(defaults=None, dict_type=<class 'dict'>, allow_no_value=False, *, delimiters=('=', ':'), comment_prefixes=('#', ';'), inline_comment_prefixes=None, strict=True, empty_lines_in_values=True, default_section='DEFAULT', interpolation=<object object at 0x100109270>, converters=<object object at 0x100109270>)",
      "description": "ConfigParser implementing interpolation.",
      "relationships": [
        {
          "target": "stdlib.configparser.RawConfigParser",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.MutableMapping",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Mapping",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Collection",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Sized",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Iterable",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Container",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.configparser.ConverterMapping",
      "name": "ConverterMapping",
      "module": "configparser",
      "type": "class",
      "signature": "(parser)",
      "description": "Enables reuse of get*() methods between the parser and section proxies.\n\nIf a parser class implements a getter directly, the value for the given\nkey will be ``None``. The presence of the converter name here enables\nsection proxies to find and use the implementation on the parser class.",
      "relationships": [
        {
          "target": "stdlib.collections.abc.MutableMapping",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Mapping",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Collection",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Sized",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Iterable",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Container",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.configparser.DuplicateOptionError",
      "name": "DuplicateOptionError",
      "module": "configparser",
      "type": "class",
      "signature": "(section, option, source=None, lineno=None)",
      "description": "Raised by strict parsers when an option is repeated in an input source.\n\nCurrent implementation raises this exception only when an option is found\nmore than once in a single file, string or dictionary.",
      "relationships": [
        {
          "target": "stdlib.configparser.Error",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Exception",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.configparser.DuplicateSectionError",
      "name": "DuplicateSectionError",
      "module": "configparser",
      "type": "class",
      "signature": "(section, source=None, lineno=None)",
      "description": "Raised when a section is repeated in an input source.\n\nPossible repetitions that raise this exception are: multiple creation\nusing the API or in strict parsers when a section is found more than once\nin a single input file, string or dictionary.",
      "relationships": [
        {
          "target": "stdlib.configparser.Error",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Exception",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.configparser.Error",
      "name": "Error",
      "module": "configparser",
      "type": "class",
      "signature": "(msg='')",
      "description": "Base class for ConfigParser exceptions.",
      "relationships": [
        {
          "target": "stdlib.builtins.Exception",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.configparser.ExtendedInterpolation",
      "name": "ExtendedInterpolation",
      "module": "configparser",
      "type": "class",
      "signature": "()",
      "description": "Advanced variant of interpolation, supports the syntax used by\n`zc.buildout`. Enables interpolation between sections.",
      "relationships": [
        {
          "target": "stdlib.configparser.Interpolation",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.configparser.Interpolation",
      "name": "Interpolation",
      "module": "configparser",
      "type": "class",
      "signature": "()",
      "description": "Dummy interpolation that passes the value through with no changes.",
      "relationships": []
    },
    {
      "id": "stdlib.configparser.InterpolationDepthError",
      "name": "InterpolationDepthError",
      "module": "configparser",
      "type": "class",
      "signature": "(option, section, rawval)",
      "description": "Raised when substitutions are nested too deeply.",
      "relationships": [
        {
          "target": "stdlib.configparser.InterpolationError",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Error",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Exception",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.configparser.InterpolationError",
      "name": "InterpolationError",
      "module": "configparser",
      "type": "class",
      "signature": "(option, section, msg)",
      "description": "Base class for interpolation-related exceptions.",
      "relationships": [
        {
          "target": "stdlib.configparser.Error",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Exception",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.configparser.InterpolationMissingOptionError",
      "name": "InterpolationMissingOptionError",
      "module": "configparser",
      "type": "class",
      "signature": "(option, section, rawval, reference)",
      "description": "A string substitution required a setting which was not available.",
      "relationships": [
        {
          "target": "stdlib.configparser.InterpolationError",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Error",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Exception",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.configparser.InterpolationSyntaxError",
      "name": "InterpolationSyntaxError",
      "module": "configparser",
      "type": "class",
      "signature": "(option, section, msg)",
      "description": "Raised when the source text contains invalid syntax.\n\nCurrent implementation raises this exception when the source text into\nwhich substitutions are made does not conform to the required syntax.",
      "relationships": [
        {
          "target": "stdlib.configparser.InterpolationError",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Error",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Exception",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.configparser.LegacyInterpolation",
      "name": "LegacyInterpolation",
      "module": "configparser",
      "type": "class",
      "signature": "(*args, **kwargs)",
      "description": "Deprecated interpolation used in old versions of ConfigParser.\nUse BasicInterpolation or ExtendedInterpolation instead.",
      "relationships": [
        {
          "target": "stdlib.configparser.Interpolation",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.configparser.MissingSectionHeaderError",
      "name": "MissingSectionHeaderError",
      "module": "configparser",
      "type": "class",
      "signature": "(filename, lineno, line)",
      "description": "Raised when a key-value pair is found before any section header.",
      "relationships": [
        {
          "target": "stdlib.configparser.ParsingError",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Error",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Exception",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.configparser.NoOptionError",
      "name": "NoOptionError",
      "module": "configparser",
      "type": "class",
      "signature": "(option, section)",
      "description": "A requested option was not found.",
      "relationships": [
        {
          "target": "stdlib.configparser.Error",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Exception",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.configparser.NoSectionError",
      "name": "NoSectionError",
      "module": "configparser",
      "type": "class",
      "signature": "(section)",
      "description": "Raised when no section matches a requested option.",
      "relationships": [
        {
          "target": "stdlib.configparser.Error",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Exception",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.configparser.ParsingError",
      "name": "ParsingError",
      "module": "configparser",
      "type": "class",
      "signature": "(source)",
      "description": "Raised when a configuration file does not follow legal syntax.",
      "relationships": [
        {
          "target": "stdlib.configparser.Error",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Exception",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.configparser.RawConfigParser",
      "name": "RawConfigParser",
      "module": "configparser",
      "type": "class",
      "signature": "(defaults=None, dict_type=<class 'dict'>, allow_no_value=False, *, delimiters=('=', ':'), comment_prefixes=('#', ';'), inline_comment_prefixes=None, strict=True, empty_lines_in_values=True, default_section='DEFAULT', interpolation=<object object at 0x100109270>, converters=<object object at 0x100109270>)",
      "description": "ConfigParser that does not do interpolation.",
      "relationships": [
        {
          "target": "stdlib.collections.abc.MutableMapping",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Mapping",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Collection",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Sized",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Iterable",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Container",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.configparser.SectionProxy",
      "name": "SectionProxy",
      "module": "configparser",
      "type": "class",
      "signature": "(parser, name)",
      "description": "A proxy for a single section from a parser.",
      "relationships": [
        {
          "target": "stdlib.collections.abc.MutableMapping",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Mapping",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Collection",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Sized",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Iterable",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Container",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.contextlib.AbstractAsyncContextManager",
      "name": "AbstractAsyncContextManager",
      "module": "contextlib",
      "type": "class",
      "signature": "()",
      "description": "An abstract base class for asynchronous context managers.",
      "relationships": [
        {
          "target": "stdlib.abc.ABC",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.contextlib.AbstractContextManager",
      "name": "AbstractContextManager",
      "module": "contextlib",
      "type": "class",
      "signature": "()",
      "description": "An abstract base class for context managers.",
      "relationships": [
        {
          "target": "stdlib.abc.ABC",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.contextlib.AsyncContextDecorator",
      "name": "AsyncContextDecorator",
      "module": "contextlib",
      "type": "class",
      "signature": "()",
      "description": "A base class or mixin that enables async context managers to work as decorators.",
      "relationships": []
    },
    {
      "id": "stdlib.contextlib.AsyncExitStack",
      "name": "AsyncExitStack",
      "module": "contextlib",
      "type": "class",
      "signature": "()",
      "description": "Async context manager for dynamic management of a stack of exit\ncallbacks.\n\nFor example:\n    async with AsyncExitStack() as stack:\n        connections = [await stack.enter_async_context(get_connection())\n            for i in range(5)]\n        # All opened connections will automatically be released at the\n        # end of the async with statement, even if attempts to open a\n        # connection later in the list raise an exception.",
      "relationships": [
        {
          "target": "stdlib.contextlib._BaseExitStack",
          "type": "base_class"
        },
        {
          "target": "stdlib.contextlib.AbstractAsyncContextManager",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.ABC",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.contextlib.ContextDecorator",
      "name": "ContextDecorator",
      "module": "contextlib",
      "type": "class",
      "signature": "()",
      "description": "A base class or mixin that enables context managers to work as decorators.",
      "relationships": []
    },
    {
      "id": "stdlib.contextlib.ExitStack",
      "name": "ExitStack",
      "module": "contextlib",
      "type": "class",
      "signature": "()",
      "description": "Context manager for dynamic management of a stack of exit callbacks.\n\nFor example:\n    with ExitStack() as stack:\n        files = [stack.enter_context(open(fname)) for fname in filenames]\n        # All opened files will automatically be closed at the end of\n        # the with statement, even if attempts to open files later\n        # in the list raise an exception.",
      "relationships": [
        {
          "target": "stdlib.contextlib._BaseExitStack",
          "type": "base_class"
        },
        {
          "target": "stdlib.contextlib.AbstractContextManager",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.ABC",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.contextlib.aclosing",
      "name": "aclosing",
      "module": "contextlib",
      "type": "class",
      "signature": "(thing)",
      "description": "Async context manager for safely finalizing an asynchronously cleaned-up\nresource such as an async generator, calling its ``aclose()`` method.\n\nCode like this:\n\n    async with aclosing(<module>.fetch(<arguments>)) as agen:\n        <block>\n\nis equivalent to this:\n\n    agen = <module>.fetch(<arguments>)\n    try:\n        <block>\n    finally:\n        await agen.aclose()",
      "relationships": [
        {
          "target": "stdlib.contextlib.AbstractAsyncContextManager",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.ABC",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.contextlib.asynccontextmanager",
      "name": "asynccontextmanager",
      "module": "contextlib",
      "type": "function",
      "signature": "(func)",
      "description": "@asynccontextmanager decorator.\n\nTypical usage:\n\n    @asynccontextmanager\n    async def some_async_generator(<arguments>):\n        <setup>\n        try:\n            yield <value>\n        finally:\n            <cleanup>\n\nThis makes this:\n\n    async with some_async_generator(<arguments>) as <variable>:\n        <body>\n\nequivalent to this:\n\n    <setup>\n    try:\n        <variable> = <value>\n        <body>\n    finally:\n        <cleanup>",
      "relationships": []
    },
    {
      "id": "stdlib.contextlib.chdir",
      "name": "chdir",
      "module": "contextlib",
      "type": "class",
      "signature": "(path)",
      "description": "Non thread-safe context manager to change the current working directory.",
      "relationships": [
        {
          "target": "stdlib.contextlib.AbstractContextManager",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.ABC",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.contextlib.closing",
      "name": "closing",
      "module": "contextlib",
      "type": "class",
      "signature": "(thing)",
      "description": "Context to automatically close something at the end of a block.\n\nCode like this:\n\n    with closing(<module>.open(<arguments>)) as f:\n        <block>\n\nis equivalent to this:\n\n    f = <module>.open(<arguments>)\n    try:\n        <block>\n    finally:\n        f.close()",
      "relationships": [
        {
          "target": "stdlib.contextlib.AbstractContextManager",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.ABC",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.contextlib.contextmanager",
      "name": "contextmanager",
      "module": "contextlib",
      "type": "function",
      "signature": "(func)",
      "description": "@contextmanager decorator.\n\nTypical usage:\n\n    @contextmanager\n    def some_generator(<arguments>):\n        <setup>\n        try:\n            yield <value>\n        finally:\n            <cleanup>\n\nThis makes this:\n\n    with some_generator(<arguments>) as <variable>:\n        <body>\n\nequivalent to this:\n\n    <setup>\n    try:\n        <variable> = <value>\n        <body>\n    finally:\n        <cleanup>",
      "relationships": []
    },
    {
      "id": "stdlib.contextlib.nullcontext",
      "name": "nullcontext",
      "module": "contextlib",
      "type": "class",
      "signature": "(enter_result=None)",
      "description": "Context manager that does no additional processing.\n\nUsed as a stand-in for a normal context manager, when a particular\nblock of code is only sometimes used with a normal context manager:\n\ncm = optional_cm if condition else nullcontext()\nwith cm:\n    # Perform operation, using optional_cm if condition is True",
      "relationships": [
        {
          "target": "stdlib.contextlib.AbstractContextManager",
          "type": "base_class"
        },
        {
          "target": "stdlib.contextlib.AbstractAsyncContextManager",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.ABC",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.contextlib.redirect_stderr",
      "name": "redirect_stderr",
      "module": "contextlib",
      "type": "class",
      "signature": "(new_target)",
      "description": "Context manager for temporarily redirecting stderr to another file.",
      "relationships": [
        {
          "target": "stdlib.contextlib._RedirectStream",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.AbstractContextManager",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.ABC",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.contextlib.redirect_stdout",
      "name": "redirect_stdout",
      "module": "contextlib",
      "type": "class",
      "signature": "(new_target)",
      "description": "Context manager for temporarily redirecting stdout to another file.\n\n# How to send help() to stderr\nwith redirect_stdout(sys.stderr):\n    help(dir)\n\n# How to write help() to a file\nwith open('help.txt', 'w') as f:\n    with redirect_stdout(f):\n        help(pow)",
      "relationships": [
        {
          "target": "stdlib.contextlib._RedirectStream",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.AbstractContextManager",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.ABC",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.contextlib.suppress",
      "name": "suppress",
      "module": "contextlib",
      "type": "class",
      "signature": "(*exceptions)",
      "description": "Context manager to suppress specified exceptions\n\nAfter the exception is suppressed, execution proceeds with the next\nstatement following the with statement.\n\n     with suppress(FileNotFoundError):\n         os.remove(somefile)\n     # Execution still resumes here if the file was already removed",
      "relationships": [
        {
          "target": "stdlib.contextlib.AbstractContextManager",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.ABC",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.copy.copy",
      "name": "copy",
      "module": "copy",
      "type": "function",
      "signature": "(x)",
      "description": "Shallow copy operation on arbitrary Python objects.\n\nSee the module's __doc__ string for more info.",
      "relationships": [
        {
          "target": "stdlib.copy._reconstruct",
          "type": "calls"
        },
        {
          "target": "stdlib.copy._copy_immutable",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.copy.deepcopy",
      "name": "deepcopy",
      "module": "copy",
      "type": "function",
      "signature": "(x, memo=None, _nil=[])",
      "description": "Deep copy operation on arbitrary Python objects.\n\nSee the module's __doc__ string for more info.",
      "relationships": [
        {
          "target": "stdlib.copy._keep_alive",
          "type": "calls"
        },
        {
          "target": "stdlib.copy._deepcopy_atomic",
          "type": "calls"
        },
        {
          "target": "stdlib.copy._reconstruct",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.copyreg.add_extension",
      "name": "add_extension",
      "module": "copyreg",
      "type": "function",
      "signature": "(module, name, code)",
      "description": "Register an extension code.",
      "relationships": []
    },
    {
      "id": "stdlib.copyreg.clear_extension_cache",
      "name": "clear_extension_cache",
      "module": "copyreg",
      "type": "function",
      "signature": "()",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.copyreg.constructor",
      "name": "constructor",
      "module": "copyreg",
      "type": "function",
      "signature": "(object)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.copyreg.pickle",
      "name": "pickle",
      "module": "copyreg",
      "type": "function",
      "signature": "(ob_type, pickle_function, constructor_ob=None)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.copyreg.constructor",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.copyreg.pickle_complex",
      "name": "pickle_complex",
      "module": "copyreg",
      "type": "function",
      "signature": "(c)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.copyreg.pickle_union",
      "name": "pickle_union",
      "module": "copyreg",
      "type": "function",
      "signature": "(obj)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.copyreg.remove_extension",
      "name": "remove_extension",
      "module": "copyreg",
      "type": "function",
      "signature": "(module, name, code)",
      "description": "Unregister an extension code.  For testing only.",
      "relationships": []
    },
    {
      "id": "stdlib.crypt.crypt",
      "name": "crypt",
      "module": "crypt",
      "type": "function",
      "signature": "(word, salt=None)",
      "description": "Return a string representing the one-way hash of a password, with a salt\nprepended.\n\nIf ``salt`` is not specified or is ``None``, the strongest\navailable method will be selected and a salt generated.  Otherwise,\n``salt`` may be one of the ``crypt.METHOD_*`` values, or a string as\nreturned by ``crypt.mksalt()``.",
      "relationships": [
        {
          "target": "stdlib.crypt.mksalt",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.crypt.mksalt",
      "name": "mksalt",
      "module": "crypt",
      "type": "function",
      "signature": "(method=None, *, rounds=None)",
      "description": "Generate a salt for the specified method.\n\nIf not specified, the strongest available method will be used.",
      "relationships": []
    },
    {
      "id": "stdlib.csv.Dialect",
      "name": "Dialect",
      "module": "csv",
      "type": "class",
      "signature": "()",
      "description": "Describe a CSV dialect.\n\nThis must be subclassed (see csv.excel).  Valid attributes are:\ndelimiter, quotechar, escapechar, doublequote, skipinitialspace,\nlineterminator, quoting.",
      "relationships": []
    },
    {
      "id": "stdlib.csv.DictReader",
      "name": "DictReader",
      "module": "csv",
      "type": "class",
      "signature": "(f, fieldnames=None, restkey=None, restval=None, dialect='excel', *args, **kwds)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.csv.DictWriter",
      "name": "DictWriter",
      "module": "csv",
      "type": "class",
      "signature": "(f, fieldnames, restval='', extrasaction='raise', dialect='excel', *args, **kwds)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.csv.Sniffer",
      "name": "Sniffer",
      "module": "csv",
      "type": "class",
      "signature": "()",
      "description": "\"Sniffs\" the format of a CSV file (i.e. delimiter, quotechar)\nReturns a Dialect object.",
      "relationships": []
    },
    {
      "id": "stdlib.csv.excel",
      "name": "excel",
      "module": "csv",
      "type": "class",
      "signature": "()",
      "description": "Describe the usual properties of Excel-generated CSV files.",
      "relationships": [
        {
          "target": "stdlib.csv.Dialect",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.csv.excel_tab",
      "name": "excel_tab",
      "module": "csv",
      "type": "class",
      "signature": "()",
      "description": "Describe the usual properties of Excel-generated TAB-delimited files.",
      "relationships": [
        {
          "target": "stdlib.csv.excel",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Dialect",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.csv.unix_dialect",
      "name": "unix_dialect",
      "module": "csv",
      "type": "class",
      "signature": "()",
      "description": "Describe the usual properties of Unix-generated CSV files.",
      "relationships": [
        {
          "target": "stdlib.csv.Dialect",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.ctypes.ARRAY",
      "name": "ARRAY",
      "module": "ctypes",
      "type": "function",
      "signature": "(typ, len)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.ctypes.CDLL",
      "name": "CDLL",
      "module": "ctypes",
      "type": "class",
      "signature": "(name, mode=4, handle=None, use_errno=False, use_last_error=False, winmode=None)",
      "description": "An instance of this class represents a loaded dll/shared\nlibrary, exporting functions using the standard C calling\nconvention (named 'cdecl' on Windows).\n\nThe exported functions can be accessed as attributes, or by\nindexing with the function name.  Examples:\n\n<obj>.qsort -> callable object\n<obj>['qsort'] -> callable object\n\nCalling the functions releases the Python GIL during the call and\nreacquires it afterwards.",
      "relationships": []
    },
    {
      "id": "stdlib.ctypes.CFUNCTYPE",
      "name": "CFUNCTYPE",
      "module": "ctypes",
      "type": "function",
      "signature": "(restype, *argtypes, **kw)",
      "description": "CFUNCTYPE(restype, *argtypes,\n             use_errno=False, use_last_error=False) -> function prototype.\n\nrestype: the result type\nargtypes: a sequence specifying the argument types\n\nThe function prototype can be called in different ways to create a\ncallable object:\n\nprototype(integer address) -> foreign function\nprototype(callable) -> create and return a C callable function from callable\nprototype(integer index, method name[, paramflags]) -> foreign function calling a COM method\nprototype((ordinal number, dll object)[, paramflags]) -> foreign function exported by ordinal\nprototype((function name, dll object)[, paramflags]) -> foreign function exported by name",
      "relationships": []
    },
    {
      "id": "stdlib.ctypes.LibraryLoader",
      "name": "LibraryLoader",
      "module": "ctypes",
      "type": "class",
      "signature": "(dlltype)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.ctypes.PYFUNCTYPE",
      "name": "PYFUNCTYPE",
      "module": "ctypes",
      "type": "function",
      "signature": "(restype, *argtypes)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.ctypes.PyDLL",
      "name": "PyDLL",
      "module": "ctypes",
      "type": "class",
      "signature": "(name, mode=4, handle=None, use_errno=False, use_last_error=False, winmode=None)",
      "description": "This class represents the Python library itself.  It allows\naccessing Python API functions.  The GIL is not released, and\nPython exceptions are handled correctly.",
      "relationships": [
        {
          "target": "stdlib.ctypes.CDLL",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.ctypes.SetPointerType",
      "name": "SetPointerType",
      "module": "ctypes",
      "type": "function",
      "signature": "(pointer, cls)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.ctypes.c_buffer",
      "name": "c_buffer",
      "module": "ctypes",
      "type": "function",
      "signature": "(init, size=None)",
      "description": "create_string_buffer(aBytes) -> character array\ncreate_string_buffer(anInteger) -> character array\ncreate_string_buffer(aBytes, anInteger) -> character array",
      "relationships": []
    },
    {
      "id": "stdlib.ctypes.cast",
      "name": "cast",
      "module": "ctypes",
      "type": "function",
      "signature": "(obj, typ)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.ctypes.create_string_buffer",
      "name": "create_string_buffer",
      "module": "ctypes",
      "type": "function",
      "signature": "(init, size=None)",
      "description": "create_string_buffer(aBytes) -> character array\ncreate_string_buffer(anInteger) -> character array\ncreate_string_buffer(aBytes, anInteger) -> character array",
      "relationships": []
    },
    {
      "id": "stdlib.ctypes.create_unicode_buffer",
      "name": "create_unicode_buffer",
      "module": "ctypes",
      "type": "function",
      "signature": "(init, size=None)",
      "description": "create_unicode_buffer(aString) -> character array\ncreate_unicode_buffer(anInteger) -> character array\ncreate_unicode_buffer(aString, anInteger) -> character array",
      "relationships": []
    },
    {
      "id": "stdlib.ctypes.string_at",
      "name": "string_at",
      "module": "ctypes",
      "type": "function",
      "signature": "(ptr, size=-1)",
      "description": "string_at(ptr[, size]) -> string\n\nReturn the byte string at void *ptr.",
      "relationships": []
    },
    {
      "id": "stdlib.ctypes.wstring_at",
      "name": "wstring_at",
      "module": "ctypes",
      "type": "function",
      "signature": "(ptr, size=-1)",
      "description": "wstring_at(ptr[, size]) -> string\n\nReturn the wide-character string at void *ptr.",
      "relationships": []
    },
    {
      "id": "stdlib.curses.initscr",
      "name": "initscr",
      "module": "curses",
      "type": "function",
      "signature": "()",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.curses.start_color",
      "name": "start_color",
      "module": "curses",
      "type": "function",
      "signature": "()",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.curses.wrapper",
      "name": "wrapper",
      "module": "curses",
      "type": "function",
      "signature": "(func, /, *args, **kwds)",
      "description": "Wrapper function that initializes curses and calls another function,\nrestoring normal keyboard/screen behavior on error.\nThe callable object 'func' is then passed the main window 'stdscr'\nas its first argument, followed by any other arguments passed to\nwrapper().",
      "relationships": [
        {
          "target": "stdlib.curses.initscr",
          "type": "calls"
        },
        {
          "target": "stdlib.curses.start_color",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.dataclasses.Field",
      "name": "Field",
      "module": "dataclasses",
      "type": "class",
      "signature": "(default, default_factory, init, repr, hash, compare, metadata, kw_only)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.dataclasses.InitVar",
      "name": "InitVar",
      "module": "dataclasses",
      "type": "class",
      "signature": "(type)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.dataclasses.asdict",
      "name": "asdict",
      "module": "dataclasses",
      "type": "function",
      "signature": "(obj, *, dict_factory=<class 'dict'>)",
      "description": "Return the fields of a dataclass instance as a new dictionary mapping\nfield names to field values.\n\nExample usage::\n\n  @dataclass\n  class C:\n      x: int\n      y: int\n\n  c = C(1, 2)\n  assert asdict(c) == {'x': 1, 'y': 2}\n\nIf given, 'dict_factory' will be used instead of built-in dict.\nThe function applies recursively to field values that are\ndataclass instances. This will also look into built-in containers:\ntuples, lists, and dicts. Other objects are copied with 'copy.deepcopy()'.",
      "relationships": [
        {
          "target": "stdlib.dataclasses._asdict_inner",
          "type": "calls"
        },
        {
          "target": "stdlib.dataclasses._is_dataclass_instance",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.dataclasses.astuple",
      "name": "astuple",
      "module": "dataclasses",
      "type": "function",
      "signature": "(obj, *, tuple_factory=<class 'tuple'>)",
      "description": "Return the fields of a dataclass instance as a new tuple of field values.\n\nExample usage::\n\n  @dataclass\n  class C:\n      x: int\n      y: int\n\n  c = C(1, 2)\n  assert astuple(c) == (1, 2)\n\nIf given, 'tuple_factory' will be used instead of built-in tuple.\nThe function applies recursively to field values that are\ndataclass instances. This will also look into built-in containers:\ntuples, lists, and dicts. Other objects are copied with 'copy.deepcopy()'.",
      "relationships": [
        {
          "target": "stdlib.dataclasses._astuple_inner",
          "type": "calls"
        },
        {
          "target": "stdlib.dataclasses._is_dataclass_instance",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.dataclasses.dataclass",
      "name": "dataclass",
      "module": "dataclasses",
      "type": "function",
      "signature": "(cls=None, /, *, init=True, repr=True, eq=True, order=False, unsafe_hash=False, frozen=False, match_args=True, kw_only=False, slots=False, weakref_slot=False)",
      "description": "Add dunder methods based on the fields defined in the class.\n\nExamines PEP 526 __annotations__ to determine fields.\n\nIf init is true, an __init__() method is added to the class. If repr\nis true, a __repr__() method is added. If order is true, rich\ncomparison dunder methods are added. If unsafe_hash is true, a\n__hash__() method is added. If frozen is true, fields may not be\nassigned to after instance creation. If match_args is true, the\n__match_args__ tuple is added. If kw_only is true, then by default\nall fields are keyword-only. If slots is true, a new class with a\n__slots__ attribute is returned.",
      "relationships": [
        {
          "target": "stdlib.dataclasses._process_class",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.dataclasses.field",
      "name": "field",
      "module": "dataclasses",
      "type": "function",
      "signature": "(*, default=<dataclasses._MISSING_TYPE object at 0x10625cef0>, default_factory=<dataclasses._MISSING_TYPE object at 0x10625cef0>, init=True, repr=True, hash=None, compare=True, metadata=None, kw_only=<dataclasses._MISSING_TYPE object at 0x10625cef0>)",
      "description": "Return an object to identify dataclass fields.\n\ndefault is the default value of the field.  default_factory is a\n0-argument function called to initialize a field's value.  If init\nis true, the field will be a parameter to the class's __init__()\nfunction.  If repr is true, the field will be included in the\nobject's repr().  If hash is true, the field will be included in the\nobject's hash().  If compare is true, the field will be used in\ncomparison functions.  metadata, if specified, must be a mapping\nwhich is stored but not otherwise examined by dataclass.  If kw_only\nis true, the field will become a keyword-only parameter to\n__init__().\n\nIt is an error to specify both default and default_factory.",
      "relationships": []
    },
    {
      "id": "stdlib.dataclasses.fields",
      "name": "fields",
      "module": "dataclasses",
      "type": "function",
      "signature": "(class_or_instance)",
      "description": "Return a tuple describing the fields of this dataclass.\n\nAccepts a dataclass or an instance of one. Tuple elements are of\ntype Field.",
      "relationships": []
    },
    {
      "id": "stdlib.dataclasses.is_dataclass",
      "name": "is_dataclass",
      "module": "dataclasses",
      "type": "function",
      "signature": "(obj)",
      "description": "Returns True if obj is a dataclass or an instance of a\ndataclass.",
      "relationships": []
    },
    {
      "id": "stdlib.dataclasses.make_dataclass",
      "name": "make_dataclass",
      "module": "dataclasses",
      "type": "function",
      "signature": "(cls_name, fields, *, bases=(), namespace=None, init=True, repr=True, eq=True, order=False, unsafe_hash=False, frozen=False, match_args=True, kw_only=False, slots=False, weakref_slot=False, module=None)",
      "description": "Return a new dynamically created dataclass.\n\nThe dataclass name will be 'cls_name'.  'fields' is an iterable\nof either (name), (name, type) or (name, type, Field) objects. If type is\nomitted, use the string 'typing.Any'.  Field objects are created by\nthe equivalent of calling 'field(name, type [, Field-info])'.::\n\n  C = make_dataclass('C', ['x', ('y', int), ('z', int, field(init=False))], bases=(Base,))\n\nis equivalent to::\n\n  @dataclass\n  class C(Base):\n      x: 'typing.Any'\n      y: int\n      z: int = field(init=False)\n\nFor the bases and namespace parameters, see the builtin type() function.\n\nThe parameters init, repr, eq, order, unsafe_hash, frozen, match_args, kw_only,\nslots, and weakref_slot are passed to dataclass().\n\nIf module parameter is defined, the '__module__' attribute of the dataclass is\nset to that value.",
      "relationships": [
        {
          "target": "stdlib.dataclasses.dataclass",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.dataclasses.replace",
      "name": "replace",
      "module": "dataclasses",
      "type": "function",
      "signature": "(obj, /, **changes)",
      "description": "Return a new object replacing specified fields with new values.\n\nThis is especially useful for frozen classes.  Example usage::\n\n  @dataclass(frozen=True)\n  class C:\n      x: int\n      y: int\n\n  c = C(1, 2)\n  c1 = replace(c, x=3)\n  assert c1.x == 3 and c1.y == 2",
      "relationships": [
        {
          "target": "stdlib.dataclasses._is_dataclass_instance",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.dbm.open",
      "name": "open",
      "module": "dbm",
      "type": "function",
      "signature": "(file, flag='r', mode=438)",
      "description": "Open or create database at path given by *file*.\n\nOptional argument *flag* can be 'r' (default) for read-only access, 'w'\nfor read-write access of an existing database, 'c' for read-write access\nto a new or existing database, and 'n' for read-write access to a new\ndatabase.\n\nNote: 'r' and 'w' fail if the database doesn't exist; 'c' creates it\nonly if it doesn't exist; and 'n' always creates a new database.",
      "relationships": [
        {
          "target": "stdlib.dbm.whichdb",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.dbm.whichdb",
      "name": "whichdb",
      "module": "dbm",
      "type": "function",
      "signature": "(filename)",
      "description": "Guess which db package to use to open a db file.\n\nReturn values:\n\n- None if the database file can't be read;\n- empty string if the file can be read but can't be recognized\n- the name of the dbm submodule (e.g. \"ndbm\" or \"gnu\") if recognized.\n\nImporting the given module may still fail, and opening the\ndatabase using that module may still fail.",
      "relationships": []
    },
    {
      "id": "stdlib.decimal.Context",
      "name": "Context",
      "module": "decimal",
      "type": "class",
      "signature": "(prec=None, rounding=None, Emin=None, Emax=None, capitals=None, clamp=None, flags=None, traps=None)",
      "description": "The context affects almost all operations and controls rounding,\nOver/Underflow, raising of exceptions and much more.  A new context\ncan be constructed as follows:\n\n    >>> c = Context(prec=28, Emin=-425000000, Emax=425000000,\n    ...             rounding=ROUND_HALF_EVEN, capitals=1, clamp=1,\n    ...             traps=[InvalidOperation, DivisionByZero, Overflow],\n    ...             flags=[])\n    >>>",
      "relationships": []
    },
    {
      "id": "stdlib.decimal.Decimal",
      "name": "Decimal",
      "module": "decimal",
      "type": "class",
      "signature": "(value='0', context=None)",
      "description": "Construct a new Decimal object. 'value' can be an integer, string, tuple,\nor another Decimal object. If no value is given, return Decimal('0'). The\ncontext does not affect the conversion and is only passed to determine if\nthe InvalidOperation trap is active.",
      "relationships": []
    },
    {
      "id": "stdlib.decimal.DecimalTuple",
      "name": "DecimalTuple",
      "module": "decimal",
      "type": "class",
      "signature": "(sign, digits, exponent)",
      "description": "DecimalTuple(sign, digits, exponent)",
      "relationships": [
        {
          "target": "stdlib.builtins.tuple",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.difflib.Differ",
      "name": "Differ",
      "module": "difflib",
      "type": "class",
      "signature": "(linejunk=None, charjunk=None)",
      "description": "Differ is a class for comparing sequences of lines of text, and\nproducing human-readable differences or deltas.  Differ uses\nSequenceMatcher both to compare sequences of lines, and to compare\nsequences of characters within similar (near-matching) lines.\n\nEach line of a Differ delta begins with a two-letter code:\n\n    '- '    line unique to sequence 1\n    '+ '    line unique to sequence 2\n    '  '    line common to both sequences\n    '? '    line not present in either input sequence\n\nLines beginning with '? ' attempt to guide the eye to intraline\ndifferences, and were not present in either input sequence.  These lines\ncan be confusing if the sequences contain tab characters.\n\nNote that Differ makes no claim to produce a *minimal* diff.  To the\ncontrary, minimal diffs are often counter-intuitive, because they synch\nup anywhere possible, sometimes accidental matches 100 pages apart.\nRestricting synch points to contiguous matches preserves some notion of\nlocality, at the occasional cost of producing a longer diff.\n\nExample: Comparing two texts.\n\nFirst we set up the texts, sequences of individual single-line strings\nending with newlines (such sequences can also be obtained from the\n`readlines()` method of file-like objects):\n\n>>> text1 = '''  1. Beautiful is better than ugly.\n...   2. Explicit is better than implicit.\n...   3. Simple is better than complex.\n...   4. Complex is better than complicated.\n... '''.splitlines(keepends=True)\n>>> len(text1)\n4\n>>> text1[0][-1]\n'\\n'\n>>> text2 = '''  1. Beautiful is better than ugly.\n...   3.   Simple is better than complex.\n...   4. Complicated is better than complex.\n...   5. Flat is better than nested.\n... '''.splitlines(keepends=True)\n\nNext we instantiate a Differ object:\n\n>>> d = Differ()\n\nNote that when instantiating a Differ object we may pass functions to\nfilter out line and character 'junk'.  See Differ.__init__ for details.\n\nFinally, we compare the two:\n\n>>> result = list(d.compare(text1, text2))\n\n'result' is a list of strings, so let's pretty-print it:\n\n>>> from pprint import pprint as _pprint\n>>> _pprint(result)\n['    1. Beautiful is better than ugly.\\n',\n '-   2. Explicit is better than implicit.\\n',\n '-   3. Simple is better than complex.\\n',\n '+   3.   Simple is better than complex.\\n',\n '?     ++\\n',\n '-   4. Complex is better than complicated.\\n',\n '?            ^                     ---- ^\\n',\n '+   4. Complicated is better than complex.\\n',\n '?           ++++ ^                      ^\\n',\n '+   5. Flat is better than nested.\\n']\n\nAs a single multi-line string it looks like this:\n\n>>> print(''.join(result), end=\"\")\n    1. Beautiful is better than ugly.\n-   2. Explicit is better than implicit.\n-   3. Simple is better than complex.\n+   3.   Simple is better than complex.\n?     ++\n-   4. Complex is better than complicated.\n?            ^                     ---- ^\n+   4. Complicated is better than complex.\n?           ++++ ^                      ^\n+   5. Flat is better than nested.",
      "relationships": []
    },
    {
      "id": "stdlib.difflib.HtmlDiff",
      "name": "HtmlDiff",
      "module": "difflib",
      "type": "class",
      "signature": "(tabsize=8, wrapcolumn=None, linejunk=None, charjunk=<function IS_CHARACTER_JUNK at 0x106327240>)",
      "description": "For producing HTML side by side comparison with change highlights.\n\nThis class can be used to create an HTML table (or a complete HTML file\ncontaining the table) showing a side by side, line by line comparison\nof text with inter-line and intra-line change highlights.  The table can\nbe generated in either full or contextual difference mode.\n\nThe following methods are provided for HTML generation:\n\nmake_table -- generates HTML for a single side by side table\nmake_file -- generates complete HTML file with a single side by side table\n\nSee tools/scripts/diff.py for an example usage of this class.",
      "relationships": []
    },
    {
      "id": "stdlib.difflib.IS_CHARACTER_JUNK",
      "name": "IS_CHARACTER_JUNK",
      "module": "difflib",
      "type": "function",
      "signature": "(ch, ws=' \\t')",
      "description": "Return True for ignorable character: iff `ch` is a space or tab.\n\nExamples:\n\n>>> IS_CHARACTER_JUNK(' ')\nTrue\n>>> IS_CHARACTER_JUNK('\\t')\nTrue\n>>> IS_CHARACTER_JUNK('\\n')\nFalse\n>>> IS_CHARACTER_JUNK('x')\nFalse",
      "relationships": []
    },
    {
      "id": "stdlib.difflib.IS_LINE_JUNK",
      "name": "IS_LINE_JUNK",
      "module": "difflib",
      "type": "function",
      "signature": "(line, pat=<built-in method match of re.Pattern object at 0x1061d5a40>)",
      "description": "Return True for ignorable line: iff `line` is blank or contains a single '#'.\n\nExamples:\n\n>>> IS_LINE_JUNK('\\n')\nTrue\n>>> IS_LINE_JUNK('  #   \\n')\nTrue\n>>> IS_LINE_JUNK('hello\\n')\nFalse",
      "relationships": []
    },
    {
      "id": "stdlib.difflib.Match",
      "name": "Match",
      "module": "difflib",
      "type": "class",
      "signature": "(a, b, size)",
      "description": "Match(a, b, size)",
      "relationships": [
        {
          "target": "stdlib.builtins.tuple",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.difflib.SequenceMatcher",
      "name": "SequenceMatcher",
      "module": "difflib",
      "type": "class",
      "signature": "(isjunk=None, a='', b='', autojunk=True)",
      "description": "SequenceMatcher is a flexible class for comparing pairs of sequences of\nany type, so long as the sequence elements are hashable.  The basic\nalgorithm predates, and is a little fancier than, an algorithm\npublished in the late 1980's by Ratcliff and Obershelp under the\nhyperbolic name \"gestalt pattern matching\".  The basic idea is to find\nthe longest contiguous matching subsequence that contains no \"junk\"\nelements (R-O doesn't address junk).  The same idea is then applied\nrecursively to the pieces of the sequences to the left and to the right\nof the matching subsequence.  This does not yield minimal edit\nsequences, but does tend to yield matches that \"look right\" to people.\n\nSequenceMatcher tries to compute a \"human-friendly diff\" between two\nsequences.  Unlike e.g. UNIX(tm) diff, the fundamental notion is the\nlongest *contiguous* & junk-free matching subsequence.  That's what\ncatches peoples' eyes.  The Windows(tm) windiff has another interesting\nnotion, pairing up elements that appear uniquely in each sequence.\nThat, and the method here, appear to yield more intuitive difference\nreports than does diff.  This method appears to be the least vulnerable\nto syncing up on blocks of \"junk lines\", though (like blank lines in\nordinary text files, or maybe \"<P>\" lines in HTML files).  That may be\nbecause this is the only method of the 3 that has a *concept* of\n\"junk\" <wink>.\n\nExample, comparing two strings, and considering blanks to be \"junk\":\n\n>>> s = SequenceMatcher(lambda x: x == \" \",\n...                     \"private Thread currentThread;\",\n...                     \"private volatile Thread currentThread;\")\n>>>\n\n.ratio() returns a float in [0, 1], measuring the \"similarity\" of the\nsequences.  As a rule of thumb, a .ratio() value over 0.6 means the\nsequences are close matches:\n\n>>> print(round(s.ratio(), 3))\n0.866\n>>>\n\nIf you're only interested in where the sequences match,\n.get_matching_blocks() is handy:\n\n>>> for block in s.get_matching_blocks():\n...     print(\"a[%d] and b[%d] match for %d elements\" % block)\na[0] and b[0] match for 8 elements\na[8] and b[17] match for 21 elements\na[29] and b[38] match for 0 elements\n\nNote that the last tuple returned by .get_matching_blocks() is always a\ndummy, (len(a), len(b), 0), and this is the only case in which the last\ntuple element (number of elements matched) is 0.\n\nIf you want to know how to change the first sequence into the second,\nuse .get_opcodes():\n\n>>> for opcode in s.get_opcodes():\n...     print(\"%6s a[%d:%d] b[%d:%d]\" % opcode)\n equal a[0:8] b[0:8]\ninsert a[8:8] b[8:17]\n equal a[8:29] b[17:38]\n\nSee the Differ class for a fancy human-friendly file differencer, which\nuses SequenceMatcher both to compare sequences of lines, and to compare\nsequences of characters within similar (near-matching) lines.\n\nSee also function get_close_matches() in this module, which shows how\nsimple code building on SequenceMatcher can be used to do useful work.\n\nTiming:  Basic R-O is cubic time worst case and quadratic time expected\ncase.  SequenceMatcher is quadratic time for the worst case and has\nexpected-case behavior dependent in a complicated way on how many\nelements the sequences have in common; best case time is linear.",
      "relationships": []
    },
    {
      "id": "stdlib.difflib.context_diff",
      "name": "context_diff",
      "module": "difflib",
      "type": "function",
      "signature": "(a, b, fromfile='', tofile='', fromfiledate='', tofiledate='', n=3, lineterm='\\n')",
      "description": "Compare two sequences of lines; generate the delta as a context diff.\n\nContext diffs are a compact way of showing line changes and a few\nlines of context.  The number of context lines is set by 'n' which\ndefaults to three.\n\nBy default, the diff control lines (those with *** or ---) are\ncreated with a trailing newline.  This is helpful so that inputs\ncreated from file.readlines() result in diffs that are suitable for\nfile.writelines() since both the inputs and outputs have trailing\nnewlines.\n\nFor inputs that do not have trailing newlines, set the lineterm\nargument to \"\" so that the output will be uniformly newline free.\n\nThe context diff format normally has a header for filenames and\nmodification times.  Any or all of these may be specified using\nstrings for 'fromfile', 'tofile', 'fromfiledate', and 'tofiledate'.\nThe modification times are normally expressed in the ISO 8601 format.\nIf not specified, the strings default to blanks.\n\nExample:\n\n>>> print(''.join(context_diff('one\\ntwo\\nthree\\nfour\\n'.splitlines(True),\n...       'zero\\none\\ntree\\nfour\\n'.splitlines(True), 'Original', 'Current')),\n...       end=\"\")\n*** Original\n--- Current\n***************\n*** 1,4 ****\n  one\n! two\n! three\n  four\n--- 1,4 ----\n+ zero\n  one\n! tree\n  four",
      "relationships": [
        {
          "target": "stdlib.difflib._check_types",
          "type": "calls"
        },
        {
          "target": "stdlib.difflib._format_range_context",
          "type": "calls"
        },
        {
          "target": "stdlib.difflib._format_range_context",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.difflib.diff_bytes",
      "name": "diff_bytes",
      "module": "difflib",
      "type": "function",
      "signature": "(dfunc, a, b, fromfile=b'', tofile=b'', fromfiledate=b'', tofiledate=b'', n=3, lineterm=b'\\n')",
      "description": "Compare `a` and `b`, two sequences of lines represented as bytes rather\nthan str. This is a wrapper for `dfunc`, which is typically either\nunified_diff() or context_diff(). Inputs are losslessly converted to\nstrings so that `dfunc` only has to worry about strings, and encoded\nback to bytes on return. This is necessary to compare files with\nunknown or inconsistent encoding. All other inputs (except `n`) must be\nbytes rather than str.",
      "relationships": []
    },
    {
      "id": "stdlib.difflib.get_close_matches",
      "name": "get_close_matches",
      "module": "difflib",
      "type": "function",
      "signature": "(word, possibilities, n=3, cutoff=0.6)",
      "description": "Use SequenceMatcher to return list of the best \"good enough\" matches.\n\nword is a sequence for which close matches are desired (typically a\nstring).\n\npossibilities is a list of sequences against which to match word\n(typically a list of strings).\n\nOptional arg n (default 3) is the maximum number of close matches to\nreturn.  n must be > 0.\n\nOptional arg cutoff (default 0.6) is a float in [0, 1].  Possibilities\nthat don't score at least that similar to word are ignored.\n\nThe best (no more than n) matches among the possibilities are returned\nin a list, sorted by similarity score, most similar first.\n\n>>> get_close_matches(\"appel\", [\"ape\", \"apple\", \"peach\", \"puppy\"])\n['apple', 'ape']\n>>> import keyword as _keyword\n>>> get_close_matches(\"wheel\", _keyword.kwlist)\n['while']\n>>> get_close_matches(\"Apple\", _keyword.kwlist)\n[]\n>>> get_close_matches(\"accept\", _keyword.kwlist)\n['except']",
      "relationships": []
    },
    {
      "id": "stdlib.difflib.ndiff",
      "name": "ndiff",
      "module": "difflib",
      "type": "function",
      "signature": "(a, b, linejunk=None, charjunk=<function IS_CHARACTER_JUNK at 0x106327240>)",
      "description": "Compare `a` and `b` (lists of strings); return a `Differ`-style delta.\n\nOptional keyword parameters `linejunk` and `charjunk` are for filter\nfunctions, or can be None:\n\n- linejunk: A function that should accept a single string argument and\n  return true iff the string is junk.  The default is None, and is\n  recommended; the underlying SequenceMatcher class has an adaptive\n  notion of \"noise\" lines.\n\n- charjunk: A function that accepts a character (string of length\n  1), and returns true iff the character is junk. The default is\n  the module-level function IS_CHARACTER_JUNK, which filters out\n  whitespace characters (a blank or tab; note: it's a bad idea to\n  include newline in this!).\n\nTools/scripts/ndiff.py is a command-line front-end to this function.\n\nExample:\n\n>>> diff = ndiff('one\\ntwo\\nthree\\n'.splitlines(keepends=True),\n...              'ore\\ntree\\nemu\\n'.splitlines(keepends=True))\n>>> print(''.join(diff), end=\"\")\n- one\n?  ^\n+ ore\n?  ^\n- two\n- three\n?  -\n+ tree\n+ emu",
      "relationships": []
    },
    {
      "id": "stdlib.difflib.restore",
      "name": "restore",
      "module": "difflib",
      "type": "function",
      "signature": "(delta, which)",
      "description": "Generate one of the two sequences that generated a delta.\n\nGiven a `delta` produced by `Differ.compare()` or `ndiff()`, extract\nlines originating from file 1 or 2 (parameter `which`), stripping off line\nprefixes.\n\nExamples:\n\n>>> diff = ndiff('one\\ntwo\\nthree\\n'.splitlines(keepends=True),\n...              'ore\\ntree\\nemu\\n'.splitlines(keepends=True))\n>>> diff = list(diff)\n>>> print(''.join(restore(diff, 1)), end=\"\")\none\ntwo\nthree\n>>> print(''.join(restore(diff, 2)), end=\"\")\nore\ntree\nemu",
      "relationships": []
    },
    {
      "id": "stdlib.difflib.unified_diff",
      "name": "unified_diff",
      "module": "difflib",
      "type": "function",
      "signature": "(a, b, fromfile='', tofile='', fromfiledate='', tofiledate='', n=3, lineterm='\\n')",
      "description": "Compare two sequences of lines; generate the delta as a unified diff.\n\nUnified diffs are a compact way of showing line changes and a few\nlines of context.  The number of context lines is set by 'n' which\ndefaults to three.\n\nBy default, the diff control lines (those with ---, +++, or @@) are\ncreated with a trailing newline.  This is helpful so that inputs\ncreated from file.readlines() result in diffs that are suitable for\nfile.writelines() since both the inputs and outputs have trailing\nnewlines.\n\nFor inputs that do not have trailing newlines, set the lineterm\nargument to \"\" so that the output will be uniformly newline free.\n\nThe unidiff format normally has a header for filenames and modification\ntimes.  Any or all of these may be specified using strings for\n'fromfile', 'tofile', 'fromfiledate', and 'tofiledate'.\nThe modification times are normally expressed in the ISO 8601 format.\n\nExample:\n\n>>> for line in unified_diff('one two three four'.split(),\n...             'zero one tree four'.split(), 'Original', 'Current',\n...             '2005-01-26 23:30:50', '2010-04-02 10:20:52',\n...             lineterm=''):\n...     print(line)                 # doctest: +NORMALIZE_WHITESPACE\n--- Original        2005-01-26 23:30:50\n+++ Current         2010-04-02 10:20:52\n@@ -1,4 +1,4 @@\n+zero\n one\n-two\n-three\n+tree\n four",
      "relationships": [
        {
          "target": "stdlib.difflib._check_types",
          "type": "calls"
        },
        {
          "target": "stdlib.difflib._format_range_unified",
          "type": "calls"
        },
        {
          "target": "stdlib.difflib._format_range_unified",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.dis.Bytecode",
      "name": "Bytecode",
      "module": "dis",
      "type": "class",
      "signature": "(x, *, first_line=None, current_offset=None, show_caches=False, adaptive=False)",
      "description": "The bytecode operations of a piece of code\n\nInstantiate this with a function, method, other compiled object, string of\ncode, or a code object (as returned by compile()).\n\nIterating over this yields the bytecode operations as Instruction instances.",
      "relationships": []
    },
    {
      "id": "stdlib.dis.Instruction",
      "name": "Instruction",
      "module": "dis",
      "type": "class",
      "signature": "(opname, opcode, arg, argval, argrepr, offset, starts_line, is_jump_target, positions=None)",
      "description": "Details for a bytecode operation\n\nDefined fields:\n  opname - human readable name for operation\n  opcode - numeric code for operation\n  arg - numeric argument to operation (if any), otherwise None\n  argval - resolved arg value (if known), otherwise same as arg\n  argrepr - human readable description of operation argument\n  offset - start index of operation within bytecode sequence\n  starts_line - line started by this opcode (if any), otherwise None\n  is_jump_target - True if other code jumps to here, otherwise False\n  positions - Optional dis.Positions object holding the span of source code\n              covered by this instruction",
      "relationships": [
        {
          "target": "stdlib.dis._Instruction",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.tuple",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.dis.Positions",
      "name": "Positions",
      "module": "dis",
      "type": "class",
      "signature": "(lineno=None, end_lineno=None, col_offset=None, end_col_offset=None)",
      "description": "Positions(lineno, end_lineno, col_offset, end_col_offset)",
      "relationships": [
        {
          "target": "stdlib.builtins.tuple",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.dis.code_info",
      "name": "code_info",
      "module": "dis",
      "type": "function",
      "signature": "(x)",
      "description": "Formatted details of methods, functions, or code.",
      "relationships": [
        {
          "target": "stdlib.dis._format_code_info",
          "type": "calls"
        },
        {
          "target": "stdlib.dis._get_code_object",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.dis.dis",
      "name": "dis",
      "module": "dis",
      "type": "function",
      "signature": "(x=None, *, file=None, depth=None, show_caches=False, adaptive=False)",
      "description": "Disassemble classes, methods, functions, and other compiled objects.\n\nWith no argument, disassemble the last traceback.\n\nCompiled objects currently include generator objects, async generator\nobjects, and coroutine objects, all of which store their code object\nin a special attribute.",
      "relationships": [
        {
          "target": "stdlib.dis.distb",
          "type": "calls"
        },
        {
          "target": "stdlib.dis._disassemble_recursive",
          "type": "calls"
        },
        {
          "target": "stdlib.dis._disassemble_bytes",
          "type": "calls"
        },
        {
          "target": "stdlib.dis.dis",
          "type": "calls"
        },
        {
          "target": "stdlib.dis._disassemble_str",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.dis.disassemble",
      "name": "disassemble",
      "module": "dis",
      "type": "function",
      "signature": "(co, lasti=-1, *, file=None, show_caches=False, adaptive=False)",
      "description": "Disassemble a code object.",
      "relationships": [
        {
          "target": "stdlib.dis._parse_exception_table",
          "type": "calls"
        },
        {
          "target": "stdlib.dis._disassemble_bytes",
          "type": "calls"
        },
        {
          "target": "stdlib.dis.findlinestarts",
          "type": "calls"
        },
        {
          "target": "stdlib.dis._get_code_array",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.dis.disco",
      "name": "disco",
      "module": "dis",
      "type": "function",
      "signature": "(co, lasti=-1, *, file=None, show_caches=False, adaptive=False)",
      "description": "Disassemble a code object.",
      "relationships": [
        {
          "target": "stdlib.dis._parse_exception_table",
          "type": "calls"
        },
        {
          "target": "stdlib.dis._disassemble_bytes",
          "type": "calls"
        },
        {
          "target": "stdlib.dis.findlinestarts",
          "type": "calls"
        },
        {
          "target": "stdlib.dis._get_code_array",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.dis.distb",
      "name": "distb",
      "module": "dis",
      "type": "function",
      "signature": "(tb=None, *, file=None, show_caches=False, adaptive=False)",
      "description": "Disassemble a traceback (default: last traceback).",
      "relationships": [
        {
          "target": "stdlib.dis.disassemble",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.dis.findlabels",
      "name": "findlabels",
      "module": "dis",
      "type": "function",
      "signature": "(code)",
      "description": "Detect all offsets in a byte code which are jump targets.\n\nReturn the list of offsets.",
      "relationships": [
        {
          "target": "stdlib.dis._unpack_opargs",
          "type": "calls"
        },
        {
          "target": "stdlib.dis._deoptop",
          "type": "calls"
        },
        {
          "target": "stdlib.dis._is_backward_jump",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.dis.findlinestarts",
      "name": "findlinestarts",
      "module": "dis",
      "type": "function",
      "signature": "(code)",
      "description": "Find the offsets in a byte code which are start of lines in the source.\n\nGenerate pairs (offset, lineno)",
      "relationships": []
    },
    {
      "id": "stdlib.dis.get_instructions",
      "name": "get_instructions",
      "module": "dis",
      "type": "function",
      "signature": "(x, *, first_line=None, show_caches=False, adaptive=False)",
      "description": "Iterator for the opcodes in methods, functions or code\n\nGenerates a series of Instruction named tuples giving the details of\neach operations in the supplied code.\n\nIf *first_line* is not None, it indicates the line number that should\nbe reported for the first source line in the disassembled code.\nOtherwise, the source line information (if any) is taken directly from\nthe disassembled code object.",
      "relationships": [
        {
          "target": "stdlib.dis._get_code_object",
          "type": "calls"
        },
        {
          "target": "stdlib.dis._get_instructions_bytes",
          "type": "calls"
        },
        {
          "target": "stdlib.dis.findlinestarts",
          "type": "calls"
        },
        {
          "target": "stdlib.dis._get_code_array",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.dis.main",
      "name": "main",
      "module": "dis",
      "type": "function",
      "signature": "(args=None)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.dis.dis",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.dis.pretty_flags",
      "name": "pretty_flags",
      "module": "dis",
      "type": "function",
      "signature": "(flags)",
      "description": "Return pretty representation of code flags.",
      "relationships": []
    },
    {
      "id": "stdlib.dis.show_code",
      "name": "show_code",
      "module": "dis",
      "type": "function",
      "signature": "(co, *, file=None)",
      "description": "Print details of methods, functions, or code to *file*.\n\nIf *file* is not provided, the output is printed on stdout.",
      "relationships": [
        {
          "target": "stdlib.dis.code_info",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.doctest.DebugRunner",
      "name": "DebugRunner",
      "module": "doctest",
      "type": "class",
      "signature": "(checker=None, verbose=None, optionflags=0)",
      "description": "Run doc tests but raise an exception as soon as there is a failure.\n\nIf an unexpected exception occurs, an UnexpectedException is raised.\nIt contains the test, the example, and the original exception:\n\n  >>> runner = DebugRunner(verbose=False)\n  >>> test = DocTestParser().get_doctest('>>> raise KeyError\\n42',\n  ...                                    {}, 'foo', 'foo.py', 0)\n  >>> try:\n  ...     runner.run(test)\n  ... except UnexpectedException as f:\n  ...     failure = f\n\n  >>> failure.test is test\n  True\n\n  >>> failure.example.want\n  '42\\n'\n\n  >>> exc_info = failure.exc_info\n  >>> raise exc_info[1] # Already has the traceback\n  Traceback (most recent call last):\n  ...\n  KeyError\n\nWe wrap the original exception to give the calling application\naccess to the test and example information.\n\nIf the output doesn't match, then a DocTestFailure is raised:\n\n  >>> test = DocTestParser().get_doctest('''\n  ...      >>> x = 1\n  ...      >>> x\n  ...      2\n  ...      ''', {}, 'foo', 'foo.py', 0)\n\n  >>> try:\n  ...    runner.run(test)\n  ... except DocTestFailure as f:\n  ...    failure = f\n\nDocTestFailure objects provide access to the test:\n\n  >>> failure.test is test\n  True\n\nAs well as to the example:\n\n  >>> failure.example.want\n  '2\\n'\n\nand the actual output:\n\n  >>> failure.got\n  '1\\n'\n\nIf a failure or error occurs, the globals are left intact:\n\n  >>> del test.globs['__builtins__']\n  >>> test.globs\n  {'x': 1}\n\n  >>> test = DocTestParser().get_doctest('''\n  ...      >>> x = 2\n  ...      >>> raise KeyError\n  ...      ''', {}, 'foo', 'foo.py', 0)\n\n  >>> runner.run(test)\n  Traceback (most recent call last):\n  ...\n  doctest.UnexpectedException: <DocTest foo from foo.py:0 (2 examples)>\n\n  >>> del test.globs['__builtins__']\n  >>> test.globs\n  {'x': 2}\n\nBut the globals are cleared if there is no error:\n\n  >>> test = DocTestParser().get_doctest('''\n  ...      >>> x = 2\n  ...      ''', {}, 'foo', 'foo.py', 0)\n\n  >>> runner.run(test)\n  TestResults(failed=0, attempted=1)\n\n  >>> test.globs\n  {}",
      "relationships": [
        {
          "target": "stdlib.doctest.DocTestRunner",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.doctest.DocFileCase",
      "name": "DocFileCase",
      "module": "doctest",
      "type": "class",
      "signature": "(test, optionflags=0, setUp=None, tearDown=None, checker=None)",
      "description": "A class whose instances are single test cases.\n\nBy default, the test code itself should be placed in a method named\n'runTest'.\n\nIf the fixture may be used for many test cases, create as\nmany test methods as are needed. When instantiating such a TestCase\nsubclass, specify in the constructor arguments the name of the test method\nthat the instance is to execute.\n\nTest authors should subclass TestCase for their own tests. Construction\nand deconstruction of the test's environment ('fixture') can be\nimplemented by overriding the 'setUp' and 'tearDown' methods respectively.\n\nIf it is necessary to override the __init__ method, the base class\n__init__ method must always be called. It is important that subclasses\nshould not change the signature of their __init__ method, since instances\nof the classes are instantiated automatically by parts of the framework\nin order to be run.\n\nWhen subclassing TestCase, you can set these attributes:\n* failureException: determines which exception will be raised when\n    the instance's assertion methods fail; test methods raising this\n    exception will be deemed to have 'failed' rather than 'errored'.\n* longMessage: determines whether long messages (including repr of\n    objects used in assert methods) will be printed on failure in *addition*\n    to any explicit message passed.\n* maxDiff: sets the maximum length of a diff in failure messages\n    by assert methods using difflib. It is looked up as an instance\n    attribute so can be configured by individual tests if required.",
      "relationships": [
        {
          "target": "stdlib.doctest.DocTestCase",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.TestCase",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.doctest.DocFileSuite",
      "name": "DocFileSuite",
      "module": "doctest",
      "type": "function",
      "signature": "(*paths, **kw)",
      "description": "A unittest suite for one or more doctest files.\n\nThe path to each doctest file is given as a string; the\ninterpretation of that string depends on the keyword argument\n\"module_relative\".\n\nA number of options may be provided as keyword arguments:\n\nmodule_relative\n  If \"module_relative\" is True, then the given file paths are\n  interpreted as os-independent module-relative paths.  By\n  default, these paths are relative to the calling module's\n  directory; but if the \"package\" argument is specified, then\n  they are relative to that package.  To ensure os-independence,\n  \"filename\" should use \"/\" characters to separate path\n  segments, and may not be an absolute path (i.e., it may not\n  begin with \"/\").\n\n  If \"module_relative\" is False, then the given file paths are\n  interpreted as os-specific paths.  These paths may be absolute\n  or relative (to the current working directory).\n\npackage\n  A Python package or the name of a Python package whose directory\n  should be used as the base directory for module relative paths.\n  If \"package\" is not specified, then the calling module's\n  directory is used as the base directory for module relative\n  filenames.  It is an error to specify \"package\" if\n  \"module_relative\" is False.\n\nsetUp\n  A set-up function.  This is called before running the\n  tests in each file. The setUp function will be passed a DocTest\n  object.  The setUp function can access the test globals as the\n  globs attribute of the test passed.\n\ntearDown\n  A tear-down function.  This is called after running the\n  tests in each file.  The tearDown function will be passed a DocTest\n  object.  The tearDown function can access the test globals as the\n  globs attribute of the test passed.\n\nglobs\n  A dictionary containing initial global variables for the tests.\n\noptionflags\n  A set of doctest option flags expressed as an integer.\n\nparser\n  A DocTestParser (or subclass) that should be used to extract\n  tests from the files.\n\nencoding\n  An encoding that will be used to convert the files to unicode.",
      "relationships": [
        {
          "target": "stdlib.doctest._normalize_module",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.DocFileTest",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.doctest.DocFileTest",
      "name": "DocFileTest",
      "module": "doctest",
      "type": "function",
      "signature": "(path, module_relative=True, package=None, globs=None, parser=<doctest.DocTestParser object at 0x106482990>, encoding=None, **options)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.doctest._load_testfile",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.doctest.DocTest",
      "name": "DocTest",
      "module": "doctest",
      "type": "class",
      "signature": "(examples, globs, name, filename, lineno, docstring)",
      "description": "A collection of doctest examples that should be run in a single\nnamespace.  Each `DocTest` defines the following attributes:\n\n  - examples: the list of examples.\n\n  - globs: The namespace (aka globals) that the examples should\n    be run in.\n\n  - name: A name identifying the DocTest (typically, the name of\n    the object whose docstring this DocTest was extracted from).\n\n  - filename: The name of the file that this DocTest was extracted\n    from, or `None` if the filename is unknown.\n\n  - lineno: The line number within filename where this DocTest\n    begins, or `None` if the line number is unavailable.  This\n    line number is zero-based, with respect to the beginning of\n    the file.\n\n  - docstring: The string that the examples were extracted from,\n    or `None` if the string is unavailable.",
      "relationships": []
    },
    {
      "id": "stdlib.doctest.DocTestCase",
      "name": "DocTestCase",
      "module": "doctest",
      "type": "class",
      "signature": "(test, optionflags=0, setUp=None, tearDown=None, checker=None)",
      "description": "A class whose instances are single test cases.\n\nBy default, the test code itself should be placed in a method named\n'runTest'.\n\nIf the fixture may be used for many test cases, create as\nmany test methods as are needed. When instantiating such a TestCase\nsubclass, specify in the constructor arguments the name of the test method\nthat the instance is to execute.\n\nTest authors should subclass TestCase for their own tests. Construction\nand deconstruction of the test's environment ('fixture') can be\nimplemented by overriding the 'setUp' and 'tearDown' methods respectively.\n\nIf it is necessary to override the __init__ method, the base class\n__init__ method must always be called. It is important that subclasses\nshould not change the signature of their __init__ method, since instances\nof the classes are instantiated automatically by parts of the framework\nin order to be run.\n\nWhen subclassing TestCase, you can set these attributes:\n* failureException: determines which exception will be raised when\n    the instance's assertion methods fail; test methods raising this\n    exception will be deemed to have 'failed' rather than 'errored'.\n* longMessage: determines whether long messages (including repr of\n    objects used in assert methods) will be printed on failure in *addition*\n    to any explicit message passed.\n* maxDiff: sets the maximum length of a diff in failure messages\n    by assert methods using difflib. It is looked up as an instance\n    attribute so can be configured by individual tests if required.",
      "relationships": [
        {
          "target": "stdlib.unittest.case.TestCase",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.doctest.DocTestFailure",
      "name": "DocTestFailure",
      "module": "doctest",
      "type": "class",
      "signature": "(test, example, got)",
      "description": "A DocTest example has failed in debugging mode.\n\nThe exception instance has variables:\n\n- test: the DocTest object being run\n\n- example: the Example object that failed\n\n- got: the actual output",
      "relationships": [
        {
          "target": "stdlib.builtins.Exception",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.doctest.DocTestFinder",
      "name": "DocTestFinder",
      "module": "doctest",
      "type": "class",
      "signature": "(verbose=False, parser=<doctest.DocTestParser object at 0x10631d3d0>, recurse=True, exclude_empty=True)",
      "description": "A class used to extract the DocTests that are relevant to a given\nobject, from its docstring and the docstrings of its contained\nobjects.  Doctests can currently be extracted from the following\nobject types: modules, functions, classes, methods, staticmethods,\nclassmethods, and properties.",
      "relationships": []
    },
    {
      "id": "stdlib.doctest.DocTestParser",
      "name": "DocTestParser",
      "module": "doctest",
      "type": "class",
      "signature": "()",
      "description": "A class used to parse strings containing doctest examples.",
      "relationships": []
    },
    {
      "id": "stdlib.doctest.DocTestRunner",
      "name": "DocTestRunner",
      "module": "doctest",
      "type": "class",
      "signature": "(checker=None, verbose=None, optionflags=0)",
      "description": "A class used to run DocTest test cases, and accumulate statistics.\nThe `run` method is used to process a single DocTest case.  It\nreturns a tuple `(f, t)`, where `t` is the number of test cases\ntried, and `f` is the number of test cases that failed.\n\n    >>> tests = DocTestFinder().find(_TestClass)\n    >>> runner = DocTestRunner(verbose=False)\n    >>> tests.sort(key = lambda test: test.name)\n    >>> for test in tests:\n    ...     print(test.name, '->', runner.run(test))\n    _TestClass -> TestResults(failed=0, attempted=2)\n    _TestClass.__init__ -> TestResults(failed=0, attempted=2)\n    _TestClass.get -> TestResults(failed=0, attempted=2)\n    _TestClass.square -> TestResults(failed=0, attempted=1)\n\nThe `summarize` method prints a summary of all the test cases that\nhave been run by the runner, and returns an aggregated `(f, t)`\ntuple:\n\n    >>> runner.summarize(verbose=1)\n    4 items passed all tests:\n       2 tests in _TestClass\n       2 tests in _TestClass.__init__\n       2 tests in _TestClass.get\n       1 tests in _TestClass.square\n    7 tests in 4 items.\n    7 passed and 0 failed.\n    Test passed.\n    TestResults(failed=0, attempted=7)\n\nThe aggregated number of tried examples and failed examples is\nalso available via the `tries` and `failures` attributes:\n\n    >>> runner.tries\n    7\n    >>> runner.failures\n    0\n\nThe comparison between expected outputs and actual outputs is done\nby an `OutputChecker`.  This comparison may be customized with a\nnumber of option flags; see the documentation for `testmod` for\nmore information.  If the option flags are insufficient, then the\ncomparison may also be customized by passing a subclass of\n`OutputChecker` to the constructor.\n\nThe test runner's display output can be controlled in two ways.\nFirst, an output function (`out) can be passed to\n`TestRunner.run`; this function will be called with strings that\nshould be displayed.  It defaults to `sys.stdout.write`.  If\ncapturing the output is not sufficient, then the display output\ncan be also customized by subclassing DocTestRunner, and\noverriding the methods `report_start`, `report_success`,\n`report_unexpected_exception`, and `report_failure`.",
      "relationships": []
    },
    {
      "id": "stdlib.doctest.DocTestSuite",
      "name": "DocTestSuite",
      "module": "doctest",
      "type": "function",
      "signature": "(module=None, globs=None, extraglobs=None, test_finder=None, **options)",
      "description": "Convert doctest tests for a module to a unittest test suite.\n\nThis converts each documentation string in a module that\ncontains doctest tests to a unittest test case.  If any of the\ntests in a doc string fail, then the test case fails.  An exception\nis raised showing the name of the file containing the test and a\n(sometimes approximate) line number.\n\nThe `module` argument provides the module to be tested.  The argument\ncan be either a module or a module name.\n\nIf no argument is given, the calling module is used.\n\nA number of options may be provided as keyword arguments:\n\nsetUp\n  A set-up function.  This is called before running the\n  tests in each file. The setUp function will be passed a DocTest\n  object.  The setUp function can access the test globals as the\n  globs attribute of the test passed.\n\ntearDown\n  A tear-down function.  This is called after running the\n  tests in each file.  The tearDown function will be passed a DocTest\n  object.  The tearDown function can access the test globals as the\n  globs attribute of the test passed.\n\nglobs\n  A dictionary containing initial global variables for the tests.\n\noptionflags\n   A set of doctest option flags expressed as an integer.",
      "relationships": [
        {
          "target": "stdlib.doctest._normalize_module",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.doctest.Example",
      "name": "Example",
      "module": "doctest",
      "type": "class",
      "signature": "(source, want, exc_msg=None, lineno=0, indent=0, options=None)",
      "description": "A single doctest example, consisting of source code and expected\noutput.  `Example` defines the following attributes:\n\n  - source: A single Python statement, always ending with a newline.\n    The constructor adds a newline if needed.\n\n  - want: The expected output from running the source code (either\n    from stdout, or a traceback in case of exception).  `want` ends\n    with a newline unless it's empty, in which case it's an empty\n    string.  The constructor adds a newline if needed.\n\n  - exc_msg: The exception message generated by the example, if\n    the example is expected to generate an exception; or `None` if\n    it is not expected to generate an exception.  This exception\n    message is compared against the return value of\n    `traceback.format_exception_only()`.  `exc_msg` ends with a\n    newline unless it's `None`.  The constructor adds a newline\n    if needed.\n\n  - lineno: The line number within the DocTest string containing\n    this Example where the Example begins.  This line number is\n    zero-based, with respect to the beginning of the DocTest.\n\n  - indent: The example's indentation in the DocTest string.\n    I.e., the number of space characters that precede the\n    example's first prompt.\n\n  - options: A dictionary mapping from option flags to True or\n    False, which is used to override default options for this\n    example.  Any option flags not contained in this dictionary\n    are left at their default value (as specified by the\n    DocTestRunner's optionflags).  By default, no options are set.",
      "relationships": []
    },
    {
      "id": "stdlib.doctest.OutputChecker",
      "name": "OutputChecker",
      "module": "doctest",
      "type": "class",
      "signature": "()",
      "description": "A class used to check the whether the actual output from a doctest\nexample matches the expected output.  `OutputChecker` defines two\nmethods: `check_output`, which compares a given pair of outputs,\nand returns true if they match; and `output_difference`, which\nreturns a string describing the differences between two outputs.",
      "relationships": []
    },
    {
      "id": "stdlib.doctest.SkipDocTestCase",
      "name": "SkipDocTestCase",
      "module": "doctest",
      "type": "class",
      "signature": "(module)",
      "description": "A class whose instances are single test cases.\n\nBy default, the test code itself should be placed in a method named\n'runTest'.\n\nIf the fixture may be used for many test cases, create as\nmany test methods as are needed. When instantiating such a TestCase\nsubclass, specify in the constructor arguments the name of the test method\nthat the instance is to execute.\n\nTest authors should subclass TestCase for their own tests. Construction\nand deconstruction of the test's environment ('fixture') can be\nimplemented by overriding the 'setUp' and 'tearDown' methods respectively.\n\nIf it is necessary to override the __init__ method, the base class\n__init__ method must always be called. It is important that subclasses\nshould not change the signature of their __init__ method, since instances\nof the classes are instantiated automatically by parts of the framework\nin order to be run.\n\nWhen subclassing TestCase, you can set these attributes:\n* failureException: determines which exception will be raised when\n    the instance's assertion methods fail; test methods raising this\n    exception will be deemed to have 'failed' rather than 'errored'.\n* longMessage: determines whether long messages (including repr of\n    objects used in assert methods) will be printed on failure in *addition*\n    to any explicit message passed.\n* maxDiff: sets the maximum length of a diff in failure messages\n    by assert methods using difflib. It is looked up as an instance\n    attribute so can be configured by individual tests if required.",
      "relationships": [
        {
          "target": "stdlib.doctest.DocTestCase",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.TestCase",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.doctest.TestResults",
      "name": "TestResults",
      "module": "doctest",
      "type": "class",
      "signature": "(failed, attempted)",
      "description": "TestResults(failed, attempted)",
      "relationships": [
        {
          "target": "stdlib.builtins.tuple",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.doctest.UnexpectedException",
      "name": "UnexpectedException",
      "module": "doctest",
      "type": "class",
      "signature": "(test, example, exc_info)",
      "description": "A DocTest example has encountered an unexpected exception\n\nThe exception instance has variables:\n\n- test: the DocTest object being run\n\n- example: the Example object that failed\n\n- exc_info: the exception info",
      "relationships": [
        {
          "target": "stdlib.builtins.Exception",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.doctest.debug",
      "name": "debug",
      "module": "doctest",
      "type": "function",
      "signature": "(module, name, pm=False)",
      "description": "Debug a single doctest docstring.\n\nProvide the module (or dotted name of the module) containing the\ntest to be debugged and the name (within the module) of the object\nwith the docstring with tests to be debugged.",
      "relationships": [
        {
          "target": "stdlib.doctest._normalize_module",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.testsource",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.debug_script",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.doctest.debug_script",
      "name": "debug_script",
      "module": "doctest",
      "type": "function",
      "signature": "(src, pm=False, globs=None)",
      "description": "Debug a test script.  `src` is the script, as a string.",
      "relationships": []
    },
    {
      "id": "stdlib.doctest.debug_src",
      "name": "debug_src",
      "module": "doctest",
      "type": "function",
      "signature": "(src, pm=False, globs=None)",
      "description": "Debug a single doctest docstring, in argument `src`'",
      "relationships": [
        {
          "target": "stdlib.doctest.script_from_examples",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.debug_script",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.doctest.register_optionflag",
      "name": "register_optionflag",
      "module": "doctest",
      "type": "function",
      "signature": "(name)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.doctest.run_docstring_examples",
      "name": "run_docstring_examples",
      "module": "doctest",
      "type": "function",
      "signature": "(f, globs, verbose=False, name='NoName', compileflags=None, optionflags=0)",
      "description": "Test examples in the given object's docstring (`f`), using `globs`\nas globals.  Optional argument `name` is used in failure messages.\nIf the optional argument `verbose` is true, then generate output\neven if there are no failures.\n\n`compileflags` gives the set of flags that should be used by the\nPython compiler when running the examples.  If not specified, then\nit will default to the set of future-import flags that apply to\n`globs`.\n\nOptional keyword arg `optionflags` specifies options for the\ntesting and output.  See the documentation for `testmod` for more\ninformation.",
      "relationships": []
    },
    {
      "id": "stdlib.doctest.script_from_examples",
      "name": "script_from_examples",
      "module": "doctest",
      "type": "function",
      "signature": "(s)",
      "description": "Extract script from text with examples.\n\nConverts text with examples to a Python script.  Example input is\nconverted to regular code.  Example output and all other words\nare converted to comments:\n\n>>> text = '''\n...       Here are examples of simple math.\n...\n...           Python has super accurate integer addition\n...\n...           >>> 2 + 2\n...           5\n...\n...           And very friendly error messages:\n...\n...           >>> 1/0\n...           To Infinity\n...           And\n...           Beyond\n...\n...           You can use logic if you want:\n...\n...           >>> if 0:\n...           ...    blah\n...           ...    blah\n...           ...\n...\n...           Ho hum\n...           '''\n\n>>> print(script_from_examples(text))\n# Here are examples of simple math.\n#\n#     Python has super accurate integer addition\n#\n2 + 2\n# Expected:\n## 5\n#\n#     And very friendly error messages:\n#\n1/0\n# Expected:\n## To Infinity\n## And\n## Beyond\n#\n#     You can use logic if you want:\n#\nif 0:\n   blah\n   blah\n#\n#     Ho hum\n<BLANKLINE>",
      "relationships": [
        {
          "target": "stdlib.doctest._comment_line",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.doctest.set_unittest_reportflags",
      "name": "set_unittest_reportflags",
      "module": "doctest",
      "type": "function",
      "signature": "(flags)",
      "description": "Sets the unittest option flags.\n\nThe old flag is returned so that a runner could restore the old\nvalue if it wished to:\n\n  >>> import doctest\n  >>> old = doctest._unittest_reportflags\n  >>> doctest.set_unittest_reportflags(REPORT_NDIFF |\n  ...                          REPORT_ONLY_FIRST_FAILURE) == old\n  True\n\n  >>> doctest._unittest_reportflags == (REPORT_NDIFF |\n  ...                                   REPORT_ONLY_FIRST_FAILURE)\n  True\n\nOnly reporting flags can be set:\n\n  >>> doctest.set_unittest_reportflags(ELLIPSIS)\n  Traceback (most recent call last):\n  ...\n  ValueError: ('Only reporting flags allowed', 8)\n\n  >>> doctest.set_unittest_reportflags(old) == (REPORT_NDIFF |\n  ...                                   REPORT_ONLY_FIRST_FAILURE)\n  True",
      "relationships": []
    },
    {
      "id": "stdlib.doctest.testfile",
      "name": "testfile",
      "module": "doctest",
      "type": "function",
      "signature": "(filename, module_relative=True, name=None, package=None, globs=None, verbose=None, report=True, optionflags=0, extraglobs=None, raise_on_error=False, parser=<doctest.DocTestParser object at 0x106482720>, encoding=None)",
      "description": "Test examples in the given file.  Return (#failures, #tests).\n\nOptional keyword arg \"module_relative\" specifies how filenames\nshould be interpreted:\n\n  - If \"module_relative\" is True (the default), then \"filename\"\n     specifies a module-relative path.  By default, this path is\n     relative to the calling module's directory; but if the\n     \"package\" argument is specified, then it is relative to that\n     package.  To ensure os-independence, \"filename\" should use\n     \"/\" characters to separate path segments, and should not\n     be an absolute path (i.e., it may not begin with \"/\").\n\n  - If \"module_relative\" is False, then \"filename\" specifies an\n    os-specific path.  The path may be absolute or relative (to\n    the current working directory).\n\nOptional keyword arg \"name\" gives the name of the test; by default\nuse the file's basename.\n\nOptional keyword argument \"package\" is a Python package or the\nname of a Python package whose directory should be used as the\nbase directory for a module relative filename.  If no package is\nspecified, then the calling module's directory is used as the base\ndirectory for module relative filenames.  It is an error to\nspecify \"package\" if \"module_relative\" is False.\n\nOptional keyword arg \"globs\" gives a dict to be used as the globals\nwhen executing examples; by default, use {}.  A copy of this dict\nis actually used for each docstring, so that each docstring's\nexamples start with a clean slate.\n\nOptional keyword arg \"extraglobs\" gives a dictionary that should be\nmerged into the globals that are used to execute examples.  By\ndefault, no extra globals are used.\n\nOptional keyword arg \"verbose\" prints lots of stuff if true, prints\nonly failures if false; by default, it's true iff \"-v\" is in sys.argv.\n\nOptional keyword arg \"report\" prints a summary at the end when true,\nelse prints nothing at the end.  In verbose mode, the summary is\ndetailed, else very brief (in fact, empty if all tests passed).\n\nOptional keyword arg \"optionflags\" or's together module constants,\nand defaults to 0.  Possible values (see the docs for details):\n\n    DONT_ACCEPT_TRUE_FOR_1\n    DONT_ACCEPT_BLANKLINE\n    NORMALIZE_WHITESPACE\n    ELLIPSIS\n    SKIP\n    IGNORE_EXCEPTION_DETAIL\n    REPORT_UDIFF\n    REPORT_CDIFF\n    REPORT_NDIFF\n    REPORT_ONLY_FIRST_FAILURE\n\nOptional keyword arg \"raise_on_error\" raises an exception on the\nfirst unexpected exception or failure. This allows failures to be\npost-mortem debugged.\n\nOptional keyword arg \"parser\" specifies a DocTestParser (or\nsubclass) that should be used to extract tests from the files.\n\nOptional keyword arg \"encoding\" specifies an encoding that should\nbe used to convert the file to unicode.\n\nAdvanced tomfoolery:  testmod runs methods of a local instance of\nclass doctest.Tester, then merges the results into (or creates)\nglobal Tester instance doctest.master.  Methods of doctest.master\ncan be called directly too, if you want to do something unusual.\nPassing report=0 to testmod is especially useful then, to delay\ndisplaying a summary.  Invoke doctest.master.summarize(verbose)\nwhen you're done fiddling.",
      "relationships": [
        {
          "target": "stdlib.doctest._load_testfile",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.doctest.testmod",
      "name": "testmod",
      "module": "doctest",
      "type": "function",
      "signature": "(m=None, name=None, globs=None, verbose=None, report=True, optionflags=0, extraglobs=None, raise_on_error=False, exclude_empty=False)",
      "description": "m=None, name=None, globs=None, verbose=None, report=True,\n   optionflags=0, extraglobs=None, raise_on_error=False,\n   exclude_empty=False\n\nTest examples in docstrings in functions and classes reachable\nfrom module m (or the current module if m is not supplied), starting\nwith m.__doc__.\n\nAlso test examples reachable from dict m.__test__ if it exists and is\nnot None.  m.__test__ maps names to functions, classes and strings;\nfunction and class docstrings are tested even if the name is private;\nstrings are tested directly, as if they were docstrings.\n\nReturn (#failures, #tests).\n\nSee help(doctest) for an overview.\n\nOptional keyword arg \"name\" gives the name of the module; by default\nuse m.__name__.\n\nOptional keyword arg \"globs\" gives a dict to be used as the globals\nwhen executing examples; by default, use m.__dict__.  A copy of this\ndict is actually used for each docstring, so that each docstring's\nexamples start with a clean slate.\n\nOptional keyword arg \"extraglobs\" gives a dictionary that should be\nmerged into the globals that are used to execute examples.  By\ndefault, no extra globals are used.  This is new in 2.4.\n\nOptional keyword arg \"verbose\" prints lots of stuff if true, prints\nonly failures if false; by default, it's true iff \"-v\" is in sys.argv.\n\nOptional keyword arg \"report\" prints a summary at the end when true,\nelse prints nothing at the end.  In verbose mode, the summary is\ndetailed, else very brief (in fact, empty if all tests passed).\n\nOptional keyword arg \"optionflags\" or's together module constants,\nand defaults to 0.  This is new in 2.3.  Possible values (see the\ndocs for details):\n\n    DONT_ACCEPT_TRUE_FOR_1\n    DONT_ACCEPT_BLANKLINE\n    NORMALIZE_WHITESPACE\n    ELLIPSIS\n    SKIP\n    IGNORE_EXCEPTION_DETAIL\n    REPORT_UDIFF\n    REPORT_CDIFF\n    REPORT_NDIFF\n    REPORT_ONLY_FIRST_FAILURE\n\nOptional keyword arg \"raise_on_error\" raises an exception on the\nfirst unexpected exception or failure. This allows failures to be\npost-mortem debugged.\n\nAdvanced tomfoolery:  testmod runs methods of a local instance of\nclass doctest.Tester, then merges the results into (or creates)\nglobal Tester instance doctest.master.  Methods of doctest.master\ncan be called directly too, if you want to do something unusual.\nPassing report=0 to testmod is especially useful then, to delay\ndisplaying a summary.  Invoke doctest.master.summarize(verbose)\nwhen you're done fiddling.",
      "relationships": []
    },
    {
      "id": "stdlib.doctest.testsource",
      "name": "testsource",
      "module": "doctest",
      "type": "function",
      "signature": "(module, name)",
      "description": "Extract the test sources from a doctest docstring as a script.\n\nProvide the module (or dotted name of the module) containing the\ntest to be debugged and the name (within the module) of the object\nwith the doc string with tests to be debugged.",
      "relationships": [
        {
          "target": "stdlib.doctest._normalize_module",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.script_from_examples",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.email.message_from_binary_file",
      "name": "message_from_binary_file",
      "module": "email",
      "type": "function",
      "signature": "(fp, *args, **kws)",
      "description": "Read a binary file and parse its contents into a Message object model.\n\nOptional _class and strict are passed to the Parser constructor.",
      "relationships": []
    },
    {
      "id": "stdlib.email.message_from_bytes",
      "name": "message_from_bytes",
      "module": "email",
      "type": "function",
      "signature": "(s, *args, **kws)",
      "description": "Parse a bytes string into a Message object model.\n\nOptional _class and strict are passed to the Parser constructor.",
      "relationships": []
    },
    {
      "id": "stdlib.email.message_from_file",
      "name": "message_from_file",
      "module": "email",
      "type": "function",
      "signature": "(fp, *args, **kws)",
      "description": "Read a file and parse its contents into a Message object model.\n\nOptional _class and strict are passed to the Parser constructor.",
      "relationships": []
    },
    {
      "id": "stdlib.email.message_from_string",
      "name": "message_from_string",
      "module": "email",
      "type": "function",
      "signature": "(s, *args, **kws)",
      "description": "Parse a string into a Message object model.\n\nOptional _class and strict are passed to the Parser constructor.",
      "relationships": []
    },
    {
      "id": "stdlib.encodings.normalize_encoding",
      "name": "normalize_encoding",
      "module": "encodings",
      "type": "function",
      "signature": "(encoding)",
      "description": "Normalize an encoding name.\n\nNormalization works as follows: all non-alphanumeric\ncharacters except the dot used for Python package names are\ncollapsed and replaced with a single underscore, e.g. '  -;#'\nbecomes '_'. Leading and trailing underscores are removed.\n\nNote that encoding names should be ASCII only.",
      "relationships": []
    },
    {
      "id": "stdlib.encodings.search_function",
      "name": "search_function",
      "module": "encodings",
      "type": "function",
      "signature": "(encoding)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.encodings.normalize_encoding",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ensurepip.bootstrap",
      "name": "bootstrap",
      "module": "ensurepip",
      "type": "function",
      "signature": "(*, root=None, upgrade=False, user=False, altinstall=False, default_pip=False, verbosity=0)",
      "description": "Bootstrap pip into the current Python installation (or the given root\ndirectory).\n\nNote that calling this function will alter both sys.path and os.environ.",
      "relationships": [
        {
          "target": "stdlib.ensurepip._bootstrap",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ensurepip.version",
      "name": "version",
      "module": "ensurepip",
      "type": "function",
      "signature": "()",
      "description": "Returns a string specifying the bundled version of pip.",
      "relationships": [
        {
          "target": "stdlib.ensurepip._get_packages",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.enum.Enum",
      "name": "Enum",
      "module": "enum",
      "type": "class",
      "signature": "(new_class_name, /, names, *, module=None, qualname=None, type=None, start=1, boundary=None)",
      "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access:\n\n  >>> Color.RED\n  <Color.RED: 1>\n\n- value lookup:\n\n  >>> Color(1)\n  <Color.RED: 1>\n\n- name lookup:\n\n  >>> Color['RED']\n  <Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details.",
      "relationships": []
    },
    {
      "id": "stdlib.enum.EnumCheck",
      "name": "EnumCheck",
      "module": "enum",
      "type": "class",
      "signature": "(*values)",
      "description": "various conditions to check an enumeration for",
      "relationships": [
        {
          "target": "stdlib.enum.StrEnum",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.str",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.ReprEnum",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Enum",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.enum.EnumMeta",
      "name": "EnumMeta",
      "module": "enum",
      "type": "class",
      "signature": "(cls, bases, classdict, *, boundary=None, _simple=False, **kwds)",
      "description": "Metaclass for Enum",
      "relationships": [
        {
          "target": "stdlib.builtins.type",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.enum.EnumType",
      "name": "EnumType",
      "module": "enum",
      "type": "class",
      "signature": "(cls, bases, classdict, *, boundary=None, _simple=False, **kwds)",
      "description": "Metaclass for Enum",
      "relationships": [
        {
          "target": "stdlib.builtins.type",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.enum.Flag",
      "name": "Flag",
      "module": "enum",
      "type": "class",
      "signature": "(new_class_name, /, names, *, module=None, qualname=None, type=None, start=1, boundary=None)",
      "description": "Support for flags",
      "relationships": [
        {
          "target": "stdlib.enum.Enum",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.enum.FlagBoundary",
      "name": "FlagBoundary",
      "module": "enum",
      "type": "class",
      "signature": "(*values)",
      "description": "control how out of range values are handled\n\"strict\" -> error is raised             [default for Flag]\n\"conform\" -> extra bits are discarded\n\"eject\" -> lose flag status\n\"keep\" -> keep flag status and all bits [default for IntFlag]",
      "relationships": [
        {
          "target": "stdlib.enum.StrEnum",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.str",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.ReprEnum",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Enum",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.enum.IntEnum",
      "name": "IntEnum",
      "module": "enum",
      "type": "class",
      "signature": "(new_class_name, /, names, *, module=None, qualname=None, type=None, start=1, boundary=None)",
      "description": "Enum where members are also (and must be) ints",
      "relationships": [
        {
          "target": "stdlib.builtins.int",
          "type": "base_class"
        },
        {
          "target": "stdlib.enum.ReprEnum",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Enum",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.enum.IntFlag",
      "name": "IntFlag",
      "module": "enum",
      "type": "class",
      "signature": "(new_class_name, /, names, *, module=None, qualname=None, type=None, start=1, boundary=None)",
      "description": "Support for integer-based Flags",
      "relationships": [
        {
          "target": "stdlib.builtins.int",
          "type": "base_class"
        },
        {
          "target": "stdlib.enum.ReprEnum",
          "type": "base_class"
        },
        {
          "target": "stdlib.enum.Flag",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Enum",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.enum.ReprEnum",
      "name": "ReprEnum",
      "module": "enum",
      "type": "class",
      "signature": "(new_class_name, /, names, *, module=None, qualname=None, type=None, start=1, boundary=None)",
      "description": "Only changes the repr(), leaving str() and format() to the mixed-in type.",
      "relationships": [
        {
          "target": "stdlib.enum.Enum",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.enum.StrEnum",
      "name": "StrEnum",
      "module": "enum",
      "type": "class",
      "signature": "(new_class_name, /, names, *, module=None, qualname=None, type=None, start=1, boundary=None)",
      "description": "Enum where members are also (and must be) strings",
      "relationships": [
        {
          "target": "stdlib.builtins.str",
          "type": "base_class"
        },
        {
          "target": "stdlib.enum.ReprEnum",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Enum",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.enum.auto",
      "name": "auto",
      "module": "enum",
      "type": "class",
      "signature": "(value=_auto_null)",
      "description": "Instances are replaced with an appropriate value in Enum class suites.",
      "relationships": []
    },
    {
      "id": "stdlib.enum.bin",
      "name": "bin",
      "module": "enum",
      "type": "function",
      "signature": "(num, max_bits=None)",
      "description": "Like built-in bin(), except negative values are represented in\ntwos-compliment, and the leading bit always indicates sign\n(0=positive, 1=negative).\n\n>>> bin(10)\n'0b0 1010'\n>>> bin(~10)   # ~10 is -11\n'0b1 0101'",
      "relationships": []
    },
    {
      "id": "stdlib.enum.global_enum",
      "name": "global_enum",
      "module": "enum",
      "type": "function",
      "signature": "(cls, update_str=False)",
      "description": "decorator that makes the repr() of an enum member reference its module\ninstead of its class; also exports all members to the enum's module's\nglobal namespace",
      "relationships": []
    },
    {
      "id": "stdlib.enum.global_enum_repr",
      "name": "global_enum_repr",
      "module": "enum",
      "type": "function",
      "signature": "(self)",
      "description": "use module.enum_name instead of class.enum_name\n\nthe module is the last module in case of a multi-module name",
      "relationships": []
    },
    {
      "id": "stdlib.enum.global_flag_repr",
      "name": "global_flag_repr",
      "module": "enum",
      "type": "function",
      "signature": "(self)",
      "description": "use module.flag_name instead of class.flag_name\n\nthe module is the last module in case of a multi-module name",
      "relationships": [
        {
          "target": "stdlib.enum._is_single_bit",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.enum.global_str",
      "name": "global_str",
      "module": "enum",
      "type": "function",
      "signature": "(self)",
      "description": "use enum_name instead of class.enum_name",
      "relationships": []
    },
    {
      "id": "stdlib.enum.member",
      "name": "member",
      "module": "enum",
      "type": "class",
      "signature": "(value)",
      "description": "Forces item to become an Enum member during class creation.",
      "relationships": []
    },
    {
      "id": "stdlib.enum.nonmember",
      "name": "nonmember",
      "module": "enum",
      "type": "class",
      "signature": "(value)",
      "description": "Protects item from becoming an Enum member during class creation.",
      "relationships": []
    },
    {
      "id": "stdlib.enum.pickle_by_enum_name",
      "name": "pickle_by_enum_name",
      "module": "enum",
      "type": "function",
      "signature": "(self, proto)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.enum.pickle_by_global_name",
      "name": "pickle_by_global_name",
      "module": "enum",
      "type": "function",
      "signature": "(self, proto)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.enum.property",
      "name": "property",
      "module": "enum",
      "type": "class",
      "signature": "(fget=None, fset=None, fdel=None, doc=None)",
      "description": "This is a descriptor, used to define attributes that act differently\nwhen accessed through an enum member and through an enum class.\nInstance access is the same as property(), but access to an attribute\nthrough the enum class will instead look in the class' _member_map_ for\na corresponding enum member.",
      "relationships": [
        {
          "target": "stdlib.types.DynamicClassAttribute",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.enum.show_flag_values",
      "name": "show_flag_values",
      "module": "enum",
      "type": "function",
      "signature": "(value)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.enum._iter_bits_lsb",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.enum.unique",
      "name": "unique",
      "module": "enum",
      "type": "function",
      "signature": "(enumeration)",
      "description": "Class decorator for enumerations ensuring unique member values.",
      "relationships": []
    },
    {
      "id": "stdlib.enum.verify",
      "name": "verify",
      "module": "enum",
      "type": "class",
      "signature": "(*checks)",
      "description": "Check an enumeration for various constraints. (see EnumCheck)",
      "relationships": []
    },
    {
      "id": "stdlib.filecmp.clear_cache",
      "name": "clear_cache",
      "module": "filecmp",
      "type": "function",
      "signature": "()",
      "description": "Clear the filecmp cache.",
      "relationships": []
    },
    {
      "id": "stdlib.filecmp.cmp",
      "name": "cmp",
      "module": "filecmp",
      "type": "function",
      "signature": "(f1, f2, shallow=True)",
      "description": "Compare two files.\n\nArguments:\n\nf1 -- First file name\n\nf2 -- Second file name\n\nshallow -- treat files as identical if their stat signatures (type, size,\n           mtime) are identical. Otherwise, files are considered different\n           if their sizes or contents differ.  [default: True]\n\nReturn value:\n\nTrue if the files are the same, False otherwise.\n\nThis function uses a cache for past comparisons and the results,\nwith cache entries invalidated if their stat information\nchanges.  The cache may be cleared by calling clear_cache().",
      "relationships": [
        {
          "target": "stdlib.filecmp._sig",
          "type": "calls"
        },
        {
          "target": "stdlib.filecmp._sig",
          "type": "calls"
        },
        {
          "target": "stdlib.filecmp._do_cmp",
          "type": "calls"
        },
        {
          "target": "stdlib.filecmp.clear_cache",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.filecmp.cmpfiles",
      "name": "cmpfiles",
      "module": "filecmp",
      "type": "function",
      "signature": "(a, b, common, shallow=True)",
      "description": "Compare common files in two directories.\n\na, b -- directory names\ncommon -- list of file names found in both directories\nshallow -- if true, do comparison based solely on stat() information\n\nReturns a tuple of three lists:\n  files that compare equal\n  files that are different\n  filenames that aren't regular files.",
      "relationships": [
        {
          "target": "stdlib.filecmp._cmp",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.filecmp.demo",
      "name": "demo",
      "module": "filecmp",
      "type": "function",
      "signature": "()",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.filecmp.dircmp",
      "name": "dircmp",
      "module": "filecmp",
      "type": "class",
      "signature": "(a, b, ignore=None, hide=None)",
      "description": "A class that manages the comparison of 2 directories.\n\ndircmp(a, b, ignore=None, hide=None)\n  A and B are directories.\n  IGNORE is a list of names to ignore,\n    defaults to DEFAULT_IGNORES.\n  HIDE is a list of names to hide,\n    defaults to [os.curdir, os.pardir].\n\nHigh level usage:\n  x = dircmp(dir1, dir2)\n  x.report() -> prints a report on the differences between dir1 and dir2\n   or\n  x.report_partial_closure() -> prints report on differences between dir1\n        and dir2, and reports on common immediate subdirectories.\n  x.report_full_closure() -> like report_partial_closure,\n        but fully recursive.\n\nAttributes:\n left_list, right_list: The files in dir1 and dir2,\n    filtered by hide and ignore.\n common: a list of names in both dir1 and dir2.\n left_only, right_only: names only in dir1, dir2.\n common_dirs: subdirectories in both dir1 and dir2.\n common_files: files in both dir1 and dir2.\n common_funny: names in both dir1 and dir2 where the type differs between\n    dir1 and dir2, or the name is not stat-able.\n same_files: list of identical files.\n diff_files: list of filenames which differ.\n funny_files: list of files which could not be compared.\n subdirs: a dictionary of dircmp instances (or MyDirCmp instances if this\n   object is of type MyDirCmp, a subclass of dircmp), keyed by names\n   in common_dirs.\n ",
      "relationships": []
    },
    {
      "id": "stdlib.fileinput.FileInput",
      "name": "FileInput",
      "module": "fileinput",
      "type": "class",
      "signature": "(files=None, inplace=False, backup='', *, mode='r', openhook=None, encoding=None, errors=None)",
      "description": "FileInput([files[, inplace[, backup]]], *, mode=None, openhook=None)\n\nClass FileInput is the implementation of the module; its methods\nfilename(), lineno(), fileline(), isfirstline(), isstdin(), fileno(),\nnextfile() and close() correspond to the functions of the same name\nin the module.\nIn addition it has a readline() method which returns the next\ninput line, and a __getitem__() method which implements the\nsequence behavior. The sequence must be accessed in strictly\nsequential order; random access and readline() cannot be mixed.",
      "relationships": []
    },
    {
      "id": "stdlib.fileinput.close",
      "name": "close",
      "module": "fileinput",
      "type": "function",
      "signature": "()",
      "description": "Close the sequence.",
      "relationships": []
    },
    {
      "id": "stdlib.fileinput.filelineno",
      "name": "filelineno",
      "module": "fileinput",
      "type": "function",
      "signature": "()",
      "description": "Return the line number in the current file. Before the first line\nhas been read, returns 0. After the last line of the last file has\nbeen read, returns the line number of that line within the file.",
      "relationships": []
    },
    {
      "id": "stdlib.fileinput.filename",
      "name": "filename",
      "module": "fileinput",
      "type": "function",
      "signature": "()",
      "description": "Return the name of the file currently being read.\nBefore the first line has been read, returns None.",
      "relationships": []
    },
    {
      "id": "stdlib.fileinput.fileno",
      "name": "fileno",
      "module": "fileinput",
      "type": "function",
      "signature": "()",
      "description": "Return the file number of the current file. When no file is currently\nopened, returns -1.",
      "relationships": []
    },
    {
      "id": "stdlib.fileinput.hook_compressed",
      "name": "hook_compressed",
      "module": "fileinput",
      "type": "function",
      "signature": "(filename, mode, *, encoding=None, errors=None)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.fileinput.hook_encoded",
      "name": "hook_encoded",
      "module": "fileinput",
      "type": "function",
      "signature": "(encoding, errors=None)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.fileinput.input",
      "name": "input",
      "module": "fileinput",
      "type": "function",
      "signature": "(files=None, inplace=False, backup='', *, mode='r', openhook=None, encoding=None, errors=None)",
      "description": "Return an instance of the FileInput class, which can be iterated.\n\nThe parameters are passed to the constructor of the FileInput class.\nThe returned instance, in addition to being an iterator,\nkeeps global state for the functions of this module,.",
      "relationships": []
    },
    {
      "id": "stdlib.fileinput.isfirstline",
      "name": "isfirstline",
      "module": "fileinput",
      "type": "function",
      "signature": "()",
      "description": "Returns true the line just read is the first line of its file,\notherwise returns false.",
      "relationships": []
    },
    {
      "id": "stdlib.fileinput.isstdin",
      "name": "isstdin",
      "module": "fileinput",
      "type": "function",
      "signature": "()",
      "description": "Returns true if the last line was read from sys.stdin,\notherwise returns false.",
      "relationships": []
    },
    {
      "id": "stdlib.fileinput.lineno",
      "name": "lineno",
      "module": "fileinput",
      "type": "function",
      "signature": "()",
      "description": "Return the cumulative line number of the line that has just been read.\nBefore the first line has been read, returns 0. After the last line\nof the last file has been read, returns the line number of that line.",
      "relationships": []
    },
    {
      "id": "stdlib.fileinput.nextfile",
      "name": "nextfile",
      "module": "fileinput",
      "type": "function",
      "signature": "()",
      "description": "Close the current file so that the next iteration will read the first\nline from the next file (if any); lines not read from the file will\nnot count towards the cumulative line count. The filename is not\nchanged until after the first line of the next file has been read.\nBefore the first line has been read, this function has no effect;\nit cannot be used to skip the first file. After the last line of the\nlast file has been read, this function has no effect.",
      "relationships": []
    },
    {
      "id": "stdlib.fnmatch.filter",
      "name": "filter",
      "module": "fnmatch",
      "type": "function",
      "signature": "(names, pat)",
      "description": "Construct a list from those elements of the iterable NAMES that match PAT.",
      "relationships": []
    },
    {
      "id": "stdlib.fnmatch.fnmatch",
      "name": "fnmatch",
      "module": "fnmatch",
      "type": "function",
      "signature": "(name, pat)",
      "description": "Test whether FILENAME matches PATTERN.\n\nPatterns are Unix shell style:\n\n*       matches everything\n?       matches any single character\n[seq]   matches any character in seq\n[!seq]  matches any char not in seq\n\nAn initial period in FILENAME is not special.\nBoth FILENAME and PATTERN are first case-normalized\nif the operating system requires it.\nIf you don't want this, use fnmatchcase(FILENAME, PATTERN).",
      "relationships": [
        {
          "target": "stdlib.fnmatch.fnmatchcase",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.fnmatch.fnmatchcase",
      "name": "fnmatchcase",
      "module": "fnmatch",
      "type": "function",
      "signature": "(name, pat)",
      "description": "Test whether FILENAME matches PATTERN, including case.\n\nThis is a version of fnmatch() which doesn't case-normalize\nits arguments.",
      "relationships": []
    },
    {
      "id": "stdlib.fnmatch.translate",
      "name": "translate",
      "module": "fnmatch",
      "type": "function",
      "signature": "(pat)",
      "description": "Translate a shell PATTERN to a regular expression.\n\nThere is no way to quote meta-characters.",
      "relationships": []
    },
    {
      "id": "stdlib.fractions.Fraction",
      "name": "Fraction",
      "module": "fractions",
      "type": "class",
      "signature": "(numerator=0, denominator=None)",
      "description": "This class implements rational numbers.\n\nIn the two-argument form of the constructor, Fraction(8, 6) will\nproduce a rational number equivalent to 4/3. Both arguments must\nbe Rational. The numerator defaults to 0 and the denominator\ndefaults to 1 so that Fraction(3) == 3 and Fraction() == 0.\n\nFractions can also be constructed from:\n\n  - numeric strings similar to those accepted by the\n    float constructor (for example, '-2.3' or '1e10')\n\n  - strings of the form '123/456'\n\n  - float and Decimal instances\n\n  - other Rational instances (including integers)",
      "relationships": [
        {
          "target": "stdlib.numbers.Rational",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Real",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Complex",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Number",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.ftplib.FTP",
      "name": "FTP",
      "module": "ftplib",
      "type": "class",
      "signature": "(host='', user='', passwd='', acct='', timeout=<object object at 0x100108a90>, source_address=None, *, encoding='utf-8')",
      "description": "An FTP client class.\n\nTo create a connection, call the class using these arguments:\n        host, user, passwd, acct, timeout, source_address, encoding\n\nThe first four arguments are all strings, and have default value ''.\nThe parameter \u00b4timeout\u00b4 must be numeric and defaults to None if not\npassed, meaning that no timeout will be set on any ftp socket(s).\nIf a timeout is passed, then this is now the default timeout for all ftp\nsocket operations for this instance.\nThe last parameter is the encoding of filenames, which defaults to utf-8.\n\nThen use self.connect() with optional host and port argument.\n\nTo download a file, use ftp.retrlines('RETR ' + filename),\nor ftp.retrbinary() with slightly different arguments.\nTo upload a file, use ftp.storlines() or ftp.storbinary(),\nwhich have an open file as argument (see their definitions\nbelow for details).\nThe download/upload functions first issue appropriate TYPE\nand PORT or PASV commands.",
      "relationships": []
    },
    {
      "id": "stdlib.ftplib.FTP_TLS",
      "name": "FTP_TLS",
      "module": "ftplib",
      "type": "class",
      "signature": "(host='', user='', passwd='', acct='', *, context=None, timeout=<object object at 0x100108a90>, source_address=None, encoding='utf-8')",
      "description": "A FTP subclass which adds TLS support to FTP as described\nin RFC-4217.\n\nConnect as usual to port 21 implicitly securing the FTP control\nconnection before authenticating.\n\nSecuring the data connection requires user to explicitly ask\nfor it by calling prot_p() method.\n\nUsage example:\n>>> from ftplib import FTP_TLS\n>>> ftps = FTP_TLS('ftp.python.org')\n>>> ftps.login()  # login anonymously previously securing control channel\n'230 Guest login ok, access restrictions apply.'\n>>> ftps.prot_p()  # switch to secure data connection\n'200 Protection level set to P'\n>>> ftps.retrlines('LIST')  # list directory content securely\ntotal 9\ndrwxr-xr-x   8 root     wheel        1024 Jan  3  1994 .\ndrwxr-xr-x   8 root     wheel        1024 Jan  3  1994 ..\ndrwxr-xr-x   2 root     wheel        1024 Jan  3  1994 bin\ndrwxr-xr-x   2 root     wheel        1024 Jan  3  1994 etc\nd-wxrwxr-x   2 ftp      wheel        1024 Sep  5 13:43 incoming\ndrwxr-xr-x   2 root     wheel        1024 Nov 17  1993 lib\ndrwxr-xr-x   6 1094     wheel        1024 Sep 13 19:07 pub\ndrwxr-xr-x   3 root     wheel        1024 Jan  3  1994 usr\n-rw-r--r--   1 root     root          312 Aug  1  1994 welcome.msg\n'226 Transfer complete.'\n>>> ftps.quit()\n'221 Goodbye.'\n>>>",
      "relationships": [
        {
          "target": "stdlib.ftplib.FTP",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.ftplib.ftpcp",
      "name": "ftpcp",
      "module": "ftplib",
      "type": "function",
      "signature": "(source, sourcename, target, targetname='', type='I')",
      "description": "Copy file from one FTP-instance to another.",
      "relationships": [
        {
          "target": "stdlib.ftplib.parse227",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ftplib.parse150",
      "name": "parse150",
      "module": "ftplib",
      "type": "function",
      "signature": "(resp)",
      "description": "Parse the '150' response for a RETR request.\nReturns the expected transfer size or None; size is not guaranteed to\nbe present in the 150 message.",
      "relationships": []
    },
    {
      "id": "stdlib.ftplib.parse227",
      "name": "parse227",
      "module": "ftplib",
      "type": "function",
      "signature": "(resp)",
      "description": "Parse the '227' response for a PASV request.\nRaises error_proto if it does not contain '(h1,h2,h3,h4,p1,p2)'\nReturn ('host.addr.as.numbers', port#) tuple.",
      "relationships": []
    },
    {
      "id": "stdlib.ftplib.parse229",
      "name": "parse229",
      "module": "ftplib",
      "type": "function",
      "signature": "(resp, peer)",
      "description": "Parse the '229' response for an EPSV request.\nRaises error_proto if it does not contain '(|||port|)'\nReturn ('host.addr.as.numbers', port#) tuple.",
      "relationships": []
    },
    {
      "id": "stdlib.ftplib.parse257",
      "name": "parse257",
      "module": "ftplib",
      "type": "function",
      "signature": "(resp)",
      "description": "Parse the '257' response for a MKD or PWD request.\nThis is a response to a MKD or PWD request: a directory name.\nReturns the directoryname in the 257 reply.",
      "relationships": []
    },
    {
      "id": "stdlib.ftplib.print_line",
      "name": "print_line",
      "module": "ftplib",
      "type": "function",
      "signature": "(line)",
      "description": "Default retrlines callback to print a line.",
      "relationships": []
    },
    {
      "id": "stdlib.ftplib.test",
      "name": "test",
      "module": "ftplib",
      "type": "function",
      "signature": "()",
      "description": "Test program.\nUsage: ftplib [-d] [-r[file]] host [-l[dir]] [-d[dir]] [-p] [file] ...\n\nOptions:\n  -d        increase debugging level\n  -r[file]  set alternate ~/.netrc file\n\nCommands:\n  -l[dir]   list directory\n  -d[dir]   change the current directory\n  -p        toggle passive and active mode\n  file      retrieve the file and write it to stdout",
      "relationships": []
    },
    {
      "id": "stdlib.functools.cache",
      "name": "cache",
      "module": "functools",
      "type": "function",
      "signature": "(user_function, /)",
      "description": "Simple lightweight unbounded cache.  Sometimes called \"memoize\".",
      "relationships": [
        {
          "target": "stdlib.functools.lru_cache",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.functools.cached_property",
      "name": "cached_property",
      "module": "functools",
      "type": "class",
      "signature": "(func)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.functools.lru_cache",
      "name": "lru_cache",
      "module": "functools",
      "type": "function",
      "signature": "(maxsize=128, typed=False)",
      "description": "Least-recently-used cache decorator.\n\nIf *maxsize* is set to None, the LRU features are disabled and the cache\ncan grow without bound.\n\nIf *typed* is True, arguments of different types will be cached separately.\nFor example, f(3.0) and f(3) will be treated as distinct calls with\ndistinct results.\n\nArguments to the cached function must be hashable.\n\nView the cache statistics named tuple (hits, misses, maxsize, currsize)\nwith f.cache_info().  Clear the cache and statistics with f.cache_clear().\nAccess the underlying function with f.__wrapped__.\n\nSee:  https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU)",
      "relationships": [
        {
          "target": "stdlib.functools.update_wrapper",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.update_wrapper",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.functools.partialmethod",
      "name": "partialmethod",
      "module": "functools",
      "type": "class",
      "signature": "(func, /, *args, **keywords)",
      "description": "Method descriptor with partial application of the given arguments\nand keywords.\n\nSupports wrapping existing descriptors and handles non-descriptor\ncallables as instance methods.",
      "relationships": []
    },
    {
      "id": "stdlib.functools.singledispatch",
      "name": "singledispatch",
      "module": "functools",
      "type": "function",
      "signature": "(func)",
      "description": "Single-dispatch generic function decorator.\n\nTransforms a function into a generic function, which can have different\nbehaviours depending upon the type of its first argument. The decorated\nfunction acts as the default implementation, and additional\nimplementations can be registered using the register() attribute of the\ngeneric function.",
      "relationships": [
        {
          "target": "stdlib.functools.update_wrapper",
          "type": "calls"
        },
        {
          "target": "stdlib.functools._find_impl",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.functools.singledispatchmethod",
      "name": "singledispatchmethod",
      "module": "functools",
      "type": "class",
      "signature": "(func)",
      "description": "Single-dispatch generic method descriptor.\n\nSupports wrapping existing descriptors and handles non-descriptor\ncallables as instance methods.",
      "relationships": []
    },
    {
      "id": "stdlib.functools.total_ordering",
      "name": "total_ordering",
      "module": "functools",
      "type": "function",
      "signature": "(cls)",
      "description": "Class decorator that fills in missing ordering methods",
      "relationships": []
    },
    {
      "id": "stdlib.functools.update_wrapper",
      "name": "update_wrapper",
      "module": "functools",
      "type": "function",
      "signature": "(wrapper, wrapped, assigned=('__module__', '__name__', '__qualname__', '__doc__', '__annotations__', '__type_params__'), updated=('__dict__',))",
      "description": "Update a wrapper function to look like the wrapped function\n\nwrapper is the function to be updated\nwrapped is the original function\nassigned is a tuple naming the attributes assigned directly\nfrom the wrapped function to the wrapper function (defaults to\nfunctools.WRAPPER_ASSIGNMENTS)\nupdated is a tuple naming the attributes of the wrapper that\nare updated with the corresponding attribute from the wrapped\nfunction (defaults to functools.WRAPPER_UPDATES)",
      "relationships": []
    },
    {
      "id": "stdlib.functools.wraps",
      "name": "wraps",
      "module": "functools",
      "type": "function",
      "signature": "(wrapped, assigned=('__module__', '__name__', '__qualname__', '__doc__', '__annotations__', '__type_params__'), updated=('__dict__',))",
      "description": "Decorator factory to apply update_wrapper() to a wrapper function\n\nReturns a decorator that invokes update_wrapper() with the decorated\nfunction as the wrapper argument and the arguments to wraps() as the\nremaining arguments. Default arguments are as for update_wrapper().\nThis is a convenience function to simplify applying partial() to\nupdate_wrapper().",
      "relationships": []
    },
    {
      "id": "stdlib.genericpath.commonprefix",
      "name": "commonprefix",
      "module": "genericpath",
      "type": "function",
      "signature": "(m)",
      "description": "Given a list of pathnames, returns the longest common leading component",
      "relationships": []
    },
    {
      "id": "stdlib.genericpath.exists",
      "name": "exists",
      "module": "genericpath",
      "type": "function",
      "signature": "(path)",
      "description": "Test whether a path exists.  Returns False for broken symbolic links",
      "relationships": []
    },
    {
      "id": "stdlib.genericpath.getatime",
      "name": "getatime",
      "module": "genericpath",
      "type": "function",
      "signature": "(filename)",
      "description": "Return the last access time of a file, reported by os.stat().",
      "relationships": []
    },
    {
      "id": "stdlib.genericpath.getctime",
      "name": "getctime",
      "module": "genericpath",
      "type": "function",
      "signature": "(filename)",
      "description": "Return the metadata change time of a file, reported by os.stat().",
      "relationships": []
    },
    {
      "id": "stdlib.genericpath.getmtime",
      "name": "getmtime",
      "module": "genericpath",
      "type": "function",
      "signature": "(filename)",
      "description": "Return the last modification time of a file, reported by os.stat().",
      "relationships": []
    },
    {
      "id": "stdlib.genericpath.getsize",
      "name": "getsize",
      "module": "genericpath",
      "type": "function",
      "signature": "(filename)",
      "description": "Return the size of a file, reported by os.stat().",
      "relationships": []
    },
    {
      "id": "stdlib.genericpath.isdir",
      "name": "isdir",
      "module": "genericpath",
      "type": "function",
      "signature": "(s)",
      "description": "Return true if the pathname refers to an existing directory.",
      "relationships": []
    },
    {
      "id": "stdlib.genericpath.isfile",
      "name": "isfile",
      "module": "genericpath",
      "type": "function",
      "signature": "(path)",
      "description": "Test whether a path is a regular file",
      "relationships": []
    },
    {
      "id": "stdlib.genericpath.islink",
      "name": "islink",
      "module": "genericpath",
      "type": "function",
      "signature": "(path)",
      "description": "Test whether a path is a symbolic link",
      "relationships": []
    },
    {
      "id": "stdlib.genericpath.samefile",
      "name": "samefile",
      "module": "genericpath",
      "type": "function",
      "signature": "(f1, f2)",
      "description": "Test whether two pathnames reference the same actual file or directory\n\nThis is determined by the device number and i-node number and\nraises an exception if an os.stat() call on either pathname fails.",
      "relationships": []
    },
    {
      "id": "stdlib.genericpath.sameopenfile",
      "name": "sameopenfile",
      "module": "genericpath",
      "type": "function",
      "signature": "(fp1, fp2)",
      "description": "Test whether two open file objects reference the same file",
      "relationships": []
    },
    {
      "id": "stdlib.genericpath.samestat",
      "name": "samestat",
      "module": "genericpath",
      "type": "function",
      "signature": "(s1, s2)",
      "description": "Test whether two stat buffers reference the same file",
      "relationships": []
    },
    {
      "id": "stdlib.getopt.GetoptError",
      "name": "GetoptError",
      "module": "getopt",
      "type": "class",
      "signature": "(msg, opt='')",
      "description": "Common base class for all non-exit exceptions.",
      "relationships": [
        {
          "target": "stdlib.builtins.Exception",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.getopt.do_longs",
      "name": "do_longs",
      "module": "getopt",
      "type": "function",
      "signature": "(opts, opt, longopts, args)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.getopt.long_has_args",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.getopt.do_shorts",
      "name": "do_shorts",
      "module": "getopt",
      "type": "function",
      "signature": "(opts, optstring, shortopts, args)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.getopt.short_has_arg",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.getopt.error",
      "name": "error",
      "module": "getopt",
      "type": "class",
      "signature": "(msg, opt='')",
      "description": "Common base class for all non-exit exceptions.",
      "relationships": [
        {
          "target": "stdlib.builtins.Exception",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.getopt.getopt",
      "name": "getopt",
      "module": "getopt",
      "type": "function",
      "signature": "(args, shortopts, longopts=[])",
      "description": "getopt(args, options[, long_options]) -> opts, args\n\nParses command line options and parameter list.  args is the\nargument list to be parsed, without the leading reference to the\nrunning program.  Typically, this means \"sys.argv[1:]\".  shortopts\nis the string of option letters that the script wants to\nrecognize, with options that require an argument followed by a\ncolon (i.e., the same format that Unix getopt() uses).  If\nspecified, longopts is a list of strings with the names of the\nlong options which should be supported.  The leading '--'\ncharacters should not be included in the option name.  Options\nwhich require an argument should be followed by an equal sign\n('=').\n\nThe return value consists of two elements: the first is a list of\n(option, value) pairs; the second is the list of program arguments\nleft after the option list was stripped (this is a trailing slice\nof the first argument).  Each option-and-value pair returned has\nthe option as its first element, prefixed with a hyphen (e.g.,\n'-x'), and the option argument as its second element, or an empty\nstring if the option has no argument.  The options occur in the\nlist in the same order in which they were found, thus allowing\nmultiple occurrences.  Long and short options may be mixed.",
      "relationships": [
        {
          "target": "stdlib.getopt.do_longs",
          "type": "calls"
        },
        {
          "target": "stdlib.getopt.do_shorts",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.getopt.gnu_getopt",
      "name": "gnu_getopt",
      "module": "getopt",
      "type": "function",
      "signature": "(args, shortopts, longopts=[])",
      "description": "getopt(args, options[, long_options]) -> opts, args\n\nThis function works like getopt(), except that GNU style scanning\nmode is used by default. This means that option and non-option\narguments may be intermixed. The getopt() function stops\nprocessing options as soon as a non-option argument is\nencountered.\n\nIf the first character of the option string is `+', or if the\nenvironment variable POSIXLY_CORRECT is set, then option\nprocessing stops as soon as a non-option argument is encountered.",
      "relationships": [
        {
          "target": "stdlib.getopt.do_longs",
          "type": "calls"
        },
        {
          "target": "stdlib.getopt.do_shorts",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.getopt.long_has_args",
      "name": "long_has_args",
      "module": "getopt",
      "type": "function",
      "signature": "(opt, longopts)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.getopt.short_has_arg",
      "name": "short_has_arg",
      "module": "getopt",
      "type": "function",
      "signature": "(opt, shortopts)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.getpass.fallback_getpass",
      "name": "fallback_getpass",
      "module": "getpass",
      "type": "function",
      "signature": "(prompt='Password: ', stream=None)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.getpass._raw_input",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.getpass.getpass",
      "name": "getpass",
      "module": "getpass",
      "type": "function",
      "signature": "(prompt='Password: ', stream=None)",
      "description": "Prompt for a password, with echo turned off.\n\nArgs:\n  prompt: Written on stream to ask for the input.  Default: 'Password: '\n  stream: A writable file object to display the prompt.  Defaults to\n          the tty.  If no tty is available defaults to sys.stderr.\nReturns:\n  The seKr3t input.\nRaises:\n  EOFError: If our input tty or stdin was closed.\n  GetPassWarning: When we were unable to turn echo off on the input.\n\nAlways restores terminal settings before returning.",
      "relationships": [
        {
          "target": "stdlib.getpass._raw_input",
          "type": "calls"
        },
        {
          "target": "stdlib.getpass.fallback_getpass",
          "type": "calls"
        },
        {
          "target": "stdlib.getpass.fallback_getpass",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.getpass.getuser",
      "name": "getuser",
      "module": "getpass",
      "type": "function",
      "signature": "()",
      "description": "Get the username from the environment or password database.\n\nFirst try various environment variables, then the password\ndatabase.  This works on Windows as long as USERNAME is set.",
      "relationships": []
    },
    {
      "id": "stdlib.getpass.unix_getpass",
      "name": "unix_getpass",
      "module": "getpass",
      "type": "function",
      "signature": "(prompt='Password: ', stream=None)",
      "description": "Prompt for a password, with echo turned off.\n\nArgs:\n  prompt: Written on stream to ask for the input.  Default: 'Password: '\n  stream: A writable file object to display the prompt.  Defaults to\n          the tty.  If no tty is available defaults to sys.stderr.\nReturns:\n  The seKr3t input.\nRaises:\n  EOFError: If our input tty or stdin was closed.\n  GetPassWarning: When we were unable to turn echo off on the input.\n\nAlways restores terminal settings before returning.",
      "relationships": [
        {
          "target": "stdlib.getpass._raw_input",
          "type": "calls"
        },
        {
          "target": "stdlib.getpass.fallback_getpass",
          "type": "calls"
        },
        {
          "target": "stdlib.getpass.fallback_getpass",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.getpass.win_getpass",
      "name": "win_getpass",
      "module": "getpass",
      "type": "function",
      "signature": "(prompt='Password: ', stream=None)",
      "description": "Prompt for password with echo off, using Windows getwch().",
      "relationships": [
        {
          "target": "stdlib.getpass.fallback_getpass",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.gettext.Catalog",
      "name": "Catalog",
      "module": "gettext",
      "type": "function",
      "signature": "(domain, localedir=None, languages=None, class_=None, fallback=False)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.gettext.find",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.gettext.GNUTranslations",
      "name": "GNUTranslations",
      "module": "gettext",
      "type": "class",
      "signature": "(fp=None)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.gettext.NullTranslations",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.gettext.NullTranslations",
      "name": "NullTranslations",
      "module": "gettext",
      "type": "class",
      "signature": "(fp=None)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.gettext.bindtextdomain",
      "name": "bindtextdomain",
      "module": "gettext",
      "type": "function",
      "signature": "(domain, localedir=None)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.gettext.c2py",
      "name": "c2py",
      "module": "gettext",
      "type": "function",
      "signature": "(plural)",
      "description": "Gets a C expression as used in PO files for plural forms and returns a\nPython function that implements an equivalent expression.",
      "relationships": [
        {
          "target": "stdlib.gettext._parse",
          "type": "calls"
        },
        {
          "target": "stdlib.gettext._tokenize",
          "type": "calls"
        },
        {
          "target": "stdlib.gettext._error",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.gettext.dgettext",
      "name": "dgettext",
      "module": "gettext",
      "type": "function",
      "signature": "(domain, message)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.gettext.translation",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.gettext.dngettext",
      "name": "dngettext",
      "module": "gettext",
      "type": "function",
      "signature": "(domain, msgid1, msgid2, n)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.gettext.translation",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.gettext.dnpgettext",
      "name": "dnpgettext",
      "module": "gettext",
      "type": "function",
      "signature": "(domain, context, msgid1, msgid2, n)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.gettext.translation",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.gettext.dpgettext",
      "name": "dpgettext",
      "module": "gettext",
      "type": "function",
      "signature": "(domain, context, message)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.gettext.translation",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.gettext.find",
      "name": "find",
      "module": "gettext",
      "type": "function",
      "signature": "(domain, localedir=None, languages=None, all=False)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.gettext._expand_lang",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.gettext.gettext",
      "name": "gettext",
      "module": "gettext",
      "type": "function",
      "signature": "(message)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.gettext.dgettext",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.gettext.install",
      "name": "install",
      "module": "gettext",
      "type": "function",
      "signature": "(domain, localedir=None, *, names=None)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.gettext.translation",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.gettext.ngettext",
      "name": "ngettext",
      "module": "gettext",
      "type": "function",
      "signature": "(msgid1, msgid2, n)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.gettext.dngettext",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.gettext.npgettext",
      "name": "npgettext",
      "module": "gettext",
      "type": "function",
      "signature": "(context, msgid1, msgid2, n)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.gettext.dnpgettext",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.gettext.pgettext",
      "name": "pgettext",
      "module": "gettext",
      "type": "function",
      "signature": "(context, message)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.gettext.dpgettext",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.gettext.textdomain",
      "name": "textdomain",
      "module": "gettext",
      "type": "function",
      "signature": "(domain=None)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.gettext.translation",
      "name": "translation",
      "module": "gettext",
      "type": "function",
      "signature": "(domain, localedir=None, languages=None, class_=None, fallback=False)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.gettext.find",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.glob.escape",
      "name": "escape",
      "module": "glob",
      "type": "function",
      "signature": "(pathname)",
      "description": "Escape all special characters.\n    ",
      "relationships": []
    },
    {
      "id": "stdlib.glob.glob",
      "name": "glob",
      "module": "glob",
      "type": "function",
      "signature": "(pathname, *, root_dir=None, dir_fd=None, recursive=False, include_hidden=False)",
      "description": "Return a list of paths matching a pathname pattern.\n\nThe pattern may contain simple shell-style wildcards a la\nfnmatch. Unlike fnmatch, filenames starting with a\ndot are special cases that are not matched by '*' and '?'\npatterns by default.\n\nIf `include_hidden` is true, the patterns '*', '?', '**'  will match hidden\ndirectories.\n\nIf `recursive` is true, the pattern '**' will match any files and\nzero or more directories and subdirectories.",
      "relationships": [
        {
          "target": "stdlib.glob.iglob",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.glob.glob0",
      "name": "glob0",
      "module": "glob",
      "type": "function",
      "signature": "(dirname, pattern)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.glob._glob0",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.glob.glob1",
      "name": "glob1",
      "module": "glob",
      "type": "function",
      "signature": "(dirname, pattern)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.glob._glob1",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.glob.has_magic",
      "name": "has_magic",
      "module": "glob",
      "type": "function",
      "signature": "(s)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.glob.iglob",
      "name": "iglob",
      "module": "glob",
      "type": "function",
      "signature": "(pathname, *, root_dir=None, dir_fd=None, recursive=False, include_hidden=False)",
      "description": "Return an iterator which yields the paths matching a pathname pattern.\n\nThe pattern may contain simple shell-style wildcards a la\nfnmatch. However, unlike fnmatch, filenames starting with a\ndot are special cases that are not matched by '*' and '?'\npatterns.\n\nIf recursive is true, the pattern '**' will match any files and\nzero or more directories and subdirectories.",
      "relationships": [
        {
          "target": "stdlib.glob._iglob",
          "type": "calls"
        },
        {
          "target": "stdlib.glob._isrecursive",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.graphlib.TopologicalSorter",
      "name": "TopologicalSorter",
      "module": "graphlib",
      "type": "class",
      "signature": "(graph=None)",
      "description": "Provides functionality to topologically sort a graph of hashable nodes",
      "relationships": []
    },
    {
      "id": "stdlib.grp.struct_group",
      "name": "struct_group",
      "module": "grp",
      "type": "class",
      "signature": "(iterable=(), /)",
      "description": "grp.struct_group: Results from getgr*() routines.\n\nThis object may be accessed either as a tuple of\n  (gr_name,gr_passwd,gr_gid,gr_mem)\nor via the object attributes as named in the above tuple.",
      "relationships": [
        {
          "target": "stdlib.builtins.tuple",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.gzip.GzipFile",
      "name": "GzipFile",
      "module": "gzip",
      "type": "class",
      "signature": "(filename=None, mode=None, compresslevel=9, fileobj=None, mtime=None)",
      "description": "The GzipFile class simulates most of the methods of a file object with\nthe exception of the truncate() method.\n\nThis class only supports opening files in binary mode. If you need to open a\ncompressed file in text mode, use the gzip.open() function.",
      "relationships": [
        {
          "target": "stdlib._compression.BaseStream",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.BufferedIOBase",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins._BufferedIOBase",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.IOBase",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins._IOBase",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.gzip.compress",
      "name": "compress",
      "module": "gzip",
      "type": "function",
      "signature": "(data, compresslevel=9, *, mtime=None)",
      "description": "Compress data in one shot and return the compressed string.\n\ncompresslevel sets the compression level in range of 0-9.\nmtime can be used to set the modification time. The modification time is\nset to the current time by default.",
      "relationships": [
        {
          "target": "stdlib.gzip._create_simple_gzip_header",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.gzip.decompress",
      "name": "decompress",
      "module": "gzip",
      "type": "function",
      "signature": "(data)",
      "description": "Decompress a gzip compressed string in one shot.\nReturn the decompressed string.",
      "relationships": [
        {
          "target": "stdlib.gzip._read_gzip_header",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.gzip.main",
      "name": "main",
      "module": "gzip",
      "type": "function",
      "signature": "()",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.gzip.open",
      "name": "open",
      "module": "gzip",
      "type": "function",
      "signature": "(filename, mode='rb', compresslevel=9, encoding=None, errors=None, newline=None)",
      "description": "Open a gzip-compressed file in binary or text mode.\n\nThe filename argument can be an actual filename (a str or bytes object), or\nan existing file object to read from or write to.\n\nThe mode argument can be \"r\", \"rb\", \"w\", \"wb\", \"x\", \"xb\", \"a\" or \"ab\" for\nbinary mode, or \"rt\", \"wt\", \"xt\" or \"at\" for text mode. The default mode is\n\"rb\", and the default compresslevel is 9.\n\nFor binary mode, this function is equivalent to the GzipFile constructor:\nGzipFile(filename, mode, compresslevel). In this case, the encoding, errors\nand newline arguments must not be provided.\n\nFor text mode, a GzipFile object is created, and wrapped in an\nio.TextIOWrapper instance with the specified encoding, error handling\nbehavior, and line ending(s).",
      "relationships": []
    },
    {
      "id": "stdlib.gzip.write32u",
      "name": "write32u",
      "module": "gzip",
      "type": "function",
      "signature": "(output, value)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.hashlib.file_digest",
      "name": "file_digest",
      "module": "hashlib",
      "type": "function",
      "signature": "(fileobj, digest, /, *, _bufsize=262144)",
      "description": "Hash the contents of a file-like object. Returns a digest object.\n\n*fileobj* must be a file-like object opened for reading in binary mode.\nIt accepts file objects from open(), io.BytesIO(), and SocketIO objects.\nThe function may bypass Python's I/O and use the file descriptor *fileno*\ndirectly.\n\n*digest* must either be a hash algorithm name as a *str*, a hash\nconstructor, or a callable that returns a hash object.",
      "relationships": [
        {
          "target": "stdlib.hashlib.new",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.hashlib.new",
      "name": "new",
      "module": "hashlib",
      "type": "function",
      "signature": "(name, data=b'', **kwargs)",
      "description": "new(name, data=b'') - Return a new hashing object using the named algorithm;\noptionally initialized with data (which must be a bytes-like object).",
      "relationships": [
        {
          "target": "stdlib.hashlib.__get_builtin_constructor",
          "type": "calls"
        },
        {
          "target": "stdlib.hashlib.__get_builtin_constructor",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.heapq.merge",
      "name": "merge",
      "module": "heapq",
      "type": "function",
      "signature": "(*iterables, key=None, reverse=False)",
      "description": "Merge multiple sorted inputs into a single sorted output.\n\nSimilar to sorted(itertools.chain(*iterables)) but returns a generator,\ndoes not pull the data into memory all at once, and assumes that each of\nthe input streams is already sorted (smallest to largest).\n\n>>> list(merge([1,3,5,7], [0,2,4,8], [5,10,15,20], [], [25]))\n[0, 1, 2, 3, 4, 5, 5, 7, 8, 10, 15, 20, 25]\n\nIf *key* is not None, applies a key function to each element to determine\nits sort order.\n\n>>> list(merge(['dog', 'horse'], ['cat', 'fish', 'kangaroo'], key=len))\n['dog', 'cat', 'fish', 'horse', 'kangaroo']",
      "relationships": []
    },
    {
      "id": "stdlib.heapq.nlargest",
      "name": "nlargest",
      "module": "heapq",
      "type": "function",
      "signature": "(n, iterable, key=None)",
      "description": "Find the n largest elements in a dataset.\n\nEquivalent to:  sorted(iterable, key=key, reverse=True)[:n]",
      "relationships": []
    },
    {
      "id": "stdlib.heapq.nsmallest",
      "name": "nsmallest",
      "module": "heapq",
      "type": "function",
      "signature": "(n, iterable, key=None)",
      "description": "Find the n smallest elements in a dataset.\n\nEquivalent to:  sorted(iterable, key=key)[:n]",
      "relationships": []
    },
    {
      "id": "stdlib.hmac.HMAC",
      "name": "HMAC",
      "module": "hmac",
      "type": "class",
      "signature": "(key, msg=None, digestmod='')",
      "description": "RFC 2104 HMAC class.  Also complies with RFC 4231.\n\nThis supports the API for Cryptographic Hash Functions (PEP 247).",
      "relationships": []
    },
    {
      "id": "stdlib.hmac.digest",
      "name": "digest",
      "module": "hmac",
      "type": "function",
      "signature": "(key, msg, digest)",
      "description": "Fast inline implementation of HMAC.\n\nkey: bytes or buffer, The key for the keyed hash object.\nmsg: bytes or buffer, Input message.\ndigest: A hash name suitable for hashlib.new() for best performance. *OR*\n        A hashlib constructor returning a new hash object. *OR*\n        A module supporting PEP 247.",
      "relationships": []
    },
    {
      "id": "stdlib.hmac.new",
      "name": "new",
      "module": "hmac",
      "type": "function",
      "signature": "(key, msg=None, digestmod='')",
      "description": "Create a new hashing object and return it.\n\nkey: bytes or buffer, The starting key for the hash.\nmsg: bytes or buffer, Initial input for the hash, or None.\ndigestmod: A hash name suitable for hashlib.new(). *OR*\n           A hashlib constructor returning a new hash object. *OR*\n           A module supporting PEP 247.\n\n           Required as of 3.8, despite its position after the optional\n           msg argument.  Passing it as a keyword argument is\n           recommended, though not required for legacy API reasons.\n\nYou can now feed arbitrary bytes into the object using its update()\nmethod, and can ask for the hash value at any time by calling its digest()\nor hexdigest() methods.",
      "relationships": []
    },
    {
      "id": "stdlib.html.escape",
      "name": "escape",
      "module": "html",
      "type": "function",
      "signature": "(s, quote=True)",
      "description": "Replace special characters \"&\", \"<\" and \">\" to HTML-safe sequences.\nIf the optional flag quote is true (the default), the quotation mark\ncharacters, both double quote (\") and single quote (') characters are also\ntranslated.",
      "relationships": []
    },
    {
      "id": "stdlib.html.unescape",
      "name": "unescape",
      "module": "html",
      "type": "function",
      "signature": "(s)",
      "description": "Convert all named and numeric character references (e.g. &gt;, &#62;,\n&x3e;) in the string s to the corresponding unicode characters.\nThis function uses the rules defined by the HTML 5 standard\nfor both valid and invalid character references, and the list of\nHTML 5 named character references defined in html.entities.html5.",
      "relationships": []
    },
    {
      "id": "stdlib.http.HTTPMethod",
      "name": "HTTPMethod",
      "module": "http",
      "type": "class",
      "signature": "(*values)",
      "description": "HTTP methods and descriptions\n\nMethods from the following RFCs are all observed:\n\n    * RFC 7231: Hypertext Transfer Protocol (HTTP/1.1), obsoletes 2616\n    * RFC 5789: PATCH Method for HTTP",
      "relationships": [
        {
          "target": "stdlib.enum.StrEnum",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.str",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.ReprEnum",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Enum",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.http.HTTPStatus",
      "name": "HTTPStatus",
      "module": "http",
      "type": "class",
      "signature": "(*values)",
      "description": "HTTP status codes and reason phrases\n\nStatus codes from the following RFCs are all observed:\n\n    * RFC 7231: Hypertext Transfer Protocol (HTTP/1.1), obsoletes 2616\n    * RFC 6585: Additional HTTP Status Codes\n    * RFC 3229: Delta encoding in HTTP\n    * RFC 4918: HTTP Extensions for WebDAV, obsoletes 2518\n    * RFC 5842: Binding Extensions to WebDAV\n    * RFC 7238: Permanent Redirect\n    * RFC 2295: Transparent Content Negotiation in HTTP\n    * RFC 2774: An HTTP Extension Framework\n    * RFC 7725: An HTTP Status Code to Report Legal Obstacles\n    * RFC 7540: Hypertext Transfer Protocol Version 2 (HTTP/2)\n    * RFC 2324: Hyper Text Coffee Pot Control Protocol (HTCPCP/1.0)\n    * RFC 8297: An HTTP Status Code for Indicating Hints\n    * RFC 8470: Using Early Data in HTTP",
      "relationships": [
        {
          "target": "stdlib.enum.IntEnum",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.int",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.ReprEnum",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Enum",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.imaplib.IMAP4",
      "name": "IMAP4",
      "module": "imaplib",
      "type": "class",
      "signature": "(host='', port=143, timeout=None)",
      "description": "IMAP4 client class.\n\nInstantiate with: IMAP4([host[, port[, timeout=None]]])\n\n        host - host's name (default: localhost);\n        port - port number (default: standard IMAP4 port).\n        timeout - socket timeout (default: None)\n                  If timeout is not given or is None,\n                  the global default socket timeout is used\n\nAll IMAP4rev1 commands are supported by methods of the same\nname (in lowercase).\n\nAll arguments to commands are converted to strings, except for\nAUTHENTICATE, and the last argument to APPEND which is passed as\nan IMAP4 literal.  If necessary (the string contains any\nnon-printing characters or white-space and isn't enclosed with\neither parentheses or double quotes) each string is quoted.\nHowever, the 'password' argument to the LOGIN command is always\nquoted.  If you want to avoid having an argument string quoted\n(eg: the 'flags' argument to STORE) then enclose the string in\nparentheses (eg: \"(\\Deleted)\").\n\nEach command returns a tuple: (type, [data, ...]) where 'type'\nis usually 'OK' or 'NO', and 'data' is either the text from the\ntagged response, or untagged results from command. Each 'data'\nis either a string, or a tuple. If a tuple, then the first part\nis the header of the response, and the second part contains\nthe data (ie: 'literal' value).\n\nErrors raise the exception class <instance>.error(\"<reason>\").\nIMAP4 server errors raise <instance>.abort(\"<reason>\"),\nwhich is a sub-class of 'error'. Mailbox status changes\nfrom READ-WRITE to READ-ONLY raise the exception class\n<instance>.readonly(\"<reason>\"), which is a sub-class of 'abort'.\n\n\"error\" exceptions imply a program error.\n\"abort\" exceptions imply the connection should be reset, and\n        the command re-tried.\n\"readonly\" exceptions imply the command should be re-tried.\n\nNote: to use this module, you must read the RFCs pertaining to the\nIMAP4 protocol, as the semantics of the arguments to each IMAP4\ncommand are left to the invoker, not to mention the results. Also,\nmost IMAP servers implement a sub-set of the commands available here.",
      "relationships": []
    },
    {
      "id": "stdlib.imaplib.IMAP4_SSL",
      "name": "IMAP4_SSL",
      "module": "imaplib",
      "type": "class",
      "signature": "(host='', port=993, *, ssl_context=None, timeout=None)",
      "description": "IMAP4 client class over SSL connection\n\nInstantiate with: IMAP4_SSL([host[, port[, ssl_context[, timeout=None]]]])\n\n        host - host's name (default: localhost);\n        port - port number (default: standard IMAP4 SSL port);\n        ssl_context - a SSLContext object that contains your certificate chain\n                      and private key (default: None)\n        timeout - socket timeout (default: None) If timeout is not given or is None,\n                  the global default socket timeout is used\n\nfor more documentation see the docstring of the parent class IMAP4.",
      "relationships": [
        {
          "target": "stdlib.imaplib.IMAP4",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.imaplib.IMAP4_stream",
      "name": "IMAP4_stream",
      "module": "imaplib",
      "type": "class",
      "signature": "(command)",
      "description": "IMAP4 client class over a stream\n\nInstantiate with: IMAP4_stream(command)\n\n        \"command\" - a string that can be passed to subprocess.Popen()\n\nfor more documentation see the docstring of the parent class IMAP4.",
      "relationships": [
        {
          "target": "stdlib.imaplib.IMAP4",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.imaplib.Int2AP",
      "name": "Int2AP",
      "module": "imaplib",
      "type": "function",
      "signature": "(num)",
      "description": "Convert integer to A-P string representation.",
      "relationships": []
    },
    {
      "id": "stdlib.imaplib.Internaldate2tuple",
      "name": "Internaldate2tuple",
      "module": "imaplib",
      "type": "function",
      "signature": "(resp)",
      "description": "Parse an IMAP4 INTERNALDATE string.\n\nReturn corresponding local time.  The return value is a\ntime.struct_time tuple or None if the string has wrong format.",
      "relationships": []
    },
    {
      "id": "stdlib.imaplib.ParseFlags",
      "name": "ParseFlags",
      "module": "imaplib",
      "type": "function",
      "signature": "(resp)",
      "description": "Convert IMAP4 flags response to python tuple.",
      "relationships": []
    },
    {
      "id": "stdlib.imaplib.Time2Internaldate",
      "name": "Time2Internaldate",
      "module": "imaplib",
      "type": "function",
      "signature": "(date_time)",
      "description": "Convert date_time to IMAP4 INTERNALDATE representation.\n\nReturn string in form: '\"DD-Mmm-YYYY HH:MM:SS +HHMM\"'.  The\ndate_time argument can be a number (int or float) representing\nseconds since epoch (as returned by time.time()), a 9-tuple\nrepresenting local time, an instance of time.struct_time (as\nreturned by time.localtime()), an aware datetime instance or a\ndouble-quoted string.  In the last case, it is assumed to already\nbe in the correct format.",
      "relationships": []
    },
    {
      "id": "stdlib.imghdr.test",
      "name": "test",
      "module": "imghdr",
      "type": "function",
      "signature": "()",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.imghdr.testall",
          "type": "calls"
        },
        {
          "target": "stdlib.imghdr.testall",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.imghdr.test_bmp",
      "name": "test_bmp",
      "module": "imghdr",
      "type": "function",
      "signature": "(h, f)",
      "description": "Verify if the image is a BMP file.",
      "relationships": []
    },
    {
      "id": "stdlib.imghdr.test_exr",
      "name": "test_exr",
      "module": "imghdr",
      "type": "function",
      "signature": "(h, f)",
      "description": "verify is the image ia a OpenEXR fileOpenEXR.",
      "relationships": []
    },
    {
      "id": "stdlib.imghdr.test_gif",
      "name": "test_gif",
      "module": "imghdr",
      "type": "function",
      "signature": "(h, f)",
      "description": "Verify if the image is a GIF ('87 or '89 variants).",
      "relationships": []
    },
    {
      "id": "stdlib.imghdr.test_jpeg",
      "name": "test_jpeg",
      "module": "imghdr",
      "type": "function",
      "signature": "(h, f)",
      "description": "Test for JPEG data with JFIF or Exif markers; and raw JPEG.",
      "relationships": []
    },
    {
      "id": "stdlib.imghdr.test_pbm",
      "name": "test_pbm",
      "module": "imghdr",
      "type": "function",
      "signature": "(h, f)",
      "description": "Verify if the image is a PBM (portable bitmap).",
      "relationships": []
    },
    {
      "id": "stdlib.imghdr.test_pgm",
      "name": "test_pgm",
      "module": "imghdr",
      "type": "function",
      "signature": "(h, f)",
      "description": "Verify if the image is a PGM (portable graymap).",
      "relationships": []
    },
    {
      "id": "stdlib.imghdr.test_png",
      "name": "test_png",
      "module": "imghdr",
      "type": "function",
      "signature": "(h, f)",
      "description": "Verify if the image is a PNG.",
      "relationships": []
    },
    {
      "id": "stdlib.imghdr.test_ppm",
      "name": "test_ppm",
      "module": "imghdr",
      "type": "function",
      "signature": "(h, f)",
      "description": "Verify if the image is a PPM (portable pixmap).",
      "relationships": []
    },
    {
      "id": "stdlib.imghdr.test_rast",
      "name": "test_rast",
      "module": "imghdr",
      "type": "function",
      "signature": "(h, f)",
      "description": "test for the Sun raster file.",
      "relationships": []
    },
    {
      "id": "stdlib.imghdr.test_rgb",
      "name": "test_rgb",
      "module": "imghdr",
      "type": "function",
      "signature": "(h, f)",
      "description": "test for the SGI image library.",
      "relationships": []
    },
    {
      "id": "stdlib.imghdr.test_tiff",
      "name": "test_tiff",
      "module": "imghdr",
      "type": "function",
      "signature": "(h, f)",
      "description": "Verify if the image is a TIFF (can be in Motorola or Intel byte order).",
      "relationships": []
    },
    {
      "id": "stdlib.imghdr.test_webp",
      "name": "test_webp",
      "module": "imghdr",
      "type": "function",
      "signature": "(h, f)",
      "description": "Verify if the image is a WebP.",
      "relationships": []
    },
    {
      "id": "stdlib.imghdr.test_xbm",
      "name": "test_xbm",
      "module": "imghdr",
      "type": "function",
      "signature": "(h, f)",
      "description": "Verify if the image is a X bitmap (X10 or X11).",
      "relationships": []
    },
    {
      "id": "stdlib.imghdr.testall",
      "name": "testall",
      "module": "imghdr",
      "type": "function",
      "signature": "(list, recursive, toplevel)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.imghdr.testall",
          "type": "calls"
        },
        {
          "target": "stdlib.imghdr.what",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.imghdr.what",
      "name": "what",
      "module": "imghdr",
      "type": "function",
      "signature": "(file, h=None)",
      "description": "Return the type of image contained in a file or byte stream.",
      "relationships": []
    },
    {
      "id": "stdlib.importlib.import_module",
      "name": "import_module",
      "module": "importlib",
      "type": "function",
      "signature": "(name, package=None)",
      "description": "Import a module.\n\nThe 'package' argument is required when performing a relative import. It\nspecifies the package to use as the anchor point from which to resolve the\nrelative import to an absolute import.",
      "relationships": []
    },
    {
      "id": "stdlib.importlib.invalidate_caches",
      "name": "invalidate_caches",
      "module": "importlib",
      "type": "function",
      "signature": "()",
      "description": "Call the invalidate_caches() method on all meta path finders stored in\nsys.meta_path (where implemented).",
      "relationships": []
    },
    {
      "id": "stdlib.importlib.reload",
      "name": "reload",
      "module": "importlib",
      "type": "function",
      "signature": "(module)",
      "description": "Reload the module and return it.\n\nThe module must have been successfully imported before.",
      "relationships": []
    },
    {
      "id": "stdlib.inspect.ArgInfo",
      "name": "ArgInfo",
      "module": "inspect",
      "type": "class",
      "signature": "(args, varargs, keywords, locals)",
      "description": "ArgInfo(args, varargs, keywords, locals)",
      "relationships": [
        {
          "target": "stdlib.builtins.tuple",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.inspect.Arguments",
      "name": "Arguments",
      "module": "inspect",
      "type": "class",
      "signature": "(args, varargs, varkw)",
      "description": "Arguments(args, varargs, varkw)",
      "relationships": [
        {
          "target": "stdlib.builtins.tuple",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.inspect.Attribute",
      "name": "Attribute",
      "module": "inspect",
      "type": "class",
      "signature": "(name, kind, defining_class, object)",
      "description": "Attribute(name, kind, defining_class, object)",
      "relationships": [
        {
          "target": "stdlib.builtins.tuple",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.inspect.BlockFinder",
      "name": "BlockFinder",
      "module": "inspect",
      "type": "class",
      "signature": "()",
      "description": "Provide a tokeneater() method to detect the end of a code block.",
      "relationships": []
    },
    {
      "id": "stdlib.inspect.BoundArguments",
      "name": "BoundArguments",
      "module": "inspect",
      "type": "class",
      "signature": "(signature, arguments)",
      "description": "Result of `Signature.bind` call.  Holds the mapping of arguments\nto the function's parameters.\n\nHas the following public attributes:\n\n* arguments : dict\n    An ordered mutable mapping of parameters' names to arguments' values.\n    Does not contain arguments' default values.\n* signature : Signature\n    The Signature object that created this instance.\n* args : tuple\n    Tuple of positional arguments values.\n* kwargs : dict\n    Dict of keyword arguments values.",
      "relationships": []
    },
    {
      "id": "stdlib.inspect.BufferFlags",
      "name": "BufferFlags",
      "module": "inspect",
      "type": "class",
      "signature": "(*values)",
      "description": "Support for integer-based Flags",
      "relationships": [
        {
          "target": "stdlib.enum.IntFlag",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.int",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.ReprEnum",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Flag",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Enum",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.inspect.ClosureVars",
      "name": "ClosureVars",
      "module": "inspect",
      "type": "class",
      "signature": "(nonlocals, globals, builtins, unbound)",
      "description": "ClosureVars(nonlocals, globals, builtins, unbound)",
      "relationships": [
        {
          "target": "stdlib.builtins.tuple",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.inspect.FrameInfo",
      "name": "FrameInfo",
      "module": "inspect",
      "type": "class",
      "signature": "(frame, filename, lineno, function, code_context, index, *, positions=None)",
      "description": "_FrameInfo(frame, filename, lineno, function, code_context, index)",
      "relationships": [
        {
          "target": "stdlib.inspect._FrameInfo",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.tuple",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.inspect.FullArgSpec",
      "name": "FullArgSpec",
      "module": "inspect",
      "type": "class",
      "signature": "(args, varargs, varkw, defaults, kwonlyargs, kwonlydefaults, annotations)",
      "description": "FullArgSpec(args, varargs, varkw, defaults, kwonlyargs, kwonlydefaults, annotations)",
      "relationships": [
        {
          "target": "stdlib.builtins.tuple",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.inspect.Parameter",
      "name": "Parameter",
      "module": "inspect",
      "type": "class",
      "signature": "(name, kind, *, default, annotation)",
      "description": "Represents a parameter in a function signature.\n\nHas the following public attributes:\n\n* name : str\n    The name of the parameter as a string.\n* default : object\n    The default value for the parameter if specified.  If the\n    parameter has no default value, this attribute is set to\n    `Parameter.empty`.\n* annotation\n    The annotation for the parameter if specified.  If the\n    parameter has no annotation, this attribute is set to\n    `Parameter.empty`.\n* kind : str\n    Describes how argument values are bound to the parameter.\n    Possible values: `Parameter.POSITIONAL_ONLY`,\n    `Parameter.POSITIONAL_OR_KEYWORD`, `Parameter.VAR_POSITIONAL`,\n    `Parameter.KEYWORD_ONLY`, `Parameter.VAR_KEYWORD`.",
      "relationships": []
    },
    {
      "id": "stdlib.inspect.Signature",
      "name": "Signature",
      "module": "inspect",
      "type": "class",
      "signature": "(parameters=None, *, return_annotation, __validate_parameters__=True)",
      "description": "A Signature object represents the overall signature of a function.\nIt stores a Parameter object for each parameter accepted by the\nfunction, as well as information specific to the function itself.\n\nA Signature object has the following public attributes and methods:\n\n* parameters : OrderedDict\n    An ordered mapping of parameters' names to the corresponding\n    Parameter objects (keyword-only arguments are in the same order\n    as listed in `code.co_varnames`).\n* return_annotation : object\n    The annotation for the return type of the function if specified.\n    If the function has no annotation for its return type, this\n    attribute is set to `Signature.empty`.\n* bind(*args, **kwargs) -> BoundArguments\n    Creates a mapping from positional and keyword arguments to\n    parameters.\n* bind_partial(*args, **kwargs) -> BoundArguments\n    Creates a partial mapping from positional and keyword arguments\n    to parameters (simulating 'functools.partial' behavior.)",
      "relationships": []
    },
    {
      "id": "stdlib.inspect.Traceback",
      "name": "Traceback",
      "module": "inspect",
      "type": "class",
      "signature": "(filename, lineno, function, code_context, index, *, positions=None)",
      "description": "_Traceback(filename, lineno, function, code_context, index)",
      "relationships": [
        {
          "target": "stdlib.inspect._Traceback",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.tuple",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.inspect.classify_class_attrs",
      "name": "classify_class_attrs",
      "module": "inspect",
      "type": "function",
      "signature": "(cls)",
      "description": "Return list of attribute-descriptor tuples.\n\nFor each name in dir(cls), the return list contains a 4-tuple\nwith these elements:\n\n    0. The name (a string).\n\n    1. The kind of attribute this is, one of these strings:\n           'class method'    created via classmethod()\n           'static method'   created via staticmethod()\n           'property'        created via property()\n           'method'          any other flavor of method or descriptor\n           'data'            not a method\n\n    2. The class which defined this attribute (a class).\n\n    3. The object as obtained by calling getattr; if this fails, or if the\n       resulting object does not live anywhere in the class' mro (including\n       metaclasses) then the object is looked up in the defining class's\n       dict (found by walking the mro).\n\nIf one of the items in dir(cls) is stored in the metaclass it will now\nbe discovered and not have None be listed as the class in which it was\ndefined.  Any items whose home class cannot be discovered are skipped.",
      "relationships": [
        {
          "target": "stdlib.inspect.getmro",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.getmro",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.isroutine",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.cleandoc",
      "name": "cleandoc",
      "module": "inspect",
      "type": "function",
      "signature": "(doc)",
      "description": "Clean up indentation from docstrings.\n\nAny whitespace that can be uniformly removed from the second line\nonwards is removed.",
      "relationships": []
    },
    {
      "id": "stdlib.inspect.currentframe",
      "name": "currentframe",
      "module": "inspect",
      "type": "function",
      "signature": "()",
      "description": "Return the frame of the caller or None if this is not possible.",
      "relationships": []
    },
    {
      "id": "stdlib.inspect.findsource",
      "name": "findsource",
      "module": "inspect",
      "type": "function",
      "signature": "(object)",
      "description": "Return the entire source file and starting line number for an object.\n\nThe argument may be a module, class, method, function, traceback, frame,\nor code object.  The source code is returned as a list of all the lines\nin the file and the line number indexes a line in that list.  An OSError\nis raised if the source code cannot be retrieved.",
      "relationships": [
        {
          "target": "stdlib.inspect.getsourcefile",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.getmodule",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.ismodule",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.isclass",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.ismethod",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.isfunction",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.istraceback",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.isframe",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.iscode",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.getfile",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.formatannotation",
      "name": "formatannotation",
      "module": "inspect",
      "type": "function",
      "signature": "(annotation, base_module=None)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.inspect.formatannotationrelativeto",
      "name": "formatannotationrelativeto",
      "module": "inspect",
      "type": "function",
      "signature": "(object)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.inspect.formatannotation",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.formatargvalues",
      "name": "formatargvalues",
      "module": "inspect",
      "type": "function",
      "signature": "(args, varargs, varkw, locals, formatarg=<class 'str'>, formatvarargs=<function <lambda> at 0x1053c6de0>, formatvarkw=<function <lambda> at 0x1053c6e80>, formatvalue=<function <lambda> at 0x1053c6f20>)",
      "description": "Format an argument spec from the 4 values returned by getargvalues.\n\nThe first four arguments are (args, varargs, varkw, locals).  The\nnext four arguments are the corresponding optional formatting functions\nthat are called to turn names and values into strings.  The ninth\nargument is an optional function to format the sequence of arguments.",
      "relationships": []
    },
    {
      "id": "stdlib.inspect.get_annotations",
      "name": "get_annotations",
      "module": "inspect",
      "type": "function",
      "signature": "(obj, *, globals=None, locals=None, eval_str=False)",
      "description": "Compute the annotations dict for an object.\n\nobj may be a callable, class, or module.\nPassing in an object of any other type raises TypeError.\n\nReturns a dict.  get_annotations() returns a new dict every time\nit's called; calling it twice on the same object will return two\ndifferent but equivalent dicts.\n\nThis function handles several details for you:\n\n  * If eval_str is true, values of type str will\n    be un-stringized using eval().  This is intended\n    for use with stringized annotations\n    (\"from __future__ import annotations\").\n  * If obj doesn't have an annotations dict, returns an\n    empty dict.  (Functions and methods always have an\n    annotations dict; classes, modules, and other types of\n    callables may not.)\n  * Ignores inherited annotations on classes.  If a class\n    doesn't have its own annotations dict, returns an empty dict.\n  * All accesses to object members and dict values are done\n    using getattr() and dict.get() for safety.\n  * Always, always, always returns a freshly-created dict.\n\neval_str controls whether or not values of type str are replaced\nwith the result of calling eval() on those values:\n\n  * If eval_str is true, eval() is called on values of type str.\n  * If eval_str is false (the default), values of type str are unchanged.\n\nglobals and locals are passed in to eval(); see the documentation\nfor eval() for more information.  If either globals or locals is\nNone, this function may replace that value with a context-specific\ndefault, contingent on type(obj):\n\n  * If obj is a module, globals defaults to obj.__dict__.\n  * If obj is a class, globals defaults to\n    sys.modules[obj.__module__].__dict__ and locals\n    defaults to the obj class namespace.\n  * If obj is a callable, globals defaults to obj.__globals__,\n    although if obj is a wrapped function (using\n    functools.update_wrapper()) it is first unwrapped.",
      "relationships": []
    },
    {
      "id": "stdlib.inspect.getabsfile",
      "name": "getabsfile",
      "module": "inspect",
      "type": "function",
      "signature": "(object, _filename=None)",
      "description": "Return an absolute path to the source or compiled file for an object.\n\nThe idea is for each object to have a unique origin, so this routine\nnormalizes the result as much as possible.",
      "relationships": [
        {
          "target": "stdlib.inspect.getsourcefile",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.getfile",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.getargs",
      "name": "getargs",
      "module": "inspect",
      "type": "function",
      "signature": "(co)",
      "description": "Get information about the arguments accepted by a code object.\n\nThree things are returned: (args, varargs, varkw), where\n'args' is the list of argument names. Keyword-only arguments are\nappended. 'varargs' and 'varkw' are the names of the * and **\narguments or None.",
      "relationships": [
        {
          "target": "stdlib.inspect.iscode",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.getargvalues",
      "name": "getargvalues",
      "module": "inspect",
      "type": "function",
      "signature": "(frame)",
      "description": "Get information about arguments passed into a particular frame.\n\nA tuple of four things is returned: (args, varargs, varkw, locals).\n'args' is a list of the argument names.\n'varargs' and 'varkw' are the names of the * and ** arguments or None.\n'locals' is the locals dictionary of the given frame.",
      "relationships": [
        {
          "target": "stdlib.inspect.getargs",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.getasyncgenlocals",
      "name": "getasyncgenlocals",
      "module": "inspect",
      "type": "function",
      "signature": "(agen)",
      "description": "Get the mapping of asynchronous generator local variables to their current\nvalues.\n\nA dict is returned, with the keys the local variable names and values the\nbound values.",
      "relationships": [
        {
          "target": "stdlib.inspect.isasyncgen",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.getasyncgenstate",
      "name": "getasyncgenstate",
      "module": "inspect",
      "type": "function",
      "signature": "(agen)",
      "description": "Get current state of an asynchronous generator object.\n\nPossible states are:\n  AGEN_CREATED: Waiting to start execution.\n  AGEN_RUNNING: Currently being executed by the interpreter.\n  AGEN_SUSPENDED: Currently suspended at a yield expression.\n  AGEN_CLOSED: Execution has completed.",
      "relationships": []
    },
    {
      "id": "stdlib.inspect.getattr_static",
      "name": "getattr_static",
      "module": "inspect",
      "type": "function",
      "signature": "(obj, attr, default=<object object at 0x100108730>)",
      "description": "Retrieve attributes without triggering dynamic lookup via the\ndescriptor protocol,  __getattr__ or __getattribute__.\n\nNote: this function may not be able to retrieve all attributes\nthat getattr can fetch (like dynamically created attributes)\nand may find attributes that getattr can't (like descriptors\nthat raise AttributeError). It can also return descriptor objects\ninstead of instance members in some cases. See the\ndocumentation for details.",
      "relationships": [
        {
          "target": "stdlib.inspect._check_class",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect._shadowed_dict",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect._check_instance",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect._check_class",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect._check_class",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect._check_class",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect._shadowed_dict",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.getblock",
      "name": "getblock",
      "module": "inspect",
      "type": "function",
      "signature": "(lines)",
      "description": "Extract the block of code at the top of the given list of lines.",
      "relationships": []
    },
    {
      "id": "stdlib.inspect.getcallargs",
      "name": "getcallargs",
      "module": "inspect",
      "type": "function",
      "signature": "(func, /, *positional, **named)",
      "description": "Get the mapping of arguments to values.\n\nA dict is returned, with keys the function argument names (including the\nnames of the * and ** arguments, if any), and values the respective bound\nvalues from 'positional' and 'named'.",
      "relationships": [
        {
          "target": "stdlib.inspect.getfullargspec",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.ismethod",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect._too_many",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect._missing_arguments",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect._missing_arguments",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.getclasstree",
      "name": "getclasstree",
      "module": "inspect",
      "type": "function",
      "signature": "(classes, unique=False)",
      "description": "Arrange the given list of classes into a hierarchy of nested lists.\n\nWhere a nested list appears, it contains classes derived from the class\nwhose entry immediately precedes the list.  Each entry is a 2-tuple\ncontaining a class and a tuple of its base classes.  If the 'unique'\nargument is true, exactly one entry appears in the returned structure\nfor each class in the given list.  Otherwise, classes using multiple\ninheritance and their descendants will appear multiple times.",
      "relationships": [
        {
          "target": "stdlib.inspect.walktree",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.getclosurevars",
      "name": "getclosurevars",
      "module": "inspect",
      "type": "function",
      "signature": "(func)",
      "description": "Get the mapping of free variables to their current values.\n\nReturns a named tuple of dicts mapping the current nonlocal, global\nand builtin references as seen by the body of the function. A final\nset of unbound names that could not be resolved is also provided.",
      "relationships": [
        {
          "target": "stdlib.inspect.ismethod",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.ismodule",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.isfunction",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.getcomments",
      "name": "getcomments",
      "module": "inspect",
      "type": "function",
      "signature": "(object)",
      "description": "Get lines of comments immediately preceding an object's source code.\n\nReturns None when source can't be found.",
      "relationships": [
        {
          "target": "stdlib.inspect.ismodule",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.findsource",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.indentsize",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.indentsize",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.indentsize",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.getcoroutinelocals",
      "name": "getcoroutinelocals",
      "module": "inspect",
      "type": "function",
      "signature": "(coroutine)",
      "description": "Get the mapping of coroutine local variables to their current values.\n\nA dict is returned, with the keys the local variable names and values the\nbound values.",
      "relationships": []
    },
    {
      "id": "stdlib.inspect.getcoroutinestate",
      "name": "getcoroutinestate",
      "module": "inspect",
      "type": "function",
      "signature": "(coroutine)",
      "description": "Get current state of a coroutine object.\n\nPossible states are:\n  CORO_CREATED: Waiting to start execution.\n  CORO_RUNNING: Currently being executed by the interpreter.\n  CORO_SUSPENDED: Currently suspended at an await expression.\n  CORO_CLOSED: Execution has completed.",
      "relationships": []
    },
    {
      "id": "stdlib.inspect.getdoc",
      "name": "getdoc",
      "module": "inspect",
      "type": "function",
      "signature": "(object)",
      "description": "Get the documentation string for an object.\n\nAll tabs are expanded to spaces.  To clean up docstrings that are\nindented to line up with blocks of code, any whitespace than can be\nuniformly removed from the second line onwards is removed.",
      "relationships": [
        {
          "target": "stdlib.inspect.cleandoc",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect._finddoc",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.getfile",
      "name": "getfile",
      "module": "inspect",
      "type": "function",
      "signature": "(object)",
      "description": "Work out which source or compiled file an object was defined in.",
      "relationships": [
        {
          "target": "stdlib.inspect.ismodule",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.isclass",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.ismethod",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.isfunction",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.istraceback",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.isframe",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.iscode",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.getframeinfo",
      "name": "getframeinfo",
      "module": "inspect",
      "type": "function",
      "signature": "(frame, context=1)",
      "description": "Get information about a frame or traceback object.\n\nA tuple of five things is returned: the filename, the line number of\nthe current line, the function name, a list of lines of context from\nthe source code, and the index of the current line within that list.\nThe optional second argument specifies the number of lines of context\nto return, which are centered around the current line.",
      "relationships": [
        {
          "target": "stdlib.inspect.istraceback",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect._get_code_position_from_tb",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect._get_code_position",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.isframe",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.getsourcefile",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.getfile",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.findsource",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.getfullargspec",
      "name": "getfullargspec",
      "module": "inspect",
      "type": "function",
      "signature": "(func)",
      "description": "Get the names and default values of a callable object's parameters.\n\nA tuple of seven things is returned:\n(args, varargs, varkw, defaults, kwonlyargs, kwonlydefaults, annotations).\n'args' is a list of the parameter names.\n'varargs' and 'varkw' are the names of the * and ** parameters or None.\n'defaults' is an n-tuple of the default values of the last n parameters.\n'kwonlyargs' is a list of keyword-only parameter names.\n'kwonlydefaults' is a dictionary mapping names from kwonlyargs to defaults.\n'annotations' is a dictionary mapping parameter names to annotations.\n\nNotable differences from inspect.signature():\n  - the \"self\" parameter is always reported, even for bound methods\n  - wrapper chains defined by __wrapped__ *not* unwrapped automatically",
      "relationships": [
        {
          "target": "stdlib.inspect._signature_from_callable",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.getgeneratorlocals",
      "name": "getgeneratorlocals",
      "module": "inspect",
      "type": "function",
      "signature": "(generator)",
      "description": "Get the mapping of generator local variables to their current values.\n\nA dict is returned, with the keys the local variable names and values the\nbound values.",
      "relationships": [
        {
          "target": "stdlib.inspect.isgenerator",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.getgeneratorstate",
      "name": "getgeneratorstate",
      "module": "inspect",
      "type": "function",
      "signature": "(generator)",
      "description": "Get current state of a generator-iterator.\n\nPossible states are:\n  GEN_CREATED: Waiting to start execution.\n  GEN_RUNNING: Currently being executed by the interpreter.\n  GEN_SUSPENDED: Currently suspended at a yield expression.\n  GEN_CLOSED: Execution has completed.",
      "relationships": []
    },
    {
      "id": "stdlib.inspect.getinnerframes",
      "name": "getinnerframes",
      "module": "inspect",
      "type": "function",
      "signature": "(tb, context=1)",
      "description": "Get a list of records for a traceback's frame and all lower frames.\n\nEach record contains a frame object, filename, line number, function\nname, a list of lines of context, and index within the context.",
      "relationships": [
        {
          "target": "stdlib.inspect.getframeinfo",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.getlineno",
      "name": "getlineno",
      "module": "inspect",
      "type": "function",
      "signature": "(frame)",
      "description": "Get the line number from a frame object, allowing for optimization.",
      "relationships": []
    },
    {
      "id": "stdlib.inspect.getmembers",
      "name": "getmembers",
      "module": "inspect",
      "type": "function",
      "signature": "(object, predicate=None)",
      "description": "Return all members of an object as (name, value) pairs sorted by name.\nOptionally, only return members that satisfy a given predicate.",
      "relationships": [
        {
          "target": "stdlib.inspect._getmembers",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.getmembers_static",
      "name": "getmembers_static",
      "module": "inspect",
      "type": "function",
      "signature": "(object, predicate=None)",
      "description": "Return all members of an object as (name, value) pairs sorted by name\nwithout triggering dynamic lookup via the descriptor protocol,\n__getattr__ or __getattribute__. Optionally, only return members that\nsatisfy a given predicate.\n\nNote: this function may not be able to retrieve all members\n   that getmembers can fetch (like dynamically created attributes)\n   and may find members that getmembers can't (like descriptors\n   that raise AttributeError). It can also return descriptor objects\n   instead of instance members in some cases.",
      "relationships": [
        {
          "target": "stdlib.inspect._getmembers",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.getmodule",
      "name": "getmodule",
      "module": "inspect",
      "type": "function",
      "signature": "(object, _filename=None)",
      "description": "Return the module an object was defined in, or None if not found.",
      "relationships": [
        {
          "target": "stdlib.inspect.ismodule",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.getabsfile",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.ismodule",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.getabsfile",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.getmodulename",
      "name": "getmodulename",
      "module": "inspect",
      "type": "function",
      "signature": "(path)",
      "description": "Return the module name for a given file, or None.",
      "relationships": []
    },
    {
      "id": "stdlib.inspect.getmro",
      "name": "getmro",
      "module": "inspect",
      "type": "function",
      "signature": "(cls)",
      "description": "Return tuple of base classes (including cls) in method resolution order.",
      "relationships": []
    },
    {
      "id": "stdlib.inspect.getouterframes",
      "name": "getouterframes",
      "module": "inspect",
      "type": "function",
      "signature": "(frame, context=1)",
      "description": "Get a list of records for a frame and all higher (calling) frames.\n\nEach record contains a frame object, filename, line number, function\nname, a list of lines of context, and index within the context.",
      "relationships": [
        {
          "target": "stdlib.inspect.getframeinfo",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.getsource",
      "name": "getsource",
      "module": "inspect",
      "type": "function",
      "signature": "(object)",
      "description": "Return the text of the source code for an object.\n\nThe argument may be a module, class, method, function, traceback, frame,\nor code object.  The source code is returned as a single string.  An\nOSError is raised if the source code cannot be retrieved.",
      "relationships": [
        {
          "target": "stdlib.inspect.getsourcelines",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.getsourcefile",
      "name": "getsourcefile",
      "module": "inspect",
      "type": "function",
      "signature": "(object)",
      "description": "Return the filename that can be used to locate an object's source.\nReturn None if no way can be identified to get the source.",
      "relationships": [
        {
          "target": "stdlib.inspect.getfile",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.getmodule",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.getsourcelines",
      "name": "getsourcelines",
      "module": "inspect",
      "type": "function",
      "signature": "(object)",
      "description": "Return a list of source lines and starting line number for an object.\n\nThe argument may be a module, class, method, function, traceback, frame,\nor code object.  The source code is returned as a list of the lines\ncorresponding to the object and the line number indicates where in the\noriginal source file the first line of code was found.  An OSError is\nraised if the source code cannot be retrieved.",
      "relationships": [
        {
          "target": "stdlib.inspect.unwrap",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.findsource",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.istraceback",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.ismodule",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.isframe",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.getblock",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.indentsize",
      "name": "indentsize",
      "module": "inspect",
      "type": "function",
      "signature": "(line)",
      "description": "Return the indent size, in spaces, at the start of a line of text.",
      "relationships": []
    },
    {
      "id": "stdlib.inspect.isabstract",
      "name": "isabstract",
      "module": "inspect",
      "type": "function",
      "signature": "(object)",
      "description": "Return true if the object is an abstract base class (ABC).",
      "relationships": []
    },
    {
      "id": "stdlib.inspect.isasyncgen",
      "name": "isasyncgen",
      "module": "inspect",
      "type": "function",
      "signature": "(object)",
      "description": "Return true if the object is an asynchronous generator.",
      "relationships": []
    },
    {
      "id": "stdlib.inspect.isasyncgenfunction",
      "name": "isasyncgenfunction",
      "module": "inspect",
      "type": "function",
      "signature": "(obj)",
      "description": "Return true if the object is an asynchronous generator function.\n\nAsynchronous generator functions are defined with \"async def\"\nsyntax and have \"yield\" expressions in their body.",
      "relationships": [
        {
          "target": "stdlib.inspect._has_code_flag",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.isawaitable",
      "name": "isawaitable",
      "module": "inspect",
      "type": "function",
      "signature": "(object)",
      "description": "Return true if object can be passed to an ``await`` expression.",
      "relationships": []
    },
    {
      "id": "stdlib.inspect.isbuiltin",
      "name": "isbuiltin",
      "module": "inspect",
      "type": "function",
      "signature": "(object)",
      "description": "Return true if the object is a built-in function or method.\n\nBuilt-in functions and methods provide these attributes:\n    __doc__         documentation string\n    __name__        original name of this function or method\n    __self__        instance to which a method is bound, or None",
      "relationships": []
    },
    {
      "id": "stdlib.inspect.isclass",
      "name": "isclass",
      "module": "inspect",
      "type": "function",
      "signature": "(object)",
      "description": "Return true if the object is a class.",
      "relationships": []
    },
    {
      "id": "stdlib.inspect.iscode",
      "name": "iscode",
      "module": "inspect",
      "type": "function",
      "signature": "(object)",
      "description": "Return true if the object is a code object.\n\nCode objects provide these attributes:\n    co_argcount         number of arguments (not including *, ** args\n                        or keyword only arguments)\n    co_code             string of raw compiled bytecode\n    co_cellvars         tuple of names of cell variables\n    co_consts           tuple of constants used in the bytecode\n    co_filename         name of file in which this code object was created\n    co_firstlineno      number of first line in Python source code\n    co_flags            bitmap: 1=optimized | 2=newlocals | 4=*arg | 8=**arg\n                        | 16=nested | 32=generator | 64=nofree | 128=coroutine\n                        | 256=iterable_coroutine | 512=async_generator\n    co_freevars         tuple of names of free variables\n    co_posonlyargcount  number of positional only arguments\n    co_kwonlyargcount   number of keyword only arguments (not including ** arg)\n    co_lnotab           encoded mapping of line numbers to bytecode indices\n    co_name             name with which this code object was defined\n    co_names            tuple of names other than arguments and function locals\n    co_nlocals          number of local variables\n    co_stacksize        virtual machine stack space required\n    co_varnames         tuple of names of arguments and local variables",
      "relationships": []
    },
    {
      "id": "stdlib.inspect.iscoroutine",
      "name": "iscoroutine",
      "module": "inspect",
      "type": "function",
      "signature": "(object)",
      "description": "Return true if the object is a coroutine.",
      "relationships": []
    },
    {
      "id": "stdlib.inspect.iscoroutinefunction",
      "name": "iscoroutinefunction",
      "module": "inspect",
      "type": "function",
      "signature": "(obj)",
      "description": "Return true if the object is a coroutine function.\n\nCoroutine functions are normally defined with \"async def\" syntax, but may\nbe marked via markcoroutinefunction.",
      "relationships": [
        {
          "target": "stdlib.inspect._has_code_flag",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect._has_coroutine_mark",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.isdatadescriptor",
      "name": "isdatadescriptor",
      "module": "inspect",
      "type": "function",
      "signature": "(object)",
      "description": "Return true if the object is a data descriptor.\n\nData descriptors have a __set__ or a __delete__ attribute.  Examples are\nproperties (defined in Python) and getsets and members (defined in C).\nTypically, data descriptors will also have __name__ and __doc__ attributes\n(properties, getsets, and members have both of these attributes), but this\nis not guaranteed.",
      "relationships": [
        {
          "target": "stdlib.inspect.isclass",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.ismethod",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.isfunction",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.isframe",
      "name": "isframe",
      "module": "inspect",
      "type": "function",
      "signature": "(object)",
      "description": "Return true if the object is a frame object.\n\nFrame objects provide these attributes:\n    f_back          next outer frame object (this frame's caller)\n    f_builtins      built-in namespace seen by this frame\n    f_code          code object being executed in this frame\n    f_globals       global namespace seen by this frame\n    f_lasti         index of last attempted instruction in bytecode\n    f_lineno        current line number in Python source code\n    f_locals        local namespace seen by this frame\n    f_trace         tracing function for this frame, or None",
      "relationships": []
    },
    {
      "id": "stdlib.inspect.isfunction",
      "name": "isfunction",
      "module": "inspect",
      "type": "function",
      "signature": "(object)",
      "description": "Return true if the object is a user-defined function.\n\nFunction objects provide these attributes:\n    __doc__         documentation string\n    __name__        name with which this function was defined\n    __code__        code object containing compiled function bytecode\n    __defaults__    tuple of any default values for arguments\n    __globals__     global namespace in which this function was defined\n    __annotations__ dict of parameter annotations\n    __kwdefaults__  dict of keyword only parameters with defaults",
      "relationships": []
    },
    {
      "id": "stdlib.inspect.isgenerator",
      "name": "isgenerator",
      "module": "inspect",
      "type": "function",
      "signature": "(object)",
      "description": "Return true if the object is a generator.\n\nGenerator objects provide these attributes:\n    __iter__        defined to support iteration over container\n    close           raises a new GeneratorExit exception inside the\n                    generator to terminate the iteration\n    gi_code         code object\n    gi_frame        frame object or possibly None once the generator has\n                    been exhausted\n    gi_running      set to 1 when generator is executing, 0 otherwise\n    next            return the next item from the container\n    send            resumes the generator and \"sends\" a value that becomes\n                    the result of the current yield-expression\n    throw           used to raise an exception inside the generator",
      "relationships": []
    },
    {
      "id": "stdlib.inspect.isgeneratorfunction",
      "name": "isgeneratorfunction",
      "module": "inspect",
      "type": "function",
      "signature": "(obj)",
      "description": "Return true if the object is a user-defined generator function.\n\nGenerator function objects provide the same attributes as functions.\nSee help(isfunction) for a list of attributes.",
      "relationships": [
        {
          "target": "stdlib.inspect._has_code_flag",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.isgetsetdescriptor",
      "name": "isgetsetdescriptor",
      "module": "inspect",
      "type": "function",
      "signature": "(object)",
      "description": "Return true if the object is a getset descriptor.\n\ngetset descriptors are specialized descriptors defined in extension\nmodules.",
      "relationships": []
    },
    {
      "id": "stdlib.inspect.ismemberdescriptor",
      "name": "ismemberdescriptor",
      "module": "inspect",
      "type": "function",
      "signature": "(object)",
      "description": "Return true if the object is a member descriptor.\n\nMember descriptors are specialized descriptors defined in extension\nmodules.",
      "relationships": []
    },
    {
      "id": "stdlib.inspect.ismethod",
      "name": "ismethod",
      "module": "inspect",
      "type": "function",
      "signature": "(object)",
      "description": "Return true if the object is an instance method.",
      "relationships": []
    },
    {
      "id": "stdlib.inspect.ismethoddescriptor",
      "name": "ismethoddescriptor",
      "module": "inspect",
      "type": "function",
      "signature": "(object)",
      "description": "Return true if the object is a method descriptor.\n\nBut not if ismethod() or isclass() or isfunction() are true.\n\nThis is new in Python 2.2, and, for example, is true of int.__add__.\nAn object passing this test has a __get__ attribute but not a __set__\nattribute, but beyond that the set of attributes varies.  __name__ is\nusually sensible, and __doc__ often is.\n\nMethods implemented via descriptors that also pass one of the other\ntests return false from the ismethoddescriptor() test, simply because\nthe other tests promise more -- you can, e.g., count on having the\n__func__ attribute (etc) when an object passes ismethod().",
      "relationships": [
        {
          "target": "stdlib.inspect.isclass",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.ismethod",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.isfunction",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.ismethodwrapper",
      "name": "ismethodwrapper",
      "module": "inspect",
      "type": "function",
      "signature": "(object)",
      "description": "Return true if the object is a method wrapper.",
      "relationships": []
    },
    {
      "id": "stdlib.inspect.ismodule",
      "name": "ismodule",
      "module": "inspect",
      "type": "function",
      "signature": "(object)",
      "description": "Return true if the object is a module.",
      "relationships": []
    },
    {
      "id": "stdlib.inspect.isroutine",
      "name": "isroutine",
      "module": "inspect",
      "type": "function",
      "signature": "(object)",
      "description": "Return true if the object is any kind of function or method.",
      "relationships": [
        {
          "target": "stdlib.inspect.isbuiltin",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.isfunction",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.ismethod",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.ismethoddescriptor",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.ismethodwrapper",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.istraceback",
      "name": "istraceback",
      "module": "inspect",
      "type": "function",
      "signature": "(object)",
      "description": "Return true if the object is a traceback.\n\nTraceback objects provide these attributes:\n    tb_frame        frame object at this level\n    tb_lasti        index of last attempted instruction in bytecode\n    tb_lineno       current line number in Python source code\n    tb_next         next inner traceback object (called by this level)",
      "relationships": []
    },
    {
      "id": "stdlib.inspect.markcoroutinefunction",
      "name": "markcoroutinefunction",
      "module": "inspect",
      "type": "function",
      "signature": "(func)",
      "description": "Decorator to ensure callable is recognised as a coroutine function.",
      "relationships": []
    },
    {
      "id": "stdlib.inspect.signature",
      "name": "signature",
      "module": "inspect",
      "type": "function",
      "signature": "(obj, *, follow_wrapped=True, globals=None, locals=None, eval_str=False)",
      "description": "Get a signature object for the passed callable.",
      "relationships": []
    },
    {
      "id": "stdlib.inspect.stack",
      "name": "stack",
      "module": "inspect",
      "type": "function",
      "signature": "(context=1)",
      "description": "Return a list of records for the stack above the caller's frame.",
      "relationships": [
        {
          "target": "stdlib.inspect.getouterframes",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.trace",
      "name": "trace",
      "module": "inspect",
      "type": "function",
      "signature": "(context=1)",
      "description": "Return a list of records for the stack below the current exception.",
      "relationships": [
        {
          "target": "stdlib.inspect.getinnerframes",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.unwrap",
      "name": "unwrap",
      "module": "inspect",
      "type": "function",
      "signature": "(func, *, stop=None)",
      "description": "Get the object wrapped by *func*.\n\nFollows the chain of :attr:`__wrapped__` attributes returning the last\nobject in the chain.\n\n*stop* is an optional callback accepting an object in the wrapper chain\nas its sole argument that allows the unwrapping to be terminated early if\nthe callback returns a true value. If the callback never returns a true\nvalue, the last object in the chain is returned as usual. For example,\n:func:`signature` uses this to stop unwrapping if any object in the\nchain has a ``__signature__`` attribute defined.\n\n:exc:`ValueError` is raised if a cycle is encountered.\n\n ",
      "relationships": []
    },
    {
      "id": "stdlib.inspect.walktree",
      "name": "walktree",
      "module": "inspect",
      "type": "function",
      "signature": "(classes, children, parent)",
      "description": "Recursive helper function for getclasstree().",
      "relationships": [
        {
          "target": "stdlib.inspect.walktree",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.io.BufferedIOBase",
      "name": "BufferedIOBase",
      "module": "io",
      "type": "class",
      "signature": "()",
      "description": "Base class for buffered IO objects.\n\nThe main difference with RawIOBase is that the read() method\nsupports omitting the size argument, and does not have a default\nimplementation that defers to readinto().\n\nIn addition, read(), readinto() and write() may raise\nBlockingIOError if the underlying raw stream is in non-blocking\nmode and not ready; unlike their raw counterparts, they will never\nreturn None.\n\nA typical implementation should not inherit from a RawIOBase\nimplementation, but wrap one.",
      "relationships": [
        {
          "target": "stdlib._io._BufferedIOBase",
          "type": "base_class"
        },
        {
          "target": "stdlib.io.IOBase",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins._IOBase",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.io.IOBase",
      "name": "IOBase",
      "module": "io",
      "type": "class",
      "signature": "()",
      "description": "The abstract base class for all I/O classes.\n\nThis class provides dummy implementations for many methods that\nderived classes can override selectively; the default implementations\nrepresent a file that cannot be read, written or seeked.\n\nEven though IOBase does not declare read, readinto, or write because\ntheir signatures will vary, implementations and clients should\nconsider those methods part of the interface. Also, implementations\nmay raise UnsupportedOperation when operations they do not support are\ncalled.\n\nThe basic type used for binary data read from or written to a file is\nbytes. Other bytes-like objects are accepted as method arguments too.\nIn some cases (such as readinto), a writable object is required. Text\nI/O classes work with str data.\n\nNote that calling any method (except additional calls to close(),\nwhich are ignored) on a closed stream should raise a ValueError.\n\nIOBase (and its subclasses) support the iterator protocol, meaning\nthat an IOBase object can be iterated over yielding the lines in a\nstream.\n\nIOBase also supports the :keyword:`with` statement. In this example,\nfp is closed after the suite of the with statement is complete:\n\nwith open('spam.txt', 'r') as fp:\n    fp.write('Spam and eggs!')",
      "relationships": [
        {
          "target": "stdlib._io._IOBase",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.io.RawIOBase",
      "name": "RawIOBase",
      "module": "io",
      "type": "class",
      "signature": "()",
      "description": "Base class for raw binary I/O.",
      "relationships": [
        {
          "target": "stdlib._io._RawIOBase",
          "type": "base_class"
        },
        {
          "target": "stdlib.io.IOBase",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins._IOBase",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.io.TextIOBase",
      "name": "TextIOBase",
      "module": "io",
      "type": "class",
      "signature": "()",
      "description": "Base class for text I/O.\n\nThis class provides a character and line based interface to stream\nI/O. There is no readinto method because Python's character strings\nare immutable.",
      "relationships": [
        {
          "target": "stdlib._io._TextIOBase",
          "type": "base_class"
        },
        {
          "target": "stdlib.io.IOBase",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins._IOBase",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.ipaddress.IPv4Address",
      "name": "IPv4Address",
      "module": "ipaddress",
      "type": "class",
      "signature": "(address)",
      "description": "Represent and manipulate single IPv4 Addresses.",
      "relationships": [
        {
          "target": "stdlib.ipaddress._BaseV4",
          "type": "base_class"
        },
        {
          "target": "stdlib.ipaddress._BaseAddress",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins._IPAddressBase",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.ipaddress.IPv4Interface",
      "name": "IPv4Interface",
      "module": "ipaddress",
      "type": "class",
      "signature": "(address)",
      "description": "Represent and manipulate single IPv4 Addresses.",
      "relationships": [
        {
          "target": "stdlib.ipaddress.IPv4Address",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins._BaseV4",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins._BaseAddress",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins._IPAddressBase",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.ipaddress.IPv4Network",
      "name": "IPv4Network",
      "module": "ipaddress",
      "type": "class",
      "signature": "(address, strict=True)",
      "description": "This class represents and manipulates 32-bit IPv4 network + addresses..\n\nAttributes: [examples for IPv4Network('192.0.2.0/27')]\n    .network_address: IPv4Address('192.0.2.0')\n    .hostmask: IPv4Address('0.0.0.31')\n    .broadcast_address: IPv4Address('192.0.2.32')\n    .netmask: IPv4Address('255.255.255.224')\n    .prefixlen: 27",
      "relationships": [
        {
          "target": "stdlib.ipaddress._BaseV4",
          "type": "base_class"
        },
        {
          "target": "stdlib.ipaddress._BaseNetwork",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins._IPAddressBase",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.ipaddress.IPv6Address",
      "name": "IPv6Address",
      "module": "ipaddress",
      "type": "class",
      "signature": "(address)",
      "description": "Represent and manipulate single IPv6 Addresses.",
      "relationships": [
        {
          "target": "stdlib.ipaddress._BaseV6",
          "type": "base_class"
        },
        {
          "target": "stdlib.ipaddress._BaseAddress",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins._IPAddressBase",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.ipaddress.IPv6Interface",
      "name": "IPv6Interface",
      "module": "ipaddress",
      "type": "class",
      "signature": "(address)",
      "description": "Represent and manipulate single IPv6 Addresses.",
      "relationships": [
        {
          "target": "stdlib.ipaddress.IPv6Address",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins._BaseV6",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins._BaseAddress",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins._IPAddressBase",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.ipaddress.IPv6Network",
      "name": "IPv6Network",
      "module": "ipaddress",
      "type": "class",
      "signature": "(address, strict=True)",
      "description": "This class represents and manipulates 128-bit IPv6 networks.\n\nAttributes: [examples for IPv6('2001:db8::1000/124')]\n    .network_address: IPv6Address('2001:db8::1000')\n    .hostmask: IPv6Address('::f')\n    .broadcast_address: IPv6Address('2001:db8::100f')\n    .netmask: IPv6Address('ffff:ffff:ffff:ffff:ffff:ffff:ffff:fff0')\n    .prefixlen: 124",
      "relationships": [
        {
          "target": "stdlib.ipaddress._BaseV6",
          "type": "base_class"
        },
        {
          "target": "stdlib.ipaddress._BaseNetwork",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins._IPAddressBase",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.ipaddress.collapse_addresses",
      "name": "collapse_addresses",
      "module": "ipaddress",
      "type": "function",
      "signature": "(addresses)",
      "description": "Collapse a list of IP objects.\n\nExample:\n    collapse_addresses([IPv4Network('192.0.2.0/25'),\n                        IPv4Network('192.0.2.128/25')]) ->\n                       [IPv4Network('192.0.2.0/24')]\n\nArgs:\n    addresses: An iterable of IPv4Network or IPv6Network objects.\n\nReturns:\n    An iterator of the collapsed IPv(4|6)Network objects.\n\nRaises:\n    TypeError: If passed a list of mixed version objects.",
      "relationships": [
        {
          "target": "stdlib.ipaddress._collapse_addresses_internal",
          "type": "calls"
        },
        {
          "target": "stdlib.ipaddress._find_address_range",
          "type": "calls"
        },
        {
          "target": "stdlib.ipaddress.summarize_address_range",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ipaddress.get_mixed_type_key",
      "name": "get_mixed_type_key",
      "module": "ipaddress",
      "type": "function",
      "signature": "(obj)",
      "description": "Return a key suitable for sorting between networks and addresses.\n\nAddress and Network objects are not sortable by default; they're\nfundamentally different so the expression\n\n    IPv4Address('192.0.2.0') <= IPv4Network('192.0.2.0/24')\n\ndoesn't make any sense.  There are some times however, where you may wish\nto have ipaddress sort these for you anyway. If you need to do this, you\ncan use this function as the key= argument to sorted().\n\nArgs:\n  obj: either a Network or Address object.\nReturns:\n  appropriate key.",
      "relationships": []
    },
    {
      "id": "stdlib.ipaddress.ip_address",
      "name": "ip_address",
      "module": "ipaddress",
      "type": "function",
      "signature": "(address)",
      "description": "Take an IP string/int and return an object of the correct type.\n\nArgs:\n    address: A string or integer, the IP address.  Either IPv4 or\n      IPv6 addresses may be supplied; integers less than 2**32 will\n      be considered to be IPv4 by default.\n\nReturns:\n    An IPv4Address or IPv6Address object.\n\nRaises:\n    ValueError: if the *address* passed isn't either a v4 or a v6\n      address",
      "relationships": []
    },
    {
      "id": "stdlib.ipaddress.ip_interface",
      "name": "ip_interface",
      "module": "ipaddress",
      "type": "function",
      "signature": "(address)",
      "description": "Take an IP string/int and return an object of the correct type.\n\nArgs:\n    address: A string or integer, the IP address.  Either IPv4 or\n      IPv6 addresses may be supplied; integers less than 2**32 will\n      be considered to be IPv4 by default.\n\nReturns:\n    An IPv4Interface or IPv6Interface object.\n\nRaises:\n    ValueError: if the string passed isn't either a v4 or a v6\n      address.\n\nNotes:\n    The IPv?Interface classes describe an Address on a particular\n    Network, so they're basically a combination of both the Address\n    and Network classes.",
      "relationships": []
    },
    {
      "id": "stdlib.ipaddress.ip_network",
      "name": "ip_network",
      "module": "ipaddress",
      "type": "function",
      "signature": "(address, strict=True)",
      "description": "Take an IP string/int and return an object of the correct type.\n\nArgs:\n    address: A string or integer, the IP network.  Either IPv4 or\n      IPv6 networks may be supplied; integers less than 2**32 will\n      be considered to be IPv4 by default.\n\nReturns:\n    An IPv4Network or IPv6Network object.\n\nRaises:\n    ValueError: if the string passed isn't either a v4 or a v6\n      address. Or if the network has host bits set.",
      "relationships": []
    },
    {
      "id": "stdlib.ipaddress.summarize_address_range",
      "name": "summarize_address_range",
      "module": "ipaddress",
      "type": "function",
      "signature": "(first, last)",
      "description": "Summarize a network range given the first and last IP addresses.\n\nExample:\n    >>> list(summarize_address_range(IPv4Address('192.0.2.0'),\n    ...                              IPv4Address('192.0.2.130')))\n    ...                                #doctest: +NORMALIZE_WHITESPACE\n    [IPv4Network('192.0.2.0/25'), IPv4Network('192.0.2.128/31'),\n     IPv4Network('192.0.2.130/32')]\n\nArgs:\n    first: the first IPv4Address or IPv6Address in the range.\n    last: the last IPv4Address or IPv6Address in the range.\n\nReturns:\n    An iterator of the summarized IPv(4|6) network objects.\n\nRaise:\n    TypeError:\n        If the first and last objects are not IP addresses.\n        If the first and last objects are not the same version.\n    ValueError:\n        If the last object is not greater than the first.\n        If the version of the first address is not 4 or 6.",
      "relationships": [
        {
          "target": "stdlib.ipaddress._count_righthand_zero_bits",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ipaddress.v4_int_to_packed",
      "name": "v4_int_to_packed",
      "module": "ipaddress",
      "type": "function",
      "signature": "(address)",
      "description": "Represent an address as 4 packed bytes in network (big-endian) order.\n\nArgs:\n    address: An integer representation of an IPv4 IP address.\n\nReturns:\n    The integer address packed as 4 bytes in network (big-endian) order.\n\nRaises:\n    ValueError: If the integer is negative or too large to be an\n      IPv4 IP address.",
      "relationships": []
    },
    {
      "id": "stdlib.ipaddress.v6_int_to_packed",
      "name": "v6_int_to_packed",
      "module": "ipaddress",
      "type": "function",
      "signature": "(address)",
      "description": "Represent an address as 16 packed bytes in network (big-endian) order.\n\nArgs:\n    address: An integer representation of an IPv6 IP address.\n\nReturns:\n    The integer address packed as 16 bytes in network (big-endian) order.",
      "relationships": []
    },
    {
      "id": "stdlib.json.detect_encoding",
      "name": "detect_encoding",
      "module": "json",
      "type": "function",
      "signature": "(b)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.json.dump",
      "name": "dump",
      "module": "json",
      "type": "function",
      "signature": "(obj, fp, *, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, default=None, sort_keys=False, **kw)",
      "description": "Serialize ``obj`` as a JSON formatted stream to ``fp`` (a\n``.write()``-supporting file-like object).\n\nIf ``skipkeys`` is true then ``dict`` keys that are not basic types\n(``str``, ``int``, ``float``, ``bool``, ``None``) will be skipped\ninstead of raising a ``TypeError``.\n\nIf ``ensure_ascii`` is false, then the strings written to ``fp`` can\ncontain non-ASCII characters if they appear in strings contained in\n``obj``. Otherwise, all such characters are escaped in JSON strings.\n\nIf ``check_circular`` is false, then the circular reference check\nfor container types will be skipped and a circular reference will\nresult in an ``RecursionError`` (or worse).\n\nIf ``allow_nan`` is false, then it will be a ``ValueError`` to\nserialize out of range ``float`` values (``nan``, ``inf``, ``-inf``)\nin strict compliance of the JSON specification, instead of using the\nJavaScript equivalents (``NaN``, ``Infinity``, ``-Infinity``).\n\nIf ``indent`` is a non-negative integer, then JSON array elements and\nobject members will be pretty-printed with that indent level. An indent\nlevel of 0 will only insert newlines. ``None`` is the most compact\nrepresentation.\n\nIf specified, ``separators`` should be an ``(item_separator, key_separator)``\ntuple.  The default is ``(', ', ': ')`` if *indent* is ``None`` and\n``(',', ': ')`` otherwise.  To get the most compact JSON representation,\nyou should specify ``(',', ':')`` to eliminate whitespace.\n\n``default(obj)`` is a function that should return a serializable version\nof obj or raise TypeError. The default simply raises TypeError.\n\nIf *sort_keys* is true (default: ``False``), then the output of\ndictionaries will be sorted by key.\n\nTo use a custom ``JSONEncoder`` subclass (e.g. one that overrides the\n``.default()`` method to serialize additional types), specify it with\nthe ``cls`` kwarg; otherwise ``JSONEncoder`` is used.",
      "relationships": []
    },
    {
      "id": "stdlib.json.dumps",
      "name": "dumps",
      "module": "json",
      "type": "function",
      "signature": "(obj, *, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, default=None, sort_keys=False, **kw)",
      "description": "Serialize ``obj`` to a JSON formatted ``str``.\n\nIf ``skipkeys`` is true then ``dict`` keys that are not basic types\n(``str``, ``int``, ``float``, ``bool``, ``None``) will be skipped\ninstead of raising a ``TypeError``.\n\nIf ``ensure_ascii`` is false, then the return value can contain non-ASCII\ncharacters if they appear in strings contained in ``obj``. Otherwise, all\nsuch characters are escaped in JSON strings.\n\nIf ``check_circular`` is false, then the circular reference check\nfor container types will be skipped and a circular reference will\nresult in an ``RecursionError`` (or worse).\n\nIf ``allow_nan`` is false, then it will be a ``ValueError`` to\nserialize out of range ``float`` values (``nan``, ``inf``, ``-inf``) in\nstrict compliance of the JSON specification, instead of using the\nJavaScript equivalents (``NaN``, ``Infinity``, ``-Infinity``).\n\nIf ``indent`` is a non-negative integer, then JSON array elements and\nobject members will be pretty-printed with that indent level. An indent\nlevel of 0 will only insert newlines. ``None`` is the most compact\nrepresentation.\n\nIf specified, ``separators`` should be an ``(item_separator, key_separator)``\ntuple.  The default is ``(', ', ': ')`` if *indent* is ``None`` and\n``(',', ': ')`` otherwise.  To get the most compact JSON representation,\nyou should specify ``(',', ':')`` to eliminate whitespace.\n\n``default(obj)`` is a function that should return a serializable version\nof obj or raise TypeError. The default simply raises TypeError.\n\nIf *sort_keys* is true (default: ``False``), then the output of\ndictionaries will be sorted by key.\n\nTo use a custom ``JSONEncoder`` subclass (e.g. one that overrides the\n``.default()`` method to serialize additional types), specify it with\nthe ``cls`` kwarg; otherwise ``JSONEncoder`` is used.",
      "relationships": []
    },
    {
      "id": "stdlib.json.load",
      "name": "load",
      "module": "json",
      "type": "function",
      "signature": "(fp, *, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, object_pairs_hook=None, **kw)",
      "description": "Deserialize ``fp`` (a ``.read()``-supporting file-like object containing\na JSON document) to a Python object.\n\n``object_hook`` is an optional function that will be called with the\nresult of any object literal decode (a ``dict``). The return value of\n``object_hook`` will be used instead of the ``dict``. This feature\ncan be used to implement custom decoders (e.g. JSON-RPC class hinting).\n\n``object_pairs_hook`` is an optional function that will be called with the\nresult of any object literal decoded with an ordered list of pairs.  The\nreturn value of ``object_pairs_hook`` will be used instead of the ``dict``.\nThis feature can be used to implement custom decoders.  If ``object_hook``\nis also defined, the ``object_pairs_hook`` takes priority.\n\nTo use a custom ``JSONDecoder`` subclass, specify it with the ``cls``\nkwarg; otherwise ``JSONDecoder`` is used.",
      "relationships": [
        {
          "target": "stdlib.json.loads",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.json.loads",
      "name": "loads",
      "module": "json",
      "type": "function",
      "signature": "(s, *, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, object_pairs_hook=None, **kw)",
      "description": "Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance\ncontaining a JSON document) to a Python object.\n\n``object_hook`` is an optional function that will be called with the\nresult of any object literal decode (a ``dict``). The return value of\n``object_hook`` will be used instead of the ``dict``. This feature\ncan be used to implement custom decoders (e.g. JSON-RPC class hinting).\n\n``object_pairs_hook`` is an optional function that will be called with the\nresult of any object literal decoded with an ordered list of pairs.  The\nreturn value of ``object_pairs_hook`` will be used instead of the ``dict``.\nThis feature can be used to implement custom decoders.  If ``object_hook``\nis also defined, the ``object_pairs_hook`` takes priority.\n\n``parse_float``, if specified, will be called with the string\nof every JSON float to be decoded. By default this is equivalent to\nfloat(num_str). This can be used to use another datatype or parser\nfor JSON floats (e.g. decimal.Decimal).\n\n``parse_int``, if specified, will be called with the string\nof every JSON int to be decoded. By default this is equivalent to\nint(num_str). This can be used to use another datatype or parser\nfor JSON integers (e.g. float).\n\n``parse_constant``, if specified, will be called with one of the\nfollowing strings: -Infinity, Infinity, NaN.\nThis can be used to raise an exception if invalid JSON numbers\nare encountered.\n\nTo use a custom ``JSONDecoder`` subclass, specify it with the ``cls``\nkwarg; otherwise ``JSONDecoder`` is used.",
      "relationships": [
        {
          "target": "stdlib.json.detect_encoding",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.linecache.checkcache",
      "name": "checkcache",
      "module": "linecache",
      "type": "function",
      "signature": "(filename=None)",
      "description": "Discard cache entries that are out of date.\n(This is not checked upon each call!)",
      "relationships": []
    },
    {
      "id": "stdlib.linecache.clearcache",
      "name": "clearcache",
      "module": "linecache",
      "type": "function",
      "signature": "()",
      "description": "Clear the cache entirely.",
      "relationships": []
    },
    {
      "id": "stdlib.linecache.getline",
      "name": "getline",
      "module": "linecache",
      "type": "function",
      "signature": "(filename, lineno, module_globals=None)",
      "description": "Get a line for a Python source file from the cache.\nUpdate the cache if it doesn't contain an entry for this file already.",
      "relationships": [
        {
          "target": "stdlib.linecache.getlines",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.linecache.getlines",
      "name": "getlines",
      "module": "linecache",
      "type": "function",
      "signature": "(filename, module_globals=None)",
      "description": "Get the lines for a Python source file from the cache.\nUpdate the cache if it doesn't contain an entry for this file already.",
      "relationships": [
        {
          "target": "stdlib.linecache.updatecache",
          "type": "calls"
        },
        {
          "target": "stdlib.linecache.clearcache",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.linecache.lazycache",
      "name": "lazycache",
      "module": "linecache",
      "type": "function",
      "signature": "(filename, module_globals)",
      "description": "Seed the cache for filename with module_globals.\n\nThe module loader will be asked for the source only when getlines is\ncalled, not immediately.\n\nIf there is an entry in the cache already, it is not altered.\n\n:return: True if a lazy load is registered in the cache,\n    otherwise False. To register such a load a module loader with a\n    get_source method must be found, the filename must be a cacheable\n    filename, and the filename must not be already cached.",
      "relationships": []
    },
    {
      "id": "stdlib.linecache.updatecache",
      "name": "updatecache",
      "module": "linecache",
      "type": "function",
      "signature": "(filename, module_globals=None)",
      "description": "Update a cache entry and return its list of lines.\nIf something's wrong, print a message, discard the cache entry,\nand return an empty list.",
      "relationships": [
        {
          "target": "stdlib.linecache.lazycache",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.locale.atof",
      "name": "atof",
      "module": "locale",
      "type": "function",
      "signature": "(string, func=<class 'float'>)",
      "description": "Parses a string as a float according to the locale settings.",
      "relationships": [
        {
          "target": "stdlib.locale.delocalize",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.locale.atoi",
      "name": "atoi",
      "module": "locale",
      "type": "function",
      "signature": "(string)",
      "description": "Converts a string to an integer according to the locale settings.",
      "relationships": [
        {
          "target": "stdlib.locale.delocalize",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.locale.currency",
      "name": "currency",
      "module": "locale",
      "type": "function",
      "signature": "(val, symbol=True, grouping=False, international=False)",
      "description": "Formats val according to the currency settings\nin the current locale.",
      "relationships": [
        {
          "target": "stdlib.locale._localize",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.locale.delocalize",
      "name": "delocalize",
      "module": "locale",
      "type": "function",
      "signature": "(string)",
      "description": "Parses a string as a normalized number according to the locale settings.",
      "relationships": []
    },
    {
      "id": "stdlib.locale.format_string",
      "name": "format_string",
      "module": "locale",
      "type": "function",
      "signature": "(f, val, grouping=False, monetary=False)",
      "description": "Formats a string in the same way that the % formatting would use,\nbut takes the current locale into account.\n\nGrouping is applied if the third parameter is true.\nConversion uses monetary thousands separator and grouping strings if\nforth parameter monetary is true.",
      "relationships": [
        {
          "target": "stdlib.locale._format",
          "type": "calls"
        },
        {
          "target": "stdlib.locale._format",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.locale.getdefaultlocale",
      "name": "getdefaultlocale",
      "module": "locale",
      "type": "function",
      "signature": "(envvars=('LC_ALL', 'LC_CTYPE', 'LANG', 'LANGUAGE'))",
      "description": "Tries to determine the default locale settings and returns\nthem as tuple (language code, encoding).\n\nAccording to POSIX, a program which has not called\nsetlocale(LC_ALL, \"\") runs using the portable 'C' locale.\nCalling setlocale(LC_ALL, \"\") lets it use the default locale as\ndefined by the LANG variable. Since we don't want to interfere\nwith the current locale setting we thus emulate the behavior\nin the way described above.\n\nTo maintain compatibility with other platforms, not only the\nLANG variable is tested, but a list of variables given as\nenvvars parameter. The first found to be defined will be\nused. envvars defaults to the search path used in GNU gettext;\nit must always contain the variable name 'LANG'.\n\nExcept for the code 'C', the language code corresponds to RFC\n1766.  code and encoding can be None in case the values cannot\nbe determined.",
      "relationships": [
        {
          "target": "stdlib.locale._getdefaultlocale",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.locale.getlocale",
      "name": "getlocale",
      "module": "locale",
      "type": "function",
      "signature": "(category=2)",
      "description": "Returns the current setting for the given locale category as\ntuple (language code, encoding).\n\ncategory may be one of the LC_* value except LC_ALL. It\ndefaults to LC_CTYPE.\n\nExcept for the code 'C', the language code corresponds to RFC\n1766.  code and encoding can be None in case the values cannot\nbe determined.",
      "relationships": [
        {
          "target": "stdlib.locale._parse_localename",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.locale.getpreferredencoding",
      "name": "getpreferredencoding",
      "module": "locale",
      "type": "function",
      "signature": "(do_setlocale=True)",
      "description": "Return the charset that the user is likely using,\naccording to the system configuration.",
      "relationships": [
        {
          "target": "stdlib.locale.setlocale",
          "type": "calls"
        },
        {
          "target": "stdlib.locale.setlocale",
          "type": "calls"
        },
        {
          "target": "stdlib.locale.setlocale",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.locale.localize",
      "name": "localize",
      "module": "locale",
      "type": "function",
      "signature": "(string, grouping=False, monetary=False)",
      "description": "Parses a string as locale number according to the locale settings.",
      "relationships": [
        {
          "target": "stdlib.locale._localize",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.locale.normalize",
      "name": "normalize",
      "module": "locale",
      "type": "function",
      "signature": "(localename)",
      "description": "Returns a normalized locale code for the given locale\nname.\n\nThe returned locale code is formatted for use with\nsetlocale().\n\nIf normalization fails, the original name is returned\nunchanged.\n\nIf the given encoding is not known, the function defaults to\nthe default encoding for the locale code just like setlocale()\ndoes.",
      "relationships": [
        {
          "target": "stdlib.locale._append_modifier",
          "type": "calls"
        },
        {
          "target": "stdlib.locale._replace_encoding",
          "type": "calls"
        },
        {
          "target": "stdlib.locale._replace_encoding",
          "type": "calls"
        },
        {
          "target": "stdlib.locale._replace_encoding",
          "type": "calls"
        },
        {
          "target": "stdlib.locale._append_modifier",
          "type": "calls"
        },
        {
          "target": "stdlib.locale._replace_encoding",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.locale.resetlocale",
      "name": "resetlocale",
      "module": "locale",
      "type": "function",
      "signature": "(category=0)",
      "description": "Sets the locale for category to the default setting.\n\nThe default setting is determined by calling\ngetdefaultlocale(). category defaults to LC_ALL.",
      "relationships": [
        {
          "target": "stdlib.locale.getdefaultlocale",
          "type": "calls"
        },
        {
          "target": "stdlib.locale._build_localename",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.locale.setlocale",
      "name": "setlocale",
      "module": "locale",
      "type": "function",
      "signature": "(category, locale=None)",
      "description": "Set the locale for the given category.  The locale can be\na string, an iterable of two strings (language code and encoding),\nor None.\n\nIterables are converted to strings using the locale aliasing\nengine.  Locale strings are passed directly to the C lib.\n\ncategory may be given as one of the LC_* values.",
      "relationships": [
        {
          "target": "stdlib.locale.normalize",
          "type": "calls"
        },
        {
          "target": "stdlib.locale._build_localename",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.locale.str",
      "name": "str",
      "module": "locale",
      "type": "function",
      "signature": "(val)",
      "description": "Convert float to string, taking the locale into account.",
      "relationships": [
        {
          "target": "stdlib.locale._format",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.logging.BufferingFormatter",
      "name": "BufferingFormatter",
      "module": "logging",
      "type": "class",
      "signature": "(linefmt=None)",
      "description": "A formatter suitable for formatting a number of records.",
      "relationships": []
    },
    {
      "id": "stdlib.logging.FileHandler",
      "name": "FileHandler",
      "module": "logging",
      "type": "class",
      "signature": "(filename, mode='a', encoding=None, delay=False, errors=None)",
      "description": "A handler class which writes formatted logging records to disk files.",
      "relationships": [
        {
          "target": "stdlib.logging.StreamHandler",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Handler",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Filterer",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.logging.Filter",
      "name": "Filter",
      "module": "logging",
      "type": "class",
      "signature": "(name='')",
      "description": "Filter instances are used to perform arbitrary filtering of LogRecords.\n\nLoggers and Handlers can optionally use Filter instances to filter\nrecords as desired. The base filter class only allows events which are\nbelow a certain point in the logger hierarchy. For example, a filter\ninitialized with \"A.B\" will allow events logged by loggers \"A.B\",\n\"A.B.C\", \"A.B.C.D\", \"A.B.D\" etc. but not \"A.BB\", \"B.A.B\" etc. If\ninitialized with the empty string, all events are passed.",
      "relationships": []
    },
    {
      "id": "stdlib.logging.Filterer",
      "name": "Filterer",
      "module": "logging",
      "type": "class",
      "signature": "()",
      "description": "A base class for loggers and handlers which allows them to share\ncommon code.",
      "relationships": []
    },
    {
      "id": "stdlib.logging.Formatter",
      "name": "Formatter",
      "module": "logging",
      "type": "class",
      "signature": "(fmt=None, datefmt=None, style='%', validate=True, *, defaults=None)",
      "description": "Formatter instances are used to convert a LogRecord to text.\n\nFormatters need to know how a LogRecord is constructed. They are\nresponsible for converting a LogRecord to (usually) a string which can\nbe interpreted by either a human or an external system. The base Formatter\nallows a formatting string to be specified. If none is supplied, the\nstyle-dependent default value, \"%(message)s\", \"{message}\", or\n\"${message}\", is used.\n\nThe Formatter can be initialized with a format string which makes use of\nknowledge of the LogRecord attributes - e.g. the default value mentioned\nabove makes use of the fact that the user's message and arguments are pre-\nformatted into a LogRecord's message attribute. Currently, the useful\nattributes in a LogRecord are described by:\n\n%(name)s            Name of the logger (logging channel)\n%(levelno)s         Numeric logging level for the message (DEBUG, INFO,\n                    WARNING, ERROR, CRITICAL)\n%(levelname)s       Text logging level for the message (\"DEBUG\", \"INFO\",\n                    \"WARNING\", \"ERROR\", \"CRITICAL\")\n%(pathname)s        Full pathname of the source file where the logging\n                    call was issued (if available)\n%(filename)s        Filename portion of pathname\n%(module)s          Module (name portion of filename)\n%(lineno)d          Source line number where the logging call was issued\n                    (if available)\n%(funcName)s        Function name\n%(created)f         Time when the LogRecord was created (time.time()\n                    return value)\n%(asctime)s         Textual time when the LogRecord was created\n%(msecs)d           Millisecond portion of the creation time\n%(relativeCreated)d Time in milliseconds when the LogRecord was created,\n                    relative to the time the logging module was loaded\n                    (typically at application startup time)\n%(thread)d          Thread ID (if available)\n%(threadName)s      Thread name (if available)\n%(taskName)s        Task name (if available)\n%(process)d         Process ID (if available)\n%(message)s         The result of record.getMessage(), computed just as\n                    the record is emitted",
      "relationships": []
    },
    {
      "id": "stdlib.logging.Handler",
      "name": "Handler",
      "module": "logging",
      "type": "class",
      "signature": "(level=0)",
      "description": "Handler instances dispatch logging events to specific destinations.\n\nThe base handler class. Acts as a placeholder which defines the Handler\ninterface. Handlers can optionally use Formatter instances to format\nrecords as desired. By default, no formatter is specified; in this case,\nthe 'raw' message as determined by record.message is logged.",
      "relationships": [
        {
          "target": "stdlib.logging.Filterer",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.logging.LogRecord",
      "name": "LogRecord",
      "module": "logging",
      "type": "class",
      "signature": "(name, level, pathname, lineno, msg, args, exc_info, func=None, sinfo=None, **kwargs)",
      "description": "A LogRecord instance represents an event being logged.\n\nLogRecord instances are created every time something is logged. They\ncontain all the information pertinent to the event being logged. The\nmain information passed in is in msg and args, which are combined\nusing str(msg) % args to create the message field of the record. The\nrecord also includes information such as when the record was created,\nthe source line where the logging call was made, and any exception\ninformation to be logged.",
      "relationships": []
    },
    {
      "id": "stdlib.logging.Logger",
      "name": "Logger",
      "module": "logging",
      "type": "class",
      "signature": "(name, level=0)",
      "description": "Instances of the Logger class represent a single logging channel. A\n\"logging channel\" indicates an area of an application. Exactly how an\n\"area\" is defined is up to the application developer. Since an\napplication can have any number of areas, logging channels are identified\nby a unique string. Application areas can be nested (e.g. an area\nof \"input processing\" might include sub-areas \"read CSV files\", \"read\nXLS files\" and \"read Gnumeric files\"). To cater for this natural nesting,\nchannel names are organized into a namespace hierarchy where levels are\nseparated by periods, much like the Java or Python package namespace. So\nin the instance given above, channel names might be \"input\" for the upper\nlevel, and \"input.csv\", \"input.xls\" and \"input.gnu\" for the sub-levels.\nThere is no arbitrary limit to the depth of nesting.",
      "relationships": [
        {
          "target": "stdlib.logging.Filterer",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.logging.LoggerAdapter",
      "name": "LoggerAdapter",
      "module": "logging",
      "type": "class",
      "signature": "(logger, extra=None)",
      "description": "An adapter for loggers which makes it easier to specify contextual\ninformation in logging output.",
      "relationships": []
    },
    {
      "id": "stdlib.logging.Manager",
      "name": "Manager",
      "module": "logging",
      "type": "class",
      "signature": "(rootnode)",
      "description": "There is [under normal circumstances] just one Manager instance, which\nholds the hierarchy of loggers.",
      "relationships": []
    },
    {
      "id": "stdlib.logging.NullHandler",
      "name": "NullHandler",
      "module": "logging",
      "type": "class",
      "signature": "(level=0)",
      "description": "This handler does nothing. It's intended to be used to avoid the\n\"No handlers could be found for logger XXX\" one-off warning. This is\nimportant for library code, which may contain code to log events. If a user\nof the library does not configure logging, the one-off warning might be\nproduced; to avoid this, the library developer simply needs to instantiate\na NullHandler and add it to the top-level logger of the library module or\npackage.",
      "relationships": [
        {
          "target": "stdlib.logging.Handler",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Filterer",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.logging.PercentStyle",
      "name": "PercentStyle",
      "module": "logging",
      "type": "class",
      "signature": "(fmt, *, defaults=None)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.logging.PlaceHolder",
      "name": "PlaceHolder",
      "module": "logging",
      "type": "class",
      "signature": "(alogger)",
      "description": "PlaceHolder instances are used in the Manager logger hierarchy to take\nthe place of nodes for which no loggers have been defined. This class is\nintended for internal use only and not as part of the public API.",
      "relationships": []
    },
    {
      "id": "stdlib.logging.RootLogger",
      "name": "RootLogger",
      "module": "logging",
      "type": "class",
      "signature": "(level)",
      "description": "A root logger is not that different to any other logger, except that\nit must have a logging level and there is only one instance of it in\nthe hierarchy.",
      "relationships": [
        {
          "target": "stdlib.logging.Logger",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Filterer",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.logging.StrFormatStyle",
      "name": "StrFormatStyle",
      "module": "logging",
      "type": "class",
      "signature": "(fmt, *, defaults=None)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.logging.PercentStyle",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.logging.StreamHandler",
      "name": "StreamHandler",
      "module": "logging",
      "type": "class",
      "signature": "(stream=None)",
      "description": "A handler class which writes logging records, appropriately formatted,\nto a stream. Note that this class does not close the stream, as\nsys.stdout or sys.stderr may be used.",
      "relationships": [
        {
          "target": "stdlib.logging.Handler",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Filterer",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.logging.StringTemplateStyle",
      "name": "StringTemplateStyle",
      "module": "logging",
      "type": "class",
      "signature": "(*args, **kwargs)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.logging.PercentStyle",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.logging.addLevelName",
      "name": "addLevelName",
      "module": "logging",
      "type": "function",
      "signature": "(level, levelName)",
      "description": "Associate 'levelName' with 'level'.\n\nThis is used when converting levels to text during message formatting.",
      "relationships": [
        {
          "target": "stdlib.logging._acquireLock",
          "type": "calls"
        },
        {
          "target": "stdlib.logging._releaseLock",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.logging.basicConfig",
      "name": "basicConfig",
      "module": "logging",
      "type": "function",
      "signature": "(**kwargs)",
      "description": "Do basic configuration for the logging system.\n\nThis function does nothing if the root logger already has handlers\nconfigured, unless the keyword argument *force* is set to ``True``.\nIt is a convenience method intended for use by simple scripts\nto do one-shot configuration of the logging package.\n\nThe default behaviour is to create a StreamHandler which writes to\nsys.stderr, set a formatter using the BASIC_FORMAT format string, and\nadd the handler to the root logger.\n\nA number of optional keyword arguments may be specified, which can alter\nthe default behaviour.\n\nfilename  Specifies that a FileHandler be created, using the specified\n          filename, rather than a StreamHandler.\nfilemode  Specifies the mode to open the file, if filename is specified\n          (if filemode is unspecified, it defaults to 'a').\nformat    Use the specified format string for the handler.\ndatefmt   Use the specified date/time format.\nstyle     If a format string is specified, use this to specify the\n          type of format string (possible values '%', '{', '$', for\n          %-formatting, :meth:`str.format` and :class:`string.Template`\n          - defaults to '%').\nlevel     Set the root logger level to the specified level.\nstream    Use the specified stream to initialize the StreamHandler. Note\n          that this argument is incompatible with 'filename' - if both\n          are present, 'stream' is ignored.\nhandlers  If specified, this should be an iterable of already created\n          handlers, which will be added to the root logger. Any handler\n          in the list which does not have a formatter assigned will be\n          assigned the formatter created in this function.\nforce     If this keyword  is specified as true, any existing handlers\n          attached to the root logger are removed and closed, before\n          carrying out the configuration as specified by the other\n          arguments.\nencoding  If specified together with a filename, this encoding is passed to\n          the created FileHandler, causing it to be used when the file is\n          opened.\nerrors    If specified together with a filename, this value is passed to the\n          created FileHandler, causing it to be used when the file is\n          opened in text mode. If not specified, the default value is\n          `backslashreplace`.\n\nNote that you could specify a stream created using open(filename, mode)\nrather than passing the filename and mode in. However, it should be\nremembered that StreamHandler does not close its stream (since it may be\nusing sys.stdout or sys.stderr), whereas FileHandler closes its stream\nwhen the handler is closed.\n\n.. versionchanged:: 3.2\n   Added the ``style`` parameter.\n\n.. versionchanged:: 3.3\n   Added the ``handlers`` parameter. A ``ValueError`` is now thrown for\n   incompatible arguments (e.g. ``handlers`` specified together with\n   ``filename``/``filemode``, or ``filename``/``filemode`` specified\n   together with ``stream``, or ``handlers`` specified together with\n   ``stream``.\n\n.. versionchanged:: 3.8\n   Added the ``force`` parameter.\n\n.. versionchanged:: 3.9\n   Added the ``encoding`` and ``errors`` parameters.",
      "relationships": [
        {
          "target": "stdlib.logging._acquireLock",
          "type": "calls"
        },
        {
          "target": "stdlib.logging._releaseLock",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.logging.captureWarnings",
      "name": "captureWarnings",
      "module": "logging",
      "type": "function",
      "signature": "(capture)",
      "description": "If capture is true, redirect all warnings to the logging package.\nIf capture is False, ensure that warnings are not redirected to logging\nbut to their original destinations.",
      "relationships": []
    },
    {
      "id": "stdlib.logging.critical",
      "name": "critical",
      "module": "logging",
      "type": "function",
      "signature": "(msg, *args, **kwargs)",
      "description": "Log a message with severity 'CRITICAL' on the root logger. If the logger\nhas no handlers, call basicConfig() to add a console handler with a\npre-defined format.",
      "relationships": [
        {
          "target": "stdlib.logging.basicConfig",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.logging.currentframe",
      "name": "currentframe",
      "module": "logging",
      "type": "function",
      "signature": "()",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.logging.debug",
      "name": "debug",
      "module": "logging",
      "type": "function",
      "signature": "(msg, *args, **kwargs)",
      "description": "Log a message with severity 'DEBUG' on the root logger. If the logger has\nno handlers, call basicConfig() to add a console handler with a pre-defined\nformat.",
      "relationships": [
        {
          "target": "stdlib.logging.basicConfig",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.logging.disable",
      "name": "disable",
      "module": "logging",
      "type": "function",
      "signature": "(level=50)",
      "description": "Disable all logging calls of severity 'level' and below.",
      "relationships": []
    },
    {
      "id": "stdlib.logging.error",
      "name": "error",
      "module": "logging",
      "type": "function",
      "signature": "(msg, *args, **kwargs)",
      "description": "Log a message with severity 'ERROR' on the root logger. If the logger has\nno handlers, call basicConfig() to add a console handler with a pre-defined\nformat.",
      "relationships": [
        {
          "target": "stdlib.logging.basicConfig",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.logging.exception",
      "name": "exception",
      "module": "logging",
      "type": "function",
      "signature": "(msg, *args, exc_info=True, **kwargs)",
      "description": "Log a message with severity 'ERROR' on the root logger, with exception\ninformation. If the logger has no handlers, basicConfig() is called to add\na console handler with a pre-defined format.",
      "relationships": [
        {
          "target": "stdlib.logging.error",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.logging.fatal",
      "name": "fatal",
      "module": "logging",
      "type": "function",
      "signature": "(msg, *args, **kwargs)",
      "description": "Don't use this function, use critical() instead.",
      "relationships": [
        {
          "target": "stdlib.logging.critical",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.logging.getHandlerByName",
      "name": "getHandlerByName",
      "module": "logging",
      "type": "function",
      "signature": "(name)",
      "description": "Get a handler with the specified *name*, or None if there isn't one with\nthat name.",
      "relationships": []
    },
    {
      "id": "stdlib.logging.getHandlerNames",
      "name": "getHandlerNames",
      "module": "logging",
      "type": "function",
      "signature": "()",
      "description": "Return all known handler names as an immutable set.",
      "relationships": []
    },
    {
      "id": "stdlib.logging.getLevelName",
      "name": "getLevelName",
      "module": "logging",
      "type": "function",
      "signature": "(level)",
      "description": "Return the textual or numeric representation of logging level 'level'.\n\nIf the level is one of the predefined levels (CRITICAL, ERROR, WARNING,\nINFO, DEBUG) then you get the corresponding string. If you have\nassociated levels with names using addLevelName then the name you have\nassociated with 'level' is returned.\n\nIf a numeric value corresponding to one of the defined levels is passed\nin, the corresponding string representation is returned.\n\nIf a string representation of the level is passed in, the corresponding\nnumeric value is returned.\n\nIf no matching numeric or string value is passed in, the string\n'Level %s' % level is returned.",
      "relationships": []
    },
    {
      "id": "stdlib.logging.getLevelNamesMapping",
      "name": "getLevelNamesMapping",
      "module": "logging",
      "type": "function",
      "signature": "()",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.logging.getLogRecordFactory",
      "name": "getLogRecordFactory",
      "module": "logging",
      "type": "function",
      "signature": "()",
      "description": "Return the factory to be used when instantiating a log record.",
      "relationships": []
    },
    {
      "id": "stdlib.logging.getLogger",
      "name": "getLogger",
      "module": "logging",
      "type": "function",
      "signature": "(name=None)",
      "description": "Return a logger with the specified name, creating it if necessary.\n\nIf no name is specified, return the root logger.",
      "relationships": []
    },
    {
      "id": "stdlib.logging.getLoggerClass",
      "name": "getLoggerClass",
      "module": "logging",
      "type": "function",
      "signature": "()",
      "description": "Return the class to be used when instantiating a logger.",
      "relationships": []
    },
    {
      "id": "stdlib.logging.info",
      "name": "info",
      "module": "logging",
      "type": "function",
      "signature": "(msg, *args, **kwargs)",
      "description": "Log a message with severity 'INFO' on the root logger. If the logger has\nno handlers, call basicConfig() to add a console handler with a pre-defined\nformat.",
      "relationships": [
        {
          "target": "stdlib.logging.basicConfig",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.logging.log",
      "name": "log",
      "module": "logging",
      "type": "function",
      "signature": "(level, msg, *args, **kwargs)",
      "description": "Log 'msg % args' with the integer severity 'level' on the root logger. If\nthe logger has no handlers, call basicConfig() to add a console handler\nwith a pre-defined format.",
      "relationships": [
        {
          "target": "stdlib.logging.basicConfig",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.logging.makeLogRecord",
      "name": "makeLogRecord",
      "module": "logging",
      "type": "function",
      "signature": "(dict)",
      "description": "Make a LogRecord whose attributes are defined by the specified dictionary,\nThis function is useful for converting a logging event received over\na socket connection (which is sent as a dictionary) into a LogRecord\ninstance.",
      "relationships": []
    },
    {
      "id": "stdlib.logging.setLogRecordFactory",
      "name": "setLogRecordFactory",
      "module": "logging",
      "type": "function",
      "signature": "(factory)",
      "description": "Set the factory to be used when instantiating a log record.\n\n:param factory: A callable which will be called to instantiate\na log record.",
      "relationships": []
    },
    {
      "id": "stdlib.logging.setLoggerClass",
      "name": "setLoggerClass",
      "module": "logging",
      "type": "function",
      "signature": "(klass)",
      "description": "Set the class to be used when instantiating a logger. The class should\ndefine __init__() such that only a name argument is required, and the\n__init__() should call Logger.__init__()",
      "relationships": []
    },
    {
      "id": "stdlib.logging.shutdown",
      "name": "shutdown",
      "module": "logging",
      "type": "function",
      "signature": "(handlerList=[<weakref at 0x1056e6ac0; to '_StderrHandler' at 0x1056f46b0>])",
      "description": "Perform any cleanup actions in the logging system (e.g. flushing\nbuffers).\n\nShould be called at application exit.",
      "relationships": []
    },
    {
      "id": "stdlib.logging.warn",
      "name": "warn",
      "module": "logging",
      "type": "function",
      "signature": "(msg, *args, **kwargs)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.logging.warning",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.logging.warning",
      "name": "warning",
      "module": "logging",
      "type": "function",
      "signature": "(msg, *args, **kwargs)",
      "description": "Log a message with severity 'WARNING' on the root logger. If the logger has\nno handlers, call basicConfig() to add a console handler with a pre-defined\nformat.",
      "relationships": [
        {
          "target": "stdlib.logging.basicConfig",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.lzma.LZMAFile",
      "name": "LZMAFile",
      "module": "lzma",
      "type": "class",
      "signature": "(filename=None, mode='r', *, format=None, check=-1, preset=None, filters=None)",
      "description": "A file object providing transparent LZMA (de)compression.\n\nAn LZMAFile can act as a wrapper for an existing file object, or\nrefer directly to a named file on disk.\n\nNote that LZMAFile provides a *binary* file interface - data read\nis returned as bytes, and data to be written must be given as bytes.",
      "relationships": [
        {
          "target": "stdlib._compression.BaseStream",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.BufferedIOBase",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins._BufferedIOBase",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.IOBase",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins._IOBase",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.lzma.compress",
      "name": "compress",
      "module": "lzma",
      "type": "function",
      "signature": "(data, format=1, check=-1, preset=None, filters=None)",
      "description": "Compress a block of data.\n\nRefer to LZMACompressor's docstring for a description of the\noptional arguments *format*, *check*, *preset* and *filters*.\n\nFor incremental compression, use an LZMACompressor instead.",
      "relationships": []
    },
    {
      "id": "stdlib.lzma.decompress",
      "name": "decompress",
      "module": "lzma",
      "type": "function",
      "signature": "(data, format=0, memlimit=None, filters=None)",
      "description": "Decompress a block of data.\n\nRefer to LZMADecompressor's docstring for a description of the\noptional arguments *format*, *check* and *filters*.\n\nFor incremental decompression, use an LZMADecompressor instead.",
      "relationships": []
    },
    {
      "id": "stdlib.lzma.open",
      "name": "open",
      "module": "lzma",
      "type": "function",
      "signature": "(filename, mode='rb', *, format=None, check=-1, preset=None, filters=None, encoding=None, errors=None, newline=None)",
      "description": "Open an LZMA-compressed file in binary or text mode.\n\nfilename can be either an actual file name (given as a str, bytes,\nor PathLike object), in which case the named file is opened, or it\ncan be an existing file object to read from or write to.\n\nThe mode argument can be \"r\", \"rb\" (default), \"w\", \"wb\", \"x\", \"xb\",\n\"a\", or \"ab\" for binary mode, or \"rt\", \"wt\", \"xt\", or \"at\" for text\nmode.\n\nThe format, check, preset and filters arguments specify the\ncompression settings, as for LZMACompressor, LZMADecompressor and\nLZMAFile.\n\nFor binary mode, this function is equivalent to the LZMAFile\nconstructor: LZMAFile(filename, mode, ...). In this case, the\nencoding, errors and newline arguments must not be provided.\n\nFor text mode, an LZMAFile object is created, and wrapped in an\nio.TextIOWrapper instance with the specified encoding, error\nhandling behavior, and line ending(s).",
      "relationships": []
    },
    {
      "id": "stdlib.mailbox.Babyl",
      "name": "Babyl",
      "module": "mailbox",
      "type": "class",
      "signature": "(path, factory=None, create=True)",
      "description": "An Rmail-style Babyl mailbox.",
      "relationships": [
        {
          "target": "stdlib.mailbox._singlefileMailbox",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Mailbox",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.mailbox.BabylMessage",
      "name": "BabylMessage",
      "module": "mailbox",
      "type": "class",
      "signature": "(message=None)",
      "description": "Message with Babyl-specific properties.",
      "relationships": [
        {
          "target": "stdlib.mailbox.Message",
          "type": "base_class"
        },
        {
          "target": "stdlib.mailbox.Message",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.mailbox.MH",
      "name": "MH",
      "module": "mailbox",
      "type": "class",
      "signature": "(path, factory=None, create=True)",
      "description": "An MH mailbox.",
      "relationships": [
        {
          "target": "stdlib.mailbox.Mailbox",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.mailbox.MHMessage",
      "name": "MHMessage",
      "module": "mailbox",
      "type": "class",
      "signature": "(message=None)",
      "description": "Message with MH-specific properties.",
      "relationships": [
        {
          "target": "stdlib.mailbox.Message",
          "type": "base_class"
        },
        {
          "target": "stdlib.mailbox.Message",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.mailbox.MMDF",
      "name": "MMDF",
      "module": "mailbox",
      "type": "class",
      "signature": "(path, factory=None, create=True)",
      "description": "An MMDF mailbox.",
      "relationships": [
        {
          "target": "stdlib.mailbox._mboxMMDF",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins._singlefileMailbox",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Mailbox",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.mailbox.MMDFMessage",
      "name": "MMDFMessage",
      "module": "mailbox",
      "type": "class",
      "signature": "(message=None)",
      "description": "Message with MMDF-specific properties.",
      "relationships": [
        {
          "target": "stdlib.mailbox._mboxMMDFMessage",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Message",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Message",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.mailbox.Mailbox",
      "name": "Mailbox",
      "module": "mailbox",
      "type": "class",
      "signature": "(path, factory=None, create=True)",
      "description": "A group of messages in a particular place.",
      "relationships": []
    },
    {
      "id": "stdlib.mailbox.Maildir",
      "name": "Maildir",
      "module": "mailbox",
      "type": "class",
      "signature": "(dirname, factory=None, create=True)",
      "description": "A qmail-style Maildir mailbox.",
      "relationships": [
        {
          "target": "stdlib.mailbox.Mailbox",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.mailbox.MaildirMessage",
      "name": "MaildirMessage",
      "module": "mailbox",
      "type": "class",
      "signature": "(message=None)",
      "description": "Message with Maildir-specific properties.",
      "relationships": [
        {
          "target": "stdlib.mailbox.Message",
          "type": "base_class"
        },
        {
          "target": "stdlib.mailbox.Message",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.mailbox.Message",
      "name": "Message",
      "module": "mailbox",
      "type": "class",
      "signature": "(message=None)",
      "description": "Message with mailbox-format-specific properties.",
      "relationships": [
        {
          "target": "stdlib.email.message.Message",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.mailbox.mbox",
      "name": "mbox",
      "module": "mailbox",
      "type": "class",
      "signature": "(path, factory=None, create=True)",
      "description": "A classic mbox mailbox.",
      "relationships": [
        {
          "target": "stdlib.mailbox._mboxMMDF",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins._singlefileMailbox",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Mailbox",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.mailbox.mboxMessage",
      "name": "mboxMessage",
      "module": "mailbox",
      "type": "class",
      "signature": "(message=None)",
      "description": "Message with mbox-specific properties.",
      "relationships": [
        {
          "target": "stdlib.mailbox._mboxMMDFMessage",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Message",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Message",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.mailcap.findmatch",
      "name": "findmatch",
      "module": "mailcap",
      "type": "function",
      "signature": "(caps, MIMEtype, key='view', filename='/dev/null', plist=[])",
      "description": "Find a match for a mailcap entry.\n\nReturn a tuple containing the command line, and the mailcap entry\nused; (None, None) if no match is found.  This may invoke the\n'test' command of several matching entries before deciding which\nentry to use.",
      "relationships": [
        {
          "target": "stdlib.mailcap.lookup",
          "type": "calls"
        },
        {
          "target": "stdlib.mailcap.subst",
          "type": "calls"
        },
        {
          "target": "stdlib.mailcap.subst",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.mailcap.findparam",
      "name": "findparam",
      "module": "mailcap",
      "type": "function",
      "signature": "(name, plist)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.mailcap.getcaps",
      "name": "getcaps",
      "module": "mailcap",
      "type": "function",
      "signature": "()",
      "description": "Return a dictionary containing the mailcap database.\n\nThe dictionary maps a MIME type (in all lowercase, e.g. 'text/plain')\nto a list of dictionaries corresponding to mailcap entries.  The list\ncollects all the entries for that MIME type from all available mailcap\nfiles.  Each dictionary contains key-value pairs for that MIME type,\nwhere the viewing command is stored with the key \"view\".",
      "relationships": [
        {
          "target": "stdlib.mailcap.listmailcapfiles",
          "type": "calls"
        },
        {
          "target": "stdlib.mailcap._readmailcapfile",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.mailcap.lineno_sort_key",
      "name": "lineno_sort_key",
      "module": "mailcap",
      "type": "function",
      "signature": "(entry)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.mailcap.listmailcapfiles",
      "name": "listmailcapfiles",
      "module": "mailcap",
      "type": "function",
      "signature": "()",
      "description": "Return a list of all mailcap files found on the system.",
      "relationships": []
    },
    {
      "id": "stdlib.mailcap.lookup",
      "name": "lookup",
      "module": "mailcap",
      "type": "function",
      "signature": "(caps, MIMEtype, key=None)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.mailcap.parsefield",
      "name": "parsefield",
      "module": "mailcap",
      "type": "function",
      "signature": "(line, i, n)",
      "description": "Separate one key-value pair in a mailcap entry.",
      "relationships": []
    },
    {
      "id": "stdlib.mailcap.parseline",
      "name": "parseline",
      "module": "mailcap",
      "type": "function",
      "signature": "(line)",
      "description": "Parse one entry in a mailcap file and return a dictionary.\n\nThe viewing command is stored as the value with the key \"view\",\nand the rest of the fields produce key-value pairs in the dict.",
      "relationships": [
        {
          "target": "stdlib.mailcap.parsefield",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.mailcap.readmailcapfile",
      "name": "readmailcapfile",
      "module": "mailcap",
      "type": "function",
      "signature": "(fp)",
      "description": "Read a mailcap file and return a dictionary keyed by MIME type.",
      "relationships": [
        {
          "target": "stdlib.mailcap._readmailcapfile",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.mailcap.show",
      "name": "show",
      "module": "mailcap",
      "type": "function",
      "signature": "(caps)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.mailcap.listmailcapfiles",
          "type": "calls"
        },
        {
          "target": "stdlib.mailcap.getcaps",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.mailcap.subst",
      "name": "subst",
      "module": "mailcap",
      "type": "function",
      "signature": "(field, MIMEtype, filename, plist=[])",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.mailcap.findparam",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.mailcap.test",
      "name": "test",
      "module": "mailcap",
      "type": "function",
      "signature": "()",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.mailcap.getcaps",
          "type": "calls"
        },
        {
          "target": "stdlib.mailcap.show",
          "type": "calls"
        },
        {
          "target": "stdlib.mailcap.findmatch",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.mimetypes.MimeTypes",
      "name": "MimeTypes",
      "module": "mimetypes",
      "type": "class",
      "signature": "(filenames=(), strict=True)",
      "description": "MIME-types datastore.\n\nThis datastore can handle information from mime.types-style files\nand supports basic determination of MIME type from a filename or\nURL, and can guess a reasonable extension given a MIME type.",
      "relationships": []
    },
    {
      "id": "stdlib.mimetypes.add_type",
      "name": "add_type",
      "module": "mimetypes",
      "type": "function",
      "signature": "(type, ext, strict=True)",
      "description": "Add a mapping between a type and an extension.\n\nWhen the extension is already known, the new\ntype will replace the old one. When the type\nis already known the extension will be added\nto the list of known extensions.\n\nIf strict is true, information will be added to\nlist of standard types, else to the list of non-standard\ntypes.",
      "relationships": [
        {
          "target": "stdlib.mimetypes.init",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.mimetypes.guess_all_extensions",
      "name": "guess_all_extensions",
      "module": "mimetypes",
      "type": "function",
      "signature": "(type, strict=True)",
      "description": "Guess the extensions for a file based on its MIME type.\n\nReturn value is a list of strings giving the possible filename\nextensions, including the leading dot ('.').  The extension is not\nguaranteed to have been associated with any particular data\nstream, but would be mapped to the MIME type `type' by\nguess_type().  If no extension can be guessed for `type', None\nis returned.\n\nOptional `strict' argument when false adds a bunch of commonly found,\nbut non-standard types.",
      "relationships": [
        {
          "target": "stdlib.mimetypes.init",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.mimetypes.guess_extension",
      "name": "guess_extension",
      "module": "mimetypes",
      "type": "function",
      "signature": "(type, strict=True)",
      "description": "Guess the extension for a file based on its MIME type.\n\nReturn value is a string giving a filename extension, including the\nleading dot ('.').  The extension is not guaranteed to have been\nassociated with any particular data stream, but would be mapped to the\nMIME type `type' by guess_type().  If no extension can be guessed for\n`type', None is returned.\n\nOptional `strict' argument when false adds a bunch of commonly found,\nbut non-standard types.",
      "relationships": [
        {
          "target": "stdlib.mimetypes.init",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.mimetypes.guess_type",
      "name": "guess_type",
      "module": "mimetypes",
      "type": "function",
      "signature": "(url, strict=True)",
      "description": "Guess the type of a file based on its URL.\n\nReturn value is a tuple (type, encoding) where type is None if the\ntype can't be guessed (no or unknown suffix) or a string of the\nform type/subtype, usable for a MIME Content-type header; and\nencoding is None for no encoding or the name of the program used\nto encode (e.g. compress or gzip).  The mappings are table\ndriven.  Encoding suffixes are case sensitive; type suffixes are\nfirst tried case sensitive, then case insensitive.\n\nThe suffixes .tgz, .taz and .tz (case sensitive!) are all mapped\nto \".tar.gz\".  (This is table-driven too, using the dictionary\nsuffix_map).\n\nOptional `strict' argument when false adds a bunch of commonly found, but\nnon-standard types.",
      "relationships": [
        {
          "target": "stdlib.mimetypes.init",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.mimetypes.init",
      "name": "init",
      "module": "mimetypes",
      "type": "function",
      "signature": "(files=None)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.mimetypes.read_mime_types",
      "name": "read_mime_types",
      "module": "mimetypes",
      "type": "function",
      "signature": "(file)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.modulefinder.AddPackagePath",
      "name": "AddPackagePath",
      "module": "modulefinder",
      "type": "function",
      "signature": "(packagename, path)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.modulefinder.Module",
      "name": "Module",
      "module": "modulefinder",
      "type": "class",
      "signature": "(name, file=None, path=None)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.modulefinder.ModuleFinder",
      "name": "ModuleFinder",
      "module": "modulefinder",
      "type": "class",
      "signature": "(path=None, debug=0, excludes=None, replace_paths=None)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.modulefinder.ReplacePackage",
      "name": "ReplacePackage",
      "module": "modulefinder",
      "type": "function",
      "signature": "(oldname, newname)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.modulefinder.test",
      "name": "test",
      "module": "modulefinder",
      "type": "function",
      "signature": "()",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.netrc.NetrcParseError",
      "name": "NetrcParseError",
      "module": "netrc",
      "type": "class",
      "signature": "(msg, filename=None, lineno=None)",
      "description": "Exception raised on syntax errors in the .netrc file.",
      "relationships": [
        {
          "target": "stdlib.builtins.Exception",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.netrc.netrc",
      "name": "netrc",
      "module": "netrc",
      "type": "class",
      "signature": "(file=None)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.nntplib.ArticleInfo",
      "name": "ArticleInfo",
      "module": "nntplib",
      "type": "class",
      "signature": "(number, message_id, lines)",
      "description": "ArticleInfo(number, message_id, lines)",
      "relationships": [
        {
          "target": "stdlib.builtins.tuple",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.nntplib.GroupInfo",
      "name": "GroupInfo",
      "module": "nntplib",
      "type": "class",
      "signature": "(group, last, first, flag)",
      "description": "GroupInfo(group, last, first, flag)",
      "relationships": [
        {
          "target": "stdlib.builtins.tuple",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.nntplib.NNTP",
      "name": "NNTP",
      "module": "nntplib",
      "type": "class",
      "signature": "(host, port=119, user=None, password=None, readermode=None, usenetrc=False, timeout=<object object at 0x100108a90>)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.nntplib.NNTPDataError",
      "name": "NNTPDataError",
      "module": "nntplib",
      "type": "class",
      "signature": "(*args)",
      "description": "Error in response data",
      "relationships": [
        {
          "target": "stdlib.nntplib.NNTPError",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Exception",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.nntplib.NNTPError",
      "name": "NNTPError",
      "module": "nntplib",
      "type": "class",
      "signature": "(*args)",
      "description": "Base class for all nntplib exceptions",
      "relationships": [
        {
          "target": "stdlib.builtins.Exception",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.nntplib.NNTPPermanentError",
      "name": "NNTPPermanentError",
      "module": "nntplib",
      "type": "class",
      "signature": "(*args)",
      "description": "5xx errors",
      "relationships": [
        {
          "target": "stdlib.nntplib.NNTPError",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Exception",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.nntplib.NNTPProtocolError",
      "name": "NNTPProtocolError",
      "module": "nntplib",
      "type": "class",
      "signature": "(*args)",
      "description": "Response does not begin with [1-5]",
      "relationships": [
        {
          "target": "stdlib.nntplib.NNTPError",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Exception",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.nntplib.NNTPReplyError",
      "name": "NNTPReplyError",
      "module": "nntplib",
      "type": "class",
      "signature": "(*args)",
      "description": "Unexpected [123]xx reply",
      "relationships": [
        {
          "target": "stdlib.nntplib.NNTPError",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Exception",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.nntplib.NNTPTemporaryError",
      "name": "NNTPTemporaryError",
      "module": "nntplib",
      "type": "class",
      "signature": "(*args)",
      "description": "4xx errors",
      "relationships": [
        {
          "target": "stdlib.nntplib.NNTPError",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Exception",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.nntplib.NNTP_SSL",
      "name": "NNTP_SSL",
      "module": "nntplib",
      "type": "class",
      "signature": "(host, port=563, user=None, password=None, ssl_context=None, readermode=None, usenetrc=False, timeout=<object object at 0x100108a90>)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.nntplib.NNTP",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.nntplib.decode_header",
      "name": "decode_header",
      "module": "nntplib",
      "type": "function",
      "signature": "(header_str)",
      "description": "Takes a unicode string representing a munged header value\nand decodes it as a (possibly non-ASCII) readable value.",
      "relationships": []
    },
    {
      "id": "stdlib.ntpath.abspath",
      "name": "abspath",
      "module": "ntpath",
      "type": "function",
      "signature": "(path)",
      "description": "Return the absolute version of a path.",
      "relationships": []
    },
    {
      "id": "stdlib.ntpath.basename",
      "name": "basename",
      "module": "ntpath",
      "type": "function",
      "signature": "(p)",
      "description": "Returns the final component of a pathname",
      "relationships": []
    },
    {
      "id": "stdlib.ntpath.commonpath",
      "name": "commonpath",
      "module": "ntpath",
      "type": "function",
      "signature": "(paths)",
      "description": "Given a sequence of path names, returns the longest common sub-path.",
      "relationships": []
    },
    {
      "id": "stdlib.ntpath.dirname",
      "name": "dirname",
      "module": "ntpath",
      "type": "function",
      "signature": "(p)",
      "description": "Returns the directory component of a pathname",
      "relationships": []
    },
    {
      "id": "stdlib.ntpath.expanduser",
      "name": "expanduser",
      "module": "ntpath",
      "type": "function",
      "signature": "(path)",
      "description": "Expand ~ and ~user constructs.\n\nIf user or $HOME is unknown, do nothing.",
      "relationships": []
    },
    {
      "id": "stdlib.ntpath.expandvars",
      "name": "expandvars",
      "module": "ntpath",
      "type": "function",
      "signature": "(path)",
      "description": "Expand shell variables of the forms $var, ${var} and %var%.\n\nUnknown variables are left unchanged.",
      "relationships": []
    },
    {
      "id": "stdlib.ntpath.isabs",
      "name": "isabs",
      "module": "ntpath",
      "type": "function",
      "signature": "(s)",
      "description": "Test whether a path is absolute",
      "relationships": []
    },
    {
      "id": "stdlib.ntpath.isdevdrive",
      "name": "isdevdrive",
      "module": "ntpath",
      "type": "function",
      "signature": "(path)",
      "description": "Determines whether the specified path is on a Windows Dev Drive.",
      "relationships": []
    },
    {
      "id": "stdlib.ntpath.isjunction",
      "name": "isjunction",
      "module": "ntpath",
      "type": "function",
      "signature": "(path)",
      "description": "Test whether a path is a junction",
      "relationships": []
    },
    {
      "id": "stdlib.ntpath.ismount",
      "name": "ismount",
      "module": "ntpath",
      "type": "function",
      "signature": "(path)",
      "description": "Test whether a path is a mount point (a drive root, the root of a\nshare, or a mounted volume)",
      "relationships": []
    },
    {
      "id": "stdlib.ntpath.join",
      "name": "join",
      "module": "ntpath",
      "type": "function",
      "signature": "(path, *paths)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.ntpath.lexists",
      "name": "lexists",
      "module": "ntpath",
      "type": "function",
      "signature": "(path)",
      "description": "Test whether a path exists.  Returns True for broken symbolic links",
      "relationships": []
    },
    {
      "id": "stdlib.ntpath.normcase",
      "name": "normcase",
      "module": "ntpath",
      "type": "function",
      "signature": "(s)",
      "description": "Normalize case of pathname.\n\nMakes all characters lowercase and all slashes into backslashes.",
      "relationships": []
    },
    {
      "id": "stdlib.ntpath.normpath",
      "name": "normpath",
      "module": "ntpath",
      "type": "function",
      "signature": "(path)",
      "description": "Normalize path, eliminating double slashes, etc.",
      "relationships": []
    },
    {
      "id": "stdlib.ntpath.realpath",
      "name": "realpath",
      "module": "ntpath",
      "type": "function",
      "signature": "(path, *, strict=False)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.ntpath.relpath",
      "name": "relpath",
      "module": "ntpath",
      "type": "function",
      "signature": "(path, start=None)",
      "description": "Return a relative version of a path",
      "relationships": []
    },
    {
      "id": "stdlib.ntpath.split",
      "name": "split",
      "module": "ntpath",
      "type": "function",
      "signature": "(p)",
      "description": "Split a pathname.\n\nReturn tuple (head, tail) where tail is everything after the final slash.\nEither part may be empty.",
      "relationships": []
    },
    {
      "id": "stdlib.ntpath.splitdrive",
      "name": "splitdrive",
      "module": "ntpath",
      "type": "function",
      "signature": "(p)",
      "description": "Split a pathname into drive/UNC sharepoint and relative path specifiers.\nReturns a 2-tuple (drive_or_unc, path); either part may be empty.\n\nIf you assign\n    result = splitdrive(p)\nIt is always true that:\n    result[0] + result[1] == p\n\nIf the path contained a drive letter, drive_or_unc will contain everything\nup to and including the colon.  e.g. splitdrive(\"c:/dir\") returns (\"c:\", \"/dir\")\n\nIf the path contained a UNC path, the drive_or_unc will contain the host name\nand share up to but not including the fourth directory separator character.\ne.g. splitdrive(\"//host/computer/dir\") returns (\"//host/computer\", \"/dir\")\n\nPaths cannot contain both a drive letter and a UNC path.",
      "relationships": []
    },
    {
      "id": "stdlib.ntpath.splitext",
      "name": "splitext",
      "module": "ntpath",
      "type": "function",
      "signature": "(p)",
      "description": "Split the extension from a pathname.\n\nExtension is everything from the last dot to the end, ignoring\nleading dots.  Returns \"(root, ext)\"; ext may be empty.",
      "relationships": []
    },
    {
      "id": "stdlib.ntpath.splitroot",
      "name": "splitroot",
      "module": "ntpath",
      "type": "function",
      "signature": "(p)",
      "description": "Split a pathname into drive, root and tail. The drive is defined\nexactly as in splitdrive(). On Windows, the root may be a single path\nseparator or an empty string. The tail contains anything after the root.\nFor example:\n\n    splitroot('//server/share/') == ('//server/share', '/', '')\n    splitroot('C:/Users/Barney') == ('C:', '/', 'Users/Barney')\n    splitroot('C:///spam///ham') == ('C:', '/', '//spam///ham')\n    splitroot('Windows/notepad') == ('', '', 'Windows/notepad')",
      "relationships": []
    },
    {
      "id": "stdlib.nturl2path.pathname2url",
      "name": "pathname2url",
      "module": "nturl2path",
      "type": "function",
      "signature": "(p)",
      "description": "OS-specific conversion from a file system path to a relative URL\nof the 'file' scheme; not recommended for general use.",
      "relationships": []
    },
    {
      "id": "stdlib.nturl2path.url2pathname",
      "name": "url2pathname",
      "module": "nturl2path",
      "type": "function",
      "signature": "(url)",
      "description": "OS-specific conversion from a relative URL of the 'file' scheme\nto a file system path; not recommended for general use.",
      "relationships": []
    },
    {
      "id": "stdlib.numbers.Complex",
      "name": "Complex",
      "module": "numbers",
      "type": "class",
      "signature": "()",
      "description": "Complex defines the operations that work on the builtin complex type.\n\nIn short, those are: a conversion to complex, .real, .imag, +, -,\n*, /, **, abs(), .conjugate, ==, and !=.\n\nIf it is given heterogeneous arguments, and doesn't have special\nknowledge about them, it should fall back to the builtin complex\ntype as described below.",
      "relationships": [
        {
          "target": "stdlib.numbers.Number",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.numbers.Integral",
      "name": "Integral",
      "module": "numbers",
      "type": "class",
      "signature": "()",
      "description": "Integral adds methods that work on integral numbers.\n\nIn short, these are conversion to int, pow with modulus, and the\nbit-string operations.",
      "relationships": [
        {
          "target": "stdlib.numbers.Rational",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Real",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Complex",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Number",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.numbers.Number",
      "name": "Number",
      "module": "numbers",
      "type": "class",
      "signature": "()",
      "description": "All numbers inherit from this class.\n\nIf you just want to check if an argument x is a number, without\ncaring what kind, use isinstance(x, Number).",
      "relationships": []
    },
    {
      "id": "stdlib.numbers.Rational",
      "name": "Rational",
      "module": "numbers",
      "type": "class",
      "signature": "()",
      "description": ".numerator and .denominator should be in lowest terms.",
      "relationships": [
        {
          "target": "stdlib.numbers.Real",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Complex",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Number",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.numbers.Real",
      "name": "Real",
      "module": "numbers",
      "type": "class",
      "signature": "()",
      "description": "To Complex, Real adds the operations that work on real numbers.\n\nIn short, those are: a conversion to float, trunc(), divmod,\n%, <, <=, >, and >=.\n\nReal also provides defaults for the derived operations.",
      "relationships": [
        {
          "target": "stdlib.numbers.Complex",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Number",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.opcode.is_pseudo",
      "name": "is_pseudo",
      "module": "opcode",
      "type": "function",
      "signature": "(op)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.operator.attrgetter",
      "name": "attrgetter",
      "module": "operator",
      "type": "class",
      "signature": "(attr, /, *attrs)",
      "description": "Return a callable object that fetches the given attribute(s) from its operand.\nAfter f = attrgetter('name'), the call f(r) returns r.name.\nAfter g = attrgetter('name', 'date'), the call g(r) returns (r.name, r.date).\nAfter h = attrgetter('name.first', 'name.last'), the call h(r) returns\n(r.name.first, r.name.last).",
      "relationships": []
    },
    {
      "id": "stdlib.operator.itemgetter",
      "name": "itemgetter",
      "module": "operator",
      "type": "class",
      "signature": "(item, /, *items)",
      "description": "Return a callable object that fetches the given item(s) from its operand.\nAfter f = itemgetter(2), the call f(r) returns r[2].\nAfter g = itemgetter(2, 5, 3), the call g(r) returns (r[2], r[5], r[3])",
      "relationships": []
    },
    {
      "id": "stdlib.operator.methodcaller",
      "name": "methodcaller",
      "module": "operator",
      "type": "class",
      "signature": "(name, /, *args, **kwargs)",
      "description": "Return a callable object that calls the given method on its operand.\nAfter f = methodcaller('name'), the call f(r) returns r.name().\nAfter g = methodcaller('name', 'date', foo=1), the call g(r) returns\nr.name('date', foo=1).",
      "relationships": []
    },
    {
      "id": "stdlib.optparse.AmbiguousOptionError",
      "name": "AmbiguousOptionError",
      "module": "optparse",
      "type": "class",
      "signature": "(opt_str, possibilities)",
      "description": "Raised if an ambiguous option is seen on the command line.",
      "relationships": [
        {
          "target": "stdlib.optparse.BadOptionError",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.OptParseError",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Exception",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.optparse.BadOptionError",
      "name": "BadOptionError",
      "module": "optparse",
      "type": "class",
      "signature": "(opt_str)",
      "description": "Raised if an invalid option is seen on the command line.",
      "relationships": [
        {
          "target": "stdlib.optparse.OptParseError",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Exception",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.optparse.HelpFormatter",
      "name": "HelpFormatter",
      "module": "optparse",
      "type": "class",
      "signature": "(indent_increment, max_help_position, width, short_first)",
      "description": "Abstract base class for formatting option help.  OptionParser\ninstances should use one of the HelpFormatter subclasses for\nformatting help; by default IndentedHelpFormatter is used.\n\nInstance attributes:\n  parser : OptionParser\n    the controlling OptionParser instance\n  indent_increment : int\n    the number of columns to indent per nesting level\n  max_help_position : int\n    the maximum starting column for option help text\n  help_position : int\n    the calculated starting column for option help text;\n    initially the same as the maximum\n  width : int\n    total number of columns for output (pass None to constructor for\n    this value to be taken from the $COLUMNS environment variable)\n  level : int\n    current indentation level\n  current_indent : int\n    current indentation level (in columns)\n  help_width : int\n    number of columns available for option help text (calculated)\n  default_tag : str\n    text to replace with each option's default value, \"%default\"\n    by default.  Set to false value to disable default value expansion.\n  option_strings : { Option : str }\n    maps Option instances to the snippet of help text explaining\n    the syntax of that option, e.g. \"-h, --help\" or\n    \"-fFILE, --file=FILE\"\n  _short_opt_fmt : str\n    format string controlling how short options with values are\n    printed in help text.  Must be either \"%s%s\" (\"-fFILE\") or\n    \"%s %s\" (\"-f FILE\"), because those are the two syntaxes that\n    Optik supports.\n  _long_opt_fmt : str\n    similar but for long options; must be either \"%s %s\" (\"--file FILE\")\n    or \"%s=%s\" (\"--file=FILE\").",
      "relationships": []
    },
    {
      "id": "stdlib.optparse.IndentedHelpFormatter",
      "name": "IndentedHelpFormatter",
      "module": "optparse",
      "type": "class",
      "signature": "(indent_increment=2, max_help_position=24, width=None, short_first=1)",
      "description": "Format help with indented section bodies.\n    ",
      "relationships": [
        {
          "target": "stdlib.optparse.HelpFormatter",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.optparse.OptParseError",
      "name": "OptParseError",
      "module": "optparse",
      "type": "class",
      "signature": "(msg)",
      "description": "Common base class for all non-exit exceptions.",
      "relationships": [
        {
          "target": "stdlib.builtins.Exception",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.optparse.Option",
      "name": "Option",
      "module": "optparse",
      "type": "class",
      "signature": "(*opts, **attrs)",
      "description": "Instance attributes:\n  _short_opts : [string]\n  _long_opts : [string]\n\n  action : string\n  type : string\n  dest : string\n  default : any\n  nargs : int\n  const : any\n  choices : [string]\n  callback : function\n  callback_args : (any*)\n  callback_kwargs : { string : any }\n  help : string\n  metavar : string",
      "relationships": []
    },
    {
      "id": "stdlib.optparse.OptionConflictError",
      "name": "OptionConflictError",
      "module": "optparse",
      "type": "class",
      "signature": "(msg, option)",
      "description": "Raised if conflicting options are added to an OptionParser.",
      "relationships": [
        {
          "target": "stdlib.optparse.OptionError",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.OptParseError",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Exception",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.optparse.OptionContainer",
      "name": "OptionContainer",
      "module": "optparse",
      "type": "class",
      "signature": "(option_class, conflict_handler, description)",
      "description": "Abstract base class.\n\nClass attributes:\n  standard_option_list : [Option]\n    list of standard options that will be accepted by all instances\n    of this parser class (intended to be overridden by subclasses).\n\nInstance attributes:\n  option_list : [Option]\n    the list of Option objects contained by this OptionContainer\n  _short_opt : { string : Option }\n    dictionary mapping short option strings, eg. \"-f\" or \"-X\",\n    to the Option instances that implement them.  If an Option\n    has multiple short option strings, it will appear in this\n    dictionary multiple times. [1]\n  _long_opt : { string : Option }\n    dictionary mapping long option strings, eg. \"--file\" or\n    \"--exclude\", to the Option instances that implement them.\n    Again, a given Option can occur multiple times in this\n    dictionary. [1]\n  defaults : { string : any }\n    dictionary mapping option destination names to default\n    values for each destination [1]\n\n[1] These mappings are common to (shared by) all components of the\n    controlling OptionParser, where they are initially created.",
      "relationships": []
    },
    {
      "id": "stdlib.optparse.OptionError",
      "name": "OptionError",
      "module": "optparse",
      "type": "class",
      "signature": "(msg, option)",
      "description": "Raised if an Option instance is created with invalid or\ninconsistent arguments.",
      "relationships": [
        {
          "target": "stdlib.optparse.OptParseError",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Exception",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.optparse.OptionGroup",
      "name": "OptionGroup",
      "module": "optparse",
      "type": "class",
      "signature": "(parser, title, description=None)",
      "description": "Abstract base class.\n\nClass attributes:\n  standard_option_list : [Option]\n    list of standard options that will be accepted by all instances\n    of this parser class (intended to be overridden by subclasses).\n\nInstance attributes:\n  option_list : [Option]\n    the list of Option objects contained by this OptionContainer\n  _short_opt : { string : Option }\n    dictionary mapping short option strings, eg. \"-f\" or \"-X\",\n    to the Option instances that implement them.  If an Option\n    has multiple short option strings, it will appear in this\n    dictionary multiple times. [1]\n  _long_opt : { string : Option }\n    dictionary mapping long option strings, eg. \"--file\" or\n    \"--exclude\", to the Option instances that implement them.\n    Again, a given Option can occur multiple times in this\n    dictionary. [1]\n  defaults : { string : any }\n    dictionary mapping option destination names to default\n    values for each destination [1]\n\n[1] These mappings are common to (shared by) all components of the\n    controlling OptionParser, where they are initially created.",
      "relationships": [
        {
          "target": "stdlib.optparse.OptionContainer",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.optparse.OptionParser",
      "name": "OptionParser",
      "module": "optparse",
      "type": "class",
      "signature": "(usage=None, option_list=None, option_class=<class 'optparse.Option'>, version=None, conflict_handler='error', description=None, formatter=None, add_help_option=True, prog=None, epilog=None)",
      "description": "Class attributes:\n  standard_option_list : [Option]\n    list of standard options that will be accepted by all instances\n    of this parser class (intended to be overridden by subclasses).\n\nInstance attributes:\n  usage : string\n    a usage string for your program.  Before it is displayed\n    to the user, \"%prog\" will be expanded to the name of\n    your program (self.prog or os.path.basename(sys.argv[0])).\n  prog : string\n    the name of the current program (to override\n    os.path.basename(sys.argv[0])).\n  description : string\n    A paragraph of text giving a brief overview of your program.\n    optparse reformats this paragraph to fit the current terminal\n    width and prints it when the user requests help (after usage,\n    but before the list of options).\n  epilog : string\n    paragraph of help text to print after option help\n\n  option_groups : [OptionGroup]\n    list of option groups in this parser (option groups are\n    irrelevant for parsing the command-line, but very useful\n    for generating help)\n\n  allow_interspersed_args : bool = true\n    if true, positional arguments may be interspersed with options.\n    Assuming -a and -b each take a single argument, the command-line\n      -ablah foo bar -bboo baz\n    will be interpreted the same as\n      -ablah -bboo -- foo bar baz\n    If this flag were false, that command line would be interpreted as\n      -ablah -- foo bar -bboo baz\n    -- ie. we stop processing options as soon as we see the first\n    non-option argument.  (This is the tradition followed by\n    Python's getopt module, Perl's Getopt::Std, and other argument-\n    parsing libraries, but it is generally annoying to users.)\n\n  process_default_values : bool = true\n    if true, option default values are processed similarly to option\n    values from the command line: that is, they are passed to the\n    type-checking function for the option's type (as long as the\n    default value is a string).  (This really only matters if you\n    have defined custom types; see SF bug #955889.)  Set it to false\n    to restore the behaviour of Optik 1.4.1 and earlier.\n\n  rargs : [string]\n    the argument list currently being parsed.  Only set when\n    parse_args() is active, and continually trimmed down as\n    we consume arguments.  Mainly there for the benefit of\n    callback options.\n  largs : [string]\n    the list of leftover arguments that we have skipped while\n    parsing options.  If allow_interspersed_args is false, this\n    list is always empty.\n  values : Values\n    the set of option values currently being accumulated.  Only\n    set when parse_args() is active.  Also mainly for callbacks.\n\nBecause of the 'rargs', 'largs', and 'values' attributes,\nOptionParser is not thread-safe.  If, for some perverse reason, you\nneed to parse command-line arguments simultaneously in different\nthreads, use different OptionParser instances.",
      "relationships": [
        {
          "target": "stdlib.optparse.OptionContainer",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.optparse.OptionValueError",
      "name": "OptionValueError",
      "module": "optparse",
      "type": "class",
      "signature": "(msg)",
      "description": "Raised if an invalid option value is encountered on the command\nline.",
      "relationships": [
        {
          "target": "stdlib.optparse.OptParseError",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Exception",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.optparse.TitledHelpFormatter",
      "name": "TitledHelpFormatter",
      "module": "optparse",
      "type": "class",
      "signature": "(indent_increment=0, max_help_position=24, width=None, short_first=0)",
      "description": "Format help with underlined section headers.\n    ",
      "relationships": [
        {
          "target": "stdlib.optparse.HelpFormatter",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.optparse.Values",
      "name": "Values",
      "module": "optparse",
      "type": "class",
      "signature": "(defaults=None)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.optparse.check_builtin",
      "name": "check_builtin",
      "module": "optparse",
      "type": "function",
      "signature": "(option, opt, value)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.optparse.check_choice",
      "name": "check_choice",
      "module": "optparse",
      "type": "function",
      "signature": "(option, opt, value)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.optparse.make_option",
      "name": "make_option",
      "module": "optparse",
      "type": "class",
      "signature": "(*opts, **attrs)",
      "description": "Instance attributes:\n  _short_opts : [string]\n  _long_opts : [string]\n\n  action : string\n  type : string\n  dest : string\n  default : any\n  nargs : int\n  const : any\n  choices : [string]\n  callback : function\n  callback_args : (any*)\n  callback_kwargs : { string : any }\n  help : string\n  metavar : string",
      "relationships": []
    },
    {
      "id": "stdlib.os.PathLike",
      "name": "PathLike",
      "module": "os",
      "type": "class",
      "signature": "()",
      "description": "Abstract base class for implementing the file system path protocol.",
      "relationships": [
        {
          "target": "stdlib.abc.ABC",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.os.execl",
      "name": "execl",
      "module": "os",
      "type": "function",
      "signature": "(file, *args)",
      "description": "execl(file, *args)\n\nExecute the executable file with argument list args, replacing the\ncurrent process. ",
      "relationships": []
    },
    {
      "id": "stdlib.os.execle",
      "name": "execle",
      "module": "os",
      "type": "function",
      "signature": "(file, *args)",
      "description": "execle(file, *args, env)\n\nExecute the executable file with argument list args and\nenvironment env, replacing the current process. ",
      "relationships": []
    },
    {
      "id": "stdlib.os.execlp",
      "name": "execlp",
      "module": "os",
      "type": "function",
      "signature": "(file, *args)",
      "description": "execlp(file, *args)\n\nExecute the executable file (which is searched for along $PATH)\nwith argument list args, replacing the current process. ",
      "relationships": []
    },
    {
      "id": "stdlib.os.execlpe",
      "name": "execlpe",
      "module": "os",
      "type": "function",
      "signature": "(file, *args)",
      "description": "execlpe(file, *args, env)\n\nExecute the executable file (which is searched for along $PATH)\nwith argument list args and environment env, replacing the current\nprocess. ",
      "relationships": []
    },
    {
      "id": "stdlib.os.execvp",
      "name": "execvp",
      "module": "os",
      "type": "function",
      "signature": "(file, args)",
      "description": "execvp(file, args)\n\nExecute the executable file (which is searched for along $PATH)\nwith argument list args, replacing the current process.\nargs may be a list or tuple of strings. ",
      "relationships": []
    },
    {
      "id": "stdlib.os.execvpe",
      "name": "execvpe",
      "module": "os",
      "type": "function",
      "signature": "(file, args, env)",
      "description": "execvpe(file, args, env)\n\nExecute the executable file (which is searched for along $PATH)\nwith argument list args and environment env, replacing the\ncurrent process.\nargs may be a list or tuple of strings. ",
      "relationships": []
    },
    {
      "id": "stdlib.os.fdopen",
      "name": "fdopen",
      "module": "os",
      "type": "function",
      "signature": "(fd, mode='r', buffering=-1, encoding=None, *args, **kwargs)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.os.fsdecode",
      "name": "fsdecode",
      "module": "os",
      "type": "function",
      "signature": "(filename)",
      "description": "Decode filename (an os.PathLike, bytes, or str) from the filesystem\nencoding with 'surrogateescape' error handler, return str unchanged. On\nWindows, use 'strict' error handler if the file system encoding is\n'mbcs' (which is the default encoding).",
      "relationships": []
    },
    {
      "id": "stdlib.os.fsencode",
      "name": "fsencode",
      "module": "os",
      "type": "function",
      "signature": "(filename)",
      "description": "Encode filename (an os.PathLike, bytes, or str) to the filesystem\nencoding with 'surrogateescape' error handler, return bytes unchanged.\nOn Windows, use 'strict' error handler if the file system encoding is\n'mbcs' (which is the default encoding).",
      "relationships": []
    },
    {
      "id": "stdlib.os.fwalk",
      "name": "fwalk",
      "module": "os",
      "type": "function",
      "signature": "(top='.', topdown=True, onerror=None, *, follow_symlinks=False, dir_fd=None)",
      "description": "Directory tree generator.\n\nThis behaves exactly like walk(), except that it yields a 4-tuple\n\n    dirpath, dirnames, filenames, dirfd\n\n`dirpath`, `dirnames` and `filenames` are identical to walk() output,\nand `dirfd` is a file descriptor referring to the directory `dirpath`.\n\nThe advantage of fwalk() over walk() is that it's safe against symlink\nraces (when follow_symlinks is False).\n\nIf dir_fd is not None, it should be a file descriptor open to a directory,\n  and top should be relative; top will then be relative to that directory.\n  (dir_fd is always supported for fwalk.)\n\nCaution:\nSince fwalk() yields file descriptors, those are only valid until the\nnext iteration step, so you should dup() them if you want to keep them\nfor a longer period.\n\nExample:\n\nimport os\nfor root, dirs, files, rootfd in os.fwalk('python/Lib/xml'):\n    print(root, \"consumes\", end=\"\")\n    print(sum(os.stat(name, dir_fd=rootfd).st_size for name in files),\n          end=\"\")\n    print(\"bytes in\", len(files), \"non-directory files\")\n    if '__pycache__' in dirs:\n        dirs.remove('__pycache__')  # don't visit __pycache__ directories",
      "relationships": []
    },
    {
      "id": "stdlib.os.get_exec_path",
      "name": "get_exec_path",
      "module": "os",
      "type": "function",
      "signature": "(env=None)",
      "description": "Returns the sequence of directories that will be searched for the\nnamed executable (similar to a shell) when launching a process.\n\n*env* must be an environment variable dict or None.  If *env* is None,\nos.environ will be used.",
      "relationships": []
    },
    {
      "id": "stdlib.os.getenv",
      "name": "getenv",
      "module": "os",
      "type": "function",
      "signature": "(key, default=None)",
      "description": "Get an environment variable, return None if it doesn't exist.\nThe optional second argument can specify an alternate default.\nkey, default and the result are str.",
      "relationships": []
    },
    {
      "id": "stdlib.os.getenvb",
      "name": "getenvb",
      "module": "os",
      "type": "function",
      "signature": "(key, default=None)",
      "description": "Get an environment variable, return None if it doesn't exist.\nThe optional second argument can specify an alternate default.\nkey, default and the result are bytes.",
      "relationships": []
    },
    {
      "id": "stdlib.os.makedirs",
      "name": "makedirs",
      "module": "os",
      "type": "function",
      "signature": "(name, mode=511, exist_ok=False)",
      "description": "makedirs(name [, mode=0o777][, exist_ok=False])\n\nSuper-mkdir; create a leaf directory and all intermediate ones.  Works like\nmkdir, except that any intermediate path segment (not just the rightmost)\nwill be created if it does not exist. If the target directory already\nexists, raise an OSError if exist_ok is False. Otherwise no exception is\nraised.  This is recursive.",
      "relationships": []
    },
    {
      "id": "stdlib.os.popen",
      "name": "popen",
      "module": "os",
      "type": "function",
      "signature": "(cmd, mode='r', buffering=-1)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.os.removedirs",
      "name": "removedirs",
      "module": "os",
      "type": "function",
      "signature": "(name)",
      "description": "removedirs(name)\n\nSuper-rmdir; remove a leaf directory and all empty intermediate\nones.  Works like rmdir except that, if the leaf directory is\nsuccessfully removed, directories corresponding to rightmost path\nsegments will be pruned away until either the whole path is\nconsumed or an error occurs.  Errors during this latter phase are\nignored -- they generally mean that a directory was not empty.",
      "relationships": []
    },
    {
      "id": "stdlib.os.renames",
      "name": "renames",
      "module": "os",
      "type": "function",
      "signature": "(old, new)",
      "description": "renames(old, new)\n\nSuper-rename; create directories as necessary and delete any left\nempty.  Works like rename, except creation of any intermediate\ndirectories needed to make the new pathname good is attempted\nfirst.  After the rename, directories corresponding to rightmost\npath segments of the old name will be pruned until either the\nwhole path is consumed or a nonempty directory is found.\n\nNote: this function can fail with the new directory structure made\nif you lack permissions needed to unlink the leaf directory or\nfile.",
      "relationships": []
    },
    {
      "id": "stdlib.os.spawnl",
      "name": "spawnl",
      "module": "os",
      "type": "function",
      "signature": "(mode, file, *args)",
      "description": "spawnl(mode, file, *args) -> integer\n\nExecute file with arguments from args in a subprocess.\nIf mode == P_NOWAIT return the pid of the process.\nIf mode == P_WAIT return the process's exit code if it exits normally;\notherwise return -SIG, where SIG is the signal that killed it. ",
      "relationships": []
    },
    {
      "id": "stdlib.os.spawnle",
      "name": "spawnle",
      "module": "os",
      "type": "function",
      "signature": "(mode, file, *args)",
      "description": "spawnle(mode, file, *args, env) -> integer\n\nExecute file with arguments from args in a subprocess with the\nsupplied environment.\nIf mode == P_NOWAIT return the pid of the process.\nIf mode == P_WAIT return the process's exit code if it exits normally;\notherwise return -SIG, where SIG is the signal that killed it. ",
      "relationships": []
    },
    {
      "id": "stdlib.os.spawnlp",
      "name": "spawnlp",
      "module": "os",
      "type": "function",
      "signature": "(mode, file, *args)",
      "description": "spawnlp(mode, file, *args) -> integer\n\nExecute file (which is looked for along $PATH) with arguments from\nargs in a subprocess with the supplied environment.\nIf mode == P_NOWAIT return the pid of the process.\nIf mode == P_WAIT return the process's exit code if it exits normally;\notherwise return -SIG, where SIG is the signal that killed it. ",
      "relationships": []
    },
    {
      "id": "stdlib.os.spawnlpe",
      "name": "spawnlpe",
      "module": "os",
      "type": "function",
      "signature": "(mode, file, *args)",
      "description": "spawnlpe(mode, file, *args, env) -> integer\n\nExecute file (which is looked for along $PATH) with arguments from\nargs in a subprocess with the supplied environment.\nIf mode == P_NOWAIT return the pid of the process.\nIf mode == P_WAIT return the process's exit code if it exits normally;\notherwise return -SIG, where SIG is the signal that killed it. ",
      "relationships": []
    },
    {
      "id": "stdlib.os.spawnv",
      "name": "spawnv",
      "module": "os",
      "type": "function",
      "signature": "(mode, file, args)",
      "description": "spawnv(mode, file, args) -> integer\n\nExecute file with arguments from args in a subprocess.\nIf mode == P_NOWAIT return the pid of the process.\nIf mode == P_WAIT return the process's exit code if it exits normally;\notherwise return -SIG, where SIG is the signal that killed it. ",
      "relationships": []
    },
    {
      "id": "stdlib.os.spawnve",
      "name": "spawnve",
      "module": "os",
      "type": "function",
      "signature": "(mode, file, args, env)",
      "description": "spawnve(mode, file, args, env) -> integer\n\nExecute file with arguments from args in a subprocess with the\nspecified environment.\nIf mode == P_NOWAIT return the pid of the process.\nIf mode == P_WAIT return the process's exit code if it exits normally;\notherwise return -SIG, where SIG is the signal that killed it. ",
      "relationships": []
    },
    {
      "id": "stdlib.os.spawnvp",
      "name": "spawnvp",
      "module": "os",
      "type": "function",
      "signature": "(mode, file, args)",
      "description": "spawnvp(mode, file, args) -> integer\n\nExecute file (which is looked for along $PATH) with arguments from\nargs in a subprocess.\nIf mode == P_NOWAIT return the pid of the process.\nIf mode == P_WAIT return the process's exit code if it exits normally;\notherwise return -SIG, where SIG is the signal that killed it. ",
      "relationships": []
    },
    {
      "id": "stdlib.os.spawnvpe",
      "name": "spawnvpe",
      "module": "os",
      "type": "function",
      "signature": "(mode, file, args, env)",
      "description": "spawnvpe(mode, file, args, env) -> integer\n\nExecute file (which is looked for along $PATH) with arguments from\nargs in a subprocess with the supplied environment.\nIf mode == P_NOWAIT return the pid of the process.\nIf mode == P_WAIT return the process's exit code if it exits normally;\notherwise return -SIG, where SIG is the signal that killed it. ",
      "relationships": []
    },
    {
      "id": "stdlib.os.stat_result",
      "name": "stat_result",
      "module": "os",
      "type": "class",
      "signature": "(iterable=(), /)",
      "description": "stat_result: Result from stat, fstat, or lstat.\n\nThis object may be accessed either as a tuple of\n  (mode, ino, dev, nlink, uid, gid, size, atime, mtime, ctime)\nor via the attributes st_mode, st_ino, st_dev, st_nlink, st_uid, and so on.\n\nPosix/windows: If your platform supports st_blksize, st_blocks, st_rdev,\nor st_flags, they are available as attributes only.\n\nSee os.stat for more information.",
      "relationships": [
        {
          "target": "stdlib.builtins.tuple",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.os.statvfs_result",
      "name": "statvfs_result",
      "module": "os",
      "type": "class",
      "signature": "(iterable=(), /)",
      "description": "statvfs_result: Result from statvfs or fstatvfs.\n\nThis object may be accessed either as a tuple of\n  (bsize, frsize, blocks, bfree, bavail, files, ffree, favail, flag, namemax),\nor via the attributes f_bsize, f_frsize, f_blocks, f_bfree, and so on.\n\nSee os.statvfs for more information.",
      "relationships": [
        {
          "target": "stdlib.builtins.tuple",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.os.terminal_size",
      "name": "terminal_size",
      "module": "os",
      "type": "class",
      "signature": "(iterable=(), /)",
      "description": "A tuple of (columns, lines) for holding terminal window size",
      "relationships": [
        {
          "target": "stdlib.builtins.tuple",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.os.walk",
      "name": "walk",
      "module": "os",
      "type": "function",
      "signature": "(top, topdown=True, onerror=None, followlinks=False)",
      "description": "Directory tree generator.\n\nFor each directory in the directory tree rooted at top (including top\nitself, but excluding '.' and '..'), yields a 3-tuple\n\n    dirpath, dirnames, filenames\n\ndirpath is a string, the path to the directory.  dirnames is a list of\nthe names of the subdirectories in dirpath (including symlinks to directories,\nand excluding '.' and '..').\nfilenames is a list of the names of the non-directory files in dirpath.\nNote that the names in the lists are just names, with no path components.\nTo get a full path (which begins with top) to a file or directory in\ndirpath, do os.path.join(dirpath, name).\n\nIf optional arg 'topdown' is true or not specified, the triple for a\ndirectory is generated before the triples for any of its subdirectories\n(directories are generated top down).  If topdown is false, the triple\nfor a directory is generated after the triples for all of its\nsubdirectories (directories are generated bottom up).\n\nWhen topdown is true, the caller can modify the dirnames list in-place\n(e.g., via del or slice assignment), and walk will only recurse into the\nsubdirectories whose names remain in dirnames; this can be used to prune the\nsearch, or to impose a specific order of visiting.  Modifying dirnames when\ntopdown is false has no effect on the behavior of os.walk(), since the\ndirectories in dirnames have already been generated by the time dirnames\nitself is generated. No matter the value of topdown, the list of\nsubdirectories is retrieved before the tuples for the directory and its\nsubdirectories are generated.\n\nBy default errors from the os.scandir() call are ignored.  If\noptional arg 'onerror' is specified, it should be a function; it\nwill be called with one argument, an OSError instance.  It can\nreport the error to continue with the walk, or raise the exception\nto abort the walk.  Note that the filename is available as the\nfilename attribute of the exception object.\n\nBy default, os.walk does not follow symbolic links to subdirectories on\nsystems that support them.  In order to get this functionality, set the\noptional argument 'followlinks' to true.\n\nCaution:  if you pass a relative pathname for top, don't change the\ncurrent working directory between resumptions of walk.  walk never\nchanges the current directory, and assumes that the client doesn't\neither.\n\nExample:\n\nimport os\nfrom os.path import join, getsize\nfor root, dirs, files in os.walk('python/Lib/xml'):\n    print(root, \"consumes \")\n    print(sum(getsize(join(root, name)) for name in files), end=\" \")\n    print(\"bytes in\", len(files), \"non-directory files\")\n    if '__pycache__' in dirs:\n        dirs.remove('__pycache__')  # don't visit __pycache__ directories",
      "relationships": []
    },
    {
      "id": "stdlib.pathlib.Path",
      "name": "Path",
      "module": "pathlib",
      "type": "class",
      "signature": "(*args, **kwargs)",
      "description": "PurePath subclass that can make system calls.\n\nPath represents a filesystem path but unlike PurePath, also offers\nmethods to do system calls on path objects. Depending on your system,\ninstantiating a Path will return either a PosixPath or a WindowsPath\nobject. You can also instantiate a PosixPath or WindowsPath directly,\nbut cannot instantiate a WindowsPath on a POSIX system or vice versa.",
      "relationships": [
        {
          "target": "stdlib.pathlib.PurePath",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.pathlib.PosixPath",
      "name": "PosixPath",
      "module": "pathlib",
      "type": "class",
      "signature": "(*args, **kwargs)",
      "description": "Path subclass for non-Windows systems.\n\nOn a POSIX system, instantiating a Path should return this object.",
      "relationships": [
        {
          "target": "stdlib.pathlib.Path",
          "type": "base_class"
        },
        {
          "target": "stdlib.pathlib.PurePosixPath",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.PurePath",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.pathlib.PurePath",
      "name": "PurePath",
      "module": "pathlib",
      "type": "class",
      "signature": "(*args, **kwargs)",
      "description": "Base class for manipulating paths without I/O.\n\nPurePath represents a filesystem path and offers operations which\ndon't imply any actual filesystem I/O.  Depending on your system,\ninstantiating a PurePath will return either a PurePosixPath or a\nPureWindowsPath object.  You can also instantiate either of these classes\ndirectly, regardless of your system.",
      "relationships": []
    },
    {
      "id": "stdlib.pathlib.PurePosixPath",
      "name": "PurePosixPath",
      "module": "pathlib",
      "type": "class",
      "signature": "(*args, **kwargs)",
      "description": "PurePath subclass for non-Windows systems.\n\nOn a POSIX system, instantiating a PurePath should return this object.\nHowever, you can also instantiate it directly on any system.",
      "relationships": [
        {
          "target": "stdlib.pathlib.PurePath",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.pathlib.PureWindowsPath",
      "name": "PureWindowsPath",
      "module": "pathlib",
      "type": "class",
      "signature": "(*args, **kwargs)",
      "description": "PurePath subclass for Windows systems.\n\nOn a Windows system, instantiating a PurePath should return this object.\nHowever, you can also instantiate it directly on any system.",
      "relationships": [
        {
          "target": "stdlib.pathlib.PurePath",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.pathlib.WindowsPath",
      "name": "WindowsPath",
      "module": "pathlib",
      "type": "class",
      "signature": "(*args, **kwargs)",
      "description": "Path subclass for Windows systems.\n\nOn a Windows system, instantiating a Path should return this object.",
      "relationships": [
        {
          "target": "stdlib.pathlib.Path",
          "type": "base_class"
        },
        {
          "target": "stdlib.pathlib.PureWindowsPath",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.PurePath",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.pdb.Pdb",
      "name": "Pdb",
      "module": "pdb",
      "type": "class",
      "signature": "(completekey='tab', stdin=None, stdout=None, skip=None, nosigint=False, readrc=True)",
      "description": "Generic Python debugger base class.\n\nThis class takes care of details of the trace facility;\na derived class should implement user interaction.\nThe standard debugger class (pdb.Pdb) is an example.\n\nThe optional skip argument must be an iterable of glob-style\nmodule name patterns.  The debugger will not step into frames\nthat originate in a module that matches one of these patterns.\nWhether a frame is considered to originate in a certain module\nis determined by the __name__ in the frame globals.",
      "relationships": [
        {
          "target": "stdlib.bdb.Bdb",
          "type": "base_class"
        },
        {
          "target": "stdlib.cmd.Cmd",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.pdb.find_function",
      "name": "find_function",
      "module": "pdb",
      "type": "function",
      "signature": "(funcname, filename)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.pdb.help",
      "name": "help",
      "module": "pdb",
      "type": "function",
      "signature": "()",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.pdb.lasti2lineno",
      "name": "lasti2lineno",
      "module": "pdb",
      "type": "function",
      "signature": "(code, lasti)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.pdb.main",
      "name": "main",
      "module": "pdb",
      "type": "function",
      "signature": "()",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.pdb.pm",
      "name": "pm",
      "module": "pdb",
      "type": "function",
      "signature": "()",
      "description": "Enter post-mortem debugging of the traceback found in sys.last_traceback.",
      "relationships": [
        {
          "target": "stdlib.pdb.post_mortem",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pdb.post_mortem",
      "name": "post_mortem",
      "module": "pdb",
      "type": "function",
      "signature": "(t=None)",
      "description": "Enter post-mortem debugging of the given *traceback* object.\n\nIf no traceback is given, it uses the one of the exception that is\ncurrently being handled (an exception must be being handled if the\ndefault is to be used).",
      "relationships": []
    },
    {
      "id": "stdlib.pdb.run",
      "name": "run",
      "module": "pdb",
      "type": "function",
      "signature": "(statement, globals=None, locals=None)",
      "description": "Execute the *statement* (given as a string or a code object)\nunder debugger control.\n\nThe debugger prompt appears before any code is executed; you can set\nbreakpoints and type continue, or you can step through the statement\nusing step or next.\n\nThe optional *globals* and *locals* arguments specify the\nenvironment in which the code is executed; by default the\ndictionary of the module __main__ is used (see the explanation of\nthe built-in exec() or eval() functions.).",
      "relationships": []
    },
    {
      "id": "stdlib.pdb.runcall",
      "name": "runcall",
      "module": "pdb",
      "type": "function",
      "signature": "(*args, **kwds)",
      "description": "Call the function (a function or method object, not a string)\nwith the given arguments.\n\nWhen runcall() returns, it returns whatever the function call\nreturned. The debugger prompt appears as soon as the function is\nentered.",
      "relationships": []
    },
    {
      "id": "stdlib.pdb.runctx",
      "name": "runctx",
      "module": "pdb",
      "type": "function",
      "signature": "(statement, globals, locals)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.pdb.run",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pdb.runeval",
      "name": "runeval",
      "module": "pdb",
      "type": "function",
      "signature": "(expression, globals=None, locals=None)",
      "description": "Evaluate the *expression* (given as a string or a code object)\nunder debugger control.\n\nWhen runeval() returns, it returns the value of the expression.\nOtherwise this function is similar to run().",
      "relationships": []
    },
    {
      "id": "stdlib.pdb.set_trace",
      "name": "set_trace",
      "module": "pdb",
      "type": "function",
      "signature": "(*, header=None)",
      "description": "Enter the debugger at the calling stack frame.\n\nThis is useful to hard-code a breakpoint at a given point in a\nprogram, even if the code is not otherwise being debugged (e.g. when\nan assertion fails). If given, *header* is printed to the console\njust before debugging begins.",
      "relationships": []
    },
    {
      "id": "stdlib.pdb.test",
      "name": "test",
      "module": "pdb",
      "type": "function",
      "signature": "()",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.pdb.run",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pickle.decode_long",
      "name": "decode_long",
      "module": "pickle",
      "type": "function",
      "signature": "(data)",
      "description": "Decode a long from a two's complement little-endian binary string.\n\n>>> decode_long(b'')\n0\n>>> decode_long(b\"\\xff\\x00\")\n255\n>>> decode_long(b\"\\xff\\x7f\")\n32767\n>>> decode_long(b\"\\x00\\xff\")\n-256\n>>> decode_long(b\"\\x00\\x80\")\n-32768\n>>> decode_long(b\"\\x80\")\n-128\n>>> decode_long(b\"\\x7f\")\n127",
      "relationships": []
    },
    {
      "id": "stdlib.pickle.encode_long",
      "name": "encode_long",
      "module": "pickle",
      "type": "function",
      "signature": "(x)",
      "description": "Encode a long to a two's complement little-endian binary string.\nNote that 0 is a special case, returning an empty string, to save a\nbyte in the LONG1 pickling context.\n\n>>> encode_long(0)\nb''\n>>> encode_long(255)\nb'\\xff\\x00'\n>>> encode_long(32767)\nb'\\xff\\x7f'\n>>> encode_long(-256)\nb'\\x00\\xff'\n>>> encode_long(-32768)\nb'\\x00\\x80'\n>>> encode_long(-128)\nb'\\x80'\n>>> encode_long(127)\nb'\\x7f'\n>>>",
      "relationships": []
    },
    {
      "id": "stdlib.pickle.whichmodule",
      "name": "whichmodule",
      "module": "pickle",
      "type": "function",
      "signature": "(obj, name)",
      "description": "Find the module an object belong to.",
      "relationships": [
        {
          "target": "stdlib.pickle._getattribute",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pickletools.ArgumentDescriptor",
      "name": "ArgumentDescriptor",
      "module": "pickletools",
      "type": "class",
      "signature": "(name, n, reader, doc)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.pickletools.OpcodeInfo",
      "name": "OpcodeInfo",
      "module": "pickletools",
      "type": "class",
      "signature": "(name, code, arg, stack_before, stack_after, proto, doc)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.pickletools.StackObject",
      "name": "StackObject",
      "module": "pickletools",
      "type": "class",
      "signature": "(name, obtype, doc)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.pickletools.dis",
      "name": "dis",
      "module": "pickletools",
      "type": "function",
      "signature": "(pickle, out=None, memo=None, indentlevel=4, annotate=0)",
      "description": "Produce a symbolic disassembly of a pickle.\n\n'pickle' is a file-like object, or string, containing a (at least one)\npickle.  The pickle is disassembled from the current position, through\nthe first STOP opcode encountered.\n\nOptional arg 'out' is a file-like object to which the disassembly is\nprinted.  It defaults to sys.stdout.\n\nOptional arg 'memo' is a Python dict, used as the pickle's memo.  It\nmay be mutated by dis(), if the pickle contains PUT or BINPUT opcodes.\nPassing the same memo object to another dis() call then allows disassembly\nto proceed across multiple pickles that were all created by the same\npickler with the same memo.  Ordinarily you don't need to worry about this.\n\nOptional arg 'indentlevel' is the number of blanks by which to indent\na new MARK level.  It defaults to 4.\n\nOptional arg 'annotate' if nonzero instructs dis() to add short\ndescription of the opcode on each line of disassembled output.\nThe value given to 'annotate' must be an integer and is used as a\nhint for the column where annotation should start.  The default\nvalue is 0, meaning no annotations.\n\nIn addition to printing the disassembly, some sanity checks are made:\n\n+ All embedded opcode arguments \"make sense\".\n\n+ Explicit and implicit pop operations have enough items on the stack.\n\n+ When an opcode implicitly refers to a markobject, a markobject is\n  actually on the stack.\n\n+ A memo entry isn't referenced before it's defined.\n\n+ The markobject isn't stored in the memo.\n\n+ A memo entry isn't redefined.",
      "relationships": [
        {
          "target": "stdlib.pickletools.genops",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pickletools.genops",
      "name": "genops",
      "module": "pickletools",
      "type": "function",
      "signature": "(pickle)",
      "description": "Generate all the opcodes in a pickle.\n\n'pickle' is a file-like object, or string, containing the pickle.\n\nEach opcode in the pickle is generated, from the current pickle position,\nstopping after a STOP opcode is delivered.  A triple is generated for\neach opcode:\n\n    opcode, arg, pos\n\nopcode is an OpcodeInfo record, describing the current opcode.\n\nIf the opcode has an argument embedded in the pickle, arg is its decoded\nvalue, as a Python object.  If the opcode doesn't have an argument, arg\nis None.\n\nIf the pickle has a tell() method, pos was the value of pickle.tell()\nbefore reading the current opcode.  If the pickle is a bytes object,\nit's wrapped in a BytesIO object, and the latter's tell() result is\nused.  Else (the pickle doesn't have a tell(), and it's not obvious how\nto query its current position) pos is None.",
      "relationships": [
        {
          "target": "stdlib.pickletools._genops",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pickletools.optimize",
      "name": "optimize",
      "module": "pickletools",
      "type": "function",
      "signature": "(p)",
      "description": "Optimize a pickle string by removing unused PUT opcodes",
      "relationships": [
        {
          "target": "stdlib.pickletools._genops",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pickletools.read_bytearray8",
      "name": "read_bytearray8",
      "module": "pickletools",
      "type": "function",
      "signature": "(f)",
      "description": ">>> import io, struct, sys\n>>> read_bytearray8(io.BytesIO(b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00abc\"))\nbytearray(b'')\n>>> read_bytearray8(io.BytesIO(b\"\\x03\\x00\\x00\\x00\\x00\\x00\\x00\\x00abcdef\"))\nbytearray(b'abc')\n>>> bigsize8 = struct.pack(\"<Q\", sys.maxsize//3)\n>>> read_bytearray8(io.BytesIO(bigsize8 + b\"abcdef\"))  #doctest: +ELLIPSIS\nTraceback (most recent call last):\n...\nValueError: expected ... bytes in a bytearray8, but only 6 remain",
      "relationships": [
        {
          "target": "stdlib.pickletools.read_uint8",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pickletools.read_bytes1",
      "name": "read_bytes1",
      "module": "pickletools",
      "type": "function",
      "signature": "(f)",
      "description": ">>> import io\n>>> read_bytes1(io.BytesIO(b\"\\x00\"))\nb''\n>>> read_bytes1(io.BytesIO(b\"\\x03abcdef\"))\nb'abc'",
      "relationships": [
        {
          "target": "stdlib.pickletools.read_uint1",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pickletools.read_bytes4",
      "name": "read_bytes4",
      "module": "pickletools",
      "type": "function",
      "signature": "(f)",
      "description": ">>> import io\n>>> read_bytes4(io.BytesIO(b\"\\x00\\x00\\x00\\x00abc\"))\nb''\n>>> read_bytes4(io.BytesIO(b\"\\x03\\x00\\x00\\x00abcdef\"))\nb'abc'\n>>> read_bytes4(io.BytesIO(b\"\\x00\\x00\\x00\\x03abcdef\"))\nTraceback (most recent call last):\n...\nValueError: expected 50331648 bytes in a bytes4, but only 6 remain",
      "relationships": [
        {
          "target": "stdlib.pickletools.read_uint4",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pickletools.read_bytes8",
      "name": "read_bytes8",
      "module": "pickletools",
      "type": "function",
      "signature": "(f)",
      "description": ">>> import io, struct, sys\n>>> read_bytes8(io.BytesIO(b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00abc\"))\nb''\n>>> read_bytes8(io.BytesIO(b\"\\x03\\x00\\x00\\x00\\x00\\x00\\x00\\x00abcdef\"))\nb'abc'\n>>> bigsize8 = struct.pack(\"<Q\", sys.maxsize//3)\n>>> read_bytes8(io.BytesIO(bigsize8 + b\"abcdef\"))  #doctest: +ELLIPSIS\nTraceback (most recent call last):\n...\nValueError: expected ... bytes in a bytes8, but only 6 remain",
      "relationships": [
        {
          "target": "stdlib.pickletools.read_uint8",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pickletools.read_decimalnl_long",
      "name": "read_decimalnl_long",
      "module": "pickletools",
      "type": "function",
      "signature": "(f)",
      "description": ">>> import io\n\n>>> read_decimalnl_long(io.BytesIO(b\"1234L\\n56\"))\n1234\n\n>>> read_decimalnl_long(io.BytesIO(b\"123456789012345678901234L\\n6\"))\n123456789012345678901234",
      "relationships": [
        {
          "target": "stdlib.pickletools.read_stringnl",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pickletools.read_decimalnl_short",
      "name": "read_decimalnl_short",
      "module": "pickletools",
      "type": "function",
      "signature": "(f)",
      "description": ">>> import io\n>>> read_decimalnl_short(io.BytesIO(b\"1234\\n56\"))\n1234\n\n>>> read_decimalnl_short(io.BytesIO(b\"1234L\\n56\"))\nTraceback (most recent call last):\n...\nValueError: invalid literal for int() with base 10: b'1234L'",
      "relationships": [
        {
          "target": "stdlib.pickletools.read_stringnl",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pickletools.read_float8",
      "name": "read_float8",
      "module": "pickletools",
      "type": "function",
      "signature": "(f)",
      "description": ">>> import io, struct\n>>> raw = struct.pack(\">d\", -1.25)\n>>> raw\nb'\\xbf\\xf4\\x00\\x00\\x00\\x00\\x00\\x00'\n>>> read_float8(io.BytesIO(raw + b\"\\n\"))\n-1.25",
      "relationships": []
    },
    {
      "id": "stdlib.pickletools.read_floatnl",
      "name": "read_floatnl",
      "module": "pickletools",
      "type": "function",
      "signature": "(f)",
      "description": ">>> import io\n>>> read_floatnl(io.BytesIO(b\"-1.25\\n6\"))\n-1.25",
      "relationships": [
        {
          "target": "stdlib.pickletools.read_stringnl",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pickletools.read_int4",
      "name": "read_int4",
      "module": "pickletools",
      "type": "function",
      "signature": "(f)",
      "description": ">>> import io\n>>> read_int4(io.BytesIO(b'\\xff\\x00\\x00\\x00'))\n255\n>>> read_int4(io.BytesIO(b'\\x00\\x00\\x00\\x80')) == -(2**31)\nTrue",
      "relationships": []
    },
    {
      "id": "stdlib.pickletools.read_long1",
      "name": "read_long1",
      "module": "pickletools",
      "type": "function",
      "signature": "(f)",
      "description": ">>> import io\n>>> read_long1(io.BytesIO(b\"\\x00\"))\n0\n>>> read_long1(io.BytesIO(b\"\\x02\\xff\\x00\"))\n255\n>>> read_long1(io.BytesIO(b\"\\x02\\xff\\x7f\"))\n32767\n>>> read_long1(io.BytesIO(b\"\\x02\\x00\\xff\"))\n-256\n>>> read_long1(io.BytesIO(b\"\\x02\\x00\\x80\"))\n-32768",
      "relationships": [
        {
          "target": "stdlib.pickletools.read_uint1",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pickletools.read_long4",
      "name": "read_long4",
      "module": "pickletools",
      "type": "function",
      "signature": "(f)",
      "description": ">>> import io\n>>> read_long4(io.BytesIO(b\"\\x02\\x00\\x00\\x00\\xff\\x00\"))\n255\n>>> read_long4(io.BytesIO(b\"\\x02\\x00\\x00\\x00\\xff\\x7f\"))\n32767\n>>> read_long4(io.BytesIO(b\"\\x02\\x00\\x00\\x00\\x00\\xff\"))\n-256\n>>> read_long4(io.BytesIO(b\"\\x02\\x00\\x00\\x00\\x00\\x80\"))\n-32768\n>>> read_long1(io.BytesIO(b\"\\x00\\x00\\x00\\x00\"))\n0",
      "relationships": [
        {
          "target": "stdlib.pickletools.read_int4",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pickletools.read_string1",
      "name": "read_string1",
      "module": "pickletools",
      "type": "function",
      "signature": "(f)",
      "description": ">>> import io\n>>> read_string1(io.BytesIO(b\"\\x00\"))\n''\n>>> read_string1(io.BytesIO(b\"\\x03abcdef\"))\n'abc'",
      "relationships": [
        {
          "target": "stdlib.pickletools.read_uint1",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pickletools.read_string4",
      "name": "read_string4",
      "module": "pickletools",
      "type": "function",
      "signature": "(f)",
      "description": ">>> import io\n>>> read_string4(io.BytesIO(b\"\\x00\\x00\\x00\\x00abc\"))\n''\n>>> read_string4(io.BytesIO(b\"\\x03\\x00\\x00\\x00abcdef\"))\n'abc'\n>>> read_string4(io.BytesIO(b\"\\x00\\x00\\x00\\x03abcdef\"))\nTraceback (most recent call last):\n...\nValueError: expected 50331648 bytes in a string4, but only 6 remain",
      "relationships": [
        {
          "target": "stdlib.pickletools.read_int4",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pickletools.read_stringnl",
      "name": "read_stringnl",
      "module": "pickletools",
      "type": "function",
      "signature": "(f, decode=True, stripquotes=True, *, encoding='latin-1')",
      "description": ">>> import io\n>>> read_stringnl(io.BytesIO(b\"'abcd'\\nefg\\n\"))\n'abcd'\n\n>>> read_stringnl(io.BytesIO(b\"\\n\"))\nTraceback (most recent call last):\n...\nValueError: no string quotes around b''\n\n>>> read_stringnl(io.BytesIO(b\"\\n\"), stripquotes=False)\n''\n\n>>> read_stringnl(io.BytesIO(b\"''\\n\"))\n''\n\n>>> read_stringnl(io.BytesIO(b'\"abcd\"'))\nTraceback (most recent call last):\n...\nValueError: no newline found when trying to read stringnl\n\nEmbedded escapes are undone in the result.\n>>> read_stringnl(io.BytesIO(br\"'a\\n\\\\b\\x00c\\td'\" + b\"\\n'e'\"))\n'a\\n\\\\b\\x00c\\td'",
      "relationships": []
    },
    {
      "id": "stdlib.pickletools.read_stringnl_noescape",
      "name": "read_stringnl_noescape",
      "module": "pickletools",
      "type": "function",
      "signature": "(f)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.pickletools.read_stringnl",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pickletools.read_stringnl_noescape_pair",
      "name": "read_stringnl_noescape_pair",
      "module": "pickletools",
      "type": "function",
      "signature": "(f)",
      "description": ">>> import io\n>>> read_stringnl_noescape_pair(io.BytesIO(b\"Queue\\nEmpty\\njunk\"))\n'Queue Empty'",
      "relationships": [
        {
          "target": "stdlib.pickletools.read_stringnl_noescape",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.read_stringnl_noescape",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pickletools.read_uint1",
      "name": "read_uint1",
      "module": "pickletools",
      "type": "function",
      "signature": "(f)",
      "description": ">>> import io\n>>> read_uint1(io.BytesIO(b'\\xff'))\n255",
      "relationships": []
    },
    {
      "id": "stdlib.pickletools.read_uint2",
      "name": "read_uint2",
      "module": "pickletools",
      "type": "function",
      "signature": "(f)",
      "description": ">>> import io\n>>> read_uint2(io.BytesIO(b'\\xff\\x00'))\n255\n>>> read_uint2(io.BytesIO(b'\\xff\\xff'))\n65535",
      "relationships": []
    },
    {
      "id": "stdlib.pickletools.read_uint4",
      "name": "read_uint4",
      "module": "pickletools",
      "type": "function",
      "signature": "(f)",
      "description": ">>> import io\n>>> read_uint4(io.BytesIO(b'\\xff\\x00\\x00\\x00'))\n255\n>>> read_uint4(io.BytesIO(b'\\x00\\x00\\x00\\x80')) == 2**31\nTrue",
      "relationships": []
    },
    {
      "id": "stdlib.pickletools.read_uint8",
      "name": "read_uint8",
      "module": "pickletools",
      "type": "function",
      "signature": "(f)",
      "description": ">>> import io\n>>> read_uint8(io.BytesIO(b'\\xff\\x00\\x00\\x00\\x00\\x00\\x00\\x00'))\n255\n>>> read_uint8(io.BytesIO(b'\\xff' * 8)) == 2**64-1\nTrue",
      "relationships": []
    },
    {
      "id": "stdlib.pickletools.read_unicodestring1",
      "name": "read_unicodestring1",
      "module": "pickletools",
      "type": "function",
      "signature": "(f)",
      "description": ">>> import io\n>>> s = 'abcd\\uabcd'\n>>> enc = s.encode('utf-8')\n>>> enc\nb'abcd\\xea\\xaf\\x8d'\n>>> n = bytes([len(enc)])  # little-endian 1-byte length\n>>> t = read_unicodestring1(io.BytesIO(n + enc + b'junk'))\n>>> s == t\nTrue\n\n>>> read_unicodestring1(io.BytesIO(n + enc[:-1]))\nTraceback (most recent call last):\n...\nValueError: expected 7 bytes in a unicodestring1, but only 6 remain",
      "relationships": [
        {
          "target": "stdlib.pickletools.read_uint1",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pickletools.read_unicodestring4",
      "name": "read_unicodestring4",
      "module": "pickletools",
      "type": "function",
      "signature": "(f)",
      "description": ">>> import io\n>>> s = 'abcd\\uabcd'\n>>> enc = s.encode('utf-8')\n>>> enc\nb'abcd\\xea\\xaf\\x8d'\n>>> n = bytes([len(enc), 0, 0, 0])  # little-endian 4-byte length\n>>> t = read_unicodestring4(io.BytesIO(n + enc + b'junk'))\n>>> s == t\nTrue\n\n>>> read_unicodestring4(io.BytesIO(n + enc[:-1]))\nTraceback (most recent call last):\n...\nValueError: expected 7 bytes in a unicodestring4, but only 6 remain",
      "relationships": [
        {
          "target": "stdlib.pickletools.read_uint4",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pickletools.read_unicodestring8",
      "name": "read_unicodestring8",
      "module": "pickletools",
      "type": "function",
      "signature": "(f)",
      "description": ">>> import io\n>>> s = 'abcd\\uabcd'\n>>> enc = s.encode('utf-8')\n>>> enc\nb'abcd\\xea\\xaf\\x8d'\n>>> n = bytes([len(enc)]) + b'\\0' * 7  # little-endian 8-byte length\n>>> t = read_unicodestring8(io.BytesIO(n + enc + b'junk'))\n>>> s == t\nTrue\n\n>>> read_unicodestring8(io.BytesIO(n + enc[:-1]))\nTraceback (most recent call last):\n...\nValueError: expected 7 bytes in a unicodestring8, but only 6 remain",
      "relationships": [
        {
          "target": "stdlib.pickletools.read_uint8",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pickletools.read_unicodestringnl",
      "name": "read_unicodestringnl",
      "module": "pickletools",
      "type": "function",
      "signature": "(f)",
      "description": ">>> import io\n>>> read_unicodestringnl(io.BytesIO(b\"abc\\\\uabcd\\njunk\")) == 'abc\\uabcd'\nTrue",
      "relationships": []
    },
    {
      "id": "stdlib.pipes.Template",
      "name": "Template",
      "module": "pipes",
      "type": "class",
      "signature": "()",
      "description": "Class representing a pipeline template.",
      "relationships": []
    },
    {
      "id": "stdlib.pipes.makepipeline",
      "name": "makepipeline",
      "module": "pipes",
      "type": "function",
      "signature": "(infile, steps, outfile)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.pkgutil.ModuleInfo",
      "name": "ModuleInfo",
      "module": "pkgutil",
      "type": "class",
      "signature": "(module_finder, name, ispkg)",
      "description": "A namedtuple with minimal info about a module.",
      "relationships": [
        {
          "target": "stdlib.builtins.tuple",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.pkgutil.extend_path",
      "name": "extend_path",
      "module": "pkgutil",
      "type": "function",
      "signature": "(path, name)",
      "description": "Extend a package's path.\n\nIntended use is to place the following code in a package's __init__.py:\n\n    from pkgutil import extend_path\n    __path__ = extend_path(__path__, __name__)\n\nFor each directory on sys.path that has a subdirectory that\nmatches the package name, add the subdirectory to the package's\n__path__.  This is useful if one wants to distribute different\nparts of a single logical package as multiple directories.\n\nIt also looks for *.pkg files beginning where * matches the name\nargument.  This feature is similar to *.pth files (see site.py),\nexcept that it doesn't special-case lines starting with 'import'.\nA *.pkg file is trusted at face value: apart from checking for\nduplicates, all entries found in a *.pkg file are added to the\npath, regardless of whether they are exist the filesystem.  (This\nis a feature.)\n\nIf the input path is not a list (as is the case for frozen\npackages) it is returned unchanged.  The input path is not\nmodified; an extended copy is returned.  Items are only appended\nto the copy at the end.\n\nIt is assumed that sys.path is a sequence.  Items of sys.path that\nare not (unicode or 8-bit) strings referring to existing\ndirectories are ignored.  Unicode items of sys.path that cause\nerrors when used as filenames may cause this function to raise an\nexception (in line with os.path.isdir() behavior).",
      "relationships": [
        {
          "target": "stdlib.pkgutil.get_importer",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pkgutil.find_loader",
      "name": "find_loader",
      "module": "pkgutil",
      "type": "function",
      "signature": "(fullname)",
      "description": "Find a \"loader\" object for fullname\n\nThis is a backwards compatibility wrapper around\nimportlib.util.find_spec that converts most failures to ImportError\nand only returns the loader rather than the full spec",
      "relationships": []
    },
    {
      "id": "stdlib.pkgutil.get_data",
      "name": "get_data",
      "module": "pkgutil",
      "type": "function",
      "signature": "(package, resource)",
      "description": "Get a resource from a package.\n\nThis is a wrapper round the PEP 302 loader get_data API. The package\nargument should be the name of a package, in standard module format\n(foo.bar). The resource argument should be in the form of a relative\nfilename, using '/' as the path separator. The parent directory name '..'\nis not allowed, and nor is a rooted name (starting with a '/').\n\nThe function returns a binary string, which is the contents of the\nspecified resource.\n\nFor packages located in the filesystem, which have already been imported,\nthis is the rough equivalent of\n\n    d = os.path.dirname(sys.modules[package].__file__)\n    data = open(os.path.join(d, resource), 'rb').read()\n\nIf the package cannot be located or loaded, or it uses a PEP 302 loader\nwhich does not support get_data(), then None is returned.",
      "relationships": []
    },
    {
      "id": "stdlib.pkgutil.get_importer",
      "name": "get_importer",
      "module": "pkgutil",
      "type": "function",
      "signature": "(path_item)",
      "description": "Retrieve a finder for the given path item\n\nThe returned finder is cached in sys.path_importer_cache\nif it was newly created by a path hook.\n\nThe cache (or part of it) can be cleared manually if a\nrescan of sys.path_hooks is necessary.",
      "relationships": []
    },
    {
      "id": "stdlib.pkgutil.get_loader",
      "name": "get_loader",
      "module": "pkgutil",
      "type": "function",
      "signature": "(module_or_name)",
      "description": "Get a \"loader\" object for module_or_name\n\nReturns None if the module cannot be found or imported.\nIf the named module is not already imported, its containing package\n(if any) is imported, in order to establish the package __path__.",
      "relationships": [
        {
          "target": "stdlib.pkgutil.find_loader",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pkgutil.iter_importer_modules",
      "name": "iter_importer_modules",
      "module": "pkgutil",
      "type": "function",
      "signature": "(importer, prefix='')",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.pkgutil.iter_importers",
      "name": "iter_importers",
      "module": "pkgutil",
      "type": "function",
      "signature": "(fullname='')",
      "description": "Yield finders for the given module name\n\nIf fullname contains a '.', the finders will be for the package\ncontaining fullname, otherwise they will be all registered top level\nfinders (i.e. those on both sys.meta_path and sys.path_hooks).\n\nIf the named module is in a package, that package is imported as a side\neffect of invoking this function.\n\nIf no module name is specified, all top level finders are produced.",
      "relationships": [
        {
          "target": "stdlib.pkgutil.get_importer",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pkgutil.iter_modules",
      "name": "iter_modules",
      "module": "pkgutil",
      "type": "function",
      "signature": "(path=None, prefix='')",
      "description": "Yields ModuleInfo for all submodules on path,\nor, if path is None, all top-level modules on sys.path.\n\n'path' should be either None or a list of paths to look for\nmodules in.\n\n'prefix' is a string to output on the front of every module name\non output.",
      "relationships": [
        {
          "target": "stdlib.pkgutil.iter_importers",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.iter_importer_modules",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pkgutil.iter_zipimport_modules",
      "name": "iter_zipimport_modules",
      "module": "pkgutil",
      "type": "function",
      "signature": "(importer, prefix='')",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.pkgutil.read_code",
      "name": "read_code",
      "module": "pkgutil",
      "type": "function",
      "signature": "(stream)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.pkgutil.resolve_name",
      "name": "resolve_name",
      "module": "pkgutil",
      "type": "function",
      "signature": "(name)",
      "description": "Resolve a name to an object.\n\nIt is expected that `name` will be a string in one of the following\nformats, where W is shorthand for a valid Python identifier and dot stands\nfor a literal period in these pseudo-regexes:\n\nW(.W)*\nW(.W)*:(W(.W)*)?\n\nThe first form is intended for backward compatibility only. It assumes that\nsome part of the dotted name is a package, and the rest is an object\nsomewhere within that package, possibly nested inside other objects.\nBecause the place where the package stops and the object hierarchy starts\ncan't be inferred by inspection, repeated attempts to import must be done\nwith this form.\n\nIn the second form, the caller makes the division point clear through the\nprovision of a single colon: the dotted name to the left of the colon is a\npackage to be imported, and the dotted name to the right is the object\nhierarchy within that package. Only one import is needed in this form. If\nit ends with the colon, then a module object is returned.\n\nThe function will return an object (which might be a module), or raise one\nof the following exceptions:\n\nValueError - if `name` isn't in a recognised format\nImportError - if an import failed when it shouldn't have\nAttributeError - if a failure occurred when traversing the object hierarchy\n                 within the imported package to get to the desired object.",
      "relationships": []
    },
    {
      "id": "stdlib.pkgutil.walk_packages",
      "name": "walk_packages",
      "module": "pkgutil",
      "type": "function",
      "signature": "(path=None, prefix='', onerror=None)",
      "description": "Yields ModuleInfo for all modules recursively\non path, or, if path is None, all accessible modules.\n\n'path' should be either None or a list of paths to look for\nmodules in.\n\n'prefix' is a string to output on the front of every module name\non output.\n\nNote that this function must import all *packages* (NOT all\nmodules!) on the given path, in order to access the __path__\nattribute to find submodules.\n\n'onerror' is a function which gets called with one argument (the\nname of the package which was being imported) if any exception\noccurs while trying to import a package.  If no onerror function is\nsupplied, ImportErrors are caught and ignored, while all other\nexceptions are propagated, terminating the search.\n\nExamples:\n\n# list all modules python can access\nwalk_packages()\n\n# list all submodules of ctypes\nwalk_packages(ctypes.__path__, ctypes.__name__+'.')",
      "relationships": [
        {
          "target": "stdlib.pkgutil.iter_modules",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.walk_packages",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.platform.architecture",
      "name": "architecture",
      "module": "platform",
      "type": "function",
      "signature": "(executable='/Users/anthonycardillo/Documents/personal/polyester/.venv/bin/python', bits='', linkage='')",
      "description": "Queries the given executable (defaults to the Python interpreter\nbinary) for various architecture information.\n\nReturns a tuple (bits, linkage) which contains information about\nthe bit architecture and the linkage format used for the\nexecutable. Both values are returned as strings.\n\nValues that cannot be determined are returned as given by the\nparameter presets. If bits is given as '', the sizeof(pointer)\n(or sizeof(long) on Python version < 1.5.2) is used as\nindicator for the supported pointer size.\n\nThe function relies on the system's \"file\" command to do the\nactual work. This is available on most if not all Unix\nplatforms. On some non-Unix platforms where the \"file\" command\ndoes not exist and the executable is set to the Python interpreter\nbinary defaults from _default_architecture are used.",
      "relationships": [
        {
          "target": "stdlib.platform._syscmd_file",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.platform.freedesktop_os_release",
      "name": "freedesktop_os_release",
      "module": "platform",
      "type": "function",
      "signature": "()",
      "description": "Return operation system identification from freedesktop.org os-release\n    ",
      "relationships": [
        {
          "target": "stdlib.platform._parse_os_release",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.platform.java_ver",
      "name": "java_ver",
      "module": "platform",
      "type": "function",
      "signature": "(release='', vendor='', vminfo=('', '', ''), osinfo=('', '', ''))",
      "description": "Version interface for Jython.\n\nReturns a tuple (release, vendor, vminfo, osinfo) with vminfo being\na tuple (vm_name, vm_release, vm_vendor) and osinfo being a\ntuple (os_name, os_version, os_arch).\n\nValues which cannot be determined are set to the defaults\ngiven as parameters (which all default to '').",
      "relationships": [
        {
          "target": "stdlib.platform._java_getprop",
          "type": "calls"
        },
        {
          "target": "stdlib.platform._java_getprop",
          "type": "calls"
        },
        {
          "target": "stdlib.platform._java_getprop",
          "type": "calls"
        },
        {
          "target": "stdlib.platform._java_getprop",
          "type": "calls"
        },
        {
          "target": "stdlib.platform._java_getprop",
          "type": "calls"
        },
        {
          "target": "stdlib.platform._java_getprop",
          "type": "calls"
        },
        {
          "target": "stdlib.platform._java_getprop",
          "type": "calls"
        },
        {
          "target": "stdlib.platform._java_getprop",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.platform.libc_ver",
      "name": "libc_ver",
      "module": "platform",
      "type": "function",
      "signature": "(executable=None, lib='', version='', chunksize=16384)",
      "description": "Tries to determine the libc version that the file executable\n(which defaults to the Python interpreter) is linked against.\n\nReturns a tuple of strings (lib,version) which default to the\ngiven parameters in case the lookup fails.\n\nNote that the function has intimate knowledge of how different\nlibc versions add symbols to the executable and thus is probably\nonly usable for executables compiled using gcc.\n\nThe file is read and scanned in chunks of chunksize bytes.",
      "relationships": []
    },
    {
      "id": "stdlib.platform.mac_ver",
      "name": "mac_ver",
      "module": "platform",
      "type": "function",
      "signature": "(release='', versioninfo=('', '', ''), machine='')",
      "description": "Get macOS version information and return it as tuple (release,\nversioninfo, machine) with versioninfo being a tuple (version,\ndev_stage, non_release_version).\n\nEntries which cannot be determined are set to the parameter values\nwhich default to ''. All tuple entries are strings.",
      "relationships": [
        {
          "target": "stdlib.platform._mac_ver_xml",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.platform.machine",
      "name": "machine",
      "module": "platform",
      "type": "function",
      "signature": "()",
      "description": "Returns the machine type, e.g. 'i386'\n\nAn empty string is returned if the value cannot be determined.",
      "relationships": [
        {
          "target": "stdlib.platform.uname",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.platform.node",
      "name": "node",
      "module": "platform",
      "type": "function",
      "signature": "()",
      "description": "Returns the computer's network name (which may not be fully\nqualified)\n\nAn empty string is returned if the value cannot be determined.",
      "relationships": [
        {
          "target": "stdlib.platform.uname",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.platform.platform",
      "name": "platform",
      "module": "platform",
      "type": "function",
      "signature": "(aliased=False, terse=False)",
      "description": "Returns a single string identifying the underlying platform\nwith as much useful information as possible (but no more :).\n\nThe output is intended to be human readable rather than\nmachine parseable. It may look different on different\nplatforms and this is intended.\n\nIf \"aliased\" is true, the function will use aliases for\nvarious platforms that report system names which differ from\ntheir common names, e.g. SunOS will be reported as\nSolaris. The system_alias() function is used to implement\nthis.\n\nSetting terse to true causes the function to return only the\nabsolute minimum information needed to identify the platform.",
      "relationships": [
        {
          "target": "stdlib.platform.uname",
          "type": "calls"
        },
        {
          "target": "stdlib.platform.system_alias",
          "type": "calls"
        },
        {
          "target": "stdlib.platform.win32_ver",
          "type": "calls"
        },
        {
          "target": "stdlib.platform.mac_ver",
          "type": "calls"
        },
        {
          "target": "stdlib.platform._platform",
          "type": "calls"
        },
        {
          "target": "stdlib.platform._platform",
          "type": "calls"
        },
        {
          "target": "stdlib.platform.libc_ver",
          "type": "calls"
        },
        {
          "target": "stdlib.platform._platform",
          "type": "calls"
        },
        {
          "target": "stdlib.platform.java_ver",
          "type": "calls"
        },
        {
          "target": "stdlib.platform._platform",
          "type": "calls"
        },
        {
          "target": "stdlib.platform._platform",
          "type": "calls"
        },
        {
          "target": "stdlib.platform._platform",
          "type": "calls"
        },
        {
          "target": "stdlib.platform.architecture",
          "type": "calls"
        },
        {
          "target": "stdlib.platform._platform",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.platform.processor",
      "name": "processor",
      "module": "platform",
      "type": "function",
      "signature": "()",
      "description": "Returns the (true) processor name, e.g. 'amdk6'\n\nAn empty string is returned if the value cannot be\ndetermined. Note that many platforms do not provide this\ninformation or simply return the same value as for machine(),\ne.g.  NetBSD does this.",
      "relationships": [
        {
          "target": "stdlib.platform.uname",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.platform.python_branch",
      "name": "python_branch",
      "module": "platform",
      "type": "function",
      "signature": "()",
      "description": "Returns a string identifying the Python implementation\nbranch.\n\nFor CPython this is the SCM branch from which the\nPython binary was built.\n\nIf not available, an empty string is returned.",
      "relationships": [
        {
          "target": "stdlib.platform._sys_version",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.platform.python_build",
      "name": "python_build",
      "module": "platform",
      "type": "function",
      "signature": "()",
      "description": "Returns a tuple (buildno, builddate) stating the Python\nbuild number and date as strings.",
      "relationships": [
        {
          "target": "stdlib.platform._sys_version",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.platform.python_compiler",
      "name": "python_compiler",
      "module": "platform",
      "type": "function",
      "signature": "()",
      "description": "Returns a string identifying the compiler used for compiling\nPython.",
      "relationships": [
        {
          "target": "stdlib.platform._sys_version",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.platform.python_implementation",
      "name": "python_implementation",
      "module": "platform",
      "type": "function",
      "signature": "()",
      "description": "Returns a string identifying the Python implementation.\n\nCurrently, the following implementations are identified:\n  'CPython' (C implementation of Python),\n  'Jython' (Java implementation of Python),\n  'PyPy' (Python implementation of Python).",
      "relationships": [
        {
          "target": "stdlib.platform._sys_version",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.platform.python_revision",
      "name": "python_revision",
      "module": "platform",
      "type": "function",
      "signature": "()",
      "description": "Returns a string identifying the Python implementation\nrevision.\n\nFor CPython this is the SCM revision from which the\nPython binary was built.\n\nIf not available, an empty string is returned.",
      "relationships": [
        {
          "target": "stdlib.platform._sys_version",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.platform.python_version",
      "name": "python_version",
      "module": "platform",
      "type": "function",
      "signature": "()",
      "description": "Returns the Python version as string 'major.minor.patchlevel'\n\nNote that unlike the Python sys.version, the returned value\nwill always include the patchlevel (it defaults to 0).",
      "relationships": [
        {
          "target": "stdlib.platform._sys_version",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.platform.python_version_tuple",
      "name": "python_version_tuple",
      "module": "platform",
      "type": "function",
      "signature": "()",
      "description": "Returns the Python version as tuple (major, minor, patchlevel)\nof strings.\n\nNote that unlike the Python sys.version, the returned value\nwill always include the patchlevel (it defaults to 0).",
      "relationships": [
        {
          "target": "stdlib.platform._sys_version",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.platform.release",
      "name": "release",
      "module": "platform",
      "type": "function",
      "signature": "()",
      "description": "Returns the system's release, e.g. '2.2.0' or 'NT'\n\nAn empty string is returned if the value cannot be determined.",
      "relationships": [
        {
          "target": "stdlib.platform.uname",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.platform.system",
      "name": "system",
      "module": "platform",
      "type": "function",
      "signature": "()",
      "description": "Returns the system/OS name, e.g. 'Linux', 'Windows' or 'Java'.\n\nAn empty string is returned if the value cannot be determined.",
      "relationships": [
        {
          "target": "stdlib.platform.uname",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.platform.system_alias",
      "name": "system_alias",
      "module": "platform",
      "type": "function",
      "signature": "(system, release, version)",
      "description": "Returns (system, release, version) aliased to common\nmarketing names used for some systems.\n\nIt also does some reordering of the information in some cases\nwhere it would otherwise cause confusion.",
      "relationships": []
    },
    {
      "id": "stdlib.platform.uname",
      "name": "uname",
      "module": "platform",
      "type": "function",
      "signature": "()",
      "description": "Fairly portable uname interface. Returns a tuple\nof strings (system, node, release, version, machine, processor)\nidentifying the underlying platform.\n\nNote that unlike the os.uname function this also returns\npossible processor information as an additional tuple entry.\n\nEntries which cannot be determined are set to ''.",
      "relationships": [
        {
          "target": "stdlib.platform._node",
          "type": "calls"
        },
        {
          "target": "stdlib.platform.win32_ver",
          "type": "calls"
        },
        {
          "target": "stdlib.platform._syscmd_ver",
          "type": "calls"
        },
        {
          "target": "stdlib.platform._get_machine_win32",
          "type": "calls"
        },
        {
          "target": "stdlib.platform.java_ver",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.platform.uname_result",
      "name": "uname_result",
      "module": "platform",
      "type": "class",
      "signature": "(system, node, release, version, machine)",
      "description": "A uname_result that's largely compatible with a\nsimple namedtuple except that 'processor' is\nresolved late and cached to avoid calling \"uname\"\nexcept when needed.",
      "relationships": [
        {
          "target": "stdlib.platform.uname_result_base",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.tuple",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.platform.version",
      "name": "version",
      "module": "platform",
      "type": "function",
      "signature": "()",
      "description": "Returns the system's release version, e.g. '#3 on degas'\n\nAn empty string is returned if the value cannot be determined.",
      "relationships": [
        {
          "target": "stdlib.platform.uname",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.platform.win32_edition",
      "name": "win32_edition",
      "module": "platform",
      "type": "function",
      "signature": "()",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.platform.win32_is_iot",
      "name": "win32_is_iot",
      "module": "platform",
      "type": "function",
      "signature": "()",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.platform.win32_edition",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.platform.win32_ver",
      "name": "win32_ver",
      "module": "platform",
      "type": "function",
      "signature": "(release='', version='', csd='', ptype='')",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.platform._win32_ver",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.plistlib.InvalidFileException",
      "name": "InvalidFileException",
      "module": "plistlib",
      "type": "class",
      "signature": "(message='Invalid file')",
      "description": "Inappropriate argument value (of correct type).",
      "relationships": [
        {
          "target": "stdlib.builtins.ValueError",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Exception",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.plistlib.PlistFormat",
      "name": "PlistFormat",
      "module": "plistlib",
      "type": "class",
      "signature": "(*values)",
      "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access:\n\n  >>> Color.RED\n  <Color.RED: 1>\n\n- value lookup:\n\n  >>> Color(1)\n  <Color.RED: 1>\n\n- name lookup:\n\n  >>> Color['RED']\n  <Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details.",
      "relationships": [
        {
          "target": "stdlib.enum.Enum",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.plistlib.UID",
      "name": "UID",
      "module": "plistlib",
      "type": "class",
      "signature": "(data)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.plistlib.dump",
      "name": "dump",
      "module": "plistlib",
      "type": "function",
      "signature": "(value, fp, *, fmt=<PlistFormat.FMT_XML: 1>, sort_keys=True, skipkeys=False)",
      "description": "Write 'value' to a .plist file. 'fp' should be a writable,\nbinary file object.",
      "relationships": []
    },
    {
      "id": "stdlib.plistlib.dumps",
      "name": "dumps",
      "module": "plistlib",
      "type": "function",
      "signature": "(value, *, fmt=<PlistFormat.FMT_XML: 1>, skipkeys=False, sort_keys=True)",
      "description": "Return a bytes object with the contents for a .plist file.\n    ",
      "relationships": [
        {
          "target": "stdlib.plistlib.dump",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.plistlib.load",
      "name": "load",
      "module": "plistlib",
      "type": "function",
      "signature": "(fp, *, fmt=None, dict_type=<class 'dict'>)",
      "description": "Read a .plist file. 'fp' should be a readable and binary file object.\nReturn the unpacked root object (which usually is a dictionary).",
      "relationships": []
    },
    {
      "id": "stdlib.plistlib.loads",
      "name": "loads",
      "module": "plistlib",
      "type": "function",
      "signature": "(value, *, fmt=None, dict_type=<class 'dict'>)",
      "description": "Read a .plist file from a bytes object.\nReturn the unpacked root object (which usually is a dictionary).",
      "relationships": [
        {
          "target": "stdlib.plistlib.load",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.poplib.POP3",
      "name": "POP3",
      "module": "poplib",
      "type": "class",
      "signature": "(host, port=110, timeout=<object object at 0x100108a90>)",
      "description": "This class supports both the minimal and optional command sets.\nArguments can be strings or integers (where appropriate)\n(e.g.: retr(1) and retr('1') both work equally well.\n\nMinimal Command Set:\n        USER name               user(name)\n        PASS string             pass_(string)\n        STAT                    stat()\n        LIST [msg]              list(msg = None)\n        RETR msg                retr(msg)\n        DELE msg                dele(msg)\n        NOOP                    noop()\n        RSET                    rset()\n        QUIT                    quit()\n\nOptional Commands (some servers support these):\n        RPOP name               rpop(name)\n        APOP name digest        apop(name, digest)\n        TOP msg n               top(msg, n)\n        UIDL [msg]              uidl(msg = None)\n        CAPA                    capa()\n        STLS                    stls()\n        UTF8                    utf8()\n\nRaises one exception: 'error_proto'.\n\nInstantiate with:\n        POP3(hostname, port=110)\n\nNB:     the POP protocol locks the mailbox from user\n        authorization until QUIT, so be sure to get in, suck\n        the messages, and quit, each time you access the\n        mailbox.\n\n        POP is a line-based protocol, which means large mail\n        messages consume lots of python cycles reading them\n        line-by-line.\n\n        If it's available on your mail server, use IMAP4\n        instead, it doesn't suffer from the two problems\n        above.",
      "relationships": []
    },
    {
      "id": "stdlib.poplib.POP3_SSL",
      "name": "POP3_SSL",
      "module": "poplib",
      "type": "class",
      "signature": "(host, port=995, *, timeout=<object object at 0x100108a90>, context=None)",
      "description": "POP3 client class over SSL connection\n\nInstantiate with: POP3_SSL(hostname, port=995, context=None)\n\n       hostname - the hostname of the pop3 over ssl server\n       port - port number\n       context - a ssl.SSLContext\n\nSee the methods of the parent class POP3 for more documentation.",
      "relationships": [
        {
          "target": "stdlib.poplib.POP3",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.posixpath.abspath",
      "name": "abspath",
      "module": "posixpath",
      "type": "function",
      "signature": "(path)",
      "description": "Return an absolute path.",
      "relationships": []
    },
    {
      "id": "stdlib.posixpath.basename",
      "name": "basename",
      "module": "posixpath",
      "type": "function",
      "signature": "(p)",
      "description": "Returns the final component of a pathname",
      "relationships": []
    },
    {
      "id": "stdlib.posixpath.commonpath",
      "name": "commonpath",
      "module": "posixpath",
      "type": "function",
      "signature": "(paths)",
      "description": "Given a sequence of path names, returns the longest common sub-path.",
      "relationships": []
    },
    {
      "id": "stdlib.posixpath.dirname",
      "name": "dirname",
      "module": "posixpath",
      "type": "function",
      "signature": "(p)",
      "description": "Returns the directory component of a pathname",
      "relationships": []
    },
    {
      "id": "stdlib.posixpath.expanduser",
      "name": "expanduser",
      "module": "posixpath",
      "type": "function",
      "signature": "(path)",
      "description": "Expand ~ and ~user constructions.  If user or $HOME is unknown,\ndo nothing.",
      "relationships": []
    },
    {
      "id": "stdlib.posixpath.expandvars",
      "name": "expandvars",
      "module": "posixpath",
      "type": "function",
      "signature": "(path)",
      "description": "Expand shell variables of form $var and ${var}.  Unknown variables\nare left unchanged.",
      "relationships": []
    },
    {
      "id": "stdlib.posixpath.isabs",
      "name": "isabs",
      "module": "posixpath",
      "type": "function",
      "signature": "(s)",
      "description": "Test whether a path is absolute",
      "relationships": []
    },
    {
      "id": "stdlib.posixpath.isjunction",
      "name": "isjunction",
      "module": "posixpath",
      "type": "function",
      "signature": "(path)",
      "description": "Test whether a path is a junction\nJunctions are not a part of posix semantics",
      "relationships": []
    },
    {
      "id": "stdlib.posixpath.ismount",
      "name": "ismount",
      "module": "posixpath",
      "type": "function",
      "signature": "(path)",
      "description": "Test whether a path is a mount point",
      "relationships": []
    },
    {
      "id": "stdlib.posixpath.join",
      "name": "join",
      "module": "posixpath",
      "type": "function",
      "signature": "(a, *p)",
      "description": "Join two or more pathname components, inserting '/' as needed.\nIf any component is an absolute path, all previous path components\nwill be discarded.  An empty last part will result in a path that\nends with a separator.",
      "relationships": []
    },
    {
      "id": "stdlib.posixpath.lexists",
      "name": "lexists",
      "module": "posixpath",
      "type": "function",
      "signature": "(path)",
      "description": "Test whether a path exists.  Returns True for broken symbolic links",
      "relationships": []
    },
    {
      "id": "stdlib.posixpath.normcase",
      "name": "normcase",
      "module": "posixpath",
      "type": "function",
      "signature": "(s)",
      "description": "Normalize case of pathname.  Has no effect under Posix",
      "relationships": []
    },
    {
      "id": "stdlib.posixpath.realpath",
      "name": "realpath",
      "module": "posixpath",
      "type": "function",
      "signature": "(filename, *, strict=False)",
      "description": "Return the canonical path of the specified filename, eliminating any\nsymbolic links encountered in the path.",
      "relationships": []
    },
    {
      "id": "stdlib.posixpath.relpath",
      "name": "relpath",
      "module": "posixpath",
      "type": "function",
      "signature": "(path, start=None)",
      "description": "Return a relative version of a path",
      "relationships": []
    },
    {
      "id": "stdlib.posixpath.split",
      "name": "split",
      "module": "posixpath",
      "type": "function",
      "signature": "(p)",
      "description": "Split a pathname.  Returns tuple \"(head, tail)\" where \"tail\" is\neverything after the final slash.  Either part may be empty.",
      "relationships": []
    },
    {
      "id": "stdlib.posixpath.splitdrive",
      "name": "splitdrive",
      "module": "posixpath",
      "type": "function",
      "signature": "(p)",
      "description": "Split a pathname into drive and path. On Posix, drive is always\nempty.",
      "relationships": []
    },
    {
      "id": "stdlib.posixpath.splitext",
      "name": "splitext",
      "module": "posixpath",
      "type": "function",
      "signature": "(p)",
      "description": "Split the extension from a pathname.\n\nExtension is everything from the last dot to the end, ignoring\nleading dots.  Returns \"(root, ext)\"; ext may be empty.",
      "relationships": []
    },
    {
      "id": "stdlib.posixpath.splitroot",
      "name": "splitroot",
      "module": "posixpath",
      "type": "function",
      "signature": "(p)",
      "description": "Split a pathname into drive, root and tail. On Posix, drive is always\nempty; the root may be empty, a single slash, or two slashes. The tail\ncontains anything after the root. For example:\n\n    splitroot('foo/bar') == ('', '', 'foo/bar')\n    splitroot('/foo/bar') == ('', '/', 'foo/bar')\n    splitroot('//foo/bar') == ('', '//', 'foo/bar')\n    splitroot('///foo/bar') == ('', '/', '//foo/bar')",
      "relationships": []
    },
    {
      "id": "stdlib.pprint.PrettyPrinter",
      "name": "PrettyPrinter",
      "module": "pprint",
      "type": "class",
      "signature": "(indent=1, width=80, depth=None, stream=None, *, compact=False, sort_dicts=True, underscore_numbers=False)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.pprint.isreadable",
      "name": "isreadable",
      "module": "pprint",
      "type": "function",
      "signature": "(object)",
      "description": "Determine if saferepr(object) is readable by eval().",
      "relationships": []
    },
    {
      "id": "stdlib.pprint.isrecursive",
      "name": "isrecursive",
      "module": "pprint",
      "type": "function",
      "signature": "(object)",
      "description": "Determine if object requires a recursive representation.",
      "relationships": []
    },
    {
      "id": "stdlib.pprint.pformat",
      "name": "pformat",
      "module": "pprint",
      "type": "function",
      "signature": "(object, indent=1, width=80, depth=None, *, compact=False, sort_dicts=True, underscore_numbers=False)",
      "description": "Format a Python object into a pretty-printed representation.",
      "relationships": []
    },
    {
      "id": "stdlib.pprint.pp",
      "name": "pp",
      "module": "pprint",
      "type": "function",
      "signature": "(object, *args, sort_dicts=False, **kwargs)",
      "description": "Pretty-print a Python object",
      "relationships": [
        {
          "target": "stdlib.pprint.pprint",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pprint.pprint",
      "name": "pprint",
      "module": "pprint",
      "type": "function",
      "signature": "(object, stream=None, indent=1, width=80, depth=None, *, compact=False, sort_dicts=True, underscore_numbers=False)",
      "description": "Pretty-print a Python object to a stream [default is sys.stdout].",
      "relationships": []
    },
    {
      "id": "stdlib.pprint.saferepr",
      "name": "saferepr",
      "module": "pprint",
      "type": "function",
      "signature": "(object)",
      "description": "Version of repr() which can handle recursive data structures.",
      "relationships": []
    },
    {
      "id": "stdlib.profile.Profile",
      "name": "Profile",
      "module": "profile",
      "type": "class",
      "signature": "(timer=None, bias=None)",
      "description": "Profiler class.\n\nself.cur is always a tuple.  Each such tuple corresponds to a stack\nframe that is currently active (self.cur[-2]).  The following are the\ndefinitions of its members.  We use this external \"parallel stack\" to\navoid contaminating the program that we are profiling. (old profiler\nused to write into the frames local dictionary!!) Derived classes\ncan change the definition of some entries, as long as they leave\n[-2:] intact (frame and previous tuple).  In case an internal error is\ndetected, the -3 element is used as the function name.\n\n[ 0] = Time that needs to be charged to the parent frame's function.\n       It is used so that a function call will not have to access the\n       timing data for the parent frame.\n[ 1] = Total time spent in this frame's function, excluding time in\n       subfunctions (this latter is tallied in cur[2]).\n[ 2] = Total time spent in subfunctions, excluding time executing the\n       frame's function (this latter is tallied in cur[1]).\n[-3] = Name of the function that corresponds to this frame.\n[-2] = Actual frame that we correspond to (used to sync exception handling).\n[-1] = Our parent 6-tuple (corresponds to frame.f_back).\n\nTiming data for each function is stored as a 5-tuple in the dictionary\nself.timings[].  The index is always the name stored in self.cur[-3].\nThe following are the definitions of the members:\n\n[0] = The number of times this function was called, not counting direct\n      or indirect recursion,\n[1] = Number of times this function appears on the stack, minus one\n[2] = Total time spent internal to this function\n[3] = Cumulative time that this function was present on the stack.  In\n      non-recursive functions, this is the total execution time from start\n      to finish of each invocation of a function, including time spent in\n      all subfunctions.\n[4] = A dictionary indicating for each function name, the number of times\n      it was called by us.",
      "relationships": []
    },
    {
      "id": "stdlib.profile.main",
      "name": "main",
      "module": "profile",
      "type": "function",
      "signature": "()",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.profile.runctx",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.profile.run",
      "name": "run",
      "module": "profile",
      "type": "function",
      "signature": "(statement, filename=None, sort=-1)",
      "description": "Run statement under profiler optionally saving results in filename\n\nThis function takes a single argument that can be passed to the\n\"exec\" statement, and an optional file name.  In all cases this\nroutine attempts to \"exec\" its first argument and gather profiling\nstatistics from the execution. If no file name is present, then this\nfunction automatically prints a simple profiling report, sorted by the\nstandard name string (file/line/function-name) that is presented in\neach line.",
      "relationships": []
    },
    {
      "id": "stdlib.profile.runctx",
      "name": "runctx",
      "module": "profile",
      "type": "function",
      "signature": "(statement, globals, locals, filename=None, sort=-1)",
      "description": "Run statement under profiler, supplying your own globals and locals,\noptionally saving results in filename.\n\nstatement and filename have the same semantics as profile.run",
      "relationships": []
    },
    {
      "id": "stdlib.pstats.FunctionProfile",
      "name": "FunctionProfile",
      "module": "pstats",
      "type": "class",
      "signature": "(ncalls: str, tottime: float, percall_tottime: float, cumtime: float, percall_cumtime: float, file_name: str, line_number: int) -> None",
      "description": "FunctionProfile(ncalls: str, tottime: float, percall_tottime: float, cumtime: float, percall_cumtime: float, file_name: str, line_number: int)",
      "relationships": []
    },
    {
      "id": "stdlib.pstats.SortKey",
      "name": "SortKey",
      "module": "pstats",
      "type": "class",
      "signature": "(*values)",
      "description": "An enumeration.",
      "relationships": [
        {
          "target": "stdlib.enum.StrEnum",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.str",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.ReprEnum",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Enum",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.pstats.Stats",
      "name": "Stats",
      "module": "pstats",
      "type": "class",
      "signature": "(*args, stream=None)",
      "description": "This class is used for creating reports from data generated by the\nProfile class.  It is a \"friend\" of that class, and imports data either\nby direct access to members of Profile class, or by reading in a dictionary\nthat was emitted (via marshal) from the Profile class.\n\nThe big change from the previous Profiler (in terms of raw functionality)\nis that an \"add()\" method has been provided to combine Stats from\nseveral distinct profile runs.  Both the constructor and the add()\nmethod now take arbitrarily many file names as arguments.\n\nAll the print methods now take an argument that indicates how many lines\nto print.  If the arg is a floating-point number between 0 and 1.0, then\nit is taken as a decimal percentage of the available lines to be printed\n(e.g., .1 means print 10% of all available lines).  If it is an integer,\nit is taken to mean the number of lines of data that you wish to have\nprinted.\n\nThe sort_stats() method now processes some additional options (i.e., in\naddition to the old -1, 0, 1, or 2 that are respectively interpreted as\n'stdname', 'calls', 'time', and 'cumulative').  It takes either an\narbitrary number of quoted strings or SortKey enum to select the sort\norder.\n\nFor example sort_stats('time', 'name') or sort_stats(SortKey.TIME,\nSortKey.NAME) sorts on the major key of 'internal function time', and on\nthe minor key of 'the name of the function'.  Look at the two tables in\nsort_stats() and get_sort_arg_defs(self) for more examples.\n\nAll methods return self, so you can string together commands like:\n    Stats('foo', 'goo').strip_dirs().sort_stats('calls').                            print_stats(5).print_callers(5)",
      "relationships": []
    },
    {
      "id": "stdlib.pstats.StatsProfile",
      "name": "StatsProfile",
      "module": "pstats",
      "type": "class",
      "signature": "(total_tt: float, func_profiles: Dict[str, pstats.FunctionProfile]) -> None",
      "description": "Class for keeping track of an item in inventory.",
      "relationships": []
    },
    {
      "id": "stdlib.pstats.TupleComp",
      "name": "TupleComp",
      "module": "pstats",
      "type": "class",
      "signature": "(comp_select_list)",
      "description": "This class provides a generic function for comparing any two tuples.\nEach instance records a list of tuple-indices (from most significant\nto least significant), and sort direction (ascending or descending) for\neach tuple-index.  The compare functions can then be used as the function\nargument to the system sort() function when a list of tuples need to be\nsorted in the instances order.",
      "relationships": []
    },
    {
      "id": "stdlib.pstats.add_callers",
      "name": "add_callers",
      "module": "pstats",
      "type": "function",
      "signature": "(target, source)",
      "description": "Combine two caller lists in a single list.",
      "relationships": []
    },
    {
      "id": "stdlib.pstats.add_func_stats",
      "name": "add_func_stats",
      "module": "pstats",
      "type": "function",
      "signature": "(target, source)",
      "description": "Add together all the stats for two profile entries.",
      "relationships": [
        {
          "target": "stdlib.pstats.add_callers",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pstats.count_calls",
      "name": "count_calls",
      "module": "pstats",
      "type": "function",
      "signature": "(callers)",
      "description": "Sum the caller statistics to get total number of calls received.",
      "relationships": []
    },
    {
      "id": "stdlib.pstats.f8",
      "name": "f8",
      "module": "pstats",
      "type": "function",
      "signature": "(x)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.pstats.func_get_function_name",
      "name": "func_get_function_name",
      "module": "pstats",
      "type": "function",
      "signature": "(func)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.pstats.func_std_string",
      "name": "func_std_string",
      "module": "pstats",
      "type": "function",
      "signature": "(func_name)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.pstats.func_strip_path",
      "name": "func_strip_path",
      "module": "pstats",
      "type": "function",
      "signature": "(func_name)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.pty.fork",
      "name": "fork",
      "module": "pty",
      "type": "function",
      "signature": "()",
      "description": "fork() -> (pid, master_fd)\nFork and make the child a session leader with a controlling terminal.",
      "relationships": [
        {
          "target": "stdlib.pty.openpty",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pty.master_open",
      "name": "master_open",
      "module": "pty",
      "type": "function",
      "signature": "()",
      "description": "master_open() -> (master_fd, slave_name)\nOpen a pty master and return the fd, and the filename of the slave end.\nDeprecated, use openpty() instead.",
      "relationships": [
        {
          "target": "stdlib.pty._open_terminal",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pty.openpty",
      "name": "openpty",
      "module": "pty",
      "type": "function",
      "signature": "()",
      "description": "openpty() -> (master_fd, slave_fd)\nOpen a pty master/slave pair, using os.openpty() if possible.",
      "relationships": [
        {
          "target": "stdlib.pty._open_terminal",
          "type": "calls"
        },
        {
          "target": "stdlib.pty.slave_open",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pty.slave_open",
      "name": "slave_open",
      "module": "pty",
      "type": "function",
      "signature": "(tty_name)",
      "description": "slave_open(tty_name) -> slave_fd\nOpen the pty slave and acquire the controlling terminal, returning\nopened filedescriptor.\nDeprecated, use openpty() instead.",
      "relationships": []
    },
    {
      "id": "stdlib.pty.spawn",
      "name": "spawn",
      "module": "pty",
      "type": "function",
      "signature": "(argv, master_read=<function _read at 0x106a3c4a0>, stdin_read=<function _read at 0x106a3c4a0>)",
      "description": "Create a spawned process.",
      "relationships": [
        {
          "target": "stdlib.pty.fork",
          "type": "calls"
        },
        {
          "target": "stdlib.pty._copy",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.py_compile.PyCompileError",
      "name": "PyCompileError",
      "module": "py_compile",
      "type": "class",
      "signature": "(exc_type, exc_value, file, msg='')",
      "description": "Exception raised when an error occurs while attempting to\ncompile the file.\n\nTo raise this exception, use\n\n    raise PyCompileError(exc_type,exc_value,file[,msg])\n\nwhere\n\n    exc_type:   exception type to be used in error message\n                type name can be accesses as class variable\n                'exc_type_name'\n\n    exc_value:  exception value to be used in error message\n                can be accesses as class variable 'exc_value'\n\n    file:       name of file being compiled to be used in error message\n                can be accesses as class variable 'file'\n\n    msg:        string message to be written as error message\n                If no value is given, a default exception message will be\n                given, consistent with 'standard' py_compile output.\n                message (or default) can be accesses as class variable\n                'msg'",
      "relationships": [
        {
          "target": "stdlib.builtins.Exception",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.py_compile.PycInvalidationMode",
      "name": "PycInvalidationMode",
      "module": "py_compile",
      "type": "class",
      "signature": "(*values)",
      "description": "Create a collection of name/value pairs.\n\nExample enumeration:\n\n>>> class Color(Enum):\n...     RED = 1\n...     BLUE = 2\n...     GREEN = 3\n\nAccess them by:\n\n- attribute access:\n\n  >>> Color.RED\n  <Color.RED: 1>\n\n- value lookup:\n\n  >>> Color(1)\n  <Color.RED: 1>\n\n- name lookup:\n\n  >>> Color['RED']\n  <Color.RED: 1>\n\nEnumerations can be iterated over, and know how many members they have:\n\n>>> len(Color)\n3\n\n>>> list(Color)\n[<Color.RED: 1>, <Color.BLUE: 2>, <Color.GREEN: 3>]\n\nMethods can be added to enumerations, and members can have their own\nattributes -- see the documentation for details.",
      "relationships": [
        {
          "target": "stdlib.enum.Enum",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.py_compile.compile",
      "name": "compile",
      "module": "py_compile",
      "type": "function",
      "signature": "(file, cfile=None, dfile=None, doraise=False, optimize=-1, invalidation_mode=None, quiet=0)",
      "description": "Byte-compile one Python source file to Python bytecode.\n\n:param file: The source file name.\n:param cfile: The target byte compiled file name.  When not given, this\n    defaults to the PEP 3147/PEP 488 location.\n:param dfile: Purported file name, i.e. the file name that shows up in\n    error messages.  Defaults to the source file name.\n:param doraise: Flag indicating whether or not an exception should be\n    raised when a compile error is found.  If an exception occurs and this\n    flag is set to False, a string indicating the nature of the exception\n    will be printed, and the function will return to the caller. If an\n    exception occurs and this flag is set to True, a PyCompileError\n    exception will be raised.\n:param optimize: The optimization level for the compiler.  Valid values\n    are -1, 0, 1 and 2.  A value of -1 means to use the optimization\n    level of the current interpreter, as given by -O command line options.\n:param invalidation_mode:\n:param quiet: Return full output with False or 0, errors only with 1,\n    and no output with 2.\n\n:return: Path to the resulting byte compiled file.\n\nNote that it isn't necessary to byte-compile Python modules for\nexecution efficiency -- Python itself byte-compiles a module when\nit is loaded, and if it can, writes out the bytecode to the\ncorresponding .pyc file.\n\nHowever, if a Python installation is shared between users, it is a\ngood idea to byte-compile all modules upon installation, since\nother users may not be able to write in the source directories,\nand thus they won't be able to write the .pyc file, and then\nthey would be byte-compiling every module each time it is loaded.\nThis can slow down program start-up considerably.\n\nSee compileall.py for a script/module that uses this module to\nbyte-compile all installed files (or all files in selected\ndirectories).\n\nDo note that FileExistsError is raised if cfile ends up pointing at a\nnon-regular file or symlink. Because the compilation uses a file renaming,\nthe resulting file would be regular and thus not the same type of file as\nit was previously.",
      "relationships": [
        {
          "target": "stdlib.py_compile._get_default_invalidation_mode",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.py_compile.main",
      "name": "main",
      "module": "py_compile",
      "type": "function",
      "signature": "()",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.pyclbr.Class",
      "name": "Class",
      "module": "pyclbr",
      "type": "class",
      "signature": "(module, name, super_, file, lineno, parent=None, *, end_lineno=None)",
      "description": "Information about a Python class.",
      "relationships": [
        {
          "target": "stdlib.pyclbr._Object",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.pyclbr.Function",
      "name": "Function",
      "module": "pyclbr",
      "type": "class",
      "signature": "(module, name, file, lineno, parent=None, is_async=False, *, end_lineno=None)",
      "description": "Information about a Python function, including methods.",
      "relationships": [
        {
          "target": "stdlib.pyclbr._Object",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.pyclbr.readmodule",
      "name": "readmodule",
      "module": "pyclbr",
      "type": "function",
      "signature": "(module, path=None)",
      "description": "Return Class objects for the top-level classes in module.\n\nThis is the original interface, before Functions were added.",
      "relationships": [
        {
          "target": "stdlib.pyclbr._readmodule",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pyclbr.readmodule_ex",
      "name": "readmodule_ex",
      "module": "pyclbr",
      "type": "function",
      "signature": "(module, path=None)",
      "description": "Return a dictionary with all functions and classes in module.\n\nSearch for module in PATH + sys.path.\nIf possible, include imported superclasses.\nDo this by reading source, without importing (and executing) it.",
      "relationships": [
        {
          "target": "stdlib.pyclbr._readmodule",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pydoc.Doc",
      "name": "Doc",
      "module": "pydoc",
      "type": "class",
      "signature": "()",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.pydoc.ErrorDuringImport",
      "name": "ErrorDuringImport",
      "module": "pydoc",
      "type": "class",
      "signature": "(filename, exc_info)",
      "description": "Errors that occurred while trying to import something to document it.",
      "relationships": [
        {
          "target": "stdlib.builtins.Exception",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.pydoc.HTMLDoc",
      "name": "HTMLDoc",
      "module": "pydoc",
      "type": "class",
      "signature": "()",
      "description": "Formatter class for HTML documentation.",
      "relationships": [
        {
          "target": "stdlib.pydoc.Doc",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.pydoc.HTMLRepr",
      "name": "HTMLRepr",
      "module": "pydoc",
      "type": "class",
      "signature": "()",
      "description": "Class for safely making an HTML representation of a Python object.",
      "relationships": [
        {
          "target": "stdlib.reprlib.Repr",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.pydoc.Helper",
      "name": "Helper",
      "module": "pydoc",
      "type": "class",
      "signature": "(input=None, output=None)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.pydoc.ModuleScanner",
      "name": "ModuleScanner",
      "module": "pydoc",
      "type": "class",
      "signature": "()",
      "description": "An interruptible scanner that searches module synopses.",
      "relationships": []
    },
    {
      "id": "stdlib.pydoc.TextDoc",
      "name": "TextDoc",
      "module": "pydoc",
      "type": "class",
      "signature": "()",
      "description": "Formatter class for text documentation.",
      "relationships": [
        {
          "target": "stdlib.pydoc.Doc",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.pydoc.TextRepr",
      "name": "TextRepr",
      "module": "pydoc",
      "type": "class",
      "signature": "()",
      "description": "Class for safely making a text representation of a Python object.",
      "relationships": [
        {
          "target": "stdlib.reprlib.Repr",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.pydoc.allmethods",
      "name": "allmethods",
      "module": "pydoc",
      "type": "function",
      "signature": "(cl)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.pydoc.allmethods",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pydoc.apropos",
      "name": "apropos",
      "module": "pydoc",
      "type": "function",
      "signature": "(key)",
      "description": "Print all the one-line module summaries that contain a substring.",
      "relationships": []
    },
    {
      "id": "stdlib.pydoc.browse",
      "name": "browse",
      "module": "pydoc",
      "type": "function",
      "signature": "(port=0, *, open_browser=True, hostname='localhost')",
      "description": "Start the enhanced pydoc web server and open a web browser.\n\nUse port '0' to start the server on an arbitrary port.\nSet open_browser to False to suppress opening a browser.",
      "relationships": [
        {
          "target": "stdlib.pydoc._start_server",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pydoc.classify_class_attrs",
      "name": "classify_class_attrs",
      "module": "pydoc",
      "type": "function",
      "signature": "(object)",
      "description": "Wrap inspect.classify_class_attrs, with fixup for data descriptors and bound methods.",
      "relationships": [
        {
          "target": "stdlib.pydoc._is_bound_method",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pydoc.classname",
      "name": "classname",
      "module": "pydoc",
      "type": "function",
      "signature": "(object, modname)",
      "description": "Get a class name and qualify it with a module name if necessary.",
      "relationships": []
    },
    {
      "id": "stdlib.pydoc.cli",
      "name": "cli",
      "module": "pydoc",
      "type": "function",
      "signature": "()",
      "description": "Command-line interface (looks at sys.argv to decide what to do).",
      "relationships": [
        {
          "target": "stdlib.pydoc._adjust_cli_sys_path",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.browse",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.apropos",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.ispath",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.ispath",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.importfile",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.ispath",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.writedocs",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.writedoc",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pydoc.cram",
      "name": "cram",
      "module": "pydoc",
      "type": "function",
      "signature": "(text, maxlen)",
      "description": "Omit part of a string if needed to make it fit in a maximum length.",
      "relationships": []
    },
    {
      "id": "stdlib.pydoc.describe",
      "name": "describe",
      "module": "pydoc",
      "type": "function",
      "signature": "(thing)",
      "description": "Produce a short description of the given thing.",
      "relationships": []
    },
    {
      "id": "stdlib.pydoc.doc",
      "name": "doc",
      "module": "pydoc",
      "type": "function",
      "signature": "(thing, title='Python Library Documentation: %s', forceload=0, output=None, is_cli=False)",
      "description": "Display text documentation, given an object or a path to an object.",
      "relationships": [
        {
          "target": "stdlib.pydoc.pager",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.render_doc",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.render_doc",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pydoc.getdoc",
      "name": "getdoc",
      "module": "pydoc",
      "type": "function",
      "signature": "(object)",
      "description": "Get the doc string or comments for an object.",
      "relationships": [
        {
          "target": "stdlib.pydoc._getdoc",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pydoc.getpager",
      "name": "getpager",
      "module": "pydoc",
      "type": "function",
      "signature": "()",
      "description": "Decide what method to use for paging through text.",
      "relationships": [
        {
          "target": "stdlib.pydoc.tempfilepager",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.pipepager",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.tempfilepager",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.plain",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.pipepager",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.plain",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.pipepager",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.pipepager",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.plain",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pydoc.importfile",
      "name": "importfile",
      "module": "pydoc",
      "type": "function",
      "signature": "(path)",
      "description": "Import a Python source file or compiled file given its path.",
      "relationships": []
    },
    {
      "id": "stdlib.pydoc.isdata",
      "name": "isdata",
      "module": "pydoc",
      "type": "function",
      "signature": "(object)",
      "description": "Check if an object is of a type that probably means it's data.",
      "relationships": []
    },
    {
      "id": "stdlib.pydoc.ispackage",
      "name": "ispackage",
      "module": "pydoc",
      "type": "function",
      "signature": "(path)",
      "description": "Guess whether a path refers to a package directory.",
      "relationships": []
    },
    {
      "id": "stdlib.pydoc.ispath",
      "name": "ispath",
      "module": "pydoc",
      "type": "function",
      "signature": "(x)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.pydoc.locate",
      "name": "locate",
      "module": "pydoc",
      "type": "function",
      "signature": "(path, forceload=0)",
      "description": "Locate an object by name or dotted path, importing as necessary.",
      "relationships": [
        {
          "target": "stdlib.pydoc.safeimport",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pydoc.pager",
      "name": "pager",
      "module": "pydoc",
      "type": "function",
      "signature": "(text)",
      "description": "The first time this is called, determine what kind of pager to use.",
      "relationships": [
        {
          "target": "stdlib.pydoc.getpager",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.pager",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pydoc.parentname",
      "name": "parentname",
      "module": "pydoc",
      "type": "function",
      "signature": "(object, modname)",
      "description": "Get a name of the enclosing class (qualified it with a module name\nif necessary) or module.",
      "relationships": []
    },
    {
      "id": "stdlib.pydoc.pathdirs",
      "name": "pathdirs",
      "module": "pydoc",
      "type": "function",
      "signature": "()",
      "description": "Convert sys.path into a list of absolute, existing, unique paths.",
      "relationships": []
    },
    {
      "id": "stdlib.pydoc.pipepager",
      "name": "pipepager",
      "module": "pydoc",
      "type": "function",
      "signature": "(text, cmd)",
      "description": "Page through text by feeding it to another program.",
      "relationships": []
    },
    {
      "id": "stdlib.pydoc.plain",
      "name": "plain",
      "module": "pydoc",
      "type": "function",
      "signature": "(text)",
      "description": "Remove boldface formatting from text.",
      "relationships": []
    },
    {
      "id": "stdlib.pydoc.plainpager",
      "name": "plainpager",
      "module": "pydoc",
      "type": "function",
      "signature": "(text)",
      "description": "Simply print unformatted text.  This is the ultimate fallback.",
      "relationships": [
        {
          "target": "stdlib.pydoc.plain",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc._escape_stdout",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pydoc.render_doc",
      "name": "render_doc",
      "module": "pydoc",
      "type": "function",
      "signature": "(thing, title='Python Library Documentation: %s', forceload=0, renderer=None)",
      "description": "Render text documentation, given an object or a path to an object.",
      "relationships": [
        {
          "target": "stdlib.pydoc.resolve",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.describe",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc._getdoc",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pydoc.replace",
      "name": "replace",
      "module": "pydoc",
      "type": "function",
      "signature": "(text, *pairs)",
      "description": "Do a series of global replacements on a string.",
      "relationships": []
    },
    {
      "id": "stdlib.pydoc.resolve",
      "name": "resolve",
      "module": "pydoc",
      "type": "function",
      "signature": "(thing, forceload=0)",
      "description": "Given an object or a path to an object, get the object and its name.",
      "relationships": [
        {
          "target": "stdlib.pydoc.locate",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pydoc.safeimport",
      "name": "safeimport",
      "module": "pydoc",
      "type": "function",
      "signature": "(path, forceload=0, cache={})",
      "description": "Import a module; handle errors; return None if the module isn't found.\n\nIf the module *is* found but an exception occurs, it's wrapped in an\nErrorDuringImport exception and reraised.  Unlike __import__, if a\npackage path is specified, the module at the end of the path is returned,\nnot the package at the beginning.  If the optional 'forceload' argument\nis 1, we reload the module from disk (unless it's a dynamic extension).",
      "relationships": []
    },
    {
      "id": "stdlib.pydoc.sort_attributes",
      "name": "sort_attributes",
      "module": "pydoc",
      "type": "function",
      "signature": "(attrs, object)",
      "description": "Sort the attrs list in-place by _fields and then alphabetically by name",
      "relationships": []
    },
    {
      "id": "stdlib.pydoc.source_synopsis",
      "name": "source_synopsis",
      "module": "pydoc",
      "type": "function",
      "signature": "(file)",
      "description": "Return the one-line summary of a file object, if present",
      "relationships": []
    },
    {
      "id": "stdlib.pydoc.splitdoc",
      "name": "splitdoc",
      "module": "pydoc",
      "type": "function",
      "signature": "(doc)",
      "description": "Split a doc string into a synopsis line (if any) and the rest.",
      "relationships": []
    },
    {
      "id": "stdlib.pydoc.stripid",
      "name": "stripid",
      "module": "pydoc",
      "type": "function",
      "signature": "(text)",
      "description": "Remove the hexadecimal id from a Python object representation.",
      "relationships": []
    },
    {
      "id": "stdlib.pydoc.synopsis",
      "name": "synopsis",
      "module": "pydoc",
      "type": "function",
      "signature": "(filename, cache={})",
      "description": "Get the one-line summary out of a module file.",
      "relationships": [
        {
          "target": "stdlib.pydoc.source_synopsis",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pydoc.tempfilepager",
      "name": "tempfilepager",
      "module": "pydoc",
      "type": "function",
      "signature": "(text, cmd)",
      "description": "Page through text by invoking a program on a temporary file.",
      "relationships": []
    },
    {
      "id": "stdlib.pydoc.ttypager",
      "name": "ttypager",
      "module": "pydoc",
      "type": "function",
      "signature": "(text)",
      "description": "Page through text on a text terminal.",
      "relationships": [
        {
          "target": "stdlib.pydoc.plain",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc._escape_stdout",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pydoc.visiblename",
      "name": "visiblename",
      "module": "pydoc",
      "type": "function",
      "signature": "(name, all=None, obj=None)",
      "description": "Decide whether to show documentation on a variable.",
      "relationships": []
    },
    {
      "id": "stdlib.pydoc.writedoc",
      "name": "writedoc",
      "module": "pydoc",
      "type": "function",
      "signature": "(thing, forceload=0)",
      "description": "Write HTML documentation to a file in the current directory.",
      "relationships": [
        {
          "target": "stdlib.pydoc.resolve",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.describe",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pydoc.writedocs",
      "name": "writedocs",
      "module": "pydoc",
      "type": "function",
      "signature": "(dir, pkgpath='', done=None)",
      "description": "Write out HTML documentation for all modules in a directory tree.",
      "relationships": [
        {
          "target": "stdlib.pydoc.writedoc",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pyexpat.XMLParserType",
      "name": "XMLParserType",
      "module": "pyexpat",
      "type": "class",
      "signature": "()",
      "description": "XML parser",
      "relationships": []
    },
    {
      "id": "stdlib.queue.LifoQueue",
      "name": "LifoQueue",
      "module": "queue",
      "type": "class",
      "signature": "(maxsize=0)",
      "description": "Variant of Queue that retrieves most recently added entries first.",
      "relationships": [
        {
          "target": "stdlib.queue.Queue",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.queue.PriorityQueue",
      "name": "PriorityQueue",
      "module": "queue",
      "type": "class",
      "signature": "(maxsize=0)",
      "description": "Variant of Queue that retrieves open entries in priority order (lowest first).\n\nEntries are typically tuples of the form:  (priority number, data).",
      "relationships": [
        {
          "target": "stdlib.queue.Queue",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.queue.Queue",
      "name": "Queue",
      "module": "queue",
      "type": "class",
      "signature": "(maxsize=0)",
      "description": "Create a queue object with a given maximum size.\n\nIf maxsize is <= 0, the queue size is infinite.",
      "relationships": []
    },
    {
      "id": "stdlib.quopri.decode",
      "name": "decode",
      "module": "quopri",
      "type": "function",
      "signature": "(input, output, header=False)",
      "description": "Read 'input', apply quoted-printable decoding, and write to 'output'.\n'input' and 'output' are binary file objects.\nIf 'header' is true, decode underscore as space (per RFC 1522).",
      "relationships": [
        {
          "target": "stdlib.quopri.ishex",
          "type": "calls"
        },
        {
          "target": "stdlib.quopri.ishex",
          "type": "calls"
        },
        {
          "target": "stdlib.quopri.unhex",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.quopri.decodestring",
      "name": "decodestring",
      "module": "quopri",
      "type": "function",
      "signature": "(s, header=False)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.quopri.decode",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.quopri.encode",
      "name": "encode",
      "module": "quopri",
      "type": "function",
      "signature": "(input, output, quotetabs, header=False)",
      "description": "Read 'input', apply quoted-printable encoding, and write to 'output'.\n\n'input' and 'output' are binary file objects. The 'quotetabs' flag\nindicates whether embedded tabs and spaces should be quoted. Note that\nline-ending tabs and spaces are always encoded, as per RFC 1521.\nThe 'header' flag indicates whether we are encoding spaces as _ as per RFC\n1522.",
      "relationships": [
        {
          "target": "stdlib.quopri.needsquoting",
          "type": "calls"
        },
        {
          "target": "stdlib.quopri.quote",
          "type": "calls"
        },
        {
          "target": "stdlib.quopri.quote",
          "type": "calls"
        },
        {
          "target": "stdlib.quopri.quote",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.quopri.encodestring",
      "name": "encodestring",
      "module": "quopri",
      "type": "function",
      "signature": "(s, quotetabs=False, header=False)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.quopri.encode",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.quopri.ishex",
      "name": "ishex",
      "module": "quopri",
      "type": "function",
      "signature": "(c)",
      "description": "Return true if the byte ordinal 'c' is a hexadecimal digit in ASCII.",
      "relationships": []
    },
    {
      "id": "stdlib.quopri.main",
      "name": "main",
      "module": "quopri",
      "type": "function",
      "signature": "()",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.quopri.decode",
          "type": "calls"
        },
        {
          "target": "stdlib.quopri.encode",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.quopri.needsquoting",
      "name": "needsquoting",
      "module": "quopri",
      "type": "function",
      "signature": "(c, quotetabs, header)",
      "description": "Decide whether a particular byte ordinal needs to be quoted.\n\nThe 'quotetabs' flag indicates whether embedded tabs and spaces should be\nquoted.  Note that line-ending tabs and spaces are always encoded, as per\nRFC 1521.",
      "relationships": []
    },
    {
      "id": "stdlib.quopri.quote",
      "name": "quote",
      "module": "quopri",
      "type": "function",
      "signature": "(c)",
      "description": "Quote a single character.",
      "relationships": []
    },
    {
      "id": "stdlib.quopri.unhex",
      "name": "unhex",
      "module": "quopri",
      "type": "function",
      "signature": "(s)",
      "description": "Get the integer value of a hexadecimal number.",
      "relationships": []
    },
    {
      "id": "stdlib.random.Random",
      "name": "Random",
      "module": "random",
      "type": "class",
      "signature": "(x=None)",
      "description": "Random number generator base class used by bound module functions.\n\nUsed to instantiate instances of Random to get generators that don't\nshare state.\n\nClass Random can also be subclassed if you want to use a different basic\ngenerator of your own devising: in that case, override the following\nmethods:  random(), seed(), getstate(), and setstate().\nOptionally, implement a getrandbits() method so that randrange()\ncan cover arbitrarily large ranges.",
      "relationships": [
        {
          "target": "stdlib._random.Random",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.random.SystemRandom",
      "name": "SystemRandom",
      "module": "random",
      "type": "class",
      "signature": "(x=None)",
      "description": "Alternate random number generator using sources provided\nby the operating system (such as /dev/urandom on Unix or\nCryptGenRandom on Windows).\n\n Not available on all systems (see os.urandom() for details).",
      "relationships": [
        {
          "target": "stdlib.random.Random",
          "type": "base_class"
        },
        {
          "target": "stdlib.random.Random",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.re.Match",
      "name": "Match",
      "module": "re",
      "type": "class",
      "signature": "()",
      "description": "The result of re.match() and re.search().\nMatch objects always have a boolean value of True.",
      "relationships": []
    },
    {
      "id": "stdlib.re.Pattern",
      "name": "Pattern",
      "module": "re",
      "type": "class",
      "signature": "()",
      "description": "Compiled regular expression object.",
      "relationships": []
    },
    {
      "id": "stdlib.re.RegexFlag",
      "name": "RegexFlag",
      "module": "re",
      "type": "class",
      "signature": "(*values)",
      "description": "An enumeration.",
      "relationships": [
        {
          "target": "stdlib.enum.IntFlag",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.int",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.ReprEnum",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Flag",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Enum",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.re.Scanner",
      "name": "Scanner",
      "module": "re",
      "type": "class",
      "signature": "(lexicon, flags=0)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.re.compile",
      "name": "compile",
      "module": "re",
      "type": "function",
      "signature": "(pattern, flags=0)",
      "description": "Compile a regular expression pattern, returning a Pattern object.",
      "relationships": [
        {
          "target": "stdlib.re._compile",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.re.error",
      "name": "error",
      "module": "re",
      "type": "class",
      "signature": "(msg, pattern=None, pos=None)",
      "description": "Exception raised for invalid regular expressions.\n\nAttributes:\n\n    msg: The unformatted error message\n    pattern: The regular expression pattern\n    pos: The index in the pattern where compilation failed (may be None)\n    lineno: The line corresponding to pos (may be None)\n    colno: The column corresponding to pos (may be None)",
      "relationships": [
        {
          "target": "stdlib.builtins.Exception",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.re.escape",
      "name": "escape",
      "module": "re",
      "type": "function",
      "signature": "(pattern)",
      "description": "Escape special characters in a string.",
      "relationships": []
    },
    {
      "id": "stdlib.re.findall",
      "name": "findall",
      "module": "re",
      "type": "function",
      "signature": "(pattern, string, flags=0)",
      "description": "Return a list of all non-overlapping matches in the string.\n\nIf one or more capturing groups are present in the pattern, return\na list of groups; this will be a list of tuples if the pattern\nhas more than one group.\n\nEmpty matches are included in the result.",
      "relationships": [
        {
          "target": "stdlib.re._compile",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.re.finditer",
      "name": "finditer",
      "module": "re",
      "type": "function",
      "signature": "(pattern, string, flags=0)",
      "description": "Return an iterator over all non-overlapping matches in the\nstring.  For each match, the iterator returns a Match object.\n\nEmpty matches are included in the result.",
      "relationships": [
        {
          "target": "stdlib.re._compile",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.re.fullmatch",
      "name": "fullmatch",
      "module": "re",
      "type": "function",
      "signature": "(pattern, string, flags=0)",
      "description": "Try to apply the pattern to all of the string, returning\na Match object, or None if no match was found.",
      "relationships": [
        {
          "target": "stdlib.re._compile",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.re.match",
      "name": "match",
      "module": "re",
      "type": "function",
      "signature": "(pattern, string, flags=0)",
      "description": "Try to apply the pattern at the start of the string, returning\na Match object, or None if no match was found.",
      "relationships": [
        {
          "target": "stdlib.re._compile",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.re.purge",
      "name": "purge",
      "module": "re",
      "type": "function",
      "signature": "()",
      "description": "Clear the regular expression caches",
      "relationships": []
    },
    {
      "id": "stdlib.re.search",
      "name": "search",
      "module": "re",
      "type": "function",
      "signature": "(pattern, string, flags=0)",
      "description": "Scan through string looking for a match to the pattern, returning\na Match object, or None if no match was found.",
      "relationships": [
        {
          "target": "stdlib.re._compile",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.re.split",
      "name": "split",
      "module": "re",
      "type": "function",
      "signature": "(pattern, string, maxsplit=0, flags=0)",
      "description": "Split the source string by the occurrences of the pattern,\nreturning a list containing the resulting substrings.  If\ncapturing parentheses are used in pattern, then the text of all\ngroups in the pattern are also returned as part of the resulting\nlist.  If maxsplit is nonzero, at most maxsplit splits occur,\nand the remainder of the string is returned as the final element\nof the list.",
      "relationships": [
        {
          "target": "stdlib.re._compile",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.re.sub",
      "name": "sub",
      "module": "re",
      "type": "function",
      "signature": "(pattern, repl, string, count=0, flags=0)",
      "description": "Return the string obtained by replacing the leftmost\nnon-overlapping occurrences of the pattern in string by the\nreplacement repl.  repl can be either a string or a callable;\nif a string, backslash escapes in it are processed.  If it is\na callable, it's passed the Match object and must return\na replacement string to be used.",
      "relationships": [
        {
          "target": "stdlib.re._compile",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.re.subn",
      "name": "subn",
      "module": "re",
      "type": "function",
      "signature": "(pattern, repl, string, count=0, flags=0)",
      "description": "Return a 2-tuple containing (new_string, number).\nnew_string is the string obtained by replacing the leftmost\nnon-overlapping occurrences of the pattern in the source\nstring by the replacement repl.  number is the number of\nsubstitutions that were made. repl can be either a string or a\ncallable; if a string, backslash escapes in it are processed.\nIf it is a callable, it's passed the Match object and must\nreturn a replacement string to be used.",
      "relationships": [
        {
          "target": "stdlib.re._compile",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.re.template",
      "name": "template",
      "module": "re",
      "type": "function",
      "signature": "(pattern, flags=0)",
      "description": "Compile a template pattern, returning a Pattern object, deprecated",
      "relationships": [
        {
          "target": "stdlib.re._compile",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.reprlib.Repr",
      "name": "Repr",
      "module": "reprlib",
      "type": "class",
      "signature": "(*, maxlevel=6, maxtuple=6, maxlist=6, maxarray=5, maxdict=4, maxset=6, maxfrozenset=6, maxdeque=6, maxstring=30, maxlong=40, maxother=30, fillvalue='...', indent=None)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.reprlib.recursive_repr",
      "name": "recursive_repr",
      "module": "reprlib",
      "type": "function",
      "signature": "(fillvalue='...')",
      "description": "Decorator to make a repr function return fillvalue for a recursive call",
      "relationships": []
    },
    {
      "id": "stdlib.resource.struct_rusage",
      "name": "struct_rusage",
      "module": "resource",
      "type": "class",
      "signature": "(iterable=(), /)",
      "description": "struct_rusage: Result from getrusage.\n\nThis object may be accessed either as a tuple of\n    (utime,stime,maxrss,ixrss,idrss,isrss,minflt,majflt,\n    nswap,inblock,oublock,msgsnd,msgrcv,nsignals,nvcsw,nivcsw)\nor via the attributes ru_utime, ru_stime, ru_maxrss, and so on.",
      "relationships": [
        {
          "target": "stdlib.builtins.tuple",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.rlcompleter.Completer",
      "name": "Completer",
      "module": "rlcompleter",
      "type": "class",
      "signature": "(namespace=None)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.rlcompleter.get_class_members",
      "name": "get_class_members",
      "module": "rlcompleter",
      "type": "function",
      "signature": "(klass)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.rlcompleter.get_class_members",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.runpy.run_module",
      "name": "run_module",
      "module": "runpy",
      "type": "function",
      "signature": "(mod_name, init_globals=None, run_name=None, alter_sys=False)",
      "description": "Execute a module's code without importing it.\n\nmod_name -- an absolute module name or package name.\n\nOptional arguments:\ninit_globals -- dictionary used to pre-populate the module\u2019s\nglobals dictionary before the code is executed.\n\nrun_name -- if not None, this will be used for setting __name__;\notherwise, __name__ will be set to mod_name + '__main__' if the\nnamed module is a package and to just mod_name otherwise.\n\nalter_sys -- if True, sys.argv[0] is updated with the value of\n__file__ and sys.modules[__name__] is updated with a temporary\nmodule object for the module being executed. Both are\nrestored to their original values before the function returns.\n\nReturns the resulting module globals dictionary.",
      "relationships": []
    },
    {
      "id": "stdlib.runpy.run_path",
      "name": "run_path",
      "module": "runpy",
      "type": "function",
      "signature": "(path_name, init_globals=None, run_name=None)",
      "description": "Execute code located at the specified filesystem location.\n\npath_name -- filesystem location of a Python script, zipfile,\nor directory containing a top level __main__.py script.\n\nOptional arguments:\ninit_globals -- dictionary used to pre-populate the module\u2019s\nglobals dictionary before the code is executed.\n\nrun_name -- if not None, this will be used to set __name__;\notherwise, '<run_path>' will be used for __name__.\n\nReturns the resulting module globals dictionary.",
      "relationships": []
    },
    {
      "id": "stdlib.sched.Event",
      "name": "Event",
      "module": "sched",
      "type": "class",
      "signature": "(time, priority, sequence, action, argument, kwargs)",
      "description": "Event(time, priority, sequence, action, argument, kwargs)",
      "relationships": [
        {
          "target": "stdlib.builtins.tuple",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.sched.scheduler",
      "name": "scheduler",
      "module": "sched",
      "type": "class",
      "signature": "(timefunc=<built-in function monotonic>, delayfunc=<built-in function sleep>)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.secrets.randbelow",
      "name": "randbelow",
      "module": "secrets",
      "type": "function",
      "signature": "(exclusive_upper_bound)",
      "description": "Return a random int in the range [0, n).",
      "relationships": []
    },
    {
      "id": "stdlib.secrets.token_bytes",
      "name": "token_bytes",
      "module": "secrets",
      "type": "function",
      "signature": "(nbytes=None)",
      "description": "Return a random byte string containing *nbytes* bytes.\n\nIf *nbytes* is ``None`` or not supplied, a reasonable\ndefault is used.\n\n>>> token_bytes(16)  #doctest:+SKIP\nb'\\xebr\\x17D*t\\xae\\xd4\\xe3S\\xb6\\xe2\\xebP1\\x8b'",
      "relationships": []
    },
    {
      "id": "stdlib.secrets.token_hex",
      "name": "token_hex",
      "module": "secrets",
      "type": "function",
      "signature": "(nbytes=None)",
      "description": "Return a random text string, in hexadecimal.\n\nThe string has *nbytes* random bytes, each byte converted to two\nhex digits.  If *nbytes* is ``None`` or not supplied, a reasonable\ndefault is used.\n\n>>> token_hex(16)  #doctest:+SKIP\n'f9bf78b9a18ce6d46a0cd2b0b86df9da'",
      "relationships": [
        {
          "target": "stdlib.secrets.token_bytes",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.secrets.token_urlsafe",
      "name": "token_urlsafe",
      "module": "secrets",
      "type": "function",
      "signature": "(nbytes=None)",
      "description": "Return a random URL-safe text string, in Base64 encoding.\n\nThe string has *nbytes* random bytes.  If *nbytes* is ``None``\nor not supplied, a reasonable default is used.\n\n>>> token_urlsafe(16)  #doctest:+SKIP\n'Drmhze6EPcv0fN_81Bj-nA'",
      "relationships": [
        {
          "target": "stdlib.secrets.token_bytes",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.select.kqueue",
      "name": "kqueue",
      "module": "select",
      "type": "class",
      "signature": "()",
      "description": "Kqueue syscall wrapper.\n\nFor example, to start watching a socket for input:\n>>> kq = kqueue()\n>>> sock = socket()\n>>> sock.connect((host, port))\n>>> kq.control([kevent(sock, KQ_FILTER_WRITE, KQ_EV_ADD)], 0)\n\nTo wait one second for it to become writeable:\n>>> kq.control(None, 1, 1000)\n\nTo stop listening:\n>>> kq.control([kevent(sock, KQ_FILTER_WRITE, KQ_EV_DELETE)], 0)",
      "relationships": []
    },
    {
      "id": "stdlib.selectors.BaseSelector",
      "name": "BaseSelector",
      "module": "selectors",
      "type": "class",
      "signature": "()",
      "description": "Selector abstract base class.\n\nA selector supports registering file objects to be monitored for specific\nI/O events.\n\nA file object is a file descriptor or any object with a `fileno()` method.\nAn arbitrary object can be attached to the file object, which can be used\nfor example to store context information, a callback, etc.\n\nA selector can use various implementations (select(), poll(), epoll()...)\ndepending on the platform. The default `Selector` class uses the most\nefficient implementation on the current platform.",
      "relationships": []
    },
    {
      "id": "stdlib.selectors.DefaultSelector",
      "name": "DefaultSelector",
      "module": "selectors",
      "type": "class",
      "signature": "()",
      "description": "Kqueue-based selector.",
      "relationships": [
        {
          "target": "stdlib.selectors._BaseSelectorImpl",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.BaseSelector",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.selectors.KqueueSelector",
      "name": "KqueueSelector",
      "module": "selectors",
      "type": "class",
      "signature": "()",
      "description": "Kqueue-based selector.",
      "relationships": [
        {
          "target": "stdlib.selectors._BaseSelectorImpl",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.BaseSelector",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.selectors.PollSelector",
      "name": "PollSelector",
      "module": "selectors",
      "type": "class",
      "signature": "()",
      "description": "Poll-based selector.",
      "relationships": [
        {
          "target": "stdlib.selectors._PollLikeSelector",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins._BaseSelectorImpl",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.BaseSelector",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.selectors.SelectSelector",
      "name": "SelectSelector",
      "module": "selectors",
      "type": "class",
      "signature": "()",
      "description": "Select-based selector.",
      "relationships": [
        {
          "target": "stdlib.selectors._BaseSelectorImpl",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.BaseSelector",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.selectors.SelectorKey",
      "name": "SelectorKey",
      "module": "selectors",
      "type": "class",
      "signature": "(fileobj, fd, events, data)",
      "description": "SelectorKey(fileobj, fd, events, data)\n\nObject used to associate a file object to its backing\nfile descriptor, selected event mask, and attached data.",
      "relationships": [
        {
          "target": "stdlib.builtins.tuple",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.shelve.BsdDbShelf",
      "name": "BsdDbShelf",
      "module": "shelve",
      "type": "class",
      "signature": "(dict, protocol=None, writeback=False, keyencoding='utf-8')",
      "description": "Shelf implementation using the \"BSD\" db interface.\n\nThis adds methods first(), next(), previous(), last() and\nset_location() that have no counterpart in [g]dbm databases.\n\nThe actual database must be opened using one of the \"bsddb\"\nmodules \"open\" routines (i.e. bsddb.hashopen, bsddb.btopen or\nbsddb.rnopen) and passed to the constructor.\n\nSee the module's __doc__ string for an overview of the interface.",
      "relationships": [
        {
          "target": "stdlib.shelve.Shelf",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.MutableMapping",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Mapping",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Collection",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Sized",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Iterable",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Container",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.shelve.DbfilenameShelf",
      "name": "DbfilenameShelf",
      "module": "shelve",
      "type": "class",
      "signature": "(filename, flag='c', protocol=None, writeback=False)",
      "description": "Shelf implementation using the \"dbm\" generic dbm interface.\n\nThis is initialized with the filename for the dbm database.\nSee the module's __doc__ string for an overview of the interface.",
      "relationships": [
        {
          "target": "stdlib.shelve.Shelf",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.MutableMapping",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Mapping",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Collection",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Sized",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Iterable",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Container",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.shelve.Shelf",
      "name": "Shelf",
      "module": "shelve",
      "type": "class",
      "signature": "(dict, protocol=None, writeback=False, keyencoding='utf-8')",
      "description": "Base class for shelf implementations.\n\nThis is initialized with a dictionary-like object.\nSee the module's __doc__ string for an overview of the interface.",
      "relationships": [
        {
          "target": "stdlib.collections.abc.MutableMapping",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Mapping",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Collection",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Sized",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Iterable",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Container",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.shelve.open",
      "name": "open",
      "module": "shelve",
      "type": "function",
      "signature": "(filename, flag='c', protocol=None, writeback=False)",
      "description": "Open a persistent dictionary for reading and writing.\n\nThe filename parameter is the base filename for the underlying\ndatabase.  As a side-effect, an extension may be added to the\nfilename and more than one file may be created.  The optional flag\nparameter has the same interpretation as the flag parameter of\ndbm.open(). The optional protocol parameter specifies the\nversion of the pickle protocol.\n\nSee the module's __doc__ string for an overview of the interface.",
      "relationships": []
    },
    {
      "id": "stdlib.shlex.join",
      "name": "join",
      "module": "shlex",
      "type": "function",
      "signature": "(split_command)",
      "description": "Return a shell-escaped string from *split_command*.",
      "relationships": [
        {
          "target": "stdlib.shlex.quote",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.shlex.quote",
      "name": "quote",
      "module": "shlex",
      "type": "function",
      "signature": "(s)",
      "description": "Return a shell-escaped version of the string *s*.",
      "relationships": []
    },
    {
      "id": "stdlib.shlex.shlex",
      "name": "shlex",
      "module": "shlex",
      "type": "class",
      "signature": "(instream=None, infile=None, posix=False, punctuation_chars=False)",
      "description": "A lexical analyzer class for simple shell-like syntaxes.",
      "relationships": []
    },
    {
      "id": "stdlib.shlex.split",
      "name": "split",
      "module": "shlex",
      "type": "function",
      "signature": "(s, comments=False, posix=True)",
      "description": "Split the string *s* using shell-like syntax.",
      "relationships": []
    },
    {
      "id": "stdlib.shutil.chown",
      "name": "chown",
      "module": "shutil",
      "type": "function",
      "signature": "(path, user=None, group=None)",
      "description": "Change owner user and group of the given path.\n\nuser and group can be the uid/gid or the user/group names, and in that case,\nthey are converted to their respective uid/gid.",
      "relationships": [
        {
          "target": "stdlib.shutil._get_uid",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil._get_gid",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.shutil.copy",
      "name": "copy",
      "module": "shutil",
      "type": "function",
      "signature": "(src, dst, *, follow_symlinks=True)",
      "description": "Copy data and mode bits (\"cp src dst\"). Return the file's destination.\n\nThe destination may be a directory.\n\nIf follow_symlinks is false, symlinks won't be followed. This\nresembles GNU's \"cp -P src dst\".\n\nIf source and destination are the same file, a SameFileError will be\nraised.",
      "relationships": [
        {
          "target": "stdlib.shutil.copyfile",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.copymode",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.shutil.copy2",
      "name": "copy2",
      "module": "shutil",
      "type": "function",
      "signature": "(src, dst, *, follow_symlinks=True)",
      "description": "Copy data and metadata. Return the file's destination.\n\nMetadata is copied with copystat(). Please see the copystat function\nfor more information.\n\nThe destination may be a directory.\n\nIf follow_symlinks is false, symlinks won't be followed. This\nresembles GNU's \"cp -P src dst\".",
      "relationships": [
        {
          "target": "stdlib.shutil.copyfile",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.copystat",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.shutil.copyfile",
      "name": "copyfile",
      "module": "shutil",
      "type": "function",
      "signature": "(src, dst, *, follow_symlinks=True)",
      "description": "Copy data from src to dst in the most efficient way possible.\n\nIf follow_symlinks is not set and src is a symbolic link, a new\nsymlink will be created instead of copying the file it points to.",
      "relationships": [
        {
          "target": "stdlib.shutil._samefile",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil._islink",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil._stat",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.copyfileobj",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil._fastcopy_fcopyfile",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil._fastcopy_sendfile",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil._copyfileobj_readinto",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.shutil.copyfileobj",
      "name": "copyfileobj",
      "module": "shutil",
      "type": "function",
      "signature": "(fsrc, fdst, length=0)",
      "description": "copy data from file-like object fsrc to file-like object fdst",
      "relationships": []
    },
    {
      "id": "stdlib.shutil.copymode",
      "name": "copymode",
      "module": "shutil",
      "type": "function",
      "signature": "(src, dst, *, follow_symlinks=True)",
      "description": "Copy mode bits from src to dst.\n\nIf follow_symlinks is not set, symlinks aren't followed if and only\nif both `src` and `dst` are symlinks.  If `lchmod` isn't available\n(e.g. Linux) this method does nothing.",
      "relationships": [
        {
          "target": "stdlib.shutil._islink",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.shutil.copystat",
      "name": "copystat",
      "module": "shutil",
      "type": "function",
      "signature": "(src, dst, *, follow_symlinks=True)",
      "description": "Copy file metadata\n\nCopy the permission bits, last access time, last modification time, and\nflags from `src` to `dst`. On Linux, copystat() also copies the \"extended\nattributes\" where possible. The file contents, owner, and group are\nunaffected. `src` and `dst` are path-like objects or path names given as\nstrings.\n\nIf the optional flag `follow_symlinks` is not set, symlinks aren't\nfollowed if and only if both `src` and `dst` are symlinks.",
      "relationships": [
        {
          "target": "stdlib.shutil._copyxattr",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil._islink",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.shutil.copytree",
      "name": "copytree",
      "module": "shutil",
      "type": "function",
      "signature": "(src, dst, symlinks=False, ignore=None, copy_function=<function copy2 at 0x105559440>, ignore_dangling_symlinks=False, dirs_exist_ok=False)",
      "description": "Recursively copy a directory tree and return the destination directory.\n\nIf exception(s) occur, an Error is raised with a list of reasons.\n\nIf the optional symlinks flag is true, symbolic links in the\nsource tree result in symbolic links in the destination tree; if\nit is false, the contents of the files pointed to by symbolic\nlinks are copied. If the file pointed to by the symlink doesn't\nexist, an exception will be added in the list of errors raised in\nan Error exception at the end of the copy process.\n\nYou can set the optional ignore_dangling_symlinks flag to true if you\nwant to silence this exception. Notice that this has no effect on\nplatforms that don't support os.symlink.\n\nThe optional ignore argument is a callable. If given, it\nis called with the `src` parameter, which is the directory\nbeing visited by copytree(), and `names` which is the list of\n`src` contents, as returned by os.listdir():\n\n    callable(src, names) -> ignored_names\n\nSince copytree() is called recursively, the callable will be\ncalled once for each directory that is copied. It returns a\nlist of names relative to the `src` directory that should\nnot be copied.\n\nThe optional copy_function argument is a callable that will be used\nto copy each file. It will be called with the source path and the\ndestination path as arguments. By default, copy2() is used, but any\nfunction that supports the same signature (like copy()) can be used.\n\nIf dirs_exist_ok is false (the default) and `dst` already exists, a\n`FileExistsError` is raised. If `dirs_exist_ok` is true, the copying\noperation will continue if it encounters existing directories, and files\nwithin the `dst` tree will be overwritten by corresponding files from the\n`src` tree.",
      "relationships": [
        {
          "target": "stdlib.shutil._copytree",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.shutil.disk_usage",
      "name": "disk_usage",
      "module": "shutil",
      "type": "function",
      "signature": "(path)",
      "description": "Return disk usage statistics about the given path.\n\nReturned value is a named tuple with attributes 'total', 'used' and\n'free', which are the amount of total, used and free space, in bytes.",
      "relationships": []
    },
    {
      "id": "stdlib.shutil.get_archive_formats",
      "name": "get_archive_formats",
      "module": "shutil",
      "type": "function",
      "signature": "()",
      "description": "Returns a list of supported formats for archiving and unarchiving.\n\nEach element of the returned sequence is a tuple (name, description)",
      "relationships": []
    },
    {
      "id": "stdlib.shutil.get_terminal_size",
      "name": "get_terminal_size",
      "module": "shutil",
      "type": "function",
      "signature": "(fallback=(80, 24))",
      "description": "Get the size of the terminal window.\n\nFor each of the two dimensions, the environment variable, COLUMNS\nand LINES respectively, is checked. If the variable is defined and\nthe value is a positive integer, it is used.\n\nWhen COLUMNS or LINES is not defined, which is the common case,\nthe terminal connected to sys.__stdout__ is queried\nby invoking os.get_terminal_size.\n\nIf the terminal size cannot be successfully queried, either because\nthe system doesn't support querying, or because we are not\nconnected to a terminal, the value given in fallback parameter\nis used. Fallback defaults to (80, 24) which is the default\nsize used by many terminal emulators.\n\nThe value returned is a named tuple of type os.terminal_size.",
      "relationships": []
    },
    {
      "id": "stdlib.shutil.get_unpack_formats",
      "name": "get_unpack_formats",
      "module": "shutil",
      "type": "function",
      "signature": "()",
      "description": "Returns a list of supported formats for unpacking.\n\nEach element of the returned sequence is a tuple\n(name, extensions, description)",
      "relationships": []
    },
    {
      "id": "stdlib.shutil.ignore_patterns",
      "name": "ignore_patterns",
      "module": "shutil",
      "type": "function",
      "signature": "(*patterns)",
      "description": "Function that can be used as copytree() ignore parameter.\n\nPatterns is a sequence of glob-style patterns\nthat are used to exclude files",
      "relationships": []
    },
    {
      "id": "stdlib.shutil.make_archive",
      "name": "make_archive",
      "module": "shutil",
      "type": "function",
      "signature": "(base_name, format, root_dir=None, base_dir=None, verbose=0, dry_run=0, owner=None, group=None, logger=None)",
      "description": "Create an archive file (eg. zip or tar).\n\n'base_name' is the name of the file to create, minus any format-specific\nextension; 'format' is the archive format: one of \"zip\", \"tar\", \"gztar\",\n\"bztar\", or \"xztar\".  Or any other registered format.\n\n'root_dir' is a directory that will be the root directory of the\narchive; ie. we typically chdir into 'root_dir' before creating the\narchive.  'base_dir' is the directory where we start archiving from;\nie. 'base_dir' will be the common prefix of all files and\ndirectories in the archive.  'root_dir' and 'base_dir' both default\nto the current directory.  Returns the name of the archive file.\n\n'owner' and 'group' are used when creating a tar archive. By default,\nuses the current owner and group.",
      "relationships": []
    },
    {
      "id": "stdlib.shutil.move",
      "name": "move",
      "module": "shutil",
      "type": "function",
      "signature": "(src, dst, copy_function=<function copy2 at 0x105559440>)",
      "description": "Recursively move a file or directory to another location. This is\nsimilar to the Unix \"mv\" command. Return the file or directory's\ndestination.\n\nIf dst is an existing directory or a symlink to a directory, then src is\nmoved inside that directory. The destination path in that directory must\nnot already exist.\n\nIf dst already exists but is not a directory, it may be overwritten\ndepending on os.rename() semantics.\n\nIf the destination is on our current filesystem, then rename() is used.\nOtherwise, src is copied to the destination and then removed. Symlinks are\nrecreated under the new name if os.rename() fails because of cross\nfilesystem renames.\n\nThe optional `copy_function` argument is a callable that will be used\nto copy the source or it will be delegated to `copytree`.\nBy default, copy2() is used, but any function that supports the same\nsignature (like copy()) can be used.\n\nA lot more could be done here...  A look at a mv.c shows a lot of\nthe issues this implementation glosses over.",
      "relationships": [
        {
          "target": "stdlib.shutil._samefile",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil._basename",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil._destinsrc",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.copytree",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.rmtree",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil._is_immutable",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.shutil.register_archive_format",
      "name": "register_archive_format",
      "module": "shutil",
      "type": "function",
      "signature": "(name, function, extra_args=None, description='')",
      "description": "Registers an archive format.\n\nname is the name of the format. function is the callable that will be\nused to create archives. If provided, extra_args is a sequence of\n(name, value) tuples that will be passed as arguments to the callable.\ndescription can be provided to describe the format, and will be returned\nby the get_archive_formats() function.",
      "relationships": []
    },
    {
      "id": "stdlib.shutil.register_unpack_format",
      "name": "register_unpack_format",
      "module": "shutil",
      "type": "function",
      "signature": "(name, extensions, function, extra_args=None, description='')",
      "description": "Registers an unpack format.\n\n`name` is the name of the format. `extensions` is a list of extensions\ncorresponding to the format.\n\n`function` is the callable that will be\nused to unpack archives. The callable will receive archives to unpack.\nIf it's unable to handle an archive, it needs to raise a ReadError\nexception.\n\nIf provided, `extra_args` is a sequence of\n(name, value) tuples that will be passed as arguments to the callable.\ndescription can be provided to describe the format, and will be returned\nby the get_unpack_formats() function.",
      "relationships": [
        {
          "target": "stdlib.shutil._check_unpack_options",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.shutil.rmtree",
      "name": "rmtree",
      "module": "shutil",
      "type": "function",
      "signature": "(path, ignore_errors=False, onerror=None, *, onexc=None, dir_fd=None)",
      "description": "Recursively delete a directory tree.\n\nIf dir_fd is not None, it should be a file descriptor open to a directory;\npath will then be relative to that directory.\ndir_fd may not be implemented on your platform.\nIf it is unavailable, using it will raise a NotImplementedError.\n\nIf ignore_errors is set, errors are ignored; otherwise, if onexc or\nonerror is set, it is called to handle the error with arguments (func,\npath, exc_info) where func is platform and implementation dependent;\npath is the argument to that function that caused it to fail; and\nthe value of exc_info describes the exception. For onexc it is the\nexception instance, and for onerror it is a tuple as returned by\nsys.exc_info().  If ignore_errors is false and both onexc and\nonerror are None, the exception is reraised.\n\nonerror is deprecated and only remains for backwards compatibility.\nIf both onerror and onexc are set, onerror is ignored and onexc is used.",
      "relationships": [
        {
          "target": "stdlib.shutil._rmtree_unsafe",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil._rmtree_islink",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil._rmtree_safe_fd",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.shutil.unpack_archive",
      "name": "unpack_archive",
      "module": "shutil",
      "type": "function",
      "signature": "(filename, extract_dir=None, format=None, *, filter=None)",
      "description": "Unpack an archive.\n\n`filename` is the name of the archive.\n\n`extract_dir` is the name of the target directory, where the archive\nis unpacked. If not provided, the current working directory is used.\n\n`format` is the archive format: one of \"zip\", \"tar\", \"gztar\", \"bztar\",\nor \"xztar\".  Or any other registered format.  If not provided,\nunpack_archive will use the filename extension and see if an unpacker\nwas registered for that extension.\n\nIn case none is found, a ValueError is raised.\n\nIf `filter` is given, it is passed to the underlying\nextraction function.",
      "relationships": [
        {
          "target": "stdlib.shutil._find_unpack_format",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.shutil.unregister_archive_format",
      "name": "unregister_archive_format",
      "module": "shutil",
      "type": "function",
      "signature": "(name)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.shutil.unregister_unpack_format",
      "name": "unregister_unpack_format",
      "module": "shutil",
      "type": "function",
      "signature": "(name)",
      "description": "Removes the pack format from the registry.",
      "relationships": []
    },
    {
      "id": "stdlib.shutil.which",
      "name": "which",
      "module": "shutil",
      "type": "function",
      "signature": "(cmd, mode=1, path=None)",
      "description": "Given a command, mode, and a PATH string, return the path which\nconforms to the given mode on the PATH, or None if there is no such\nfile.\n\n`mode` defaults to os.F_OK | os.X_OK. `path` defaults to the result\nof os.environ.get(\"PATH\"), or can be overridden with a custom search\npath.",
      "relationships": [
        {
          "target": "stdlib.shutil._win_path_needs_curdir",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil._access_check",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.signal.Handlers",
      "name": "Handlers",
      "module": "signal",
      "type": "class",
      "signature": "(*values)",
      "description": "An enumeration.",
      "relationships": [
        {
          "target": "stdlib.enum.IntEnum",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.int",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.ReprEnum",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Enum",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.signal.Sigmasks",
      "name": "Sigmasks",
      "module": "signal",
      "type": "class",
      "signature": "(*values)",
      "description": "An enumeration.",
      "relationships": [
        {
          "target": "stdlib.enum.IntEnum",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.int",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.ReprEnum",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Enum",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.signal.Signals",
      "name": "Signals",
      "module": "signal",
      "type": "class",
      "signature": "(*values)",
      "description": "An enumeration.",
      "relationships": [
        {
          "target": "stdlib.enum.IntEnum",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.int",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.ReprEnum",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Enum",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.signal.getsignal",
      "name": "getsignal",
      "module": "signal",
      "type": "function",
      "signature": "(signalnum)",
      "description": "Return the current action for the given signal.\n\nThe return value can be:\n  SIG_IGN -- if the signal is being ignored\n  SIG_DFL -- if the default action for the signal is in effect\n  None    -- if an unknown handler is in effect\n  anything else -- the callable Python object used as a handler",
      "relationships": [
        {
          "target": "stdlib.signal._int_to_enum",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.signal.pthread_sigmask",
      "name": "pthread_sigmask",
      "module": "signal",
      "type": "function",
      "signature": "(how, mask)",
      "description": "Fetch and/or change the signal mask of the calling thread.",
      "relationships": [
        {
          "target": "stdlib.signal._int_to_enum",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.signal.signal",
      "name": "signal",
      "module": "signal",
      "type": "function",
      "signature": "(signalnum, handler)",
      "description": "Set the action for the given signal.\n\nThe action can be SIG_DFL, SIG_IGN, or a callable Python object.\nThe previous action is returned.  See getsignal() for possible return values.\n\n*** IMPORTANT NOTICE ***\nA signal handler function is called with two arguments:\nthe first is the signal number, the second is the interrupted stack frame.",
      "relationships": [
        {
          "target": "stdlib.signal._int_to_enum",
          "type": "calls"
        },
        {
          "target": "stdlib.signal._enum_to_int",
          "type": "calls"
        },
        {
          "target": "stdlib.signal._enum_to_int",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.signal.sigpending",
      "name": "sigpending",
      "module": "signal",
      "type": "function",
      "signature": "()",
      "description": "Examine pending signals.\n\nReturns a set of signal numbers that are pending for delivery to\nthe calling thread.",
      "relationships": [
        {
          "target": "stdlib.signal._int_to_enum",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.signal.sigwait",
      "name": "sigwait",
      "module": "signal",
      "type": "function",
      "signature": "(sigset)",
      "description": "Wait for a signal.\n\nSuspend execution of the calling thread until the delivery of one of the\nsignals specified in the signal set sigset.  The function accepts the signal\nand returns the signal number.",
      "relationships": [
        {
          "target": "stdlib.signal._int_to_enum",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.signal.valid_signals",
      "name": "valid_signals",
      "module": "signal",
      "type": "function",
      "signature": "()",
      "description": "Return a set of valid signal numbers on this platform.\n\nThe signal numbers returned by this function can be safely passed to\nfunctions like `pthread_sigmask`.",
      "relationships": [
        {
          "target": "stdlib.signal._int_to_enum",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.site.abs_paths",
      "name": "abs_paths",
      "module": "site",
      "type": "function",
      "signature": "()",
      "description": "Set all module __file__ and __cached__ attributes to an absolute path",
      "relationships": []
    },
    {
      "id": "stdlib.site.addpackage",
      "name": "addpackage",
      "module": "site",
      "type": "function",
      "signature": "(sitedir, name, known_paths)",
      "description": "Process a .pth file within the site-packages directory:\nFor each line in the file, either combine it with sitedir to a path\nand add that to known_paths, or execute it if it starts with 'import '.",
      "relationships": []
    },
    {
      "id": "stdlib.site.addsitedir",
      "name": "addsitedir",
      "module": "site",
      "type": "function",
      "signature": "(sitedir, known_paths=None)",
      "description": "Add 'sitedir' argument to sys.path if missing and handle .pth files in\n'sitedir'",
      "relationships": []
    },
    {
      "id": "stdlib.site.addsitepackages",
      "name": "addsitepackages",
      "module": "site",
      "type": "function",
      "signature": "(known_paths, prefixes=None)",
      "description": "Add site-packages to sys.path",
      "relationships": []
    },
    {
      "id": "stdlib.site.addusersitepackages",
      "name": "addusersitepackages",
      "module": "site",
      "type": "function",
      "signature": "(known_paths)",
      "description": "Add a per user site-package to sys.path\n\nEach user has its own python directory with site-packages in the\nhome directory.",
      "relationships": []
    },
    {
      "id": "stdlib.site.check_enableusersite",
      "name": "check_enableusersite",
      "module": "site",
      "type": "function",
      "signature": "()",
      "description": "Check if user site directory is safe for inclusion\n\nThe function tests for the command line flag (including environment var),\nprocess uid/gid equal to effective uid/gid.\n\nNone: Disabled for security reasons\nFalse: Disabled by user (command line option)\nTrue: Safe and enabled",
      "relationships": []
    },
    {
      "id": "stdlib.site.enablerlcompleter",
      "name": "enablerlcompleter",
      "module": "site",
      "type": "function",
      "signature": "()",
      "description": "Enable default readline configuration on interactive prompts, by\nregistering a sys.__interactivehook__.\n\nIf the readline module can be imported, the hook will set the Tab key\nas completion key and register ~/.python_history as history file.\nThis can be overridden in the sitecustomize or usercustomize module,\nor in a PYTHONSTARTUP file.",
      "relationships": []
    },
    {
      "id": "stdlib.site.execsitecustomize",
      "name": "execsitecustomize",
      "module": "site",
      "type": "function",
      "signature": "()",
      "description": "Run custom site specific code, if available.",
      "relationships": []
    },
    {
      "id": "stdlib.site.execusercustomize",
      "name": "execusercustomize",
      "module": "site",
      "type": "function",
      "signature": "()",
      "description": "Run custom user specific code, if available.",
      "relationships": []
    },
    {
      "id": "stdlib.site.getsitepackages",
      "name": "getsitepackages",
      "module": "site",
      "type": "function",
      "signature": "(prefixes=None)",
      "description": "Returns a list containing all global site-packages directories.\n\nFor each directory present in ``prefixes`` (or the global ``PREFIXES``),\nthis function will find its `site-packages` subdirectory depending on the\nsystem environment, and will return a list of full paths.",
      "relationships": []
    },
    {
      "id": "stdlib.site.getuserbase",
      "name": "getuserbase",
      "module": "site",
      "type": "function",
      "signature": "()",
      "description": "Returns the `user base` directory path.\n\nThe `user base` directory can be used to store data. If the global\nvariable ``USER_BASE`` is not initialized yet, this function will also set\nit.",
      "relationships": []
    },
    {
      "id": "stdlib.site.getusersitepackages",
      "name": "getusersitepackages",
      "module": "site",
      "type": "function",
      "signature": "()",
      "description": "Returns the user-specific site-packages directory path.\n\nIf the global variable ``USER_SITE`` is not initialized yet, this\nfunction will also set it.",
      "relationships": []
    },
    {
      "id": "stdlib.site.main",
      "name": "main",
      "module": "site",
      "type": "function",
      "signature": "()",
      "description": "Add standard site-specific directories to the module search path.\n\nThis function is called automatically when this module is imported,\nunless the python interpreter was started with the -S flag.",
      "relationships": []
    },
    {
      "id": "stdlib.site.makepath",
      "name": "makepath",
      "module": "site",
      "type": "function",
      "signature": "(*paths)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.site.removeduppaths",
      "name": "removeduppaths",
      "module": "site",
      "type": "function",
      "signature": "()",
      "description": "Remove duplicate entries from sys.path along with making them\nabsolute",
      "relationships": []
    },
    {
      "id": "stdlib.site.setcopyright",
      "name": "setcopyright",
      "module": "site",
      "type": "function",
      "signature": "()",
      "description": "Set 'copyright' and 'credits' in builtins",
      "relationships": []
    },
    {
      "id": "stdlib.site.sethelper",
      "name": "sethelper",
      "module": "site",
      "type": "function",
      "signature": "()",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.site.setquit",
      "name": "setquit",
      "module": "site",
      "type": "function",
      "signature": "()",
      "description": "Define new builtins 'quit' and 'exit'.\n\nThese are objects which make the interpreter exit when called.\nThe repr of each object contains a hint at how it works.",
      "relationships": []
    },
    {
      "id": "stdlib.site.venv",
      "name": "venv",
      "module": "site",
      "type": "function",
      "signature": "(known_paths)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.smtplib.LMTP",
      "name": "LMTP",
      "module": "smtplib",
      "type": "class",
      "signature": "(host='', port=2003, local_hostname=None, source_address=None, timeout=<object object at 0x100108a90>)",
      "description": "LMTP - Local Mail Transfer Protocol\n\nThe LMTP protocol, which is very similar to ESMTP, is heavily based\non the standard SMTP client. It's common to use Unix sockets for\nLMTP, so our connect() method must support that as well as a regular\nhost:port server.  local_hostname and source_address have the same\nmeaning as they do in the SMTP class.  To specify a Unix socket,\nyou must use an absolute path as the host, starting with a '/'.\n\nAuthentication is supported, using the regular SMTP mechanism. When\nusing a Unix socket, LMTP generally don't support or require any\nauthentication, but your mileage might vary.",
      "relationships": [
        {
          "target": "stdlib.smtplib.SMTP",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.smtplib.SMTP",
      "name": "SMTP",
      "module": "smtplib",
      "type": "class",
      "signature": "(host='', port=0, local_hostname=None, timeout=<object object at 0x100108a90>, source_address=None)",
      "description": "This class manages a connection to an SMTP or ESMTP server.\nSMTP Objects:\n    SMTP objects have the following attributes:\n        helo_resp\n            This is the message given by the server in response to the\n            most recent HELO command.\n\n        ehlo_resp\n            This is the message given by the server in response to the\n            most recent EHLO command. This is usually multiline.\n\n        does_esmtp\n            This is a True value _after you do an EHLO command_, if the\n            server supports ESMTP.\n\n        esmtp_features\n            This is a dictionary, which, if the server supports ESMTP,\n            will _after you do an EHLO command_, contain the names of the\n            SMTP service extensions this server supports, and their\n            parameters (if any).\n\n            Note, all extension names are mapped to lower case in the\n            dictionary.\n\n    See each method's docstrings for details.  In general, there is a\n    method of the same name to perform each SMTP command.  There is also a\n    method called 'sendmail' that will do an entire mail transaction.\n    ",
      "relationships": []
    },
    {
      "id": "stdlib.smtplib.SMTPAuthenticationError",
      "name": "SMTPAuthenticationError",
      "module": "smtplib",
      "type": "class",
      "signature": "(code, msg)",
      "description": "Authentication error.\n\nMost probably the server didn't accept the username/password\ncombination provided.",
      "relationships": [
        {
          "target": "stdlib.smtplib.SMTPResponseException",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.SMTPException",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.OSError",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Exception",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.smtplib.SMTPConnectError",
      "name": "SMTPConnectError",
      "module": "smtplib",
      "type": "class",
      "signature": "(code, msg)",
      "description": "Error during connection establishment.",
      "relationships": [
        {
          "target": "stdlib.smtplib.SMTPResponseException",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.SMTPException",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.OSError",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Exception",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.smtplib.SMTPDataError",
      "name": "SMTPDataError",
      "module": "smtplib",
      "type": "class",
      "signature": "(code, msg)",
      "description": "The SMTP server didn't accept the data.",
      "relationships": [
        {
          "target": "stdlib.smtplib.SMTPResponseException",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.SMTPException",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.OSError",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Exception",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.smtplib.SMTPHeloError",
      "name": "SMTPHeloError",
      "module": "smtplib",
      "type": "class",
      "signature": "(code, msg)",
      "description": "The server refused our HELO reply.",
      "relationships": [
        {
          "target": "stdlib.smtplib.SMTPResponseException",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.SMTPException",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.OSError",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Exception",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.smtplib.SMTPRecipientsRefused",
      "name": "SMTPRecipientsRefused",
      "module": "smtplib",
      "type": "class",
      "signature": "(recipients)",
      "description": "All recipient addresses refused.\n\nThe errors for each recipient are accessible through the attribute\n'recipients', which is a dictionary of exactly the same sort as\nSMTP.sendmail() returns.",
      "relationships": [
        {
          "target": "stdlib.smtplib.SMTPException",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.OSError",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Exception",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.smtplib.SMTPResponseException",
      "name": "SMTPResponseException",
      "module": "smtplib",
      "type": "class",
      "signature": "(code, msg)",
      "description": "Base class for all exceptions that include an SMTP error code.\n\nThese exceptions are generated in some instances when the SMTP\nserver returns an error code.  The error code is stored in the\n`smtp_code' attribute of the error, and the `smtp_error' attribute\nis set to the error message.",
      "relationships": [
        {
          "target": "stdlib.smtplib.SMTPException",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.OSError",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Exception",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.smtplib.SMTPSenderRefused",
      "name": "SMTPSenderRefused",
      "module": "smtplib",
      "type": "class",
      "signature": "(code, msg, sender)",
      "description": "Sender address refused.\n\nIn addition to the attributes set by on all SMTPResponseException\nexceptions, this sets `sender' to the string that the SMTP refused.",
      "relationships": [
        {
          "target": "stdlib.smtplib.SMTPResponseException",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.SMTPException",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.OSError",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Exception",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.smtplib.SMTP_SSL",
      "name": "SMTP_SSL",
      "module": "smtplib",
      "type": "class",
      "signature": "(host='', port=0, local_hostname=None, *, timeout=<object object at 0x100108a90>, source_address=None, context=None)",
      "description": "This is a subclass derived from SMTP that connects over an SSL\nencrypted socket (to use this class you need a socket module that was\ncompiled with SSL support). If host is not specified, '' (the local\nhost) is used. If port is omitted, the standard SMTP-over-SSL port\n(465) is used.  local_hostname and source_address have the same meaning\nas they do in the SMTP class.  context also optional, can contain a\nSSLContext.",
      "relationships": [
        {
          "target": "stdlib.smtplib.SMTP",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.smtplib.quoteaddr",
      "name": "quoteaddr",
      "module": "smtplib",
      "type": "function",
      "signature": "(addrstring)",
      "description": "Quote a subset of the email addresses defined by RFC 821.\n\nShould be able to handle anything email.utils.parseaddr can handle.",
      "relationships": []
    },
    {
      "id": "stdlib.smtplib.quotedata",
      "name": "quotedata",
      "module": "smtplib",
      "type": "function",
      "signature": "(data)",
      "description": "Quote data for email.\n\nDouble leading '.', and change Unix newline '\\n', or Mac '\\r' into\ninternet CRLF end-of-line.",
      "relationships": []
    },
    {
      "id": "stdlib.sndhdr.SndHeaders",
      "name": "SndHeaders",
      "module": "sndhdr",
      "type": "class",
      "signature": "(filetype, framerate, nchannels, nframes, sampwidth)",
      "description": "SndHeaders(filetype, framerate, nchannels, nframes, sampwidth)",
      "relationships": [
        {
          "target": "stdlib.builtins.tuple",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.sndhdr.get_long_be",
      "name": "get_long_be",
      "module": "sndhdr",
      "type": "function",
      "signature": "(b)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.sndhdr.get_long_le",
      "name": "get_long_le",
      "module": "sndhdr",
      "type": "function",
      "signature": "(b)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.sndhdr.get_short_be",
      "name": "get_short_be",
      "module": "sndhdr",
      "type": "function",
      "signature": "(b)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.sndhdr.get_short_le",
      "name": "get_short_le",
      "module": "sndhdr",
      "type": "function",
      "signature": "(b)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.sndhdr.test",
      "name": "test",
      "module": "sndhdr",
      "type": "function",
      "signature": "()",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.sndhdr.testall",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.testall",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.sndhdr.test_8svx",
      "name": "test_8svx",
      "module": "sndhdr",
      "type": "function",
      "signature": "(h, f)",
      "description": "8SVX file",
      "relationships": []
    },
    {
      "id": "stdlib.sndhdr.test_aifc",
      "name": "test_aifc",
      "module": "sndhdr",
      "type": "function",
      "signature": "(h, f)",
      "description": "AIFC and AIFF files",
      "relationships": []
    },
    {
      "id": "stdlib.sndhdr.test_au",
      "name": "test_au",
      "module": "sndhdr",
      "type": "function",
      "signature": "(h, f)",
      "description": "AU and SND files",
      "relationships": []
    },
    {
      "id": "stdlib.sndhdr.test_hcom",
      "name": "test_hcom",
      "module": "sndhdr",
      "type": "function",
      "signature": "(h, f)",
      "description": "HCOM file",
      "relationships": [
        {
          "target": "stdlib.sndhdr.get_long_be",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.sndhdr.test_sndr",
      "name": "test_sndr",
      "module": "sndhdr",
      "type": "function",
      "signature": "(h, f)",
      "description": "SNDR file",
      "relationships": [
        {
          "target": "stdlib.sndhdr.get_short_le",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.sndhdr.test_sndt",
      "name": "test_sndt",
      "module": "sndhdr",
      "type": "function",
      "signature": "(h, f)",
      "description": "SNDT file",
      "relationships": [
        {
          "target": "stdlib.sndhdr.get_long_le",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.get_short_le",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.sndhdr.test_voc",
      "name": "test_voc",
      "module": "sndhdr",
      "type": "function",
      "signature": "(h, f)",
      "description": "VOC file",
      "relationships": [
        {
          "target": "stdlib.sndhdr.get_short_le",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.sndhdr.test_wav",
      "name": "test_wav",
      "module": "sndhdr",
      "type": "function",
      "signature": "(h, f)",
      "description": "WAV file",
      "relationships": []
    },
    {
      "id": "stdlib.sndhdr.testall",
      "name": "testall",
      "module": "sndhdr",
      "type": "function",
      "signature": "(list, recursive, toplevel)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.sndhdr.testall",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.what",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.sndhdr.what",
      "name": "what",
      "module": "sndhdr",
      "type": "function",
      "signature": "(filename)",
      "description": "Guess the type of a sound file.",
      "relationships": [
        {
          "target": "stdlib.sndhdr.whathdr",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.sndhdr.whathdr",
      "name": "whathdr",
      "module": "sndhdr",
      "type": "function",
      "signature": "(filename)",
      "description": "Recognize sound headers.",
      "relationships": []
    },
    {
      "id": "stdlib.socket.AddressFamily",
      "name": "AddressFamily",
      "module": "socket",
      "type": "class",
      "signature": "(*values)",
      "description": "An enumeration.",
      "relationships": [
        {
          "target": "stdlib.enum.IntEnum",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.int",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.ReprEnum",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Enum",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.socket.AddressInfo",
      "name": "AddressInfo",
      "module": "socket",
      "type": "class",
      "signature": "(*values)",
      "description": "An enumeration.",
      "relationships": [
        {
          "target": "stdlib.enum.IntFlag",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.int",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.ReprEnum",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Flag",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Enum",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.socket.MsgFlag",
      "name": "MsgFlag",
      "module": "socket",
      "type": "class",
      "signature": "(*values)",
      "description": "An enumeration.",
      "relationships": [
        {
          "target": "stdlib.enum.IntFlag",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.int",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.ReprEnum",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Flag",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Enum",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.socket.SocketIO",
      "name": "SocketIO",
      "module": "socket",
      "type": "class",
      "signature": "(sock, mode)",
      "description": "Raw I/O implementation for stream sockets.\n\nThis class supports the makefile() method on sockets.  It provides\nthe raw I/O interface on top of a socket object.",
      "relationships": [
        {
          "target": "stdlib.io.RawIOBase",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins._RawIOBase",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.IOBase",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins._IOBase",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.socket.SocketKind",
      "name": "SocketKind",
      "module": "socket",
      "type": "class",
      "signature": "(*values)",
      "description": "An enumeration.",
      "relationships": [
        {
          "target": "stdlib.enum.IntEnum",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.int",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.ReprEnum",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Enum",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.socket.create_connection",
      "name": "create_connection",
      "module": "socket",
      "type": "function",
      "signature": "(address, timeout=<object object at 0x100108a90>, source_address=None, *, all_errors=False)",
      "description": "Connect to *address* and return the socket object.\n\nConvenience function.  Connect to *address* (a 2-tuple ``(host,\nport)``) and return the socket object.  Passing the optional\n*timeout* parameter will set the timeout on the socket instance\nbefore attempting to connect.  If no *timeout* is supplied, the\nglobal default timeout setting returned by :func:`getdefaulttimeout`\nis used.  If *source_address* is set it must be a tuple of (host, port)\nfor the socket to bind as a source address before making the connection.\nA host of '' or port 0 tells the OS to use the default. When a connection\ncannot be created, raises the last error if *all_errors* is False,\nand an ExceptionGroup of all errors if *all_errors* is True.",
      "relationships": [
        {
          "target": "stdlib.socket.getaddrinfo",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.socket.create_server",
      "name": "create_server",
      "module": "socket",
      "type": "function",
      "signature": "(address, *, family=<AddressFamily.AF_INET: 2>, backlog=None, reuse_port=False, dualstack_ipv6=False)",
      "description": "Convenience function which creates a SOCK_STREAM type socket\nbound to *address* (a 2-tuple (host, port)) and return the socket\nobject.\n\n*family* should be either AF_INET or AF_INET6.\n*backlog* is the queue size passed to socket.listen().\n*reuse_port* dictates whether to use the SO_REUSEPORT socket option.\n*dualstack_ipv6*: if true and the platform supports it, it will\ncreate an AF_INET6 socket able to accept both IPv4 or IPv6\nconnections. When false it will explicitly disable this option on\nplatforms that enable it by default (e.g. Linux).\n\n>>> with create_server(('', 8000)) as server:\n...     while True:\n...         conn, addr = server.accept()\n...         # handle new connection",
      "relationships": [
        {
          "target": "stdlib.socket.has_dualstack_ipv6",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.socket.fromfd",
      "name": "fromfd",
      "module": "socket",
      "type": "function",
      "signature": "(fd, family, type, proto=0)",
      "description": "fromfd(fd, family, type[, proto]) -> socket object\n\nCreate a socket object from a duplicate of the given file\ndescriptor.  The remaining arguments are the same as for socket().",
      "relationships": []
    },
    {
      "id": "stdlib.socket.getaddrinfo",
      "name": "getaddrinfo",
      "module": "socket",
      "type": "function",
      "signature": "(host, port, family=0, type=0, proto=0, flags=0)",
      "description": "Resolve host and port into list of address info entries.\n\nTranslate the host/port argument into a sequence of 5-tuples that contain\nall the necessary arguments for creating a socket connected to that service.\nhost is a domain name, a string representation of an IPv4/v6 address or\nNone. port is a string service name such as 'http', a numeric port number or\nNone. By passing None as the value of host and port, you can pass NULL to\nthe underlying C API.\n\nThe family, type and proto arguments can be optionally specified in order to\nnarrow the list of addresses returned. Passing zero as a value for each of\nthese arguments selects the full range of results.",
      "relationships": [
        {
          "target": "stdlib.socket._intenum_converter",
          "type": "calls"
        },
        {
          "target": "stdlib.socket._intenum_converter",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.socket.getfqdn",
      "name": "getfqdn",
      "module": "socket",
      "type": "function",
      "signature": "(name='')",
      "description": "Get fully qualified domain name from name.\n\nAn empty argument is interpreted as meaning the local host.\n\nFirst the hostname returned by gethostbyaddr() is checked, then\npossibly existing aliases. In case no FQDN is available and `name`\nwas given, it is returned unchanged. If `name` was empty, '0.0.0.0' or '::',\nhostname from gethostname() is returned.",
      "relationships": []
    },
    {
      "id": "stdlib.socket.has_dualstack_ipv6",
      "name": "has_dualstack_ipv6",
      "module": "socket",
      "type": "function",
      "signature": "()",
      "description": "Return True if the platform supports creating a SOCK_STREAM socket\nwhich can handle both AF_INET and AF_INET6 (IPv4 / IPv6) connections.",
      "relationships": []
    },
    {
      "id": "stdlib.socket.recv_fds",
      "name": "recv_fds",
      "module": "socket",
      "type": "function",
      "signature": "(sock, bufsize, maxfds, flags=0)",
      "description": "recv_fds(sock, bufsize, maxfds[, flags]) -> (data, list of file\ndescriptors, msg_flags, address)\n\nReceive up to maxfds file descriptors returning the message\ndata and a list containing the descriptors.",
      "relationships": []
    },
    {
      "id": "stdlib.socket.send_fds",
      "name": "send_fds",
      "module": "socket",
      "type": "function",
      "signature": "(sock, buffers, fds, flags=0, address=None)",
      "description": "send_fds(sock, buffers, fds[, flags[, address]]) -> integer\n\nSend the list of file descriptors fds over an AF_UNIX socket.",
      "relationships": []
    },
    {
      "id": "stdlib.socket.socket",
      "name": "socket",
      "module": "socket",
      "type": "class",
      "signature": "(family=-1, type=-1, proto=-1, fileno=None)",
      "description": "A subclass of _socket.socket adding the makefile() method.",
      "relationships": [
        {
          "target": "stdlib._socket.socket",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.socket.socketpair",
      "name": "socketpair",
      "module": "socket",
      "type": "function",
      "signature": "(family=None, type=<SocketKind.SOCK_STREAM: 1>, proto=0)",
      "description": "socketpair([family[, type[, proto]]]) -> (socket object, socket object)\nCreate a pair of socket objects from the sockets returned by the platform\nsocketpair() function.\nThe arguments are the same as for socket() except the default family is AF_UNIX\nif defined on the platform; otherwise, the default is AF_INET.",
      "relationships": []
    },
    {
      "id": "stdlib.socketserver.BaseRequestHandler",
      "name": "BaseRequestHandler",
      "module": "socketserver",
      "type": "class",
      "signature": "(request, client_address, server)",
      "description": "Base class for request handler classes.\n\nThis class is instantiated for each request to be handled.  The\nconstructor sets the instance variables request, client_address\nand server, and then calls the handle() method.  To implement a\nspecific service, all you need to do is to derive a class which\ndefines a handle() method.\n\nThe handle() method can find the request as self.request, the\nclient address as self.client_address, and the server (in case it\nneeds access to per-server information) as self.server.  Since a\nseparate instance is created for each request, the handle() method\ncan define other arbitrary instance variables.",
      "relationships": []
    },
    {
      "id": "stdlib.socketserver.BaseServer",
      "name": "BaseServer",
      "module": "socketserver",
      "type": "class",
      "signature": "(server_address, RequestHandlerClass)",
      "description": "Base class for server classes.\n\nMethods for the caller:\n\n- __init__(server_address, RequestHandlerClass)\n- serve_forever(poll_interval=0.5)\n- shutdown()\n- handle_request()  # if you do not use serve_forever()\n- fileno() -> int   # for selector\n\nMethods that may be overridden:\n\n- server_bind()\n- server_activate()\n- get_request() -> request, client_address\n- handle_timeout()\n- verify_request(request, client_address)\n- server_close()\n- process_request(request, client_address)\n- shutdown_request(request)\n- close_request(request)\n- service_actions()\n- handle_error()\n\nMethods for derived classes:\n\n- finish_request(request, client_address)\n\nClass variables that may be overridden by derived classes or\ninstances:\n\n- timeout\n- address_family\n- socket_type\n- allow_reuse_address\n- allow_reuse_port\n\nInstance variables:\n\n- RequestHandlerClass\n- socket",
      "relationships": []
    },
    {
      "id": "stdlib.socketserver.DatagramRequestHandler",
      "name": "DatagramRequestHandler",
      "module": "socketserver",
      "type": "class",
      "signature": "(request, client_address, server)",
      "description": "Define self.rfile and self.wfile for datagram sockets.",
      "relationships": [
        {
          "target": "stdlib.socketserver.BaseRequestHandler",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.socketserver.ForkingMixIn",
      "name": "ForkingMixIn",
      "module": "socketserver",
      "type": "class",
      "signature": "()",
      "description": "Mix-in class to handle each request in a new process.",
      "relationships": []
    },
    {
      "id": "stdlib.socketserver.ForkingTCPServer",
      "name": "ForkingTCPServer",
      "module": "socketserver",
      "type": "class",
      "signature": "(server_address, RequestHandlerClass, bind_and_activate=True)",
      "description": "Mix-in class to handle each request in a new process.",
      "relationships": [
        {
          "target": "stdlib.socketserver.ForkingMixIn",
          "type": "base_class"
        },
        {
          "target": "stdlib.socketserver.TCPServer",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.BaseServer",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.socketserver.ForkingUDPServer",
      "name": "ForkingUDPServer",
      "module": "socketserver",
      "type": "class",
      "signature": "(server_address, RequestHandlerClass, bind_and_activate=True)",
      "description": "Mix-in class to handle each request in a new process.",
      "relationships": [
        {
          "target": "stdlib.socketserver.ForkingMixIn",
          "type": "base_class"
        },
        {
          "target": "stdlib.socketserver.UDPServer",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.TCPServer",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.BaseServer",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.socketserver.ForkingUnixDatagramServer",
      "name": "ForkingUnixDatagramServer",
      "module": "socketserver",
      "type": "class",
      "signature": "(server_address, RequestHandlerClass, bind_and_activate=True)",
      "description": "Mix-in class to handle each request in a new process.",
      "relationships": [
        {
          "target": "stdlib.socketserver.ForkingMixIn",
          "type": "base_class"
        },
        {
          "target": "stdlib.socketserver.UnixDatagramServer",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.UDPServer",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.TCPServer",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.BaseServer",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.socketserver.ForkingUnixStreamServer",
      "name": "ForkingUnixStreamServer",
      "module": "socketserver",
      "type": "class",
      "signature": "(server_address, RequestHandlerClass, bind_and_activate=True)",
      "description": "Mix-in class to handle each request in a new process.",
      "relationships": [
        {
          "target": "stdlib.socketserver.ForkingMixIn",
          "type": "base_class"
        },
        {
          "target": "stdlib.socketserver.UnixStreamServer",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.TCPServer",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.BaseServer",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.socketserver.StreamRequestHandler",
      "name": "StreamRequestHandler",
      "module": "socketserver",
      "type": "class",
      "signature": "(request, client_address, server)",
      "description": "Define self.rfile and self.wfile for stream sockets.",
      "relationships": [
        {
          "target": "stdlib.socketserver.BaseRequestHandler",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.socketserver.TCPServer",
      "name": "TCPServer",
      "module": "socketserver",
      "type": "class",
      "signature": "(server_address, RequestHandlerClass, bind_and_activate=True)",
      "description": "Base class for various socket-based server classes.\n\nDefaults to synchronous IP stream (i.e., TCP).\n\nMethods for the caller:\n\n- __init__(server_address, RequestHandlerClass, bind_and_activate=True)\n- serve_forever(poll_interval=0.5)\n- shutdown()\n- handle_request()  # if you don't use serve_forever()\n- fileno() -> int   # for selector\n\nMethods that may be overridden:\n\n- server_bind()\n- server_activate()\n- get_request() -> request, client_address\n- handle_timeout()\n- verify_request(request, client_address)\n- process_request(request, client_address)\n- shutdown_request(request)\n- close_request(request)\n- handle_error()\n\nMethods for derived classes:\n\n- finish_request(request, client_address)\n\nClass variables that may be overridden by derived classes or\ninstances:\n\n- timeout\n- address_family\n- socket_type\n- request_queue_size (only for stream sockets)\n- allow_reuse_address\n- allow_reuse_port\n\nInstance variables:\n\n- server_address\n- RequestHandlerClass\n- socket",
      "relationships": [
        {
          "target": "stdlib.socketserver.BaseServer",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.socketserver.ThreadingMixIn",
      "name": "ThreadingMixIn",
      "module": "socketserver",
      "type": "class",
      "signature": "()",
      "description": "Mix-in class to handle each request in a new thread.",
      "relationships": []
    },
    {
      "id": "stdlib.socketserver.ThreadingTCPServer",
      "name": "ThreadingTCPServer",
      "module": "socketserver",
      "type": "class",
      "signature": "(server_address, RequestHandlerClass, bind_and_activate=True)",
      "description": "Mix-in class to handle each request in a new thread.",
      "relationships": [
        {
          "target": "stdlib.socketserver.ThreadingMixIn",
          "type": "base_class"
        },
        {
          "target": "stdlib.socketserver.TCPServer",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.BaseServer",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.socketserver.ThreadingUDPServer",
      "name": "ThreadingUDPServer",
      "module": "socketserver",
      "type": "class",
      "signature": "(server_address, RequestHandlerClass, bind_and_activate=True)",
      "description": "Mix-in class to handle each request in a new thread.",
      "relationships": [
        {
          "target": "stdlib.socketserver.ThreadingMixIn",
          "type": "base_class"
        },
        {
          "target": "stdlib.socketserver.UDPServer",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.TCPServer",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.BaseServer",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.socketserver.ThreadingUnixDatagramServer",
      "name": "ThreadingUnixDatagramServer",
      "module": "socketserver",
      "type": "class",
      "signature": "(server_address, RequestHandlerClass, bind_and_activate=True)",
      "description": "Mix-in class to handle each request in a new thread.",
      "relationships": [
        {
          "target": "stdlib.socketserver.ThreadingMixIn",
          "type": "base_class"
        },
        {
          "target": "stdlib.socketserver.UnixDatagramServer",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.UDPServer",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.TCPServer",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.BaseServer",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.socketserver.ThreadingUnixStreamServer",
      "name": "ThreadingUnixStreamServer",
      "module": "socketserver",
      "type": "class",
      "signature": "(server_address, RequestHandlerClass, bind_and_activate=True)",
      "description": "Mix-in class to handle each request in a new thread.",
      "relationships": [
        {
          "target": "stdlib.socketserver.ThreadingMixIn",
          "type": "base_class"
        },
        {
          "target": "stdlib.socketserver.UnixStreamServer",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.TCPServer",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.BaseServer",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.socketserver.UDPServer",
      "name": "UDPServer",
      "module": "socketserver",
      "type": "class",
      "signature": "(server_address, RequestHandlerClass, bind_and_activate=True)",
      "description": "UDP server class.",
      "relationships": [
        {
          "target": "stdlib.socketserver.TCPServer",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.BaseServer",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.socketserver.UnixDatagramServer",
      "name": "UnixDatagramServer",
      "module": "socketserver",
      "type": "class",
      "signature": "(server_address, RequestHandlerClass, bind_and_activate=True)",
      "description": "UDP server class.",
      "relationships": [
        {
          "target": "stdlib.socketserver.UDPServer",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.TCPServer",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.BaseServer",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.socketserver.UnixStreamServer",
      "name": "UnixStreamServer",
      "module": "socketserver",
      "type": "class",
      "signature": "(server_address, RequestHandlerClass, bind_and_activate=True)",
      "description": "Base class for various socket-based server classes.\n\nDefaults to synchronous IP stream (i.e., TCP).\n\nMethods for the caller:\n\n- __init__(server_address, RequestHandlerClass, bind_and_activate=True)\n- serve_forever(poll_interval=0.5)\n- shutdown()\n- handle_request()  # if you don't use serve_forever()\n- fileno() -> int   # for selector\n\nMethods that may be overridden:\n\n- server_bind()\n- server_activate()\n- get_request() -> request, client_address\n- handle_timeout()\n- verify_request(request, client_address)\n- process_request(request, client_address)\n- shutdown_request(request)\n- close_request(request)\n- handle_error()\n\nMethods for derived classes:\n\n- finish_request(request, client_address)\n\nClass variables that may be overridden by derived classes or\ninstances:\n\n- timeout\n- address_family\n- socket_type\n- request_queue_size (only for stream sockets)\n- allow_reuse_address\n- allow_reuse_port\n\nInstance variables:\n\n- server_address\n- RequestHandlerClass\n- socket",
      "relationships": [
        {
          "target": "stdlib.socketserver.TCPServer",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.BaseServer",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.sqlite3.Blob",
      "name": "Blob",
      "module": "sqlite3",
      "type": "class",
      "signature": "()",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.ssl.AlertDescription",
      "name": "AlertDescription",
      "module": "ssl",
      "type": "class",
      "signature": "(*values)",
      "description": "An enumeration.",
      "relationships": [
        {
          "target": "stdlib.enum.IntEnum",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.int",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.ReprEnum",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Enum",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.ssl.DER_cert_to_PEM_cert",
      "name": "DER_cert_to_PEM_cert",
      "module": "ssl",
      "type": "function",
      "signature": "(der_cert_bytes)",
      "description": "Takes a certificate in binary DER format and returns the\nPEM version of it as a string.",
      "relationships": []
    },
    {
      "id": "stdlib.ssl.DefaultVerifyPaths",
      "name": "DefaultVerifyPaths",
      "module": "ssl",
      "type": "class",
      "signature": "(cafile, capath, openssl_cafile_env, openssl_cafile, openssl_capath_env, openssl_capath)",
      "description": "DefaultVerifyPaths(cafile, capath, openssl_cafile_env, openssl_cafile, openssl_capath_env, openssl_capath)",
      "relationships": [
        {
          "target": "stdlib.builtins.tuple",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.ssl.Options",
      "name": "Options",
      "module": "ssl",
      "type": "class",
      "signature": "(*values)",
      "description": "An enumeration.",
      "relationships": [
        {
          "target": "stdlib.enum.IntFlag",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.int",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.ReprEnum",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Flag",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Enum",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.ssl.PEM_cert_to_DER_cert",
      "name": "PEM_cert_to_DER_cert",
      "module": "ssl",
      "type": "function",
      "signature": "(pem_cert_string)",
      "description": "Takes a certificate in ASCII PEM format and returns the\nDER-encoded version of it as a byte sequence",
      "relationships": []
    },
    {
      "id": "stdlib.ssl.Purpose",
      "name": "Purpose",
      "module": "ssl",
      "type": "class",
      "signature": "(*values)",
      "description": "SSLContext purpose flags with X509v3 Extended Key Usage objects\n    ",
      "relationships": [
        {
          "target": "stdlib.ssl._ASN1Object",
          "type": "base_class"
        },
        {
          "target": "stdlib.ssl._ASN1Object",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.tuple",
          "type": "base_class"
        },
        {
          "target": "stdlib.enum.Enum",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.ssl.SSLContext",
      "name": "SSLContext",
      "module": "ssl",
      "type": "class",
      "signature": "(protocol=None, *args, **kwargs)",
      "description": "An SSLContext holds various SSL-related configuration options and\ndata, such as certificates and possibly a private key.",
      "relationships": [
        {
          "target": "stdlib._ssl._SSLContext",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.ssl.SSLErrorNumber",
      "name": "SSLErrorNumber",
      "module": "ssl",
      "type": "class",
      "signature": "(*values)",
      "description": "An enumeration.",
      "relationships": [
        {
          "target": "stdlib.enum.IntEnum",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.int",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.ReprEnum",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Enum",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.ssl.SSLObject",
      "name": "SSLObject",
      "module": "ssl",
      "type": "class",
      "signature": "(*args, **kwargs)",
      "description": "This class implements an interface on top of a low-level SSL object as\nimplemented by OpenSSL. This object captures the state of an SSL connection\nbut does not provide any network IO itself. IO needs to be performed\nthrough separate \"BIO\" objects which are OpenSSL's IO abstraction layer.\n\nThis class does not have a public constructor. Instances are returned by\n``SSLContext.wrap_bio``. This class is typically used by framework authors\nthat want to implement asynchronous IO for SSL through memory buffers.\n\nWhen compared to ``SSLSocket``, this object lacks the following features:\n\n * Any form of network IO, including methods such as ``recv`` and ``send``.\n * The ``do_handshake_on_connect`` and ``suppress_ragged_eofs`` machinery.",
      "relationships": []
    },
    {
      "id": "stdlib.ssl.SSLSocket",
      "name": "SSLSocket",
      "module": "ssl",
      "type": "class",
      "signature": "(*args, **kwargs)",
      "description": "This class implements a subtype of socket.socket that wraps\nthe underlying OS socket in an SSL context when necessary, and\nprovides read and write methods over that channel. ",
      "relationships": [
        {
          "target": "stdlib.socket.socket",
          "type": "base_class"
        },
        {
          "target": "stdlib.socket.socket",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.ssl.TLSVersion",
      "name": "TLSVersion",
      "module": "ssl",
      "type": "class",
      "signature": "(*values)",
      "description": "An enumeration.",
      "relationships": [
        {
          "target": "stdlib.enum.IntEnum",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.int",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.ReprEnum",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Enum",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.ssl.VerifyFlags",
      "name": "VerifyFlags",
      "module": "ssl",
      "type": "class",
      "signature": "(*values)",
      "description": "An enumeration.",
      "relationships": [
        {
          "target": "stdlib.enum.IntFlag",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.int",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.ReprEnum",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Flag",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Enum",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.ssl.VerifyMode",
      "name": "VerifyMode",
      "module": "ssl",
      "type": "class",
      "signature": "(*values)",
      "description": "An enumeration.",
      "relationships": [
        {
          "target": "stdlib.enum.IntEnum",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.int",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.ReprEnum",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Enum",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.ssl.cert_time_to_seconds",
      "name": "cert_time_to_seconds",
      "module": "ssl",
      "type": "function",
      "signature": "(cert_time)",
      "description": "Return the time in seconds since the Epoch, given the timestring\nrepresenting the \"notBefore\" or \"notAfter\" date from a certificate\nin ``\"%b %d %H:%M:%S %Y %Z\"`` strptime format (C locale).\n\n\"notBefore\" or \"notAfter\" dates must use UTC (RFC 5280).\n\nMonth is one of: Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\nUTC should be specified as GMT (see ASN1_TIME_print())",
      "relationships": []
    },
    {
      "id": "stdlib.ssl.create_default_context",
      "name": "create_default_context",
      "module": "ssl",
      "type": "function",
      "signature": "(purpose=<Purpose.SERVER_AUTH: _ASN1Object(nid=129, shortname='serverAuth', longname='TLS Web Server Authentication', oid='1.3.6.1.5.5.7.3.1')>, *, cafile=None, capath=None, cadata=None)",
      "description": "Create a SSLContext object with default settings.\n\nNOTE: The protocol and settings may change anytime without prior\n      deprecation. The values represent a fair balance between maximum\n      compatibility and security.",
      "relationships": []
    },
    {
      "id": "stdlib.ssl.get_default_verify_paths",
      "name": "get_default_verify_paths",
      "module": "ssl",
      "type": "function",
      "signature": "()",
      "description": "Return paths to default cafile and capath.\n    ",
      "relationships": []
    },
    {
      "id": "stdlib.ssl.get_protocol_name",
      "name": "get_protocol_name",
      "module": "ssl",
      "type": "function",
      "signature": "(protocol_code)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.ssl.get_server_certificate",
      "name": "get_server_certificate",
      "module": "ssl",
      "type": "function",
      "signature": "(addr, ssl_version=<_SSLMethod.PROTOCOL_TLS_CLIENT: 16>, ca_certs=None, timeout=<object object at 0x100108a90>)",
      "description": "Retrieve the certificate from the server at the specified address,\nand return it as a PEM-encoded string.\nIf 'ca_certs' is specified, validate the server cert against it.\nIf 'ssl_version' is specified, use it in the connection attempt.\nIf 'timeout' is specified, use it in the connection attempt.",
      "relationships": [
        {
          "target": "stdlib.ssl._create_stdlib_context",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.DER_cert_to_PEM_cert",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.statistics.LinearRegression",
      "name": "LinearRegression",
      "module": "statistics",
      "type": "class",
      "signature": "(slope, intercept)",
      "description": "LinearRegression(slope, intercept)",
      "relationships": [
        {
          "target": "stdlib.builtins.tuple",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.statistics.NormalDist",
      "name": "NormalDist",
      "module": "statistics",
      "type": "class",
      "signature": "(mu=0.0, sigma=1.0)",
      "description": "Normal distribution of a random variable",
      "relationships": []
    },
    {
      "id": "stdlib.statistics.correlation",
      "name": "correlation",
      "module": "statistics",
      "type": "function",
      "signature": "(x, y, /, *, method='linear')",
      "description": "Pearson's correlation coefficient\n\nReturn the Pearson's correlation coefficient for two inputs. Pearson's\ncorrelation coefficient *r* takes values between -1 and +1. It measures\nthe strength and direction of a linear relationship.\n\n>>> x = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n>>> y = [9, 8, 7, 6, 5, 4, 3, 2, 1]\n>>> correlation(x, x)\n1.0\n>>> correlation(x, y)\n-1.0\n\nIf *method* is \"ranked\", computes Spearman's rank correlation coefficient\nfor two inputs.  The data is replaced by ranks.  Ties are averaged\nso that equal values receive the same rank.  The resulting coefficient\nmeasures the strength of a monotonic relationship.\n\nSpearman's rank correlation coefficient is appropriate for ordinal\ndata or for continuous data that doesn't meet the linear proportion\nrequirement for Pearson's correlation coefficient.",
      "relationships": [
        {
          "target": "stdlib.statistics._rank",
          "type": "calls"
        },
        {
          "target": "stdlib.statistics._rank",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.statistics.covariance",
      "name": "covariance",
      "module": "statistics",
      "type": "function",
      "signature": "(x, y, /)",
      "description": "Covariance\n\nReturn the sample covariance of two inputs *x* and *y*. Covariance\nis a measure of the joint variability of two inputs.\n\n>>> x = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n>>> y = [1, 2, 3, 1, 2, 3, 1, 2, 3]\n>>> covariance(x, y)\n0.75\n>>> z = [9, 8, 7, 6, 5, 4, 3, 2, 1]\n>>> covariance(x, z)\n-7.5\n>>> covariance(z, x)\n-7.5",
      "relationships": []
    },
    {
      "id": "stdlib.statistics.fmean",
      "name": "fmean",
      "module": "statistics",
      "type": "function",
      "signature": "(data, weights=None)",
      "description": "Convert data to floats and compute the arithmetic mean.\n\nThis runs faster than the mean() function and it always returns a float.\nIf the input dataset is empty, it raises a StatisticsError.\n\n>>> fmean([3.5, 4.0, 5.25])\n4.25",
      "relationships": []
    },
    {
      "id": "stdlib.statistics.geometric_mean",
      "name": "geometric_mean",
      "module": "statistics",
      "type": "function",
      "signature": "(data)",
      "description": "Convert data to floats and compute the geometric mean.\n\nRaises a StatisticsError if the input dataset is empty,\nif it contains a zero, or if it contains a negative value.\n\nNo special efforts are made to achieve exact results.\n(However, this may change in the future.)\n\n>>> round(geometric_mean([54, 24, 36]), 9)\n36.0",
      "relationships": [
        {
          "target": "stdlib.statistics.fmean",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.statistics.harmonic_mean",
      "name": "harmonic_mean",
      "module": "statistics",
      "type": "function",
      "signature": "(data, weights=None)",
      "description": "Return the harmonic mean of data.\n\nThe harmonic mean is the reciprocal of the arithmetic mean of the\nreciprocals of the data.  It can be used for averaging ratios or\nrates, for example speeds.\n\nSuppose a car travels 40 km/hr for 5 km and then speeds-up to\n60 km/hr for another 5 km. What is the average speed?\n\n    >>> harmonic_mean([40, 60])\n    48.0\n\nSuppose a car travels 40 km/hr for 5 km, and when traffic clears,\nspeeds-up to 60 km/hr for the remaining 30 km of the journey. What\nis the average speed?\n\n    >>> harmonic_mean([40, 60], weights=[5, 30])\n    56.0\n\nIf ``data`` is empty, or any element is less than zero,\n``harmonic_mean`` will raise ``StatisticsError``.",
      "relationships": [
        {
          "target": "stdlib.statistics._convert",
          "type": "calls"
        },
        {
          "target": "stdlib.statistics._sum",
          "type": "calls"
        },
        {
          "target": "stdlib.statistics._fail_neg",
          "type": "calls"
        },
        {
          "target": "stdlib.statistics._sum",
          "type": "calls"
        },
        {
          "target": "stdlib.statistics._fail_neg",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.statistics.linear_regression",
      "name": "linear_regression",
      "module": "statistics",
      "type": "function",
      "signature": "(x, y, /, *, proportional=False)",
      "description": "Slope and intercept for simple linear regression.\n\nReturn the slope and intercept of simple linear regression\nparameters estimated using ordinary least squares. Simple linear\nregression describes relationship between an independent variable\n*x* and a dependent variable *y* in terms of a linear function:\n\n    y = slope * x + intercept + noise\n\nwhere *slope* and *intercept* are the regression parameters that are\nestimated, and noise represents the variability of the data that was\nnot explained by the linear regression (it is equal to the\ndifference between predicted and actual values of the dependent\nvariable).\n\nThe parameters are returned as a named tuple.\n\n>>> x = [1, 2, 3, 4, 5]\n>>> noise = NormalDist().samples(5, seed=42)\n>>> y = [3 * x[i] + 2 + noise[i] for i in range(5)]\n>>> linear_regression(x, y)  #doctest: +ELLIPSIS\nLinearRegression(slope=3.09078914170..., intercept=1.75684970486...)\n\nIf *proportional* is true, the independent variable *x* and the\ndependent variable *y* are assumed to be directly proportional.\nThe data is fit to a line passing through the origin.\n\nSince the *intercept* will always be 0.0, the underlying linear\nfunction simplifies to:\n\n    y = slope * x + noise\n\n>>> y = [3 * x[i] + noise[i] for i in range(5)]\n>>> linear_regression(x, y, proportional=True)  #doctest: +ELLIPSIS\nLinearRegression(slope=3.02447542484..., intercept=0.0)",
      "relationships": []
    },
    {
      "id": "stdlib.statistics.mean",
      "name": "mean",
      "module": "statistics",
      "type": "function",
      "signature": "(data)",
      "description": "Return the sample arithmetic mean of data.\n\n>>> mean([1, 2, 3, 4, 4])\n2.8\n\n>>> from fractions import Fraction as F\n>>> mean([F(3, 7), F(1, 21), F(5, 3), F(1, 3)])\nFraction(13, 21)\n\n>>> from decimal import Decimal as D\n>>> mean([D(\"0.5\"), D(\"0.75\"), D(\"0.625\"), D(\"0.375\")])\nDecimal('0.5625')\n\nIf ``data`` is empty, StatisticsError will be raised.",
      "relationships": [
        {
          "target": "stdlib.statistics._sum",
          "type": "calls"
        },
        {
          "target": "stdlib.statistics._convert",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.statistics.median",
      "name": "median",
      "module": "statistics",
      "type": "function",
      "signature": "(data)",
      "description": "Return the median (middle value) of numeric data.\n\nWhen the number of data points is odd, return the middle data point.\nWhen the number of data points is even, the median is interpolated by\ntaking the average of the two middle values:\n\n>>> median([1, 3, 5])\n3\n>>> median([1, 3, 5, 7])\n4.0",
      "relationships": []
    },
    {
      "id": "stdlib.statistics.median_grouped",
      "name": "median_grouped",
      "module": "statistics",
      "type": "function",
      "signature": "(data, interval=1.0)",
      "description": "Estimates the median for numeric data binned around the midpoints\nof consecutive, fixed-width intervals.\n\nThe *data* can be any iterable of numeric data with each value being\nexactly the midpoint of a bin.  At least one value must be present.\n\nThe *interval* is width of each bin.\n\nFor example, demographic information may have been summarized into\nconsecutive ten-year age groups with each group being represented\nby the 5-year midpoints of the intervals:\n\n    >>> demographics = Counter({\n    ...    25: 172,   # 20 to 30 years old\n    ...    35: 484,   # 30 to 40 years old\n    ...    45: 387,   # 40 to 50 years old\n    ...    55:  22,   # 50 to 60 years old\n    ...    65:   6,   # 60 to 70 years old\n    ... })\n\nThe 50th percentile (median) is the 536th person out of the 1071\nmember cohort.  That person is in the 30 to 40 year old age group.\n\nThe regular median() function would assume that everyone in the\ntricenarian age group was exactly 35 years old.  A more tenable\nassumption is that the 484 members of that age group are evenly\ndistributed between 30 and 40.  For that, we use median_grouped().\n\n    >>> data = list(demographics.elements())\n    >>> median(data)\n    35\n    >>> round(median_grouped(data, interval=10), 1)\n    37.5\n\nThe caller is responsible for making sure the data points are separated\nby exact multiples of *interval*.  This is essential for getting a\ncorrect result.  The function does not check this precondition.\n\nInputs may be any numeric type that can be coerced to a float during\nthe interpolation step.",
      "relationships": []
    },
    {
      "id": "stdlib.statistics.median_high",
      "name": "median_high",
      "module": "statistics",
      "type": "function",
      "signature": "(data)",
      "description": "Return the high median of data.\n\nWhen the number of data points is odd, the middle value is returned.\nWhen it is even, the larger of the two middle values is returned.\n\n>>> median_high([1, 3, 5])\n3\n>>> median_high([1, 3, 5, 7])\n5",
      "relationships": []
    },
    {
      "id": "stdlib.statistics.median_low",
      "name": "median_low",
      "module": "statistics",
      "type": "function",
      "signature": "(data)",
      "description": "Return the low median of numeric data.\n\nWhen the number of data points is odd, the middle value is returned.\nWhen it is even, the smaller of the two middle values is returned.\n\n>>> median_low([1, 3, 5])\n3\n>>> median_low([1, 3, 5, 7])\n3",
      "relationships": []
    },
    {
      "id": "stdlib.statistics.mode",
      "name": "mode",
      "module": "statistics",
      "type": "function",
      "signature": "(data)",
      "description": "Return the most common data point from discrete or nominal data.\n\n``mode`` assumes discrete data, and returns a single value. This is the\nstandard treatment of the mode as commonly taught in schools:\n\n    >>> mode([1, 1, 2, 3, 3, 3, 3, 4])\n    3\n\nThis also works with nominal (non-numeric) data:\n\n    >>> mode([\"red\", \"blue\", \"blue\", \"red\", \"green\", \"red\", \"red\"])\n    'red'\n\nIf there are multiple modes with same frequency, return the first one\nencountered:\n\n    >>> mode(['red', 'red', 'green', 'blue', 'blue'])\n    'red'\n\nIf *data* is empty, ``mode``, raises StatisticsError.",
      "relationships": []
    },
    {
      "id": "stdlib.statistics.multimode",
      "name": "multimode",
      "module": "statistics",
      "type": "function",
      "signature": "(data)",
      "description": "Return a list of the most frequently occurring values.\n\nWill return more than one result if there are multiple modes\nor an empty list if *data* is empty.\n\n>>> multimode('aabbbbbbbbcc')\n['b']\n>>> multimode('aabbbbccddddeeffffgg')\n['b', 'd', 'f']\n>>> multimode('')\n[]",
      "relationships": []
    },
    {
      "id": "stdlib.statistics.pstdev",
      "name": "pstdev",
      "module": "statistics",
      "type": "function",
      "signature": "(data, mu=None)",
      "description": "Return the square root of the population variance.\n\nSee ``pvariance`` for arguments and other details.\n\n>>> pstdev([1.5, 2.5, 2.5, 2.75, 3.25, 4.75])\n0.986893273527251",
      "relationships": [
        {
          "target": "stdlib.statistics._ss",
          "type": "calls"
        },
        {
          "target": "stdlib.statistics._float_sqrt_of_frac",
          "type": "calls"
        },
        {
          "target": "stdlib.statistics._decimal_sqrt_of_frac",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.statistics.pvariance",
      "name": "pvariance",
      "module": "statistics",
      "type": "function",
      "signature": "(data, mu=None)",
      "description": "Return the population variance of ``data``.\n\ndata should be a sequence or iterable of Real-valued numbers, with at least one\nvalue. The optional argument mu, if given, should be the mean of\nthe data. If it is missing or None, the mean is automatically calculated.\n\nUse this function to calculate the variance from the entire population.\nTo estimate the variance from a sample, the ``variance`` function is\nusually a better choice.\n\nExamples:\n\n>>> data = [0.0, 0.25, 0.25, 1.25, 1.5, 1.75, 2.75, 3.25]\n>>> pvariance(data)\n1.25\n\nIf you have already calculated the mean of the data, you can pass it as\nthe optional second argument to avoid recalculating it:\n\n>>> mu = mean(data)\n>>> pvariance(data, mu)\n1.25\n\nDecimals and Fractions are supported:\n\n>>> from decimal import Decimal as D\n>>> pvariance([D(\"27.5\"), D(\"30.25\"), D(\"30.25\"), D(\"34.5\"), D(\"41.75\")])\nDecimal('24.815')\n\n>>> from fractions import Fraction as F\n>>> pvariance([F(1, 4), F(5, 4), F(1, 2)])\nFraction(13, 72)",
      "relationships": [
        {
          "target": "stdlib.statistics._ss",
          "type": "calls"
        },
        {
          "target": "stdlib.statistics._convert",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.statistics.quantiles",
      "name": "quantiles",
      "module": "statistics",
      "type": "function",
      "signature": "(data, *, n=4, method='exclusive')",
      "description": "Divide *data* into *n* continuous intervals with equal probability.\n\nReturns a list of (n - 1) cut points separating the intervals.\n\nSet *n* to 4 for quartiles (the default).  Set *n* to 10 for deciles.\nSet *n* to 100 for percentiles which gives the 99 cuts points that\nseparate *data* in to 100 equal sized groups.\n\nThe *data* can be any iterable containing sample.\nThe cut points are linearly interpolated between data points.\n\nIf *method* is set to *inclusive*, *data* is treated as population\ndata.  The minimum value is treated as the 0th percentile and the\nmaximum value is treated as the 100th percentile.",
      "relationships": []
    },
    {
      "id": "stdlib.statistics.stdev",
      "name": "stdev",
      "module": "statistics",
      "type": "function",
      "signature": "(data, xbar=None)",
      "description": "Return the square root of the sample variance.\n\nSee ``variance`` for arguments and other details.\n\n>>> stdev([1.5, 2.5, 2.5, 2.75, 3.25, 4.75])\n1.0810874155219827",
      "relationships": [
        {
          "target": "stdlib.statistics._ss",
          "type": "calls"
        },
        {
          "target": "stdlib.statistics._float_sqrt_of_frac",
          "type": "calls"
        },
        {
          "target": "stdlib.statistics._decimal_sqrt_of_frac",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.statistics.variance",
      "name": "variance",
      "module": "statistics",
      "type": "function",
      "signature": "(data, xbar=None)",
      "description": "Return the sample variance of data.\n\ndata should be an iterable of Real-valued numbers, with at least two\nvalues. The optional argument xbar, if given, should be the mean of\nthe data. If it is missing or None, the mean is automatically calculated.\n\nUse this function when your data is a sample from a population. To\ncalculate the variance from the entire population, see ``pvariance``.\n\nExamples:\n\n>>> data = [2.75, 1.75, 1.25, 0.25, 0.5, 1.25, 3.5]\n>>> variance(data)\n1.3720238095238095\n\nIf you have already calculated the mean of your data, you can pass it as\nthe optional second argument ``xbar`` to avoid recalculating it:\n\n>>> m = mean(data)\n>>> variance(data, m)\n1.3720238095238095\n\nThis function does not check that ``xbar`` is actually the mean of\n``data``. Giving arbitrary values for ``xbar`` may lead to invalid or\nimpossible results.\n\nDecimals and Fractions are supported:\n\n>>> from decimal import Decimal as D\n>>> variance([D(\"27.5\"), D(\"30.25\"), D(\"30.25\"), D(\"34.5\"), D(\"41.75\")])\nDecimal('31.01875')\n\n>>> from fractions import Fraction as F\n>>> variance([F(1, 6), F(1, 2), F(5, 3)])\nFraction(67, 108)",
      "relationships": [
        {
          "target": "stdlib.statistics._ss",
          "type": "calls"
        },
        {
          "target": "stdlib.statistics._convert",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.string.Formatter",
      "name": "Formatter",
      "module": "string",
      "type": "class",
      "signature": "()",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.string.Template",
      "name": "Template",
      "module": "string",
      "type": "class",
      "signature": "(template)",
      "description": "A string class for supporting $-substitutions.",
      "relationships": []
    },
    {
      "id": "stdlib.string.capwords",
      "name": "capwords",
      "module": "string",
      "type": "function",
      "signature": "(s, sep=None)",
      "description": "capwords(s [,sep]) -> string\n\nSplit the argument into words using split, capitalize each\nword using capitalize, and join the capitalized words using\njoin.  If the optional second argument sep is absent or None,\nruns of whitespace characters are replaced by a single space\nand leading and trailing whitespace are removed, otherwise\nsep is used to split and join the words.",
      "relationships": []
    },
    {
      "id": "stdlib.stringprep.in_table_a1",
      "name": "in_table_a1",
      "module": "stringprep",
      "type": "function",
      "signature": "(code)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.stringprep.in_table_b1",
      "name": "in_table_b1",
      "module": "stringprep",
      "type": "function",
      "signature": "(code)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.stringprep.in_table_c11",
      "name": "in_table_c11",
      "module": "stringprep",
      "type": "function",
      "signature": "(code)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.stringprep.in_table_c11_c12",
      "name": "in_table_c11_c12",
      "module": "stringprep",
      "type": "function",
      "signature": "(code)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.stringprep.in_table_c12",
      "name": "in_table_c12",
      "module": "stringprep",
      "type": "function",
      "signature": "(code)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.stringprep.in_table_c21",
      "name": "in_table_c21",
      "module": "stringprep",
      "type": "function",
      "signature": "(code)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.stringprep.in_table_c21_c22",
      "name": "in_table_c21_c22",
      "module": "stringprep",
      "type": "function",
      "signature": "(code)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.stringprep.in_table_c22",
      "name": "in_table_c22",
      "module": "stringprep",
      "type": "function",
      "signature": "(code)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.stringprep.in_table_c3",
      "name": "in_table_c3",
      "module": "stringprep",
      "type": "function",
      "signature": "(code)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.stringprep.in_table_c4",
      "name": "in_table_c4",
      "module": "stringprep",
      "type": "function",
      "signature": "(code)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.stringprep.in_table_c5",
      "name": "in_table_c5",
      "module": "stringprep",
      "type": "function",
      "signature": "(code)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.stringprep.in_table_c6",
      "name": "in_table_c6",
      "module": "stringprep",
      "type": "function",
      "signature": "(code)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.stringprep.in_table_c7",
      "name": "in_table_c7",
      "module": "stringprep",
      "type": "function",
      "signature": "(code)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.stringprep.in_table_c8",
      "name": "in_table_c8",
      "module": "stringprep",
      "type": "function",
      "signature": "(code)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.stringprep.in_table_c9",
      "name": "in_table_c9",
      "module": "stringprep",
      "type": "function",
      "signature": "(code)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.stringprep.in_table_d1",
      "name": "in_table_d1",
      "module": "stringprep",
      "type": "function",
      "signature": "(code)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.stringprep.in_table_d2",
      "name": "in_table_d2",
      "module": "stringprep",
      "type": "function",
      "signature": "(code)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.stringprep.map_table_b2",
      "name": "map_table_b2",
      "module": "stringprep",
      "type": "function",
      "signature": "(a)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.stringprep.map_table_b3",
          "type": "calls"
        },
        {
          "target": "stdlib.stringprep.map_table_b3",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.stringprep.map_table_b3",
      "name": "map_table_b3",
      "module": "stringprep",
      "type": "function",
      "signature": "(code)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.subprocess.CalledProcessError",
      "name": "CalledProcessError",
      "module": "subprocess",
      "type": "class",
      "signature": "(returncode, cmd, output=None, stderr=None)",
      "description": "Raised when run() is called with check=True and the process\nreturns a non-zero exit status.\n\nAttributes:\n  cmd, returncode, stdout, stderr, output",
      "relationships": [
        {
          "target": "stdlib.subprocess.SubprocessError",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Exception",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.subprocess.CompletedProcess",
      "name": "CompletedProcess",
      "module": "subprocess",
      "type": "class",
      "signature": "(args, returncode, stdout=None, stderr=None)",
      "description": "A process that has finished running.\n\nThis is returned by run().\n\nAttributes:\n  args: The list or str args passed to run().\n  returncode: The exit code of the process, negative for signals.\n  stdout: The standard output (None if not captured).\n  stderr: The standard error (None if not captured).",
      "relationships": []
    },
    {
      "id": "stdlib.subprocess.Popen",
      "name": "Popen",
      "module": "subprocess",
      "type": "class",
      "signature": "(args, bufsize=-1, executable=None, stdin=None, stdout=None, stderr=None, preexec_fn=None, close_fds=True, shell=False, cwd=None, env=None, universal_newlines=None, startupinfo=None, creationflags=0, restore_signals=True, start_new_session=False, pass_fds=(), *, user=None, group=None, extra_groups=None, encoding=None, errors=None, text=None, umask=-1, pipesize=-1, process_group=None)",
      "description": "Execute a child program in a new process.\n\nFor a complete description of the arguments see the Python documentation.\n\nArguments:\n  args: A string, or a sequence of program arguments.\n\n  bufsize: supplied as the buffering argument to the open() function when\n      creating the stdin/stdout/stderr pipe file objects\n\n  executable: A replacement program to execute.\n\n  stdin, stdout and stderr: These specify the executed programs' standard\n      input, standard output and standard error file handles, respectively.\n\n  preexec_fn: (POSIX only) An object to be called in the child process\n      just before the child is executed.\n\n  close_fds: Controls closing or inheriting of file descriptors.\n\n  shell: If true, the command will be executed through the shell.\n\n  cwd: Sets the current directory before the child is executed.\n\n  env: Defines the environment variables for the new process.\n\n  text: If true, decode stdin, stdout and stderr using the given encoding\n      (if set) or the system default otherwise.\n\n  universal_newlines: Alias of text, provided for backwards compatibility.\n\n  startupinfo and creationflags (Windows only)\n\n  restore_signals (POSIX only)\n\n  start_new_session (POSIX only)\n\n  process_group (POSIX only)\n\n  group (POSIX only)\n\n  extra_groups (POSIX only)\n\n  user (POSIX only)\n\n  umask (POSIX only)\n\n  pass_fds (POSIX only)\n\n  encoding and errors: Text mode encoding and error handling to use for\n      file objects stdin, stdout and stderr.\n\nAttributes:\n    stdin, stdout, stderr, pid, returncode",
      "relationships": []
    },
    {
      "id": "stdlib.subprocess.TimeoutExpired",
      "name": "TimeoutExpired",
      "module": "subprocess",
      "type": "class",
      "signature": "(cmd, timeout, output=None, stderr=None)",
      "description": "This exception is raised when the timeout expires while waiting for a\nchild process.\n\nAttributes:\n    cmd, output, stdout, stderr, timeout",
      "relationships": [
        {
          "target": "stdlib.subprocess.SubprocessError",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Exception",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.subprocess.call",
      "name": "call",
      "module": "subprocess",
      "type": "function",
      "signature": "(*popenargs, timeout=None, **kwargs)",
      "description": "Run command with arguments.  Wait for command to complete or\nfor timeout seconds, then return the returncode attribute.\n\nThe arguments are the same as for the Popen constructor.  Example:\n\nretcode = call([\"ls\", \"-l\"])",
      "relationships": []
    },
    {
      "id": "stdlib.subprocess.check_call",
      "name": "check_call",
      "module": "subprocess",
      "type": "function",
      "signature": "(*popenargs, **kwargs)",
      "description": "Run command with arguments.  Wait for command to complete.  If\nthe exit code was zero then return, otherwise raise\nCalledProcessError.  The CalledProcessError object will have the\nreturn code in the returncode attribute.\n\nThe arguments are the same as for the call function.  Example:\n\ncheck_call([\"ls\", \"-l\"])",
      "relationships": [
        {
          "target": "stdlib.subprocess.call",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.subprocess.check_output",
      "name": "check_output",
      "module": "subprocess",
      "type": "function",
      "signature": "(*popenargs, timeout=None, **kwargs)",
      "description": "Run command with arguments and return its output.\n\nIf the exit code was non-zero it raises a CalledProcessError.  The\nCalledProcessError object will have the return code in the returncode\nattribute and output in the output attribute.\n\nThe arguments are the same as for the Popen constructor.  Example:\n\n>>> check_output([\"ls\", \"-l\", \"/dev/null\"])\nb'crw-rw-rw- 1 root root 1, 3 Oct 18  2007 /dev/null\\n'\n\nThe stdout argument is not allowed as it is used internally.\nTo capture standard error in the result, use stderr=STDOUT.\n\n>>> check_output([\"/bin/sh\", \"-c\",\n...               \"ls -l non_existent_file ; exit 0\"],\n...              stderr=STDOUT)\nb'ls: non_existent_file: No such file or directory\\n'\n\nThere is an additional optional argument, \"input\", allowing you to\npass a string to the subprocess's stdin.  If you use this argument\nyou may not also use the Popen constructor's \"stdin\" argument, as\nit too will be used internally.  Example:\n\n>>> check_output([\"sed\", \"-e\", \"s/foo/bar/\"],\n...              input=b\"when in the course of fooman events\\n\")\nb'when in the course of barman events\\n'\n\nBy default, all communication is in bytes, and therefore any \"input\"\nshould be bytes, and the return value will be bytes.  If in text mode,\nany \"input\" should be a string, and the return value will be a string\ndecoded according to locale encoding, or by \"encoding\" if set. Text mode\nis triggered by setting any of text, encoding, errors or universal_newlines.",
      "relationships": [
        {
          "target": "stdlib.subprocess.run",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.subprocess.getoutput",
      "name": "getoutput",
      "module": "subprocess",
      "type": "function",
      "signature": "(cmd, *, encoding=None, errors=None)",
      "description": "Return output (stdout or stderr) of executing cmd in a shell.\n\nLike getstatusoutput(), except the exit status is ignored and the return\nvalue is a string containing the command's output.  Example:\n\n>>> import subprocess\n>>> subprocess.getoutput('ls /bin/ls')\n'/bin/ls'",
      "relationships": [
        {
          "target": "stdlib.subprocess.getstatusoutput",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.subprocess.getstatusoutput",
      "name": "getstatusoutput",
      "module": "subprocess",
      "type": "function",
      "signature": "(cmd, *, encoding=None, errors=None)",
      "description": "Return (exitcode, output) of executing cmd in a shell.\n\nExecute the string 'cmd' in a shell with 'check_output' and\nreturn a 2-tuple (status, output). The locale encoding is used\nto decode the output and process newlines.\n\nA trailing newline is stripped from the output.\nThe exit status for the command can be interpreted\naccording to the rules for the function 'wait'. Example:\n\n>>> import subprocess\n>>> subprocess.getstatusoutput('ls /bin/ls')\n(0, '/bin/ls')\n>>> subprocess.getstatusoutput('cat /bin/junk')\n(1, 'cat: /bin/junk: No such file or directory')\n>>> subprocess.getstatusoutput('/bin/junk')\n(127, 'sh: /bin/junk: not found')\n>>> subprocess.getstatusoutput('/bin/kill $$')\n(-15, '')",
      "relationships": [
        {
          "target": "stdlib.subprocess.check_output",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.subprocess.list2cmdline",
      "name": "list2cmdline",
      "module": "subprocess",
      "type": "function",
      "signature": "(seq)",
      "description": "Translate a sequence of arguments into a command line\nstring, using the same rules as the MS C runtime:\n\n1) Arguments are delimited by white space, which is either a\n   space or a tab.\n\n2) A string surrounded by double quotation marks is\n   interpreted as a single argument, regardless of white space\n   contained within.  A quoted string can be embedded in an\n   argument.\n\n3) A double quotation mark preceded by a backslash is\n   interpreted as a literal double quotation mark.\n\n4) Backslashes are interpreted literally, unless they\n   immediately precede a double quotation mark.\n\n5) If backslashes immediately precede a double quotation mark,\n   every pair of backslashes is interpreted as a literal\n   backslash.  If the number of backslashes is odd, the last\n   backslash escapes the next double quotation mark as\n   described in rule 3.",
      "relationships": []
    },
    {
      "id": "stdlib.subprocess.run",
      "name": "run",
      "module": "subprocess",
      "type": "function",
      "signature": "(*popenargs, input=None, capture_output=False, timeout=None, check=False, **kwargs)",
      "description": "Run command with arguments and return a CompletedProcess instance.\n\nThe returned instance will have attributes args, returncode, stdout and\nstderr. By default, stdout and stderr are not captured, and those attributes\nwill be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them,\nor pass capture_output=True to capture both.\n\nIf check is True and the exit code was non-zero, it raises a\nCalledProcessError. The CalledProcessError object will have the return code\nin the returncode attribute, and output & stderr attributes if those streams\nwere captured.\n\nIf timeout (seconds) is given and the process takes too long,\n a TimeoutExpired exception will be raised.\n\nThere is an optional argument \"input\", allowing you to\npass bytes or a string to the subprocess's stdin.  If you use this argument\nyou may not also use the Popen constructor's \"stdin\" argument, as\nit will be used internally.\n\nBy default, all communication is in bytes, and therefore any \"input\" should\nbe bytes, and the stdout and stderr will be bytes. If in text mode, any\n\"input\" should be a string, and stdout and stderr will be strings decoded\naccording to locale encoding, or by \"encoding\" if set. Text mode is\ntriggered by setting any of text, encoding, errors or universal_newlines.\n\nThe other arguments are the same as for the Popen constructor.",
      "relationships": []
    },
    {
      "id": "stdlib.sunau.Au_read",
      "name": "Au_read",
      "module": "sunau",
      "type": "class",
      "signature": "(f)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.sunau.Au_write",
      "name": "Au_write",
      "module": "sunau",
      "type": "class",
      "signature": "(f)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.sunau.open",
      "name": "open",
      "module": "sunau",
      "type": "function",
      "signature": "(f, mode=None)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.symtable.Class",
      "name": "Class",
      "module": "symtable",
      "type": "class",
      "signature": "(raw_table, filename)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.symtable.SymbolTable",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.symtable.Function",
      "name": "Function",
      "module": "symtable",
      "type": "class",
      "signature": "(raw_table, filename)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.symtable.SymbolTable",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.symtable.Symbol",
      "name": "Symbol",
      "module": "symtable",
      "type": "class",
      "signature": "(name, flags, namespaces=None, *, module_scope=False)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.symtable.SymbolTable",
      "name": "SymbolTable",
      "module": "symtable",
      "type": "class",
      "signature": "(raw_table, filename)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.symtable.SymbolTableFactory",
      "name": "SymbolTableFactory",
      "module": "symtable",
      "type": "class",
      "signature": "()",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.symtable.symtable",
      "name": "symtable",
      "module": "symtable",
      "type": "function",
      "signature": "(code, filename, compile_type)",
      "description": "Return the toplevel *SymbolTable* for the source code.\n\n*filename* is the name of the file with the code\nand *compile_type* is the *compile()* mode argument.",
      "relationships": []
    },
    {
      "id": "stdlib.sysconfig.expand_makefile_vars",
      "name": "expand_makefile_vars",
      "module": "sysconfig",
      "type": "function",
      "signature": "(s, vars)",
      "description": "Expand Makefile-style variables -- \"${foo}\" or \"$(foo)\" -- in\n'string' according to 'vars' (a dictionary mapping variable names to\nvalues).  Variables not present in 'vars' are silently expanded to the\nempty string.  The variable values in 'vars' should not contain further\nvariable expansions; if 'vars' is the output of 'parse_makefile()',\nyou're fine.  Returns a variable-expanded version of 's'.",
      "relationships": []
    },
    {
      "id": "stdlib.sysconfig.get_config_h_filename",
      "name": "get_config_h_filename",
      "module": "sysconfig",
      "type": "function",
      "signature": "()",
      "description": "Return the path of pyconfig.h.",
      "relationships": [
        {
          "target": "stdlib.sysconfig.get_path",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.sysconfig.get_config_var",
      "name": "get_config_var",
      "module": "sysconfig",
      "type": "function",
      "signature": "(name)",
      "description": "Return the value of a single variable using the dictionary returned by\n'get_config_vars()'.\n\nEquivalent to get_config_vars().get(name)",
      "relationships": [
        {
          "target": "stdlib.sysconfig.get_config_vars",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.sysconfig.get_config_vars",
      "name": "get_config_vars",
      "module": "sysconfig",
      "type": "function",
      "signature": "(*args)",
      "description": "With no arguments, return a dictionary of all configuration\nvariables relevant for the current platform.\n\nOn Unix, this means every variable defined in Python's installed Makefile;\nOn Windows it's a much smaller set.\n\nWith arguments, return a list of values that result from looking up\neach argument in the configuration variable dictionary.",
      "relationships": [
        {
          "target": "stdlib.sysconfig._init_config_vars",
          "type": "calls"
        },
        {
          "target": "stdlib.sysconfig._init_config_vars",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.sysconfig.get_default_scheme",
      "name": "get_default_scheme",
      "module": "sysconfig",
      "type": "function",
      "signature": "()",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.sysconfig.get_preferred_scheme",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.sysconfig.get_makefile_filename",
      "name": "get_makefile_filename",
      "module": "sysconfig",
      "type": "function",
      "signature": "()",
      "description": "Return the path of the Makefile.",
      "relationships": [
        {
          "target": "stdlib.sysconfig.get_path",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.sysconfig.get_path",
      "name": "get_path",
      "module": "sysconfig",
      "type": "function",
      "signature": "(name, scheme='venv', vars=None, expand=True)",
      "description": "Return a path corresponding to the scheme.\n\n``scheme`` is the install scheme name.",
      "relationships": [
        {
          "target": "stdlib.sysconfig.get_default_scheme",
          "type": "calls"
        },
        {
          "target": "stdlib.sysconfig.get_paths",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.sysconfig.get_path_names",
      "name": "get_path_names",
      "module": "sysconfig",
      "type": "function",
      "signature": "()",
      "description": "Return a tuple containing the paths names.",
      "relationships": []
    },
    {
      "id": "stdlib.sysconfig.get_paths",
      "name": "get_paths",
      "module": "sysconfig",
      "type": "function",
      "signature": "(scheme='venv', vars=None, expand=True)",
      "description": "Return a mapping containing an install scheme.\n\n``scheme`` is the install scheme name. If not provided, it will\nreturn the default scheme for the current platform.",
      "relationships": [
        {
          "target": "stdlib.sysconfig.get_default_scheme",
          "type": "calls"
        },
        {
          "target": "stdlib.sysconfig._expand_vars",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.sysconfig.get_platform",
      "name": "get_platform",
      "module": "sysconfig",
      "type": "function",
      "signature": "()",
      "description": "Return a string that identifies the current platform.\n\nThis is used mainly to distinguish platform-specific build directories and\nplatform-specific built distributions.  Typically includes the OS name and\nversion and the architecture (as supplied by 'os.uname()'), although the\nexact information included depends on the OS; on Linux, the kernel version\nisn't particularly important.\n\nExamples of returned values:\n   linux-i586\n   linux-alpha (?)\n   solaris-2.6-sun4u\n\nWindows will return one of:\n   win-amd64 (64-bit Windows on AMD64 (aka x86_64, Intel64, EM64T, etc)\n   win-arm64 (64-bit Windows on ARM64 (aka AArch64)\n   win32 (all others - specifically, sys.platform is returned)\n\nFor other non-POSIX platforms, currently just returns 'sys.platform'.",
      "relationships": [
        {
          "target": "stdlib.sysconfig.get_config_vars",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.sysconfig.get_preferred_scheme",
      "name": "get_preferred_scheme",
      "module": "sysconfig",
      "type": "function",
      "signature": "(key)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.sysconfig._get_preferred_schemes",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.sysconfig.get_python_version",
      "name": "get_python_version",
      "module": "sysconfig",
      "type": "function",
      "signature": "()",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.sysconfig.get_scheme_names",
      "name": "get_scheme_names",
      "module": "sysconfig",
      "type": "function",
      "signature": "()",
      "description": "Return a tuple containing the schemes names.",
      "relationships": []
    },
    {
      "id": "stdlib.sysconfig.is_python_build",
      "name": "is_python_build",
      "module": "sysconfig",
      "type": "function",
      "signature": "(check_home=None)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.sysconfig.parse_config_h",
      "name": "parse_config_h",
      "module": "sysconfig",
      "type": "function",
      "signature": "(fp, vars=None)",
      "description": "Parse a config.h-style file.\n\nA dictionary containing name/value pairs is returned.  If an\noptional dictionary is passed in as the second argument, it is\nused instead of a new dictionary.",
      "relationships": []
    },
    {
      "id": "stdlib.tabnanny.NannyNag",
      "name": "NannyNag",
      "module": "tabnanny",
      "type": "class",
      "signature": "(lineno, msg, line)",
      "description": "Raised by process_tokens() if detecting an ambiguous indent.\nCaptured and handled in check().",
      "relationships": [
        {
          "target": "stdlib.builtins.Exception",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.tabnanny.Whitespace",
      "name": "Whitespace",
      "module": "tabnanny",
      "type": "class",
      "signature": "(ws)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.tabnanny.check",
      "name": "check",
      "module": "tabnanny",
      "type": "function",
      "signature": "(file)",
      "description": "check(file_or_dir)\n\nIf file_or_dir is a directory and not a symbolic link, then recursively\ndescend the directory tree named by file_or_dir, checking all .py files\nalong the way. If file_or_dir is an ordinary Python source file, it is\nchecked for whitespace related problems. The diagnostic messages are\nwritten to standard output using the print statement.",
      "relationships": [
        {
          "target": "stdlib.tabnanny.process_tokens",
          "type": "calls"
        },
        {
          "target": "stdlib.tabnanny.errprint",
          "type": "calls"
        },
        {
          "target": "stdlib.tabnanny.errprint",
          "type": "calls"
        },
        {
          "target": "stdlib.tabnanny.errprint",
          "type": "calls"
        },
        {
          "target": "stdlib.tabnanny.errprint",
          "type": "calls"
        },
        {
          "target": "stdlib.tabnanny.check",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.tabnanny.errprint",
      "name": "errprint",
      "module": "tabnanny",
      "type": "function",
      "signature": "(*args)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.tabnanny.format_witnesses",
      "name": "format_witnesses",
      "module": "tabnanny",
      "type": "function",
      "signature": "(w)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.tabnanny.main",
      "name": "main",
      "module": "tabnanny",
      "type": "function",
      "signature": "()",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.tabnanny.errprint",
          "type": "calls"
        },
        {
          "target": "stdlib.tabnanny.check",
          "type": "calls"
        },
        {
          "target": "stdlib.tabnanny.errprint",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.tabnanny.process_tokens",
      "name": "process_tokens",
      "module": "tabnanny",
      "type": "function",
      "signature": "(tokens)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.tabnanny._process_tokens",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.tarfile.AbsoluteLinkError",
      "name": "AbsoluteLinkError",
      "module": "tarfile",
      "type": "class",
      "signature": "(tarinfo)",
      "description": "Base exception.",
      "relationships": [
        {
          "target": "stdlib.tarfile.FilterError",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.TarError",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Exception",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.tarfile.AbsolutePathError",
      "name": "AbsolutePathError",
      "module": "tarfile",
      "type": "class",
      "signature": "(tarinfo)",
      "description": "Base exception.",
      "relationships": [
        {
          "target": "stdlib.tarfile.FilterError",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.TarError",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Exception",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.tarfile.ExFileObject",
      "name": "ExFileObject",
      "module": "tarfile",
      "type": "class",
      "signature": "(tarfile, tarinfo)",
      "description": "Create a new buffered reader using the given readable raw IO object.",
      "relationships": [
        {
          "target": "stdlib._io.BufferedReader",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins._BufferedIOBase",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins._IOBase",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.tarfile.LinkFallbackError",
      "name": "LinkFallbackError",
      "module": "tarfile",
      "type": "class",
      "signature": "(tarinfo, path)",
      "description": "Base exception.",
      "relationships": [
        {
          "target": "stdlib.tarfile.FilterError",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.TarError",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Exception",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.tarfile.LinkOutsideDestinationError",
      "name": "LinkOutsideDestinationError",
      "module": "tarfile",
      "type": "class",
      "signature": "(tarinfo, path)",
      "description": "Base exception.",
      "relationships": [
        {
          "target": "stdlib.tarfile.FilterError",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.TarError",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Exception",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.tarfile.OutsideDestinationError",
      "name": "OutsideDestinationError",
      "module": "tarfile",
      "type": "class",
      "signature": "(tarinfo, path)",
      "description": "Base exception.",
      "relationships": [
        {
          "target": "stdlib.tarfile.FilterError",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.TarError",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Exception",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.tarfile.SpecialFileError",
      "name": "SpecialFileError",
      "module": "tarfile",
      "type": "class",
      "signature": "(tarinfo)",
      "description": "Base exception.",
      "relationships": [
        {
          "target": "stdlib.tarfile.FilterError",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.TarError",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Exception",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.tarfile.TarFile",
      "name": "TarFile",
      "module": "tarfile",
      "type": "class",
      "signature": "(name=None, mode='r', fileobj=None, format=None, tarinfo=None, dereference=None, ignore_zeros=None, encoding=None, errors='surrogateescape', pax_headers=None, debug=None, errorlevel=None, copybufsize=None)",
      "description": "The TarFile Class provides an interface to tar archives.\n    ",
      "relationships": []
    },
    {
      "id": "stdlib.tarfile.TarInfo",
      "name": "TarInfo",
      "module": "tarfile",
      "type": "class",
      "signature": "(name='')",
      "description": "Informational class which holds the details about an\narchive member given by a tar header block.\nTarInfo objects are returned by TarFile.getmember(),\nTarFile.getmembers() and TarFile.gettarinfo() and are\nusually created internally.",
      "relationships": []
    },
    {
      "id": "stdlib.tarfile.calc_chksums",
      "name": "calc_chksums",
      "module": "tarfile",
      "type": "function",
      "signature": "(buf)",
      "description": "Calculate the checksum for a member's header by summing up all\ncharacters except for the chksum field which is treated as if\nit was filled with spaces. According to the GNU tar sources,\nsome tars (Sun and NeXT) calculate chksum with signed char,\nwhich will be different if there are chars in the buffer with\nthe high bit set. So we calculate two checksums, unsigned and\nsigned.",
      "relationships": []
    },
    {
      "id": "stdlib.tarfile.copyfileobj",
      "name": "copyfileobj",
      "module": "tarfile",
      "type": "function",
      "signature": "(src, dst, length=None, exception=<class 'OSError'>, bufsize=None)",
      "description": "Copy length bytes from fileobj src to fileobj dst.\nIf length is None, copy the entire content.",
      "relationships": []
    },
    {
      "id": "stdlib.tarfile.data_filter",
      "name": "data_filter",
      "module": "tarfile",
      "type": "function",
      "signature": "(member, dest_path)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.tarfile._get_filtered_attrs",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.tarfile.fully_trusted_filter",
      "name": "fully_trusted_filter",
      "module": "tarfile",
      "type": "function",
      "signature": "(member, dest_path)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.tarfile.is_tarfile",
      "name": "is_tarfile",
      "module": "tarfile",
      "type": "function",
      "signature": "(name)",
      "description": "Return True if name points to a tar archive that we\nare able to handle, else return False.\n\n'name' should be a string, file, or file-like object.",
      "relationships": []
    },
    {
      "id": "stdlib.tarfile.itn",
      "name": "itn",
      "module": "tarfile",
      "type": "function",
      "signature": "(n, digits=8, format=2)",
      "description": "Convert a python number to a number field.\n    ",
      "relationships": []
    },
    {
      "id": "stdlib.tarfile.main",
      "name": "main",
      "module": "tarfile",
      "type": "function",
      "signature": "()",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.tarfile.is_tarfile",
          "type": "calls"
        },
        {
          "target": "stdlib.tarfile.is_tarfile",
          "type": "calls"
        },
        {
          "target": "stdlib.tarfile.is_tarfile",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.tarfile.nti",
      "name": "nti",
      "module": "tarfile",
      "type": "function",
      "signature": "(s)",
      "description": "Convert a number field to a python number.\n    ",
      "relationships": [
        {
          "target": "stdlib.tarfile.nts",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.tarfile.nts",
      "name": "nts",
      "module": "tarfile",
      "type": "function",
      "signature": "(s, encoding, errors)",
      "description": "Convert a null-terminated bytes object to a string.\n    ",
      "relationships": []
    },
    {
      "id": "stdlib.tarfile.stn",
      "name": "stn",
      "module": "tarfile",
      "type": "function",
      "signature": "(s, length, encoding, errors)",
      "description": "Convert a string to a null-terminated bytes object.\n    ",
      "relationships": []
    },
    {
      "id": "stdlib.tarfile.tar_filter",
      "name": "tar_filter",
      "module": "tarfile",
      "type": "function",
      "signature": "(member, dest_path)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.tarfile._get_filtered_attrs",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.telnetlib.Telnet",
      "name": "Telnet",
      "module": "telnetlib",
      "type": "class",
      "signature": "(host=None, port=0, timeout=<object object at 0x100108a90>)",
      "description": "Telnet interface class.\n\nAn instance of this class represents a connection to a telnet\nserver.  The instance is initially not connected; the open()\nmethod must be used to establish a connection.  Alternatively, the\nhost name and optional port number can be passed to the\nconstructor, too.\n\nDon't try to reopen an already connected instance.\n\nThis class has many read_*() methods.  Note that some of them\nraise EOFError when the end of the connection is read, because\nthey can return an empty string for other reasons.  See the\nindividual doc strings.\n\nread_until(expected, [timeout])\n    Read until the expected string has been seen, or a timeout is\n    hit (default is no timeout); may block.\n\nread_all()\n    Read all data until EOF; may block.\n\nread_some()\n    Read at least one byte or EOF; may block.\n\nread_very_eager()\n    Read all data available already queued or on the socket,\n    without blocking.\n\nread_eager()\n    Read either data already queued or some data available on the\n    socket, without blocking.\n\nread_lazy()\n    Read all data in the raw queue (processing it first), without\n    doing any socket I/O.\n\nread_very_lazy()\n    Reads all data in the cooked queue, without doing any socket\n    I/O.\n\nread_sb_data()\n    Reads available data between SB ... SE sequence. Don't block.\n\nset_option_negotiation_callback(callback)\n    Each time a telnet option is read on the input flow, this callback\n    (if set) is called with the following parameters :\n    callback(telnet socket, command, option)\n        option will be chr(0) when there is no option.\n    No other action is done afterwards by telnetlib.",
      "relationships": []
    },
    {
      "id": "stdlib.telnetlib.test",
      "name": "test",
      "module": "telnetlib",
      "type": "function",
      "signature": "()",
      "description": "Test program for telnetlib.\n\nUsage: python telnetlib.py [-d] ... [host [port]]\n\nDefault host is localhost; default port is 23.",
      "relationships": []
    },
    {
      "id": "stdlib.tempfile.NamedTemporaryFile",
      "name": "NamedTemporaryFile",
      "module": "tempfile",
      "type": "function",
      "signature": "(mode='w+b', buffering=-1, encoding=None, newline=None, suffix=None, prefix=None, dir=None, delete=True, *, errors=None, delete_on_close=True)",
      "description": "Create and return a temporary file.\nArguments:\n'prefix', 'suffix', 'dir' -- as for mkstemp.\n'mode' -- the mode argument to io.open (default \"w+b\").\n'buffering' -- the buffer size argument to io.open (default -1).\n'encoding' -- the encoding argument to io.open (default None)\n'newline' -- the newline argument to io.open (default None)\n'delete' -- whether the file is automatically deleted (default True).\n'delete_on_close' -- if 'delete', whether the file is deleted on close\n   (default True) or otherwise either on context manager exit\n   (if context manager was used) or on object finalization. .\n'errors' -- the errors argument to io.open (default None)\nThe file is created as mkstemp() would do it.\n\nReturns an object with a file-like interface; the name of the file\nis accessible as its 'name' attribute.  The file will be automatically\ndeleted when it is closed unless the 'delete' argument is set to False.\n\nOn POSIX, NamedTemporaryFiles cannot be automatically deleted if\nthe creating process is terminated abruptly with a SIGKILL signal.\nWindows can delete the file even in this case.",
      "relationships": [
        {
          "target": "stdlib.tempfile._sanitize_params",
          "type": "calls"
        },
        {
          "target": "stdlib.tempfile._mkstemp_inner",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.tempfile.SpooledTemporaryFile",
      "name": "SpooledTemporaryFile",
      "module": "tempfile",
      "type": "class",
      "signature": "(max_size=0, mode='w+b', buffering=-1, encoding=None, newline=None, suffix=None, prefix=None, dir=None, *, errors=None)",
      "description": "Temporary file wrapper, specialized to switch from BytesIO\nor StringIO to a real file when it exceeds a certain size or\nwhen a fileno is needed.",
      "relationships": [
        {
          "target": "stdlib.io.IOBase",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins._IOBase",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.tempfile.TemporaryDirectory",
      "name": "TemporaryDirectory",
      "module": "tempfile",
      "type": "class",
      "signature": "(suffix=None, prefix=None, dir=None, ignore_cleanup_errors=False, *, delete=True)",
      "description": "Create and return a temporary directory.  This has the same\nbehavior as mkdtemp but can be used as a context manager.  For\nexample:\n\n    with TemporaryDirectory() as tmpdir:\n        ...\n\nUpon exiting the context, the directory and everything contained\nin it are removed (unless delete=False is passed or an exception\nis raised during cleanup and ignore_cleanup_errors is not True).\n\nOptional Arguments:\n    suffix - A str suffix for the directory name.  (see mkdtemp)\n    prefix - A str prefix for the directory name.  (see mkdtemp)\n    dir - A directory to create this temp dir in.  (see mkdtemp)\n    ignore_cleanup_errors - False; ignore exceptions during cleanup?\n    delete - True; whether the directory is automatically deleted.",
      "relationships": []
    },
    {
      "id": "stdlib.tempfile.TemporaryFile",
      "name": "TemporaryFile",
      "module": "tempfile",
      "type": "function",
      "signature": "(mode='w+b', buffering=-1, encoding=None, newline=None, suffix=None, prefix=None, dir=None, *, errors=None)",
      "description": "Create and return a temporary file.\nArguments:\n'prefix', 'suffix', 'dir' -- as for mkstemp.\n'mode' -- the mode argument to io.open (default \"w+b\").\n'buffering' -- the buffer size argument to io.open (default -1).\n'encoding' -- the encoding argument to io.open (default None)\n'newline' -- the newline argument to io.open (default None)\n'errors' -- the errors argument to io.open (default None)\nThe file is created as mkstemp() would do it.\n\nReturns an object with a file-like interface.  The file has no\nname, and will cease to exist when it is closed.",
      "relationships": [
        {
          "target": "stdlib.tempfile._sanitize_params",
          "type": "calls"
        },
        {
          "target": "stdlib.tempfile._mkstemp_inner",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.tempfile.gettempdir",
      "name": "gettempdir",
      "module": "tempfile",
      "type": "function",
      "signature": "()",
      "description": "Returns tempfile.tempdir as str.",
      "relationships": [
        {
          "target": "stdlib.tempfile._gettempdir",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.tempfile.gettempdirb",
      "name": "gettempdirb",
      "module": "tempfile",
      "type": "function",
      "signature": "()",
      "description": "Returns tempfile.tempdir as bytes.",
      "relationships": [
        {
          "target": "stdlib.tempfile._gettempdir",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.tempfile.gettempprefix",
      "name": "gettempprefix",
      "module": "tempfile",
      "type": "function",
      "signature": "()",
      "description": "The default prefix for temporary directories as string.",
      "relationships": []
    },
    {
      "id": "stdlib.tempfile.gettempprefixb",
      "name": "gettempprefixb",
      "module": "tempfile",
      "type": "function",
      "signature": "()",
      "description": "The default prefix for temporary directories as bytes.",
      "relationships": []
    },
    {
      "id": "stdlib.tempfile.mkdtemp",
      "name": "mkdtemp",
      "module": "tempfile",
      "type": "function",
      "signature": "(suffix=None, prefix=None, dir=None)",
      "description": "User-callable function to create and return a unique temporary\ndirectory.  The return value is the pathname of the directory.\n\nArguments are as for mkstemp, except that the 'text' argument is\nnot accepted.\n\nThe directory is readable, writable, and searchable only by the\ncreating user.\n\nCaller is responsible for deleting the directory when done with it.",
      "relationships": [
        {
          "target": "stdlib.tempfile._sanitize_params",
          "type": "calls"
        },
        {
          "target": "stdlib.tempfile._get_candidate_names",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.tempfile.mkstemp",
      "name": "mkstemp",
      "module": "tempfile",
      "type": "function",
      "signature": "(suffix=None, prefix=None, dir=None, text=False)",
      "description": "User-callable function to create and return a unique temporary\nfile.  The return value is a pair (fd, name) where fd is the\nfile descriptor returned by os.open, and name is the filename.\n\nIf 'suffix' is not None, the file name will end with that suffix,\notherwise there will be no suffix.\n\nIf 'prefix' is not None, the file name will begin with that prefix,\notherwise a default prefix is used.\n\nIf 'dir' is not None, the file will be created in that directory,\notherwise a default directory is used.\n\nIf 'text' is specified and true, the file is opened in text\nmode.  Else (the default) the file is opened in binary mode.\n\nIf any of 'suffix', 'prefix' and 'dir' are not None, they must be the\nsame type.  If they are bytes, the returned name will be bytes; str\notherwise.\n\nThe file is readable and writable only by the creating user ID.\nIf the operating system uses permission bits to indicate whether a\nfile is executable, the file is executable by no one. The file\ndescriptor is not inherited by children of this process.\n\nCaller is responsible for deleting the file when done with it.",
      "relationships": [
        {
          "target": "stdlib.tempfile._sanitize_params",
          "type": "calls"
        },
        {
          "target": "stdlib.tempfile._mkstemp_inner",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.tempfile.mktemp",
      "name": "mktemp",
      "module": "tempfile",
      "type": "function",
      "signature": "(suffix='', prefix='tmp', dir=None)",
      "description": "User-callable function to return a unique temporary file name.  The\nfile is not created.\n\nArguments are similar to mkstemp, except that the 'text' argument is\nnot accepted, and suffix=None, prefix=None and bytes file names are not\nsupported.\n\nTHIS FUNCTION IS UNSAFE AND SHOULD NOT BE USED.  The file name may\nrefer to a file that did not exist at some point, but by the time\nyou get around to creating it, someone else may have beaten you to\nthe punch.",
      "relationships": [
        {
          "target": "stdlib.tempfile._get_candidate_names",
          "type": "calls"
        },
        {
          "target": "stdlib.tempfile.gettempdir",
          "type": "calls"
        },
        {
          "target": "stdlib.tempfile._exists",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.textwrap.TextWrapper",
      "name": "TextWrapper",
      "module": "textwrap",
      "type": "class",
      "signature": "(width=70, initial_indent='', subsequent_indent='', expand_tabs=True, replace_whitespace=True, fix_sentence_endings=False, break_long_words=True, drop_whitespace=True, break_on_hyphens=True, tabsize=8, *, max_lines=None, placeholder=' [...]')",
      "description": "Object for wrapping/filling text.  The public interface consists of\nthe wrap() and fill() methods; the other methods are just there for\nsubclasses to override in order to tweak the default behaviour.\nIf you want to completely replace the main wrapping algorithm,\nyou'll probably have to override _wrap_chunks().\n\nSeveral instance attributes control various aspects of wrapping:\n  width (default: 70)\n    the maximum width of wrapped lines (unless break_long_words\n    is false)\n  initial_indent (default: \"\")\n    string that will be prepended to the first line of wrapped\n    output.  Counts towards the line's width.\n  subsequent_indent (default: \"\")\n    string that will be prepended to all lines save the first\n    of wrapped output; also counts towards each line's width.\n  expand_tabs (default: true)\n    Expand tabs in input text to spaces before further processing.\n    Each tab will become 0 .. 'tabsize' spaces, depending on its position\n    in its line.  If false, each tab is treated as a single character.\n  tabsize (default: 8)\n    Expand tabs in input text to 0 .. 'tabsize' spaces, unless\n    'expand_tabs' is false.\n  replace_whitespace (default: true)\n    Replace all whitespace characters in the input text by spaces\n    after tab expansion.  Note that if expand_tabs is false and\n    replace_whitespace is true, every tab will be converted to a\n    single space!\n  fix_sentence_endings (default: false)\n    Ensure that sentence-ending punctuation is always followed\n    by two spaces.  Off by default because the algorithm is\n    (unavoidably) imperfect.\n  break_long_words (default: true)\n    Break words longer than 'width'.  If false, those words will not\n    be broken, and some lines might be longer than 'width'.\n  break_on_hyphens (default: true)\n    Allow breaking hyphenated words. If true, wrapping will occur\n    preferably on whitespaces and right after hyphens part of\n    compound words.\n  drop_whitespace (default: true)\n    Drop leading and trailing whitespace from lines.\n  max_lines (default: None)\n    Truncate wrapped lines.\n  placeholder (default: ' [...]')\n    Append to the last line of truncated text.",
      "relationships": []
    },
    {
      "id": "stdlib.textwrap.dedent",
      "name": "dedent",
      "module": "textwrap",
      "type": "function",
      "signature": "(text)",
      "description": "Remove any common leading whitespace from every line in `text`.\n\nThis can be used to make triple-quoted strings line up with the left\nedge of the display, while still presenting them in the source code\nin indented form.\n\nNote that tabs and spaces are both treated as whitespace, but they\nare not equal: the lines \"  hello\" and \"\\thello\" are\nconsidered to have no common leading whitespace.\n\nEntirely blank lines are normalized to a newline character.",
      "relationships": []
    },
    {
      "id": "stdlib.textwrap.fill",
      "name": "fill",
      "module": "textwrap",
      "type": "function",
      "signature": "(text, width=70, **kwargs)",
      "description": "Fill a single paragraph of text, returning a new string.\n\nReformat the single paragraph in 'text' to fit in lines of no more\nthan 'width' columns, and return a new string containing the entire\nwrapped paragraph.  As with wrap(), tabs are expanded and other\nwhitespace characters converted to space.  See TextWrapper class for\navailable keyword args to customize wrapping behaviour.",
      "relationships": []
    },
    {
      "id": "stdlib.textwrap.indent",
      "name": "indent",
      "module": "textwrap",
      "type": "function",
      "signature": "(text, prefix, predicate=None)",
      "description": "Adds 'prefix' to the beginning of selected lines in 'text'.\n\nIf 'predicate' is provided, 'prefix' will only be added to the lines\nwhere 'predicate(line)' is True. If 'predicate' is not provided,\nit will default to adding 'prefix' to all non-empty lines that do not\nconsist solely of whitespace characters.",
      "relationships": []
    },
    {
      "id": "stdlib.textwrap.shorten",
      "name": "shorten",
      "module": "textwrap",
      "type": "function",
      "signature": "(text, width, **kwargs)",
      "description": "Collapse and truncate the given text to fit in the given width.\n\nThe text first has its whitespace collapsed.  If it then fits in\nthe *width*, it is returned as is.  Otherwise, as many words\nas possible are joined and then the placeholder is appended::\n\n    >>> textwrap.shorten(\"Hello  world!\", width=12)\n    'Hello world!'\n    >>> textwrap.shorten(\"Hello  world!\", width=11)\n    'Hello [...]'",
      "relationships": []
    },
    {
      "id": "stdlib.textwrap.wrap",
      "name": "wrap",
      "module": "textwrap",
      "type": "function",
      "signature": "(text, width=70, **kwargs)",
      "description": "Wrap a single paragraph of text, returning a list of wrapped lines.\n\nReformat the single paragraph in 'text' so it fits in lines of no\nmore than 'width' columns, and return a list of wrapped lines.  By\ndefault, tabs in 'text' are expanded with string.expandtabs(), and\nall other whitespace characters (including newline) are converted to\nspace.  See TextWrapper class for available keyword args to customize\nwrapping behaviour.",
      "relationships": []
    },
    {
      "id": "stdlib.threading.Barrier",
      "name": "Barrier",
      "module": "threading",
      "type": "class",
      "signature": "(parties, action=None, timeout=None)",
      "description": "Implements a Barrier.\n\nUseful for synchronizing a fixed number of threads at known synchronization\npoints.  Threads block on 'wait()' and are simultaneously awoken once they\nhave all made that call.",
      "relationships": []
    },
    {
      "id": "stdlib.threading.BoundedSemaphore",
      "name": "BoundedSemaphore",
      "module": "threading",
      "type": "class",
      "signature": "(value=1)",
      "description": "Implements a bounded semaphore.\n\nA bounded semaphore checks to make sure its current value doesn't exceed its\ninitial value. If it does, ValueError is raised. In most situations\nsemaphores are used to guard resources with limited capacity.\n\nIf the semaphore is released too many times it's a sign of a bug. If not\ngiven, value defaults to 1.\n\nLike regular semaphores, bounded semaphores manage a counter representing\nthe number of release() calls minus the number of acquire() calls, plus an\ninitial value. The acquire() method blocks if necessary until it can return\nwithout making the counter negative. If not given, value defaults to 1.",
      "relationships": [
        {
          "target": "stdlib.threading.Semaphore",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.threading.Condition",
      "name": "Condition",
      "module": "threading",
      "type": "class",
      "signature": "(lock=None)",
      "description": "Class that implements a condition variable.\n\nA condition variable allows one or more threads to wait until they are\nnotified by another thread.\n\nIf the lock argument is given and not None, it must be a Lock or RLock\nobject, and it is used as the underlying lock. Otherwise, a new RLock object\nis created and used as the underlying lock.",
      "relationships": []
    },
    {
      "id": "stdlib.threading.Event",
      "name": "Event",
      "module": "threading",
      "type": "class",
      "signature": "()",
      "description": "Class implementing event objects.\n\nEvents manage a flag that can be set to true with the set() method and reset\nto false with the clear() method. The wait() method blocks until the flag is\ntrue.  The flag is initially false.",
      "relationships": []
    },
    {
      "id": "stdlib.threading.RLock",
      "name": "RLock",
      "module": "threading",
      "type": "function",
      "signature": "(*args, **kwargs)",
      "description": "Factory function that returns a new reentrant lock.\n\nA reentrant lock must be released by the thread that acquired it. Once a\nthread has acquired a reentrant lock, the same thread may acquire it again\nwithout blocking; the thread must release it once for each time it has\nacquired it.",
      "relationships": []
    },
    {
      "id": "stdlib.threading.Semaphore",
      "name": "Semaphore",
      "module": "threading",
      "type": "class",
      "signature": "(value=1)",
      "description": "This class implements semaphore objects.\n\nSemaphores manage a counter representing the number of release() calls minus\nthe number of acquire() calls, plus an initial value. The acquire() method\nblocks if necessary until it can return without making the counter\nnegative. If not given, value defaults to 1.",
      "relationships": []
    },
    {
      "id": "stdlib.threading.Thread",
      "name": "Thread",
      "module": "threading",
      "type": "class",
      "signature": "(group=None, target=None, name=None, args=(), kwargs=None, *, daemon=None)",
      "description": "A class that represents a thread of control.\n\nThis class can be safely subclassed in a limited fashion. There are two ways\nto specify the activity: by passing a callable object to the constructor, or\nby overriding the run() method in a subclass.",
      "relationships": []
    },
    {
      "id": "stdlib.threading.Timer",
      "name": "Timer",
      "module": "threading",
      "type": "class",
      "signature": "(interval, function, args=None, kwargs=None)",
      "description": "Call a function after a specified number of seconds:\n\nt = Timer(30.0, f, args=None, kwargs=None)\nt.start()\nt.cancel()     # stop the timer's action if it's still waiting",
      "relationships": [
        {
          "target": "stdlib.threading.Thread",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.threading.activeCount",
      "name": "activeCount",
      "module": "threading",
      "type": "function",
      "signature": "()",
      "description": "Return the number of Thread objects currently alive.\n\nThis function is deprecated, use active_count() instead.",
      "relationships": [
        {
          "target": "stdlib.threading.active_count",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.threading.active_count",
      "name": "active_count",
      "module": "threading",
      "type": "function",
      "signature": "()",
      "description": "Return the number of Thread objects currently alive.\n\nThe returned count is equal to the length of the list returned by\nenumerate().",
      "relationships": []
    },
    {
      "id": "stdlib.threading.currentThread",
      "name": "currentThread",
      "module": "threading",
      "type": "function",
      "signature": "()",
      "description": "Return the current Thread object, corresponding to the caller's thread of control.\n\nThis function is deprecated, use current_thread() instead.",
      "relationships": [
        {
          "target": "stdlib.threading.current_thread",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.threading.current_thread",
      "name": "current_thread",
      "module": "threading",
      "type": "function",
      "signature": "()",
      "description": "Return the current Thread object, corresponding to the caller's thread of control.\n\nIf the caller's thread of control was not created through the threading\nmodule, a dummy thread object with limited functionality is returned.",
      "relationships": []
    },
    {
      "id": "stdlib.threading.enumerate",
      "name": "enumerate",
      "module": "threading",
      "type": "function",
      "signature": "()",
      "description": "Return a list of all Thread objects currently alive.\n\nThe list includes daemonic threads, dummy thread objects created by\ncurrent_thread(), and the main thread. It excludes terminated threads and\nthreads that have not yet been started.",
      "relationships": []
    },
    {
      "id": "stdlib.threading.getprofile",
      "name": "getprofile",
      "module": "threading",
      "type": "function",
      "signature": "()",
      "description": "Get the profiler function as set by threading.setprofile().",
      "relationships": []
    },
    {
      "id": "stdlib.threading.gettrace",
      "name": "gettrace",
      "module": "threading",
      "type": "function",
      "signature": "()",
      "description": "Get the trace function as set by threading.settrace().",
      "relationships": []
    },
    {
      "id": "stdlib.threading.main_thread",
      "name": "main_thread",
      "module": "threading",
      "type": "function",
      "signature": "()",
      "description": "Return the main thread object.\n\nIn normal conditions, the main thread is the thread from which the\nPython interpreter was started.",
      "relationships": []
    },
    {
      "id": "stdlib.threading.setprofile",
      "name": "setprofile",
      "module": "threading",
      "type": "function",
      "signature": "(func)",
      "description": "Set a profile function for all threads started from the threading module.\n\nThe func will be passed to sys.setprofile() for each thread, before its\nrun() method is called.",
      "relationships": []
    },
    {
      "id": "stdlib.threading.setprofile_all_threads",
      "name": "setprofile_all_threads",
      "module": "threading",
      "type": "function",
      "signature": "(func)",
      "description": "Set a profile function for all threads started from the threading module\nand all Python threads that are currently executing.\n\nThe func will be passed to sys.setprofile() for each thread, before its\nrun() method is called.",
      "relationships": [
        {
          "target": "stdlib.threading.setprofile",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.threading.settrace",
      "name": "settrace",
      "module": "threading",
      "type": "function",
      "signature": "(func)",
      "description": "Set a trace function for all threads started from the threading module.\n\nThe func will be passed to sys.settrace() for each thread, before its run()\nmethod is called.",
      "relationships": []
    },
    {
      "id": "stdlib.threading.settrace_all_threads",
      "name": "settrace_all_threads",
      "module": "threading",
      "type": "function",
      "signature": "(func)",
      "description": "Set a trace function for all threads started from the threading module\nand all Python threads that are currently executing.\n\nThe func will be passed to sys.settrace() for each thread, before its run()\nmethod is called.",
      "relationships": [
        {
          "target": "stdlib.threading.settrace",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.timeit.Timer",
      "name": "Timer",
      "module": "timeit",
      "type": "class",
      "signature": "(stmt='pass', setup='pass', timer=<built-in function perf_counter>, globals=None)",
      "description": "Class for timing execution speed of small code snippets.\n\nThe constructor takes a statement to be timed, an additional\nstatement used for setup, and a timer function.  Both statements\ndefault to 'pass'; the timer function is platform-dependent (see\nmodule doc string).  If 'globals' is specified, the code will be\nexecuted within that namespace (as opposed to inside timeit's\nnamespace).\n\nTo measure the execution time of the first statement, use the\ntimeit() method.  The repeat() method is a convenience to call\ntimeit() multiple times and return a list of results.\n\nThe statements may contain newlines, as long as they don't contain\nmulti-line string literals.",
      "relationships": []
    },
    {
      "id": "stdlib.timeit.main",
      "name": "main",
      "module": "timeit",
      "type": "function",
      "signature": "(args=None, *, _wrap_timer=None)",
      "description": "Main program, used when run as a script.\n\nThe optional 'args' argument specifies the command line to be parsed,\ndefaulting to sys.argv[1:].\n\nThe return value is an exit code to be passed to sys.exit(); it\nmay be None to indicate success.\n\nWhen an exception happens during timing, a traceback is printed to\nstderr and the return value is 1.  Exceptions at other times\n(including the template compilation) are not caught.\n\n'_wrap_timer' is an internal interface used for unit testing.  If it\nis not None, it must be a callable that accepts a timer function\nand returns another timer function (used for unit testing).",
      "relationships": []
    },
    {
      "id": "stdlib.timeit.reindent",
      "name": "reindent",
      "module": "timeit",
      "type": "function",
      "signature": "(src, indent)",
      "description": "Helper to reindent a multi-line statement.",
      "relationships": []
    },
    {
      "id": "stdlib.timeit.repeat",
      "name": "repeat",
      "module": "timeit",
      "type": "function",
      "signature": "(stmt='pass', setup='pass', timer=<built-in function perf_counter>, repeat=5, number=1000000, globals=None)",
      "description": "Convenience function to create Timer object and call repeat method.",
      "relationships": []
    },
    {
      "id": "stdlib.timeit.timeit",
      "name": "timeit",
      "module": "timeit",
      "type": "function",
      "signature": "(stmt='pass', setup='pass', timer=<built-in function perf_counter>, number=1000000, globals=None)",
      "description": "Convenience function to create Timer object and call timeit method.",
      "relationships": []
    },
    {
      "id": "stdlib.token.ISEOF",
      "name": "ISEOF",
      "module": "token",
      "type": "function",
      "signature": "(x)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.token.ISNONTERMINAL",
      "name": "ISNONTERMINAL",
      "module": "token",
      "type": "function",
      "signature": "(x)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.token.ISTERMINAL",
      "name": "ISTERMINAL",
      "module": "token",
      "type": "function",
      "signature": "(x)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.tokenize.TokenInfo",
      "name": "TokenInfo",
      "module": "tokenize",
      "type": "class",
      "signature": "(type, string, start, end, line)",
      "description": "TokenInfo(type, string, start, end, line)",
      "relationships": [
        {
          "target": "stdlib.tokenize.TokenInfo",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.tuple",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.tokenize.Untokenizer",
      "name": "Untokenizer",
      "module": "tokenize",
      "type": "class",
      "signature": "()",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.tokenize.any",
      "name": "any",
      "module": "tokenize",
      "type": "function",
      "signature": "(*choices)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.tokenize.group",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.tokenize.detect_encoding",
      "name": "detect_encoding",
      "module": "tokenize",
      "type": "function",
      "signature": "(readline)",
      "description": "The detect_encoding() function is used to detect the encoding that should\nbe used to decode a Python source file.  It requires one argument, readline,\nin the same way as the tokenize() generator.\n\nIt will call readline a maximum of twice, and return the encoding used\n(as a string) and a list of any lines (left as bytes) it has read in.\n\nIt detects the encoding from the presence of a utf-8 bom or an encoding\ncookie as specified in pep-0263.  If both a bom and a cookie are present,\nbut disagree, a SyntaxError will be raised.  If the encoding cookie is an\ninvalid charset, raise a SyntaxError.  Note that if a utf-8 bom is found,\n'utf-8-sig' is returned.\n\nIf no encoding is specified, then the default of 'utf-8' will be returned.",
      "relationships": [
        {
          "target": "stdlib.tokenize._get_normal_name",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.tokenize.generate_tokens",
      "name": "generate_tokens",
      "module": "tokenize",
      "type": "function",
      "signature": "(readline)",
      "description": "Tokenize a source reading Python code as unicode strings.\n\nThis has the same API as tokenize(), except that it expects the *readline*\ncallable to return str objects instead of bytes.",
      "relationships": [
        {
          "target": "stdlib.tokenize._generate_tokens_from_c_tokenizer",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.tokenize.group",
      "name": "group",
      "module": "tokenize",
      "type": "function",
      "signature": "(*choices)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.tokenize.main",
      "name": "main",
      "module": "tokenize",
      "type": "function",
      "signature": "()",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.tokenize._generate_tokens_from_c_tokenizer",
          "type": "calls"
        },
        {
          "target": "stdlib.tokenize.tokenize",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.tokenize.maybe",
      "name": "maybe",
      "module": "tokenize",
      "type": "function",
      "signature": "(*choices)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.tokenize.group",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.tokenize.open",
      "name": "open",
      "module": "tokenize",
      "type": "function",
      "signature": "(filename)",
      "description": "Open a file in read only mode using the encoding detected by\ndetect_encoding().",
      "relationships": [
        {
          "target": "stdlib.tokenize.detect_encoding",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.tokenize.tokenize",
      "name": "tokenize",
      "module": "tokenize",
      "type": "function",
      "signature": "(readline)",
      "description": "The tokenize() generator requires one argument, readline, which\nmust be a callable object which provides the same interface as the\nreadline() method of built-in file objects.  Each call to the function\nshould return one line of input as bytes.  Alternatively, readline\ncan be a callable function terminating with StopIteration:\n    readline = open(myfile, 'rb').__next__  # Example of alternate readline\n\nThe generator produces 5-tuples with these members: the token type; the\ntoken string; a 2-tuple (srow, scol) of ints specifying the row and\ncolumn where the token begins in the source; a 2-tuple (erow, ecol) of\nints specifying the row and column where the token ends in the source;\nand the line on which the token was found.  The line passed is the\nphysical line.\n\nThe first token sequence will always be an ENCODING token\nwhich tells you which encoding was used to decode the bytes stream.",
      "relationships": [
        {
          "target": "stdlib.tokenize.detect_encoding",
          "type": "calls"
        },
        {
          "target": "stdlib.tokenize._generate_tokens_from_c_tokenizer",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.tokenize.untokenize",
      "name": "untokenize",
      "module": "tokenize",
      "type": "function",
      "signature": "(iterable)",
      "description": "Transform tokens back into Python source code.\nIt returns a bytes object, encoded using the ENCODING\ntoken, which is the first token sequence output by tokenize.\n\nEach element returned by the iterable must be a token sequence\nwith at least two elements, a token number and token value.  If\nonly two tokens are passed, the resulting output is poor.\n\nThe result is guaranteed to tokenize back to match the input so\nthat the conversion is lossless and round-trips are assured.\nThe guarantee applies only to the token type and token string as\nthe spacing between tokens (column positions) may change.",
      "relationships": []
    },
    {
      "id": "stdlib.trace.CoverageResults",
      "name": "CoverageResults",
      "module": "trace",
      "type": "class",
      "signature": "(counts=None, calledfuncs=None, infile=None, callers=None, outfile=None)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.trace.Trace",
      "name": "Trace",
      "module": "trace",
      "type": "class",
      "signature": "(count=1, trace=1, countfuncs=0, countcallers=0, ignoremods=(), ignoredirs=(), infile=None, outfile=None, timing=False)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.trace.main",
      "name": "main",
      "module": "trace",
      "type": "function",
      "signature": "()",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.traceback.FrameSummary",
      "name": "FrameSummary",
      "module": "traceback",
      "type": "class",
      "signature": "(filename, lineno, name, *, lookup_line=True, locals=None, line=None, end_lineno=None, colno=None, end_colno=None)",
      "description": "Information about a single frame from a traceback.\n\n- :attr:`filename` The filename for the frame.\n- :attr:`lineno` The line within filename for the frame that was\n  active when the frame was captured.\n- :attr:`name` The name of the function or method that was executing\n  when the frame was captured.\n- :attr:`line` The text from the linecache module for the\n  of code that was running when the frame was captured.\n- :attr:`locals` Either None if locals were not supplied, or a dict\n  mapping the name to the repr() of the variable.",
      "relationships": []
    },
    {
      "id": "stdlib.traceback.StackSummary",
      "name": "StackSummary",
      "module": "traceback",
      "type": "class",
      "signature": "(iterable=(), /)",
      "description": "A list of FrameSummary objects, representing a stack of frames.",
      "relationships": [
        {
          "target": "stdlib.builtins.list",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.traceback.TracebackException",
      "name": "TracebackException",
      "module": "traceback",
      "type": "class",
      "signature": "(exc_type, exc_value, exc_traceback, *, limit=None, lookup_lines=True, capture_locals=False, compact=False, max_group_width=15, max_group_depth=10, _seen=None)",
      "description": "An exception ready for rendering.\n\nThe traceback module captures enough attributes from the original exception\nto this intermediary form to ensure that no references are held, while\nstill being able to fully print or format it.\n\nmax_group_width and max_group_depth control the formatting of exception\ngroups. The depth refers to the nesting level of the group, and the width\nrefers to the size of a single exception group's exceptions array. The\nformatted output is truncated when either limit is exceeded.\n\nUse `from_exception` to create TracebackException instances from exception\nobjects, or the constructor to create TracebackException instances from\nindividual components.\n\n- :attr:`__cause__` A TracebackException of the original *__cause__*.\n- :attr:`__context__` A TracebackException of the original *__context__*.\n- :attr:`exceptions` For exception groups - a list of TracebackException\n  instances for the nested *exceptions*.  ``None`` for other exceptions.\n- :attr:`__suppress_context__` The *__suppress_context__* value from the\n  original exception.\n- :attr:`stack` A `StackSummary` representing the traceback.\n- :attr:`exc_type` The class of the original traceback.\n- :attr:`filename` For syntax errors - the filename where the error\n  occurred.\n- :attr:`lineno` For syntax errors - the linenumber where the error\n  occurred.\n- :attr:`end_lineno` For syntax errors - the end linenumber where the error\n  occurred. Can be `None` if not present.\n- :attr:`text` For syntax errors - the text where the error\n  occurred.\n- :attr:`offset` For syntax errors - the offset into the text where the\n  error occurred.\n- :attr:`end_offset` For syntax errors - the end offset into the text where\n  the error occurred. Can be `None` if not present.\n- :attr:`msg` For syntax errors - the compiler error message.",
      "relationships": []
    },
    {
      "id": "stdlib.traceback.clear_frames",
      "name": "clear_frames",
      "module": "traceback",
      "type": "function",
      "signature": "(tb)",
      "description": "Clear all references to local variables in the frames of a traceback.",
      "relationships": []
    },
    {
      "id": "stdlib.traceback.extract_stack",
      "name": "extract_stack",
      "module": "traceback",
      "type": "function",
      "signature": "(f=None, limit=None)",
      "description": "Extract the raw traceback from the current stack frame.\n\nThe return value has the same format as for extract_tb().  The\noptional 'f' and 'limit' arguments have the same meaning as for\nprint_stack().  Each item in the list is a quadruple (filename,\nline number, function name, text), and the entries are in order\nfrom oldest to newest stack frame.",
      "relationships": [
        {
          "target": "stdlib.traceback.walk_stack",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.traceback.extract_tb",
      "name": "extract_tb",
      "module": "traceback",
      "type": "function",
      "signature": "(tb, limit=None)",
      "description": "Return a StackSummary object representing a list of\npre-processed entries from traceback.\n\nThis is useful for alternate formatting of stack traces.  If\n'limit' is omitted or None, all entries are extracted.  A\npre-processed stack trace entry is a FrameSummary object\ncontaining attributes filename, lineno, name, and line\nrepresenting the information that is usually printed for a stack\ntrace.  The line is a string with leading and trailing\nwhitespace stripped; if the source is not available it is None.",
      "relationships": [
        {
          "target": "stdlib.traceback._walk_tb_with_full_positions",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.traceback.format_exc",
      "name": "format_exc",
      "module": "traceback",
      "type": "function",
      "signature": "(limit=None, chain=True)",
      "description": "Like print_exc() but return a string.",
      "relationships": [
        {
          "target": "stdlib.traceback.format_exception",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.traceback.format_exception",
      "name": "format_exception",
      "module": "traceback",
      "type": "function",
      "signature": "(exc, /, value=<implicit>, tb=<implicit>, limit=None, chain=True)",
      "description": "Format a stack trace and the exception information.\n\nThe arguments have the same meaning as the corresponding arguments\nto print_exception().  The return value is a list of strings, each\nending in a newline and some containing internal newlines.  When\nthese lines are concatenated and printed, exactly the same text is\nprinted as does print_exception().",
      "relationships": [
        {
          "target": "stdlib.traceback._parse_value_tb",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.traceback.format_exception_only",
      "name": "format_exception_only",
      "module": "traceback",
      "type": "function",
      "signature": "(exc, /, value=<implicit>)",
      "description": "Format the exception part of a traceback.\n\nThe return value is a list of strings, each ending in a newline.\n\nThe list contains the exception's message, which is\nnormally a single string; however, for :exc:`SyntaxError` exceptions, it\ncontains several lines that (when printed) display detailed information\nabout where the syntax error occurred. Following the message, the list\ncontains the exception's ``__notes__``.",
      "relationships": []
    },
    {
      "id": "stdlib.traceback.format_list",
      "name": "format_list",
      "module": "traceback",
      "type": "function",
      "signature": "(extracted_list)",
      "description": "Format a list of tuples or FrameSummary objects for printing.\n\nGiven a list of tuples or FrameSummary objects as returned by\nextract_tb() or extract_stack(), return a list of strings ready\nfor printing.\n\nEach string in the resulting list corresponds to the item with the\nsame index in the argument list.  Each string ends in a newline;\nthe strings may contain internal newlines as well, for those items\nwhose source text line is not None.",
      "relationships": []
    },
    {
      "id": "stdlib.traceback.format_stack",
      "name": "format_stack",
      "module": "traceback",
      "type": "function",
      "signature": "(f=None, limit=None)",
      "description": "Shorthand for 'format_list(extract_stack(f, limit))'.",
      "relationships": [
        {
          "target": "stdlib.traceback.format_list",
          "type": "calls"
        },
        {
          "target": "stdlib.traceback.extract_stack",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.traceback.format_tb",
      "name": "format_tb",
      "module": "traceback",
      "type": "function",
      "signature": "(tb, limit=None)",
      "description": "A shorthand for 'format_list(extract_tb(tb, limit))'.",
      "relationships": [
        {
          "target": "stdlib.traceback.extract_tb",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.traceback.print_exc",
      "name": "print_exc",
      "module": "traceback",
      "type": "function",
      "signature": "(limit=None, file=None, chain=True)",
      "description": "Shorthand for 'print_exception(sys.exception(), limit=limit, file=file, chain=chain)'.",
      "relationships": [
        {
          "target": "stdlib.traceback.print_exception",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.traceback.print_exception",
      "name": "print_exception",
      "module": "traceback",
      "type": "function",
      "signature": "(exc, /, value=<implicit>, tb=<implicit>, limit=None, file=None, chain=True)",
      "description": "Print exception up to 'limit' stack trace entries from 'tb' to 'file'.\n\nThis differs from print_tb() in the following ways: (1) if\ntraceback is not None, it prints a header \"Traceback (most recent\ncall last):\"; (2) it prints the exception type and value after the\nstack trace; (3) if type is SyntaxError and value has the\nappropriate format, it prints the line where the syntax error\noccurred with a caret on the next line indicating the approximate\nposition of the error.",
      "relationships": [
        {
          "target": "stdlib.traceback._parse_value_tb",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.traceback.print_last",
      "name": "print_last",
      "module": "traceback",
      "type": "function",
      "signature": "(limit=None, file=None, chain=True)",
      "description": "This is a shorthand for 'print_exception(sys.last_exc, limit=limit, file=file, chain=chain)'.",
      "relationships": [
        {
          "target": "stdlib.traceback.print_exception",
          "type": "calls"
        },
        {
          "target": "stdlib.traceback.print_exception",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.traceback.print_list",
      "name": "print_list",
      "module": "traceback",
      "type": "function",
      "signature": "(extracted_list, file=None)",
      "description": "Print the list of tuples as returned by extract_tb() or\nextract_stack() as a formatted stack trace to the given file.",
      "relationships": []
    },
    {
      "id": "stdlib.traceback.print_stack",
      "name": "print_stack",
      "module": "traceback",
      "type": "function",
      "signature": "(f=None, limit=None, file=None)",
      "description": "Print a stack trace from its invocation point.\n\nThe optional 'f' argument can be used to specify an alternate\nstack frame at which to start. The optional 'limit' and 'file'\narguments have the same meaning as for print_exception().",
      "relationships": [
        {
          "target": "stdlib.traceback.print_list",
          "type": "calls"
        },
        {
          "target": "stdlib.traceback.extract_stack",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.traceback.print_tb",
      "name": "print_tb",
      "module": "traceback",
      "type": "function",
      "signature": "(tb, limit=None, file=None)",
      "description": "Print up to 'limit' stack trace entries from the traceback 'tb'.\n\nIf 'limit' is omitted or None, all entries are printed.  If 'file'\nis omitted or None, the output goes to sys.stderr; otherwise\n'file' should be an open file or file-like object with a write()\nmethod.",
      "relationships": [
        {
          "target": "stdlib.traceback.print_list",
          "type": "calls"
        },
        {
          "target": "stdlib.traceback.extract_tb",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.traceback.walk_stack",
      "name": "walk_stack",
      "module": "traceback",
      "type": "function",
      "signature": "(f)",
      "description": "Walk a stack yielding the frame and line number for each frame.\n\nThis will follow f.f_back from the given frame. If no frame is given, the\ncurrent stack is used. Usually used with StackSummary.extract.",
      "relationships": []
    },
    {
      "id": "stdlib.traceback.walk_tb",
      "name": "walk_tb",
      "module": "traceback",
      "type": "function",
      "signature": "(tb)",
      "description": "Walk a traceback yielding the frame and line number for each frame.\n\nThis will follow tb.tb_next (and thus is in the opposite order to\nwalk_stack). Usually used with StackSummary.extract.",
      "relationships": []
    },
    {
      "id": "stdlib.tracemalloc.BaseFilter",
      "name": "BaseFilter",
      "module": "tracemalloc",
      "type": "class",
      "signature": "(inclusive)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.tracemalloc.DomainFilter",
      "name": "DomainFilter",
      "module": "tracemalloc",
      "type": "class",
      "signature": "(inclusive, domain)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.tracemalloc.BaseFilter",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.tracemalloc.Filter",
      "name": "Filter",
      "module": "tracemalloc",
      "type": "class",
      "signature": "(inclusive, filename_pattern, lineno=None, all_frames=False, domain=None)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.tracemalloc.BaseFilter",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.tracemalloc.Frame",
      "name": "Frame",
      "module": "tracemalloc",
      "type": "class",
      "signature": "(frame)",
      "description": "Frame of a traceback.",
      "relationships": []
    },
    {
      "id": "stdlib.tracemalloc.Snapshot",
      "name": "Snapshot",
      "module": "tracemalloc",
      "type": "class",
      "signature": "(traces, traceback_limit)",
      "description": "Snapshot of traces of memory blocks allocated by Python.",
      "relationships": []
    },
    {
      "id": "stdlib.tracemalloc.Statistic",
      "name": "Statistic",
      "module": "tracemalloc",
      "type": "class",
      "signature": "(traceback, size, count)",
      "description": "Statistic difference on memory allocations between two Snapshot instance.",
      "relationships": []
    },
    {
      "id": "stdlib.tracemalloc.StatisticDiff",
      "name": "StatisticDiff",
      "module": "tracemalloc",
      "type": "class",
      "signature": "(traceback, size, size_diff, count, count_diff)",
      "description": "Statistic difference on memory allocations between an old and a new\nSnapshot instance.",
      "relationships": []
    },
    {
      "id": "stdlib.tracemalloc.Trace",
      "name": "Trace",
      "module": "tracemalloc",
      "type": "class",
      "signature": "(trace)",
      "description": "Trace of a memory block.",
      "relationships": []
    },
    {
      "id": "stdlib.tracemalloc.Traceback",
      "name": "Traceback",
      "module": "tracemalloc",
      "type": "class",
      "signature": "(frames, total_nframe=None)",
      "description": "Sequence of Frame instances sorted from the oldest frame\nto the most recent frame.",
      "relationships": [
        {
          "target": "stdlib.collections.abc.Sequence",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Reversible",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Collection",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Sized",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Iterable",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Container",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.tracemalloc.get_object_traceback",
      "name": "get_object_traceback",
      "module": "tracemalloc",
      "type": "function",
      "signature": "(obj)",
      "description": "Get the traceback where the Python object *obj* was allocated.\nReturn a Traceback instance.\n\nReturn None if the tracemalloc module is not tracing memory allocations or\ndid not trace the allocation of the object.",
      "relationships": []
    },
    {
      "id": "stdlib.tracemalloc.take_snapshot",
      "name": "take_snapshot",
      "module": "tracemalloc",
      "type": "function",
      "signature": "()",
      "description": "Take a snapshot of traces of memory blocks allocated by Python.",
      "relationships": []
    },
    {
      "id": "stdlib.tty.cfmakecbreak",
      "name": "cfmakecbreak",
      "module": "tty",
      "type": "function",
      "signature": "(mode)",
      "description": "Make termios mode cbreak.",
      "relationships": []
    },
    {
      "id": "stdlib.tty.cfmakeraw",
      "name": "cfmakeraw",
      "module": "tty",
      "type": "function",
      "signature": "(mode)",
      "description": "Make termios mode raw.",
      "relationships": []
    },
    {
      "id": "stdlib.tty.setcbreak",
      "name": "setcbreak",
      "module": "tty",
      "type": "function",
      "signature": "(fd, when=2)",
      "description": "Put terminal into cbreak mode.",
      "relationships": [
        {
          "target": "stdlib.tty.cfmakecbreak",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.tty.setraw",
      "name": "setraw",
      "module": "tty",
      "type": "function",
      "signature": "(fd, when=2)",
      "description": "Put terminal into raw mode.",
      "relationships": [
        {
          "target": "stdlib.tty.cfmakeraw",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.types.DynamicClassAttribute",
      "name": "DynamicClassAttribute",
      "module": "types",
      "type": "class",
      "signature": "(fget=None, fset=None, fdel=None, doc=None)",
      "description": "Route attribute access on a class to __getattr__.\n\nThis is a descriptor, used to define attributes that act differently when\naccessed through an instance and through a class.  Instance access remains\nnormal, but access to an attribute through a class will be routed to the\nclass's __getattr__ method; this is done by raising AttributeError.\n\nThis allows one to have properties active on an instance, and have virtual\nattributes on the class with the same name.  (Enum used this between Python\nversions 3.4 - 3.9 .)\n\nSubclass from this to use a different method of accessing virtual attributes\nand still be treated properly by the inspect module. (Enum uses this since\nPython 3.10 .)",
      "relationships": []
    },
    {
      "id": "stdlib.types.UnionType",
      "name": "UnionType",
      "module": "types",
      "type": "class",
      "signature": "()",
      "description": "Represent a PEP 604 union type\n\nE.g. for int | str",
      "relationships": []
    },
    {
      "id": "stdlib.types.coroutine",
      "name": "coroutine",
      "module": "types",
      "type": "function",
      "signature": "(func)",
      "description": "Convert regular generator function to a coroutine.",
      "relationships": []
    },
    {
      "id": "stdlib.types.get_original_bases",
      "name": "get_original_bases",
      "module": "types",
      "type": "function",
      "signature": "(cls, /)",
      "description": "Return the class's \"original\" bases prior to modification by `__mro_entries__`.\n\nExamples::\n\n    from typing import TypeVar, Generic, NamedTuple, TypedDict\n\n    T = TypeVar(\"T\")\n    class Foo(Generic[T]): ...\n    class Bar(Foo[int], float): ...\n    class Baz(list[str]): ...\n    Eggs = NamedTuple(\"Eggs\", [(\"a\", int), (\"b\", str)])\n    Spam = TypedDict(\"Spam\", {\"a\": int, \"b\": str})\n\n    assert get_original_bases(Bar) == (Foo[int], float)\n    assert get_original_bases(Baz) == (list[str],)\n    assert get_original_bases(Eggs) == (NamedTuple,)\n    assert get_original_bases(Spam) == (TypedDict,)\n    assert get_original_bases(int) == (object,)",
      "relationships": []
    },
    {
      "id": "stdlib.types.new_class",
      "name": "new_class",
      "module": "types",
      "type": "function",
      "signature": "(name, bases=(), kwds=None, exec_body=None)",
      "description": "Create a class object dynamically using the appropriate metaclass.",
      "relationships": [
        {
          "target": "stdlib.types.resolve_bases",
          "type": "calls"
        },
        {
          "target": "stdlib.types.prepare_class",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.types.prepare_class",
      "name": "prepare_class",
      "module": "types",
      "type": "function",
      "signature": "(name, bases=(), kwds=None)",
      "description": "Call the __prepare__ method of the appropriate metaclass.\n\nReturns (metaclass, namespace, kwds) as a 3-tuple\n\n*metaclass* is the appropriate metaclass\n*namespace* is the prepared class namespace\n*kwds* is an updated copy of the passed in kwds argument with any\n'metaclass' entry removed. If no kwds argument is passed in, this will\nbe an empty dict.",
      "relationships": [
        {
          "target": "stdlib.types._calculate_meta",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.types.resolve_bases",
      "name": "resolve_bases",
      "module": "types",
      "type": "function",
      "signature": "(bases)",
      "description": "Resolve MRO entries dynamically as specified by PEP 560.",
      "relationships": []
    },
    {
      "id": "stdlib.typing.Annotated",
      "name": "Annotated",
      "module": "typing",
      "type": "class",
      "signature": "(*args, **kwargs)",
      "description": "Add context-specific metadata to a type.\n\nExample: Annotated[int, runtime_check.Unsigned] indicates to the\nhypothetical runtime_check module that this type is an unsigned int.\nEvery other consumer of this type can ignore this metadata and treat\nthis type as int.\n\nThe first argument to Annotated must be a valid type.\n\nDetails:\n\n- It's an error to call `Annotated` with less than two arguments.\n- Access the metadata via the ``__metadata__`` attribute::\n\n    assert Annotated[int, '$'].__metadata__ == ('$',)\n\n- Nested Annotated types are flattened::\n\n    assert Annotated[Annotated[T, Ann1, Ann2], Ann3] == Annotated[T, Ann1, Ann2, Ann3]\n\n- Instantiating an annotated type is equivalent to instantiating the\nunderlying type::\n\n    assert Annotated[C, Ann1](5) == C(5)\n\n- Annotated can be used as a generic type alias::\n\n    type Optimized[T] = Annotated[T, runtime.Optimize()]\n    # type checker will treat Optimized[int]\n    # as equivalent to Annotated[int, runtime.Optimize()]\n\n    type OptimizedList[T] = Annotated[list[T], runtime.Optimize()]\n    # type checker will treat OptimizedList[int]\n    # as equivalent to Annotated[list[int], runtime.Optimize()]\n\n- Annotated cannot be used with an unpacked TypeVarTuple::\n\n    type Variadic[*Ts] = Annotated[*Ts, Ann1]  # NOT valid\n\n  This would be equivalent to::\n\n    Annotated[T1, T2, T3, ..., Ann1]\n\n  where T1, T2 etc. are TypeVars, which would be invalid, because\n  only one type should be passed to Annotated.",
      "relationships": []
    },
    {
      "id": "stdlib.typing.Any",
      "name": "Any",
      "module": "typing",
      "type": "class",
      "signature": "(*args, **kwargs)",
      "description": "Special type indicating an unconstrained type.\n\n- Any is compatible with every type.\n- Any assumed to have all methods.\n- All values assumed to be instances of Any.\n\nNote that all the above statements are true from the point of view of\nstatic type checkers. At runtime, Any should not be used with instance\nchecks.",
      "relationships": []
    },
    {
      "id": "stdlib.typing.BinaryIO",
      "name": "BinaryIO",
      "module": "typing",
      "type": "class",
      "signature": "()",
      "description": "Typed version of the return of open() in binary mode.",
      "relationships": [
        {
          "target": "stdlib.typing.IO",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Generic",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.typing.ForwardRef",
      "name": "ForwardRef",
      "module": "typing",
      "type": "class",
      "signature": "(arg, is_argument=True, module=None, *, is_class=False)",
      "description": "Internal wrapper to hold a forward reference.",
      "relationships": [
        {
          "target": "stdlib.typing._Final",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.typing.Generic",
      "name": "Generic",
      "module": "typing",
      "type": "class",
      "signature": "()",
      "description": "Abstract base class for generic types.\n\nOn Python 3.12 and newer, generic classes implicitly inherit from\nGeneric when they declare a parameter list after the class's name::\n\n    class Mapping[KT, VT]:\n        def __getitem__(self, key: KT) -> VT:\n            ...\n        # Etc.\n\nOn older versions of Python, however, generic classes have to\nexplicitly inherit from Generic.\n\nAfter a class has been declared to be generic, it can then be used as\nfollows::\n\n    def lookup_name[KT, VT](mapping: Mapping[KT, VT], key: KT, default: VT) -> VT:\n        try:\n            return mapping[key]\n        except KeyError:\n            return default",
      "relationships": []
    },
    {
      "id": "stdlib.typing.IO",
      "name": "IO",
      "module": "typing",
      "type": "class",
      "signature": "()",
      "description": "Generic base class for TextIO and BinaryIO.\n\nThis is an abstract, generic version of the return of open().\n\nNOTE: This does not distinguish between the different possible\nclasses (text vs. binary, read vs. write vs. read/write,\nappend-only, unbuffered).  The TextIO and BinaryIO subclasses\nbelow capture the distinctions between text vs. binary, which is\npervasive in the interface; however we currently do not offer a\nway to track the other distinctions in the type system.",
      "relationships": [
        {
          "target": "stdlib.typing.Generic",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.typing.NamedTuple",
      "name": "NamedTuple",
      "module": "typing",
      "type": "function",
      "signature": "(typename, fields=None, /, **kwargs)",
      "description": "Typed version of namedtuple.\n\nUsage::\n\n    class Employee(NamedTuple):\n        name: str\n        id: int\n\nThis is equivalent to::\n\n    Employee = collections.namedtuple('Employee', ['name', 'id'])\n\nThe resulting class has an extra __annotations__ attribute, giving a\ndict that maps field names to types.  (The field names are also in\nthe _fields attribute, which is part of the namedtuple API.)\nAn alternative equivalent functional syntax is also accepted::\n\n    Employee = NamedTuple('Employee', [('name', str), ('id', int)])",
      "relationships": [
        {
          "target": "stdlib.typing._make_nmtuple",
          "type": "calls"
        },
        {
          "target": "stdlib.typing._caller",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.typing.NamedTupleMeta",
      "name": "NamedTupleMeta",
      "module": "typing",
      "type": "class",
      "signature": "(typename, bases, ns)",
      "description": "type(object) -> the object's type\ntype(name, bases, dict, **kwds) -> a new type",
      "relationships": [
        {
          "target": "stdlib.builtins.type",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.typing.NewType",
      "name": "NewType",
      "module": "typing",
      "type": "class",
      "signature": "(name, tp)",
      "description": "NewType creates simple unique types with almost zero runtime overhead.\n\nNewType(name, tp) is considered a subtype of tp\nby static type checkers. At runtime, NewType(name, tp) returns\na dummy callable that simply returns its argument.\n\nUsage::\n\n    UserId = NewType('UserId', int)\n\n    def name_by_id(user_id: UserId) -> str:\n        ...\n\n    UserId('user')          # Fails type check\n\n    name_by_id(42)          # Fails type check\n    name_by_id(UserId(42))  # OK\n\n    num = UserId(5) + 1     # type: int",
      "relationships": []
    },
    {
      "id": "stdlib.typing.Protocol",
      "name": "Protocol",
      "module": "typing",
      "type": "class",
      "signature": "()",
      "description": "Base class for protocol classes.\n\nProtocol classes are defined as::\n\n    class Proto(Protocol):\n        def meth(self) -> int:\n            ...\n\nSuch classes are primarily used with static type checkers that recognize\nstructural subtyping (static duck-typing).\n\nFor example::\n\n    class C:\n        def meth(self) -> int:\n            return 0\n\n    def func(x: Proto) -> int:\n        return x.meth()\n\n    func(C())  # Passes static type check\n\nSee PEP 544 for details. Protocol classes decorated with\n@typing.runtime_checkable act as simple-minded runtime protocols that check\nonly the presence of given attributes, ignoring their type signatures.\nProtocol classes can be generic, they are defined as::\n\n    class GenProto[T](Protocol):\n        def meth(self) -> T:\n            ...",
      "relationships": [
        {
          "target": "stdlib.typing.Generic",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.typing.SupportsAbs",
      "name": "SupportsAbs",
      "module": "typing",
      "type": "class",
      "signature": "(*args, **kwargs)",
      "description": "An ABC with one abstract method __abs__ that is covariant in its return type.",
      "relationships": [
        {
          "target": "stdlib.typing.Protocol",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Generic",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.typing.SupportsBytes",
      "name": "SupportsBytes",
      "module": "typing",
      "type": "class",
      "signature": "(*args, **kwargs)",
      "description": "An ABC with one abstract method __bytes__.",
      "relationships": [
        {
          "target": "stdlib.typing.Protocol",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Generic",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.typing.SupportsComplex",
      "name": "SupportsComplex",
      "module": "typing",
      "type": "class",
      "signature": "(*args, **kwargs)",
      "description": "An ABC with one abstract method __complex__.",
      "relationships": [
        {
          "target": "stdlib.typing.Protocol",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Generic",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.typing.SupportsFloat",
      "name": "SupportsFloat",
      "module": "typing",
      "type": "class",
      "signature": "(*args, **kwargs)",
      "description": "An ABC with one abstract method __float__.",
      "relationships": [
        {
          "target": "stdlib.typing.Protocol",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Generic",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.typing.SupportsIndex",
      "name": "SupportsIndex",
      "module": "typing",
      "type": "class",
      "signature": "(*args, **kwargs)",
      "description": "An ABC with one abstract method __index__.",
      "relationships": [
        {
          "target": "stdlib.typing.Protocol",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Generic",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.typing.SupportsInt",
      "name": "SupportsInt",
      "module": "typing",
      "type": "class",
      "signature": "(*args, **kwargs)",
      "description": "An ABC with one abstract method __int__.",
      "relationships": [
        {
          "target": "stdlib.typing.Protocol",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Generic",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.typing.SupportsRound",
      "name": "SupportsRound",
      "module": "typing",
      "type": "class",
      "signature": "(*args, **kwargs)",
      "description": "An ABC with one abstract method __round__ that is covariant in its return type.",
      "relationships": [
        {
          "target": "stdlib.typing.Protocol",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Generic",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.typing.TextIO",
      "name": "TextIO",
      "module": "typing",
      "type": "class",
      "signature": "()",
      "description": "Typed version of the return of open() in text mode.",
      "relationships": [
        {
          "target": "stdlib.typing.IO",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Generic",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.typing.TypedDict",
      "name": "TypedDict",
      "module": "typing",
      "type": "function",
      "signature": "(typename, fields=None, /, *, total=True, **kwargs)",
      "description": "A simple typed namespace. At runtime it is equivalent to a plain dict.\n\nTypedDict creates a dictionary type such that a type checker will expect all\ninstances to have a certain set of keys, where each key is\nassociated with a value of a consistent type. This expectation\nis not checked at runtime.\n\nUsage::\n\n    >>> class Point2D(TypedDict):\n    ...     x: int\n    ...     y: int\n    ...     label: str\n    ...\n    >>> a: Point2D = {'x': 1, 'y': 2, 'label': 'good'}  # OK\n    >>> b: Point2D = {'z': 3, 'label': 'bad'}           # Fails type check\n    >>> Point2D(x=1, y=2, label='first') == dict(x=1, y=2, label='first')\n    True\n\nThe type info can be accessed via the Point2D.__annotations__ dict, and\nthe Point2D.__required_keys__ and Point2D.__optional_keys__ frozensets.\nTypedDict supports an additional equivalent form::\n\n    Point2D = TypedDict('Point2D', {'x': int, 'y': int, 'label': str})\n\nBy default, all keys must be present in a TypedDict. It is possible\nto override this by specifying totality::\n\n    class Point2D(TypedDict, total=False):\n        x: int\n        y: int\n\nThis means that a Point2D TypedDict can have any of the keys omitted. A type\nchecker is only expected to support a literal False or True as the value of\nthe total argument. True is the default, and makes all items defined in the\nclass body be required.\n\nThe Required and NotRequired special forms can also be used to mark\nindividual keys as being required or not required::\n\n    class Point2D(TypedDict):\n        x: int               # the \"x\" key must always be present (Required is the default)\n        y: NotRequired[int]  # the \"y\" key can be omitted\n\nSee PEP 655 for more details on Required and NotRequired.",
      "relationships": [
        {
          "target": "stdlib.typing._caller",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.typing.assert_never",
      "name": "assert_never",
      "module": "typing",
      "type": "function",
      "signature": "(arg: Never, /) -> Never",
      "description": "Statically assert that a line of code is unreachable.\n\nExample::\n\n    def int_or_str(arg: int | str) -> None:\n        match arg:\n            case int():\n                print(\"It's an int\")\n            case str():\n                print(\"It's a str\")\n            case _:\n                assert_never(arg)\n\nIf a type checker finds that a call to assert_never() is\nreachable, it will emit an error.\n\nAt runtime, this throws an exception when called.",
      "relationships": []
    },
    {
      "id": "stdlib.typing.assert_type",
      "name": "assert_type",
      "module": "typing",
      "type": "function",
      "signature": "(val, typ, /)",
      "description": "Ask a static type checker to confirm that the value is of the given type.\n\nAt runtime this does nothing: it returns the first argument unchanged with no\nchecks or side effects, no matter the actual type of the argument.\n\nWhen a static type checker encounters a call to assert_type(), it\nemits an error if the value is not of the specified type::\n\n    def greet(name: str) -> None:\n        assert_type(name, str)  # OK\n        assert_type(name, int)  # type checker error",
      "relationships": []
    },
    {
      "id": "stdlib.typing.cast",
      "name": "cast",
      "module": "typing",
      "type": "function",
      "signature": "(typ, val)",
      "description": "Cast a value to a type.\n\nThis returns the value unchanged.  To the type checker this\nsignals that the return value has the designated type, but at\nruntime we intentionally don't check anything (we want this\nto be as fast as possible).",
      "relationships": []
    },
    {
      "id": "stdlib.typing.clear_overloads",
      "name": "clear_overloads",
      "module": "typing",
      "type": "function",
      "signature": "()",
      "description": "Clear all overloads in the registry.",
      "relationships": []
    },
    {
      "id": "stdlib.typing.dataclass_transform",
      "name": "dataclass_transform",
      "module": "typing",
      "type": "function",
      "signature": "(*, eq_default: bool = True, order_default: bool = False, kw_only_default: bool = False, frozen_default: bool = False, field_specifiers: tuple[typing.Union[type[typing.Any], typing.Callable[..., typing.Any]], ...] = (), **kwargs: Any) -> <class '_IdentityCallable'>",
      "description": "Decorator to mark an object as providing dataclass-like behaviour.\n\nThe decorator can be applied to a function, class, or metaclass.\n\nExample usage with a decorator function::\n\n    @dataclass_transform()\n    def create_model[T](cls: type[T]) -> type[T]:\n        ...\n        return cls\n\n    @create_model\n    class CustomerModel:\n        id: int\n        name: str\n\nOn a base class::\n\n    @dataclass_transform()\n    class ModelBase: ...\n\n    class CustomerModel(ModelBase):\n        id: int\n        name: str\n\nOn a metaclass::\n\n    @dataclass_transform()\n    class ModelMeta(type): ...\n\n    class ModelBase(metaclass=ModelMeta): ...\n\n    class CustomerModel(ModelBase):\n        id: int\n        name: str\n\nThe ``CustomerModel`` classes defined above will\nbe treated by type checkers similarly to classes created with\n``@dataclasses.dataclass``.\nFor example, type checkers will assume these classes have\n``__init__`` methods that accept ``id`` and ``name``.\n\nThe arguments to this decorator can be used to customize this behavior:\n- ``eq_default`` indicates whether the ``eq`` parameter is assumed to be\n    ``True`` or ``False`` if it is omitted by the caller.\n- ``order_default`` indicates whether the ``order`` parameter is\n    assumed to be True or False if it is omitted by the caller.\n- ``kw_only_default`` indicates whether the ``kw_only`` parameter is\n    assumed to be True or False if it is omitted by the caller.\n- ``frozen_default`` indicates whether the ``frozen`` parameter is\n    assumed to be True or False if it is omitted by the caller.\n- ``field_specifiers`` specifies a static list of supported classes\n    or functions that describe fields, similar to ``dataclasses.field()``.\n- Arbitrary other keyword arguments are accepted in order to allow for\n    possible future extensions.\n\nAt runtime, this decorator records its arguments in the\n``__dataclass_transform__`` attribute on the decorated object.\nIt has no other runtime effect.\n\nSee PEP 681 for more details.",
      "relationships": []
    },
    {
      "id": "stdlib.typing.final",
      "name": "final",
      "module": "typing",
      "type": "function",
      "signature": "(f)",
      "description": "Decorator to indicate final methods and final classes.\n\nUse this decorator to indicate to type checkers that the decorated\nmethod cannot be overridden, and decorated class cannot be subclassed.\n\nFor example::\n\n    class Base:\n        @final\n        def done(self) -> None:\n            ...\n    class Sub(Base):\n        def done(self) -> None:  # Error reported by type checker\n            ...\n\n    @final\n    class Leaf:\n        ...\n    class Other(Leaf):  # Error reported by type checker\n        ...\n\nThere is no runtime checking of these properties. The decorator\nattempts to set the ``__final__`` attribute to ``True`` on the decorated\nobject to allow runtime introspection.",
      "relationships": []
    },
    {
      "id": "stdlib.typing.get_args",
      "name": "get_args",
      "module": "typing",
      "type": "function",
      "signature": "(tp)",
      "description": "Get type arguments with all substitutions performed.\n\nFor unions, basic simplifications used by Union constructor are performed.\n\nExamples::\n\n    >>> T = TypeVar('T')\n    >>> assert get_args(Dict[str, int]) == (str, int)\n    >>> assert get_args(int) == ()\n    >>> assert get_args(Union[int, Union[T, int], str][int]) == (int, str)\n    >>> assert get_args(Union[int, Tuple[T, int]][str]) == (int, Tuple[str, int])\n    >>> assert get_args(Callable[[], T][int]) == ([], int)",
      "relationships": [
        {
          "target": "stdlib.typing._should_unflatten_callable_args",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.typing.get_origin",
      "name": "get_origin",
      "module": "typing",
      "type": "function",
      "signature": "(tp)",
      "description": "Get the unsubscripted version of a type.\n\nThis supports generic types, Callable, Tuple, Union, Literal, Final, ClassVar,\nAnnotated, and others. Return None for unsupported types.\n\nExamples::\n\n    >>> P = ParamSpec('P')\n    >>> assert get_origin(Literal[42]) is Literal\n    >>> assert get_origin(int) is None\n    >>> assert get_origin(ClassVar[int]) is ClassVar\n    >>> assert get_origin(Generic) is Generic\n    >>> assert get_origin(Generic[T]) is Generic\n    >>> assert get_origin(Union[T, int]) is Union\n    >>> assert get_origin(List[Tuple[T, T]][int]) is list\n    >>> assert get_origin(P.args) is P",
      "relationships": []
    },
    {
      "id": "stdlib.typing.get_overloads",
      "name": "get_overloads",
      "module": "typing",
      "type": "function",
      "signature": "(func)",
      "description": "Return all defined overloads for *func* as a sequence.",
      "relationships": []
    },
    {
      "id": "stdlib.typing.get_type_hints",
      "name": "get_type_hints",
      "module": "typing",
      "type": "function",
      "signature": "(obj, globalns=None, localns=None, include_extras=False)",
      "description": "Return type hints for an object.\n\nThis is often the same as obj.__annotations__, but it handles\nforward references encoded as string literals and recursively replaces all\n'Annotated[T, ...]' with 'T' (unless 'include_extras=True').\n\nThe argument may be a module, class, method, or function. The annotations\nare returned as a dictionary. For classes, annotations include also\ninherited members.\n\nTypeError is raised if the argument is not of a type that can contain\nannotations, and an empty dictionary is returned if no annotations are\npresent.\n\nBEWARE -- the behavior of globalns and localns is counterintuitive\n(unless you are familiar with how eval() and exec() work).  The\nsearch order is locals first, then globals.\n\n- If no dict arguments are passed, an attempt is made to use the\n  globals from obj (or the respective module's globals for classes),\n  and these are also used as the locals.  If the object does not appear\n  to have globals, an empty dictionary is used.  For classes, the search\n  order is globals first then locals.\n\n- If one dict argument is passed, it is used for both globals and\n  locals.\n\n- If two dict arguments are passed, they specify globals and\n  locals, respectively.",
      "relationships": [
        {
          "target": "stdlib.typing._eval_type",
          "type": "calls"
        },
        {
          "target": "stdlib.typing._strip_annotations",
          "type": "calls"
        },
        {
          "target": "stdlib.typing._eval_type",
          "type": "calls"
        },
        {
          "target": "stdlib.typing._strip_annotations",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.typing.io",
      "name": "io",
      "module": "typing",
      "type": "class",
      "signature": "()",
      "description": "Wrapper namespace for IO generic classes.",
      "relationships": []
    },
    {
      "id": "stdlib.typing.is_typeddict",
      "name": "is_typeddict",
      "module": "typing",
      "type": "function",
      "signature": "(tp)",
      "description": "Check if an annotation is a TypedDict class.\n\nFor example::\n\n    >>> from typing import TypedDict\n    >>> class Film(TypedDict):\n    ...     title: str\n    ...     year: int\n    ...\n    >>> is_typeddict(Film)\n    True\n    >>> is_typeddict(dict)\n    False",
      "relationships": []
    },
    {
      "id": "stdlib.typing.no_type_check",
      "name": "no_type_check",
      "module": "typing",
      "type": "function",
      "signature": "(arg)",
      "description": "Decorator to indicate that annotations are not type hints.\n\nThe argument must be a class or function; if it is a class, it\napplies recursively to all methods and classes defined in that class\n(but not to methods defined in its superclasses or subclasses).\n\nThis mutates the function(s) or class(es) in place.",
      "relationships": [
        {
          "target": "stdlib.typing.no_type_check",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.typing.no_type_check_decorator",
      "name": "no_type_check_decorator",
      "module": "typing",
      "type": "function",
      "signature": "(decorator)",
      "description": "Decorator to give another decorator the @no_type_check effect.\n\nThis wraps the decorator with something that wraps the decorated\nfunction in @no_type_check.",
      "relationships": [
        {
          "target": "stdlib.typing.no_type_check",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.typing.overload",
      "name": "overload",
      "module": "typing",
      "type": "function",
      "signature": "(func)",
      "description": "Decorator for overloaded functions/methods.\n\nIn a stub file, place two or more stub definitions for the same\nfunction in a row, each decorated with @overload.\n\nFor example::\n\n    @overload\n    def utf8(value: None) -> None: ...\n    @overload\n    def utf8(value: bytes) -> bytes: ...\n    @overload\n    def utf8(value: str) -> bytes: ...\n\nIn a non-stub file (i.e. a regular .py file), do the same but\nfollow it with an implementation.  The implementation should *not*\nbe decorated with @overload::\n\n    @overload\n    def utf8(value: None) -> None: ...\n    @overload\n    def utf8(value: bytes) -> bytes: ...\n    @overload\n    def utf8(value: str) -> bytes: ...\n    def utf8(value):\n        ...  # implementation goes here\n\nThe overloads for a function can be retrieved at runtime using the\nget_overloads() function.",
      "relationships": []
    },
    {
      "id": "stdlib.typing.override",
      "name": "override",
      "module": "typing",
      "type": "function",
      "signature": "(method: F, /) -> F",
      "description": "Indicate that a method is intended to override a method in a base class.\n\nUsage::\n\n    class Base:\n        def method(self) -> None:\n            pass\n\n    class Child(Base):\n        @override\n        def method(self) -> None:\n            super().method()\n\nWhen this decorator is applied to a method, the type checker will\nvalidate that it overrides a method or attribute with the same name on a\nbase class.  This helps prevent bugs that may occur when a base class is\nchanged without an equivalent change to a child class.\n\nThere is no runtime checking of this property. The decorator attempts to\nset the ``__override__`` attribute to ``True`` on the decorated object to\nallow runtime introspection.\n\nSee PEP 698 for details.",
      "relationships": []
    },
    {
      "id": "stdlib.typing.re",
      "name": "re",
      "module": "typing",
      "type": "class",
      "signature": "()",
      "description": "Wrapper namespace for re type aliases.",
      "relationships": []
    },
    {
      "id": "stdlib.typing.reveal_type",
      "name": "reveal_type",
      "module": "typing",
      "type": "function",
      "signature": "(obj: T, /) -> T",
      "description": "Ask a static type checker to reveal the inferred type of an expression.\n\nWhen a static type checker encounters a call to ``reveal_type()``,\nit will emit the inferred type of the argument::\n\n    x: int = 1\n    reveal_type(x)\n\nRunning a static type checker (e.g., mypy) on this example\nwill produce output similar to 'Revealed type is \"builtins.int\"'.\n\nAt runtime, the function prints the runtime type of the\nargument and returns the argument unchanged.",
      "relationships": []
    },
    {
      "id": "stdlib.typing.runtime_checkable",
      "name": "runtime_checkable",
      "module": "typing",
      "type": "function",
      "signature": "(cls)",
      "description": "Mark a protocol class as a runtime protocol.\n\nSuch protocol can be used with isinstance() and issubclass().\nRaise TypeError if applied to a non-protocol class.\nThis allows a simple-minded structural check very similar to\none trick ponies in collections.abc such as Iterable.\n\nFor example::\n\n    @runtime_checkable\n    class Closable(Protocol):\n        def close(self): ...\n\n    assert isinstance(open('/some/file'), Closable)\n\nWarning: this will check only the presence of the required methods,\nnot their type signatures!",
      "relationships": []
    },
    {
      "id": "stdlib.unicodedata.UCD",
      "name": "UCD",
      "module": "unicodedata",
      "type": "class",
      "signature": "()",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.uu.decode",
      "name": "decode",
      "module": "uu",
      "type": "function",
      "signature": "(in_file, out_file=None, mode=None, quiet=False)",
      "description": "Decode uuencoded file",
      "relationships": []
    },
    {
      "id": "stdlib.uu.encode",
      "name": "encode",
      "module": "uu",
      "type": "function",
      "signature": "(in_file, out_file, name=None, mode=None, *, backtick=False)",
      "description": "Uuencode file",
      "relationships": []
    },
    {
      "id": "stdlib.uu.test",
      "name": "test",
      "module": "uu",
      "type": "function",
      "signature": "()",
      "description": "uuencode/uudecode main program",
      "relationships": [
        {
          "target": "stdlib.uu.decode",
          "type": "calls"
        },
        {
          "target": "stdlib.uu.encode",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.uuid.SafeUUID",
      "name": "SafeUUID",
      "module": "uuid",
      "type": "class",
      "signature": "(*values)",
      "description": "An enumeration.",
      "relationships": [
        {
          "target": "stdlib.enum.Enum",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.uuid.UUID",
      "name": "UUID",
      "module": "uuid",
      "type": "class",
      "signature": "(hex=None, bytes=None, bytes_le=None, fields=None, int=None, version=None, *, is_safe=<SafeUUID.unknown: None>)",
      "description": "Instances of the UUID class represent UUIDs as specified in RFC 4122.\nUUID objects are immutable, hashable, and usable as dictionary keys.\nConverting a UUID to a string with str() yields something in the form\n'12345678-1234-1234-1234-123456789abc'.  The UUID constructor accepts\nfive possible forms: a similar string of hexadecimal digits, or a tuple\nof six integer fields (with 32-bit, 16-bit, 16-bit, 8-bit, 8-bit, and\n48-bit values respectively) as an argument named 'fields', or a string\nof 16 bytes (with all the integer fields in big-endian order) as an\nargument named 'bytes', or a string of 16 bytes (with the first three\nfields in little-endian order) as an argument named 'bytes_le', or a\nsingle 128-bit integer as an argument named 'int'.\n\nUUIDs have these read-only attributes:\n\n    bytes       the UUID as a 16-byte string (containing the six\n                integer fields in big-endian byte order)\n\n    bytes_le    the UUID as a 16-byte string (with time_low, time_mid,\n                and time_hi_version in little-endian byte order)\n\n    fields      a tuple of the six integer fields of the UUID,\n                which are also available as six individual attributes\n                and two derived attributes:\n\n        time_low                the first 32 bits of the UUID\n        time_mid                the next 16 bits of the UUID\n        time_hi_version         the next 16 bits of the UUID\n        clock_seq_hi_variant    the next 8 bits of the UUID\n        clock_seq_low           the next 8 bits of the UUID\n        node                    the last 48 bits of the UUID\n\n        time                    the 60-bit timestamp\n        clock_seq               the 14-bit sequence number\n\n    hex         the UUID as a 32-character hexadecimal string\n\n    int         the UUID as a 128-bit integer\n\n    urn         the UUID as a URN as specified in RFC 4122\n\n    variant     the UUID variant (one of the constants RESERVED_NCS,\n                RFC_4122, RESERVED_MICROSOFT, or RESERVED_FUTURE)\n\n    version     the UUID version number (1 through 5, meaningful only\n                when the variant is RFC_4122)\n\n    is_safe     An enum indicating whether the UUID has been generated in\n                a way that is safe for multiprocessing applications, via\n                uuid_generate_time_safe(3).",
      "relationships": []
    },
    {
      "id": "stdlib.uuid.getnode",
      "name": "getnode",
      "module": "uuid",
      "type": "function",
      "signature": "()",
      "description": "Get the hardware address as a 48-bit positive integer.\n\nThe first time this runs, it may launch a separate program, which could\nbe quite slow.  If all attempts to obtain the hardware address fail, we\nchoose a random 48-bit number with its eighth bit set to 1 as recommended\nin RFC 4122.",
      "relationships": []
    },
    {
      "id": "stdlib.uuid.main",
      "name": "main",
      "module": "uuid",
      "type": "function",
      "signature": "()",
      "description": "Run the uuid command line interface.",
      "relationships": []
    },
    {
      "id": "stdlib.uuid.uuid1",
      "name": "uuid1",
      "module": "uuid",
      "type": "function",
      "signature": "(node=None, clock_seq=None)",
      "description": "Generate a UUID from a host ID, sequence number, and the current time.\nIf 'node' is not given, getnode() is used to obtain the hardware\naddress.  If 'clock_seq' is given, it is used as the sequence number;\notherwise a random 14-bit sequence number is chosen.",
      "relationships": [
        {
          "target": "stdlib.uuid.getnode",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.uuid.uuid3",
      "name": "uuid3",
      "module": "uuid",
      "type": "function",
      "signature": "(namespace, name)",
      "description": "Generate a UUID from the MD5 hash of a namespace UUID and a name.",
      "relationships": []
    },
    {
      "id": "stdlib.uuid.uuid4",
      "name": "uuid4",
      "module": "uuid",
      "type": "function",
      "signature": "()",
      "description": "Generate a random UUID.",
      "relationships": []
    },
    {
      "id": "stdlib.uuid.uuid5",
      "name": "uuid5",
      "module": "uuid",
      "type": "function",
      "signature": "(namespace, name)",
      "description": "Generate a UUID from the SHA-1 hash of a namespace UUID and a name.",
      "relationships": []
    },
    {
      "id": "stdlib.venv.EnvBuilder",
      "name": "EnvBuilder",
      "module": "venv",
      "type": "class",
      "signature": "(system_site_packages=False, clear=False, symlinks=False, upgrade=False, with_pip=False, prompt=None, upgrade_deps=False)",
      "description": "This class exists to allow virtual environment creation to be\ncustomized. The constructor parameters determine the builder's\nbehaviour when called upon to create a virtual environment.\n\nBy default, the builder makes the system (global) site-packages dir\n*un*available to the created environment.\n\nIf invoked using the Python -m option, the default is to use copying\non Windows platforms but symlinks elsewhere. If instantiated some\nother way, the default is to *not* use symlinks.\n\n:param system_site_packages: If True, the system (global) site-packages\n                             dir is available to created environments.\n:param clear: If True, delete the contents of the environment directory if\n              it already exists, before environment creation.\n:param symlinks: If True, attempt to symlink rather than copy files into\n                 virtual environment.\n:param upgrade: If True, upgrade an existing virtual environment.\n:param with_pip: If True, ensure pip is installed in the virtual\n                 environment\n:param prompt: Alternative terminal prefix for the environment.\n:param upgrade_deps: Update the base venv modules to the latest on PyPI",
      "relationships": []
    },
    {
      "id": "stdlib.venv.create",
      "name": "create",
      "module": "venv",
      "type": "function",
      "signature": "(env_dir, system_site_packages=False, clear=False, symlinks=False, with_pip=False, prompt=None, upgrade_deps=False)",
      "description": "Create a virtual environment in a directory.",
      "relationships": []
    },
    {
      "id": "stdlib.venv.main",
      "name": "main",
      "module": "venv",
      "type": "function",
      "signature": "(args=None)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.warnings.WarningMessage",
      "name": "WarningMessage",
      "module": "warnings",
      "type": "class",
      "signature": "(message, category, filename, lineno, file=None, line=None, source=None)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.warnings.catch_warnings",
      "name": "catch_warnings",
      "module": "warnings",
      "type": "class",
      "signature": "(*, record=False, module=None, action=None, category=<class 'Warning'>, lineno=0, append=False)",
      "description": "A context manager that copies and restores the warnings filter upon\nexiting the context.\n\nThe 'record' argument specifies whether warnings should be captured by a\ncustom implementation of warnings.showwarning() and be appended to a list\nreturned by the context manager. Otherwise None is returned by the context\nmanager. The objects appended to the list are arguments whose attributes\nmirror the arguments to showwarning().\n\nThe 'module' argument is to specify an alternative module to the module\nnamed 'warnings' and imported under that name. This argument is only useful\nwhen testing the warnings module itself.\n\nIf the 'action' argument is not None, the remaining arguments are passed\nto warnings.simplefilter() as if it were called immediately on entering the\ncontext.",
      "relationships": []
    },
    {
      "id": "stdlib.warnings.filterwarnings",
      "name": "filterwarnings",
      "module": "warnings",
      "type": "function",
      "signature": "(action, message='', category=<class 'Warning'>, module='', lineno=0, append=False)",
      "description": "Insert an entry into the list of warnings filters (at the front).\n\n'action' -- one of \"error\", \"ignore\", \"always\", \"default\", \"module\",\n            or \"once\"\n'message' -- a regex that the warning message must match\n'category' -- a class that the warning must be a subclass of\n'module' -- a regex that the module name must match\n'lineno' -- an integer line number, 0 matches all warnings\n'append' -- if true, append to the list of filters",
      "relationships": [
        {
          "target": "stdlib.warnings._add_filter",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.warnings.formatwarning",
      "name": "formatwarning",
      "module": "warnings",
      "type": "function",
      "signature": "(message, category, filename, lineno, line=None)",
      "description": "Function to format a warning the standard way.",
      "relationships": [
        {
          "target": "stdlib.warnings._formatwarnmsg_impl",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.warnings.resetwarnings",
      "name": "resetwarnings",
      "module": "warnings",
      "type": "function",
      "signature": "()",
      "description": "Clear the list of warning filters, so that no filters are active.",
      "relationships": []
    },
    {
      "id": "stdlib.warnings.showwarning",
      "name": "showwarning",
      "module": "warnings",
      "type": "function",
      "signature": "(message, category, filename, lineno, file=None, line=None)",
      "description": "Hook to write a warning to a file; replace if you like.",
      "relationships": [
        {
          "target": "stdlib.warnings._showwarnmsg_impl",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.warnings.simplefilter",
      "name": "simplefilter",
      "module": "warnings",
      "type": "function",
      "signature": "(action, category=<class 'Warning'>, lineno=0, append=False)",
      "description": "Insert a simple entry into the list of warnings filters (at the front).\n\nA simple filter matches all modules and messages.\n'action' -- one of \"error\", \"ignore\", \"always\", \"default\", \"module\",\n            or \"once\"\n'category' -- a class that the warning must be a subclass of\n'lineno' -- an integer line number, 0 matches all warnings\n'append' -- if true, append to the list of filters",
      "relationships": [
        {
          "target": "stdlib.warnings._add_filter",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.wave.Wave_read",
      "name": "Wave_read",
      "module": "wave",
      "type": "class",
      "signature": "(f)",
      "description": "Variables used in this class:\n\nThese variables are available to the user though appropriate\nmethods of this class:\n_file -- the open file with methods read(), close(), and seek()\n          set through the __init__() method\n_nchannels -- the number of audio channels\n          available through the getnchannels() method\n_nframes -- the number of audio frames\n          available through the getnframes() method\n_sampwidth -- the number of bytes per audio sample\n          available through the getsampwidth() method\n_framerate -- the sampling frequency\n          available through the getframerate() method\n_comptype -- the AIFF-C compression type ('NONE' if AIFF)\n          available through the getcomptype() method\n_compname -- the human-readable AIFF-C compression type\n          available through the getcomptype() method\n_soundpos -- the position in the audio stream\n          available through the tell() method, set through the\n          setpos() method\n\nThese variables are used internally only:\n_fmt_chunk_read -- 1 iff the FMT chunk has been read\n_data_seek_needed -- 1 iff positioned correctly in audio\n          file for readframes()\n_data_chunk -- instantiation of a chunk class for the DATA chunk\n_framesize -- size of one frame in the file",
      "relationships": []
    },
    {
      "id": "stdlib.wave.Wave_write",
      "name": "Wave_write",
      "module": "wave",
      "type": "class",
      "signature": "(f)",
      "description": "Variables used in this class:\n\nThese variables are user settable through appropriate methods\nof this class:\n_file -- the open file with methods write(), close(), tell(), seek()\n          set through the __init__() method\n_comptype -- the AIFF-C compression type ('NONE' in AIFF)\n          set through the setcomptype() or setparams() method\n_compname -- the human-readable AIFF-C compression type\n          set through the setcomptype() or setparams() method\n_nchannels -- the number of audio channels\n          set through the setnchannels() or setparams() method\n_sampwidth -- the number of bytes per audio sample\n          set through the setsampwidth() or setparams() method\n_framerate -- the sampling frequency\n          set through the setframerate() or setparams() method\n_nframes -- the number of audio frames written to the header\n          set through the setnframes() or setparams() method\n\nThese variables are used internally only:\n_datalength -- the size of the audio samples written to the header\n_nframeswritten -- the number of frames actually written\n_datawritten -- the size of the audio samples actually written",
      "relationships": []
    },
    {
      "id": "stdlib.wave.open",
      "name": "open",
      "module": "wave",
      "type": "function",
      "signature": "(f, mode=None)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.weakref.CallableProxyType",
      "name": "CallableProxyType",
      "module": "weakref",
      "type": "class",
      "signature": "()",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.weakref.KeyedRef",
      "name": "KeyedRef",
      "module": "weakref",
      "type": "class",
      "signature": "(ob, callback, key)",
      "description": "Specialized reference that includes a key corresponding to the value.\n\nThis is used in the WeakValueDictionary to avoid having to create\na function object for each key stored in the mapping.  A shared\ncallback object can use the 'key' attribute of a KeyedRef instead\nof getting a reference to the key from an enclosing scope.",
      "relationships": [
        {
          "target": "stdlib.weakref.ReferenceType",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.weakref.ProxyType",
      "name": "ProxyType",
      "module": "weakref",
      "type": "class",
      "signature": "()",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.weakref.WeakKeyDictionary",
      "name": "WeakKeyDictionary",
      "module": "weakref",
      "type": "class",
      "signature": "(dict=None)",
      "description": "Mapping class that references keys weakly.\n\nEntries in the dictionary will be discarded when there is no\nlonger a strong reference to the key. This can be used to\nassociate additional data with an object owned by other parts of\nan application without adding attributes to those objects. This\ncan be especially useful with objects that override attribute\naccesses.",
      "relationships": [
        {
          "target": "stdlib.collections.abc.MutableMapping",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Mapping",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Collection",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Sized",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Iterable",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Container",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.weakref.WeakMethod",
      "name": "WeakMethod",
      "module": "weakref",
      "type": "class",
      "signature": "(meth, callback=None)",
      "description": "A custom `weakref.ref` subclass which simulates a weak reference to\na bound method, working around the lifetime problem of bound methods.",
      "relationships": [
        {
          "target": "stdlib.weakref.ReferenceType",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.weakref.WeakValueDictionary",
      "name": "WeakValueDictionary",
      "module": "weakref",
      "type": "class",
      "signature": "(other=(), /, **kw)",
      "description": "Mapping class that references values weakly.\n\nEntries in the dictionary will be discarded when no strong\nreference to the value exists anymore",
      "relationships": [
        {
          "target": "stdlib.collections.abc.MutableMapping",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Mapping",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Collection",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Sized",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Iterable",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Container",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.weakref.finalize",
      "name": "finalize",
      "module": "weakref",
      "type": "class",
      "signature": "(obj, func, /, *args, **kwargs)",
      "description": "Class for finalization of weakrefable objects\n\nfinalize(obj, func, *args, **kwargs) returns a callable finalizer\nobject which will be called when obj is garbage collected. The\nfirst time the finalizer is called it evaluates func(*arg, **kwargs)\nand returns the result. After this the finalizer is dead, and\ncalling it just returns None.\n\nWhen the program exits any remaining finalizers for which the\natexit attribute is true will be run in reverse order of creation.\nBy default atexit is true.",
      "relationships": []
    },
    {
      "id": "stdlib.webbrowser.BackgroundBrowser",
      "name": "BackgroundBrowser",
      "module": "webbrowser",
      "type": "class",
      "signature": "(name)",
      "description": "Class for all browsers which are to be started in the\nbackground.",
      "relationships": [
        {
          "target": "stdlib.webbrowser.GenericBrowser",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.BaseBrowser",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.webbrowser.BaseBrowser",
      "name": "BaseBrowser",
      "module": "webbrowser",
      "type": "class",
      "signature": "(name='')",
      "description": "Parent class for all browsers. Do not use directly.",
      "relationships": []
    },
    {
      "id": "stdlib.webbrowser.Chrome",
      "name": "Chrome",
      "module": "webbrowser",
      "type": "class",
      "signature": "(name='')",
      "description": "Launcher class for Google Chrome browser.",
      "relationships": [
        {
          "target": "stdlib.webbrowser.UnixBrowser",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.BaseBrowser",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.webbrowser.Chromium",
      "name": "Chromium",
      "module": "webbrowser",
      "type": "class",
      "signature": "(name='')",
      "description": "Launcher class for Google Chrome browser.",
      "relationships": [
        {
          "target": "stdlib.webbrowser.UnixBrowser",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.BaseBrowser",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.webbrowser.Edge",
      "name": "Edge",
      "module": "webbrowser",
      "type": "class",
      "signature": "(name='')",
      "description": "Launcher class for Microsoft Edge browser.",
      "relationships": [
        {
          "target": "stdlib.webbrowser.UnixBrowser",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.BaseBrowser",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.webbrowser.Elinks",
      "name": "Elinks",
      "module": "webbrowser",
      "type": "class",
      "signature": "(name='')",
      "description": "Launcher class for Elinks browsers.",
      "relationships": [
        {
          "target": "stdlib.webbrowser.UnixBrowser",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.BaseBrowser",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.webbrowser.Epiphany",
      "name": "Epiphany",
      "module": "webbrowser",
      "type": "class",
      "signature": "(name='')",
      "description": "Launcher class for Epiphany browser.",
      "relationships": [
        {
          "target": "stdlib.webbrowser.UnixBrowser",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.BaseBrowser",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.webbrowser.GenericBrowser",
      "name": "GenericBrowser",
      "module": "webbrowser",
      "type": "class",
      "signature": "(name)",
      "description": "Class for all browsers started with a command\nand without remote functionality.",
      "relationships": [
        {
          "target": "stdlib.webbrowser.BaseBrowser",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.webbrowser.Konqueror",
      "name": "Konqueror",
      "module": "webbrowser",
      "type": "class",
      "signature": "(name='')",
      "description": "Controller for the KDE File Manager (kfm, or Konqueror).\n\nSee the output of ``kfmclient --commands``\nfor more information on the Konqueror remote-control interface.",
      "relationships": [
        {
          "target": "stdlib.webbrowser.BaseBrowser",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.webbrowser.MacOSX",
      "name": "MacOSX",
      "module": "webbrowser",
      "type": "class",
      "signature": "(name)",
      "description": "Launcher class for Aqua browsers on Mac OS X\n\nOptionally specify a browser name on instantiation.  Note that this\nwill not work for Aqua browsers if the user has moved the application\npackage after installation.\n\nIf no browser is specified, the default browser, as specified in the\nInternet System Preferences panel, will be used.",
      "relationships": [
        {
          "target": "stdlib.webbrowser.BaseBrowser",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.webbrowser.MacOSXOSAScript",
      "name": "MacOSXOSAScript",
      "module": "webbrowser",
      "type": "class",
      "signature": "(name='default')",
      "description": "Parent class for all browsers. Do not use directly.",
      "relationships": [
        {
          "target": "stdlib.webbrowser.BaseBrowser",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.webbrowser.Mozilla",
      "name": "Mozilla",
      "module": "webbrowser",
      "type": "class",
      "signature": "(name='')",
      "description": "Launcher class for Mozilla browsers.",
      "relationships": [
        {
          "target": "stdlib.webbrowser.UnixBrowser",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.BaseBrowser",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.webbrowser.Opera",
      "name": "Opera",
      "module": "webbrowser",
      "type": "class",
      "signature": "(name='')",
      "description": "Launcher class for Opera browser.",
      "relationships": [
        {
          "target": "stdlib.webbrowser.UnixBrowser",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.BaseBrowser",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.webbrowser.UnixBrowser",
      "name": "UnixBrowser",
      "module": "webbrowser",
      "type": "class",
      "signature": "(name='')",
      "description": "Parent class for all Unix browsers with remote functionality.",
      "relationships": [
        {
          "target": "stdlib.webbrowser.BaseBrowser",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.webbrowser.get",
      "name": "get",
      "module": "webbrowser",
      "type": "function",
      "signature": "(using=None)",
      "description": "Return a browser launcher instance appropriate for the environment.",
      "relationships": [
        {
          "target": "stdlib.webbrowser.register_standard_browsers",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser._synthesize",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.webbrowser.main",
      "name": "main",
      "module": "webbrowser",
      "type": "function",
      "signature": "()",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.webbrowser.open",
      "name": "open",
      "module": "webbrowser",
      "type": "function",
      "signature": "(url, new=0, autoraise=True)",
      "description": "Display url using the default browser.\n\nIf possible, open url in a location determined by new.\n- 0: the same browser window (the default).\n- 1: a new browser window.\n- 2: a new browser page (\"tab\").\nIf possible, autoraise raises the window (the default) or not.\n\nIf opening the browser succeeds, return True.\nIf there is a problem, return False.",
      "relationships": [
        {
          "target": "stdlib.webbrowser.get",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.register_standard_browsers",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.webbrowser.open_new",
      "name": "open_new",
      "module": "webbrowser",
      "type": "function",
      "signature": "(url)",
      "description": "Open url in a new window of the default browser.\n\nIf not possible, then open url in the only browser window.",
      "relationships": []
    },
    {
      "id": "stdlib.webbrowser.open_new_tab",
      "name": "open_new_tab",
      "module": "webbrowser",
      "type": "function",
      "signature": "(url)",
      "description": "Open url in a new page (\"tab\") of the default browser.\n\nIf not possible, then the behavior becomes equivalent to open_new().",
      "relationships": []
    },
    {
      "id": "stdlib.webbrowser.register",
      "name": "register",
      "module": "webbrowser",
      "type": "function",
      "signature": "(name, klass, instance=None, *, preferred=False)",
      "description": "Register a browser connector.",
      "relationships": [
        {
          "target": "stdlib.webbrowser.register_standard_browsers",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.webbrowser.register_X_browsers",
      "name": "register_X_browsers",
      "module": "webbrowser",
      "type": "function",
      "signature": "()",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.webbrowser.register",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.register",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.register",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.register",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.register",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.register",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.register",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.register",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.register",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.register",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.register",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.register",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.webbrowser.register_standard_browsers",
      "name": "register_standard_browsers",
      "module": "webbrowser",
      "type": "function",
      "signature": "()",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.webbrowser.register",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.register",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.register",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.register",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.register",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.register",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.register",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.register_X_browsers",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.register",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.register",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.register",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.register",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.register",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.register",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser._synthesize",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.register",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.xdrlib.ConversionError",
      "name": "ConversionError",
      "module": "xdrlib",
      "type": "class",
      "signature": "(msg)",
      "description": "Exception class for this module. Use:\n\nexcept xdrlib.Error as var:\n    # var has the Error instance for the exception\n\nPublic ivars:\n    msg -- contains the message",
      "relationships": [
        {
          "target": "stdlib.xdrlib.Error",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.Exception",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.xdrlib.Error",
      "name": "Error",
      "module": "xdrlib",
      "type": "class",
      "signature": "(msg)",
      "description": "Exception class for this module. Use:\n\nexcept xdrlib.Error as var:\n    # var has the Error instance for the exception\n\nPublic ivars:\n    msg -- contains the message",
      "relationships": [
        {
          "target": "stdlib.builtins.Exception",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.xdrlib.Packer",
      "name": "Packer",
      "module": "xdrlib",
      "type": "class",
      "signature": "()",
      "description": "Pack various data representations into a buffer.",
      "relationships": []
    },
    {
      "id": "stdlib.xdrlib.Unpacker",
      "name": "Unpacker",
      "module": "xdrlib",
      "type": "class",
      "signature": "(data)",
      "description": "Unpacks various data representations from the given buffer.",
      "relationships": []
    },
    {
      "id": "stdlib.xdrlib.raise_conversion_error",
      "name": "raise_conversion_error",
      "module": "xdrlib",
      "type": "function",
      "signature": "(function)",
      "description": "Wrap any raised struct.errors in a ConversionError. ",
      "relationships": []
    },
    {
      "id": "stdlib.zipapp.create_archive",
      "name": "create_archive",
      "module": "zipapp",
      "type": "function",
      "signature": "(source, target=None, interpreter=None, main=None, filter=None, compressed=False)",
      "description": "Create an application archive from SOURCE.\n\nThe SOURCE can be the name of a directory, or a filename or a file-like\nobject referring to an existing archive.\n\nThe content of SOURCE is packed into an application archive in TARGET,\nwhich can be a filename or a file-like object.  If SOURCE is a directory,\nTARGET can be omitted and will default to the name of SOURCE with .pyz\nappended.\n\nThe created application archive will have a shebang line specifying\nthat it should run with INTERPRETER (there will be no shebang line if\nINTERPRETER is None), and a __main__.py which runs MAIN (if MAIN is\nnot specified, an existing __main__.py will be used).  It is an error\nto specify MAIN for anything other than a directory source with no\n__main__.py, and it is an error to omit MAIN if the directory has no\n__main__.py.",
      "relationships": [
        {
          "target": "stdlib.zipapp._copy_archive",
          "type": "calls"
        },
        {
          "target": "stdlib.zipapp._maybe_open",
          "type": "calls"
        },
        {
          "target": "stdlib.zipapp._write_file_prefix",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.zipapp.get_interpreter",
      "name": "get_interpreter",
      "module": "zipapp",
      "type": "function",
      "signature": "(archive)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.zipapp._maybe_open",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.zipapp.main",
      "name": "main",
      "module": "zipapp",
      "type": "function",
      "signature": "(args=None)",
      "description": "Run the zipapp command line interface.\n\nThe ARGS parameter lets you specify the argument list directly.\nOmitting ARGS (or setting it to None) works as for argparse, using\nsys.argv[1:] as the argument list.",
      "relationships": [
        {
          "target": "stdlib.zipapp.create_archive",
          "type": "calls"
        },
        {
          "target": "stdlib.zipapp.get_interpreter",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.zipfile.LZMACompressor",
      "name": "LZMACompressor",
      "module": "zipfile",
      "type": "class",
      "signature": "()",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.zipfile.LZMADecompressor",
      "name": "LZMADecompressor",
      "module": "zipfile",
      "type": "class",
      "signature": "()",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.zipfile.PyZipFile",
      "name": "PyZipFile",
      "module": "zipfile",
      "type": "class",
      "signature": "(file, mode='r', compression=0, allowZip64=True, optimize=-1)",
      "description": "Class to create ZIP archives with Python library files and packages.",
      "relationships": [
        {
          "target": "stdlib.zipfile.ZipFile",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.zipfile.ZipExtFile",
      "name": "ZipExtFile",
      "module": "zipfile",
      "type": "class",
      "signature": "(fileobj, mode, zipinfo, pwd=None, close_fileobj=False)",
      "description": "File-like object for reading an archive member.\nIs returned by ZipFile.open().",
      "relationships": [
        {
          "target": "stdlib.io.BufferedIOBase",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins._BufferedIOBase",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins.IOBase",
          "type": "base_class"
        },
        {
          "target": "stdlib.builtins._IOBase",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.zipfile.ZipFile",
      "name": "ZipFile",
      "module": "zipfile",
      "type": "class",
      "signature": "(file, mode='r', compression=0, allowZip64=True, compresslevel=None, *, strict_timestamps=True, metadata_encoding=None)",
      "description": "Class with methods to open, read, write, close, list zip files.\n\nz = ZipFile(file, mode=\"r\", compression=ZIP_STORED, allowZip64=True,\n            compresslevel=None)\n\nfile: Either the path to the file, or a file-like object.\n      If it is a path, the file will be opened and closed by ZipFile.\nmode: The mode can be either read 'r', write 'w', exclusive create 'x',\n      or append 'a'.\ncompression: ZIP_STORED (no compression), ZIP_DEFLATED (requires zlib),\n             ZIP_BZIP2 (requires bz2) or ZIP_LZMA (requires lzma).\nallowZip64: if True ZipFile will create files with ZIP64 extensions when\n            needed, otherwise it will raise an exception when this would\n            be necessary.\ncompresslevel: None (default for the given compression type) or an integer\n               specifying the level to pass to the compressor.\n               When using ZIP_STORED or ZIP_LZMA this keyword has no effect.\n               When using ZIP_DEFLATED integers 0 through 9 are accepted.\n               When using ZIP_BZIP2 integers 1 through 9 are accepted.",
      "relationships": []
    },
    {
      "id": "stdlib.zipfile.ZipInfo",
      "name": "ZipInfo",
      "module": "zipfile",
      "type": "class",
      "signature": "(filename='NoName', date_time=(1980, 1, 1, 0, 0, 0))",
      "description": "Class with attributes describing each file in the ZIP archive.",
      "relationships": []
    },
    {
      "id": "stdlib.zipfile.is_zipfile",
      "name": "is_zipfile",
      "module": "zipfile",
      "type": "function",
      "signature": "(filename)",
      "description": "Quickly see if a file is a ZIP file by checking the magic number.\n\nThe filename argument may be a file or file-like object too.",
      "relationships": [
        {
          "target": "stdlib.zipfile._check_zipfile",
          "type": "calls"
        },
        {
          "target": "stdlib.zipfile._check_zipfile",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.zipfile.main",
      "name": "main",
      "module": "zipfile",
      "type": "function",
      "signature": "(args=None)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.zipimport.zipimporter",
      "name": "zipimporter",
      "module": "zipimport",
      "type": "class",
      "signature": "(path)",
      "description": "zipimporter(archivepath) -> zipimporter object\n\nCreate a new zipimporter instance. 'archivepath' must be a path to\na zipfile, or to a specific path inside a zipfile. For example, it can be\n'/tmp/myimport.zip', or '/tmp/myimport.zip/mydirectory', if mydirectory is a\nvalid directory inside the archive.\n\n'ZipImportError is raised if 'archivepath' doesn't point to a valid Zip\narchive.\n\nThe 'archive' attribute of zipimporter objects contains the name of the\nzipfile targeted.",
      "relationships": [
        {
          "target": "stdlib._frozen_importlib_external._LoaderBasics",
          "type": "base_class"
        }
      ]
    }
  ]
}