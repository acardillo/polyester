{
  "metadata": {
    "python_version": "3.9",
    "module_count": 183,
    "function_count": 1915,
    "extracted_at": "2026-02-07T19:25:37.381631"
  },
  "data": [
    {
      "id": "stdlib.abc.ABC",
      "name": "ABC",
      "module": "abc",
      "type": "class",
      "signature": "()",
      "description": "Helper class that provides a standard way to create an ABC using\ninheritance.",
      "relationships": []
    },
    {
      "id": "stdlib.abc.ABCMeta",
      "name": "ABCMeta",
      "module": "abc",
      "type": "class",
      "signature": "(name, bases, namespace, **kwargs)",
      "description": "Metaclass for defining Abstract Base Classes (ABCs).\n\nUse this metaclass to create an ABC.  An ABC can be subclassed\ndirectly, and then acts as a mix-in class.  You can also register\nunrelated concrete classes (even built-in classes) and unrelated\nABCs as 'virtual subclasses' -- these and their descendants will\nbe considered subclasses of the registering ABC by the built-in\nissubclass() function, but the registering ABC won't show up in\ntheir MRO (Method Resolution Order) nor will method\nimplementations defined by the registering ABC be callable (not\neven via super()).",
      "relationships": [
        {
          "target": "type",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.abc.abstractclassmethod",
      "name": "abstractclassmethod",
      "module": "abc",
      "type": "class",
      "signature": "(callable)",
      "description": "A decorator indicating abstract classmethods.\n\nDeprecated, use 'classmethod' with 'abstractmethod' instead:\n\n    class C(ABC):\n        @classmethod\n        @abstractmethod\n        def my_abstract_classmethod(cls, ...):\n            ...",
      "relationships": [
        {
          "target": "classmethod",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.abc.abstractmethod",
      "name": "abstractmethod",
      "module": "abc",
      "type": "function",
      "signature": "(funcobj)",
      "description": "A decorator indicating abstract methods.\n\nRequires that the metaclass is ABCMeta or derived from it.  A\nclass that has a metaclass derived from ABCMeta cannot be\ninstantiated unless all of its abstract methods are overridden.\nThe abstract methods can be called using any of the normal\n'super' call mechanisms.  abstractmethod() may be used to declare\nabstract methods for properties and descriptors.\n\nUsage:\n\n    class C(metaclass=ABCMeta):\n        @abstractmethod\n        def my_abstract_method(self, ...):\n            ...",
      "relationships": []
    },
    {
      "id": "stdlib.abc.abstractproperty",
      "name": "abstractproperty",
      "module": "abc",
      "type": "class",
      "signature": "(fget=None, fset=None, fdel=None, doc=None)",
      "description": "A decorator indicating abstract properties.\n\nDeprecated, use 'property' with 'abstractmethod' instead:\n\n    class C(ABC):\n        @property\n        @abstractmethod\n        def my_abstract_property(self):\n            ...",
      "relationships": [
        {
          "target": "property",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.abc.abstractstaticmethod",
      "name": "abstractstaticmethod",
      "module": "abc",
      "type": "class",
      "signature": "(callable)",
      "description": "A decorator indicating abstract staticmethods.\n\nDeprecated, use 'staticmethod' with 'abstractmethod' instead:\n\n    class C(ABC):\n        @staticmethod\n        @abstractmethod\n        def my_abstract_staticmethod(...):\n            ...",
      "relationships": [
        {
          "target": "staticmethod",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.aifc.Aifc_read",
      "name": "Aifc_read",
      "module": "aifc",
      "type": "class",
      "signature": "(f)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.aifc.Aifc_write",
      "name": "Aifc_write",
      "module": "aifc",
      "type": "class",
      "signature": "(f)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.aifc.Chunk",
      "name": "Chunk",
      "module": "aifc",
      "type": "class",
      "signature": "(file, align=True, bigendian=True, inclheader=False)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.aifc.namedtuple",
      "name": "namedtuple",
      "module": "aifc",
      "type": "function",
      "signature": "(typename, field_names, *, rename=False, defaults=None, module=None)",
      "description": "Returns a new subclass of tuple with named fields.\n\n>>> Point = namedtuple('Point', ['x', 'y'])\n>>> Point.__doc__                   # docstring for the new class\n'Point(x, y)'\n>>> p = Point(11, y=22)             # instantiate with positional args or keywords\n>>> p[0] + p[1]                     # indexable like a plain tuple\n33\n>>> x, y = p                        # unpack like a regular tuple\n>>> x, y\n(11, 22)\n>>> p.x + p.y                       # fields also accessible by name\n33\n>>> d = p._asdict()                 # convert to a dictionary\n>>> d['x']\n11\n>>> Point(**d)                      # convert from a dictionary\nPoint(x=11, y=22)\n>>> p._replace(x=100)               # _replace() is like str.replace() but targets named fields\nPoint(x=100, y=22)",
      "relationships": [
        {
          "target": "stdlib.aifc.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.aifc.list",
          "type": "calls"
        },
        {
          "target": "stdlib.aifc.intern",
          "type": "calls"
        },
        {
          "target": "stdlib.aifc.set",
          "type": "calls"
        },
        {
          "target": "stdlib.aifc.tuple",
          "type": "calls"
        },
        {
          "target": "stdlib.aifc.len",
          "type": "calls"
        },
        {
          "target": "stdlib.aifc.join",
          "type": "calls"
        },
        {
          "target": "stdlib.aifc.eval",
          "type": "calls"
        },
        {
          "target": "stdlib.aifc.enumerate",
          "type": "calls"
        },
        {
          "target": "stdlib.aifc.type",
          "type": "calls"
        },
        {
          "target": "stdlib.aifc.split",
          "type": "calls"
        },
        {
          "target": "stdlib.aifc.map",
          "type": "calls"
        },
        {
          "target": "stdlib.aifc.str",
          "type": "calls"
        },
        {
          "target": "stdlib.aifc.set",
          "type": "calls"
        },
        {
          "target": "stdlib.aifc.enumerate",
          "type": "calls"
        },
        {
          "target": "stdlib.aifc._iskeyword",
          "type": "calls"
        },
        {
          "target": "stdlib.aifc.add",
          "type": "calls"
        },
        {
          "target": "stdlib.aifc.tuple",
          "type": "calls"
        },
        {
          "target": "stdlib.aifc.dict",
          "type": "calls"
        },
        {
          "target": "stdlib.aifc.map",
          "type": "calls"
        },
        {
          "target": "stdlib.aifc.tuple_new",
          "type": "calls"
        },
        {
          "target": "stdlib.aifc._make",
          "type": "calls"
        },
        {
          "target": "stdlib.aifc._dict",
          "type": "calls"
        },
        {
          "target": "stdlib.aifc._tuple",
          "type": "calls"
        },
        {
          "target": "stdlib.aifc.intern",
          "type": "calls"
        },
        {
          "target": "stdlib.aifc._tuplegetter",
          "type": "calls"
        },
        {
          "target": "stdlib.aifc.add",
          "type": "calls"
        },
        {
          "target": "stdlib.aifc.type",
          "type": "calls"
        },
        {
          "target": "stdlib.aifc.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.aifc.isidentifier",
          "type": "calls"
        },
        {
          "target": "stdlib.aifc.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.aifc.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.aifc.startswith",
          "type": "calls"
        },
        {
          "target": "stdlib.aifc.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.aifc.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.aifc.len",
          "type": "calls"
        },
        {
          "target": "stdlib.aifc.len",
          "type": "calls"
        },
        {
          "target": "stdlib.aifc.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.aifc.reversed",
          "type": "calls"
        },
        {
          "target": "stdlib.aifc.join",
          "type": "calls"
        },
        {
          "target": "stdlib.aifc._len",
          "type": "calls"
        },
        {
          "target": "stdlib.aifc.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.aifc._map",
          "type": "calls"
        },
        {
          "target": "stdlib.aifc.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.aifc._zip",
          "type": "calls"
        },
        {
          "target": "stdlib.aifc.get",
          "type": "calls"
        },
        {
          "target": "stdlib.aifc.replace",
          "type": "calls"
        },
        {
          "target": "stdlib.aifc._iskeyword",
          "type": "calls"
        },
        {
          "target": "stdlib.aifc.startswith",
          "type": "calls"
        },
        {
          "target": "stdlib.aifc.list",
          "type": "calls"
        },
        {
          "target": "stdlib.aifc.isidentifier",
          "type": "calls"
        },
        {
          "target": "stdlib.aifc.zip",
          "type": "calls"
        },
        {
          "target": "stdlib.aifc.reversed",
          "type": "calls"
        },
        {
          "target": "stdlib.aifc.reversed",
          "type": "calls"
        },
        {
          "target": "stdlib.aifc.len",
          "type": "calls"
        },
        {
          "target": "stdlib.aifc.list",
          "type": "calls"
        },
        {
          "target": "stdlib.aifc._getframe",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.aifc.open",
      "name": "open",
      "module": "aifc",
      "type": "function",
      "signature": "(f, mode=None)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.aifc.hasattr",
          "type": "calls"
        },
        {
          "target": "stdlib.aifc.Aifc_read",
          "type": "calls"
        },
        {
          "target": "stdlib.aifc.Aifc_write",
          "type": "calls"
        },
        {
          "target": "stdlib.aifc.Error",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.antigravity.geohash",
      "name": "geohash",
      "module": "antigravity",
      "type": "function",
      "signature": "(latitude, longitude, datedow)",
      "description": "Compute geohash() using the Munroe algorithm.\n\n>>> geohash(37.421542, -122.085589, b'2005-05-26-10458.68')\n37.857713 -122.544543",
      "relationships": [
        {
          "target": "stdlib.antigravity.hexdigest",
          "type": "calls"
        },
        {
          "target": "stdlib.antigravity.print",
          "type": "calls"
        },
        {
          "target": "stdlib.antigravity.md5",
          "type": "calls"
        },
        {
          "target": "stdlib.antigravity.fromhex",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.argparse.Action",
      "name": "Action",
      "module": "argparse",
      "type": "class",
      "signature": "(option_strings, dest, nargs=None, const=None, default=None, type=None, choices=None, required=False, help=None, metavar=None)",
      "description": "Information about how to convert command line strings to Python objects.\n\nAction objects are used by an ArgumentParser to represent the information\nneeded to parse a single argument from one or more strings from the\ncommand line. The keyword arguments to the Action constructor are also\nall attributes of Action instances.\n\nKeyword Arguments:\n\n    - option_strings -- A list of command-line option strings which\n        should be associated with this action.\n\n    - dest -- The name of the attribute to hold the created object(s)\n\n    - nargs -- The number of command-line arguments that should be\n        consumed. By default, one argument will be consumed and a single\n        value will be produced.  Other values include:\n            - N (an integer) consumes N arguments (and produces a list)\n            - '?' consumes zero or one arguments\n            - '*' consumes zero or more arguments (and produces a list)\n            - '+' consumes one or more arguments (and produces a list)\n        Note that the difference between the default and nargs=1 is that\n        with the default, a single value will be produced, while with\n        nargs=1, a list containing a single value will be produced.\n\n    - const -- The value to be produced if the option is specified and the\n        option uses an action that takes no values.\n\n    - default -- The value to be produced if the option is not specified.\n\n    - type -- A callable that accepts a single string argument, and\n        returns the converted value.  The standard Python types str, int,\n        float, and complex are useful examples of such callables.  If None,\n        str is used.\n\n    - choices -- A container of values that should be allowed. If not None,\n        after a command-line argument has been converted to the appropriate\n        type, an exception will be raised if it is not a member of this\n        collection.\n\n    - required -- True if the action must always be specified at the\n        command line. This is only meaningful for optional command-line\n        arguments.\n\n    - help -- The help string describing the argument.\n\n    - metavar -- The name to be used for the option's argument with the\n        help string. If None, the 'dest' value will be used as the name.",
      "relationships": [
        {
          "target": "_AttributeHolder",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.argparse.ArgumentDefaultsHelpFormatter",
      "name": "ArgumentDefaultsHelpFormatter",
      "module": "argparse",
      "type": "class",
      "signature": "(prog, indent_increment=2, max_help_position=24, width=None)",
      "description": "Help message formatter which adds default values to argument help.\n\nOnly the name of this class is considered a public API. All the methods\nprovided by the class are considered an implementation detail.",
      "relationships": [
        {
          "target": "HelpFormatter",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.argparse.ArgumentError",
      "name": "ArgumentError",
      "module": "argparse",
      "type": "class",
      "signature": "(argument, message)",
      "description": "An error from creating or using an argument (optional or positional).\n\nThe string value of this exception is the message, augmented with\ninformation about the argument that caused it.",
      "relationships": [
        {
          "target": "Exception",
          "type": "base_class"
        },
        {
          "target": "BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.argparse.ArgumentParser",
      "name": "ArgumentParser",
      "module": "argparse",
      "type": "class",
      "signature": "(prog=None, usage=None, description=None, epilog=None, parents=[], formatter_class=<class 'argparse.HelpFormatter'>, prefix_chars='-', fromfile_prefix_chars=None, argument_default=None, conflict_handler='error', add_help=True, allow_abbrev=True, exit_on_error=True)",
      "description": "Object for parsing command line strings into Python objects.\n\nKeyword Arguments:\n    - prog -- The name of the program (default: sys.argv[0])\n    - usage -- A usage message (default: auto-generated from arguments)\n    - description -- A description of what the program does\n    - epilog -- Text following the argument descriptions\n    - parents -- Parsers whose arguments should be copied into this one\n    - formatter_class -- HelpFormatter class for printing help messages\n    - prefix_chars -- Characters that prefix optional arguments\n    - fromfile_prefix_chars -- Characters that prefix files containing\n        additional arguments\n    - argument_default -- The default value for all arguments\n    - conflict_handler -- String indicating how to handle conflicts\n    - add_help -- Add a -h/-help option\n    - allow_abbrev -- Allow long options to be abbreviated unambiguously\n    - exit_on_error -- Determines whether or not ArgumentParser exits with\n        error info when an error occurs",
      "relationships": [
        {
          "target": "_AttributeHolder",
          "type": "base_class"
        },
        {
          "target": "_ActionsContainer",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.argparse.BooleanOptionalAction",
      "name": "BooleanOptionalAction",
      "module": "argparse",
      "type": "class",
      "signature": "(option_strings, dest, default=None, type=None, choices=None, required=False, help=None, metavar=None)",
      "description": "Information about how to convert command line strings to Python objects.\n\nAction objects are used by an ArgumentParser to represent the information\nneeded to parse a single argument from one or more strings from the\ncommand line. The keyword arguments to the Action constructor are also\nall attributes of Action instances.\n\nKeyword Arguments:\n\n    - option_strings -- A list of command-line option strings which\n        should be associated with this action.\n\n    - dest -- The name of the attribute to hold the created object(s)\n\n    - nargs -- The number of command-line arguments that should be\n        consumed. By default, one argument will be consumed and a single\n        value will be produced.  Other values include:\n            - N (an integer) consumes N arguments (and produces a list)\n            - '?' consumes zero or one arguments\n            - '*' consumes zero or more arguments (and produces a list)\n            - '+' consumes one or more arguments (and produces a list)\n        Note that the difference between the default and nargs=1 is that\n        with the default, a single value will be produced, while with\n        nargs=1, a list containing a single value will be produced.\n\n    - const -- The value to be produced if the option is specified and the\n        option uses an action that takes no values.\n\n    - default -- The value to be produced if the option is not specified.\n\n    - type -- A callable that accepts a single string argument, and\n        returns the converted value.  The standard Python types str, int,\n        float, and complex are useful examples of such callables.  If None,\n        str is used.\n\n    - choices -- A container of values that should be allowed. If not None,\n        after a command-line argument has been converted to the appropriate\n        type, an exception will be raised if it is not a member of this\n        collection.\n\n    - required -- True if the action must always be specified at the\n        command line. This is only meaningful for optional command-line\n        arguments.\n\n    - help -- The help string describing the argument.\n\n    - metavar -- The name to be used for the option's argument with the\n        help string. If None, the 'dest' value will be used as the name.",
      "relationships": [
        {
          "target": "Action",
          "type": "base_class"
        },
        {
          "target": "_AttributeHolder",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.argparse.FileType",
      "name": "FileType",
      "module": "argparse",
      "type": "class",
      "signature": "(mode='r', bufsize=-1, encoding=None, errors=None)",
      "description": "Factory for creating file object types\n\nInstances of FileType are typically passed as type= arguments to the\nArgumentParser add_argument() method.\n\nKeyword Arguments:\n    - mode -- A string indicating how the file is to be opened. Accepts the\n        same values as the builtin open() function.\n    - bufsize -- The file's desired buffer size. Accepts the same values as\n        the builtin open() function.\n    - encoding -- The file's encoding. Accepts the same values as the\n        builtin open() function.\n    - errors -- A string indicating how encoding and decoding errors are to\n        be handled. Accepts the same value as the builtin open() function.",
      "relationships": []
    },
    {
      "id": "stdlib.argparse.HelpFormatter",
      "name": "HelpFormatter",
      "module": "argparse",
      "type": "class",
      "signature": "(prog, indent_increment=2, max_help_position=24, width=None)",
      "description": "Formatter for generating usage messages and argument help strings.\n\nOnly the name of this class is considered a public API. All the methods\nprovided by the class are considered an implementation detail.",
      "relationships": []
    },
    {
      "id": "stdlib.argparse.MetavarTypeHelpFormatter",
      "name": "MetavarTypeHelpFormatter",
      "module": "argparse",
      "type": "class",
      "signature": "(prog, indent_increment=2, max_help_position=24, width=None)",
      "description": "Help message formatter which uses the argument 'type' as the default\nmetavar value (instead of the argument 'dest')\n\nOnly the name of this class is considered a public API. All the methods\nprovided by the class are considered an implementation detail.",
      "relationships": [
        {
          "target": "HelpFormatter",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.argparse.Namespace",
      "name": "Namespace",
      "module": "argparse",
      "type": "class",
      "signature": "(**kwargs)",
      "description": "Simple object for storing attributes.\n\nImplements equality by attribute names and values, and provides a simple\nstring representation.",
      "relationships": [
        {
          "target": "_AttributeHolder",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.argparse.RawDescriptionHelpFormatter",
      "name": "RawDescriptionHelpFormatter",
      "module": "argparse",
      "type": "class",
      "signature": "(prog, indent_increment=2, max_help_position=24, width=None)",
      "description": "Help message formatter which retains any formatting in descriptions.\n\nOnly the name of this class is considered a public API. All the methods\nprovided by the class are considered an implementation detail.",
      "relationships": [
        {
          "target": "HelpFormatter",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.argparse.RawTextHelpFormatter",
      "name": "RawTextHelpFormatter",
      "module": "argparse",
      "type": "class",
      "signature": "(prog, indent_increment=2, max_help_position=24, width=None)",
      "description": "Help message formatter which retains formatting of all help text.\n\nOnly the name of this class is considered a public API. All the methods\nprovided by the class are considered an implementation detail.",
      "relationships": [
        {
          "target": "RawDescriptionHelpFormatter",
          "type": "base_class"
        },
        {
          "target": "HelpFormatter",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.argparse.ngettext",
      "name": "ngettext",
      "module": "argparse",
      "type": "function",
      "signature": "(msgid1, msgid2, n)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.argparse.dngettext",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ast.Bytes",
      "name": "Bytes",
      "module": "ast",
      "type": "class",
      "signature": "(*args, **kwargs)",
      "description": "Deprecated AST node class. Use ast.Constant instead",
      "relationships": [
        {
          "target": "Constant",
          "type": "base_class"
        },
        {
          "target": "expr",
          "type": "base_class"
        },
        {
          "target": "AST",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.ast.Ellipsis",
      "name": "Ellipsis",
      "module": "ast",
      "type": "class",
      "signature": "(*args, **kwargs)",
      "description": "Deprecated AST node class. Use ast.Constant instead",
      "relationships": [
        {
          "target": "Constant",
          "type": "base_class"
        },
        {
          "target": "expr",
          "type": "base_class"
        },
        {
          "target": "AST",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.ast.ExtSlice",
      "name": "ExtSlice",
      "module": "ast",
      "type": "class",
      "signature": "(dims=(), **kwargs)",
      "description": "Deprecated AST node class. Use ast.Tuple instead.",
      "relationships": [
        {
          "target": "slice",
          "type": "base_class"
        },
        {
          "target": "AST",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.ast.Index",
      "name": "Index",
      "module": "ast",
      "type": "class",
      "signature": "(value, **kwargs)",
      "description": "Deprecated AST node class. Use the index value directly instead.",
      "relationships": [
        {
          "target": "slice",
          "type": "base_class"
        },
        {
          "target": "AST",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.ast.IntEnum",
      "name": "IntEnum",
      "module": "ast",
      "type": "class",
      "signature": "(value, names=None, *, module=None, qualname=None, type=None, start=1)",
      "description": "Enum where members are also (and must be) ints",
      "relationships": [
        {
          "target": "int",
          "type": "base_class"
        },
        {
          "target": "Enum",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.ast.NameConstant",
      "name": "NameConstant",
      "module": "ast",
      "type": "class",
      "signature": "(*args, **kwargs)",
      "description": "Deprecated AST node class. Use ast.Constant instead",
      "relationships": [
        {
          "target": "Constant",
          "type": "base_class"
        },
        {
          "target": "expr",
          "type": "base_class"
        },
        {
          "target": "AST",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.ast.NodeTransformer",
      "name": "NodeTransformer",
      "module": "ast",
      "type": "class",
      "signature": "()",
      "description": "A :class:`NodeVisitor` subclass that walks the abstract syntax tree and\nallows modification of nodes.\n\nThe `NodeTransformer` will walk the AST and use the return value of the\nvisitor methods to replace or remove the old node.  If the return value of\nthe visitor method is ``None``, the node will be removed from its location,\notherwise it is replaced with the return value.  The return value may be the\noriginal node in which case no replacement takes place.\n\nHere is an example transformer that rewrites all occurrences of name lookups\n(``foo``) to ``data['foo']``::\n\n   class RewriteName(NodeTransformer):\n\n       def visit_Name(self, node):\n           return Subscript(\n               value=Name(id='data', ctx=Load()),\n               slice=Constant(value=node.id),\n               ctx=node.ctx\n           )\n\nKeep in mind that if the node you're operating on has child nodes you must\neither transform the child nodes yourself or call the :meth:`generic_visit`\nmethod for the node first.\n\nFor nodes that were part of a collection of statements (that applies to all\nstatement nodes), the visitor may also return a list of nodes rather than\njust a single node.\n\nUsually you use the transformer like this::\n\n   node = YourTransformer().visit(node)",
      "relationships": [
        {
          "target": "NodeVisitor",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.ast.NodeVisitor",
      "name": "NodeVisitor",
      "module": "ast",
      "type": "class",
      "signature": "()",
      "description": "A node visitor base class that walks the abstract syntax tree and calls a\nvisitor function for every node found.  This function may return a value\nwhich is forwarded by the `visit` method.\n\nThis class is meant to be subclassed, with the subclass adding visitor\nmethods.\n\nPer default the visitor functions for the nodes are ``'visit_'`` +\nclass name of the node.  So a `TryFinally` node visit function would\nbe `visit_TryFinally`.  This behavior can be changed by overriding\nthe `visit` method.  If no visitor function exists for a node\n(return value `None`) the `generic_visit` visitor is used instead.\n\nDon't use the `NodeVisitor` if you want to apply changes to nodes during\ntraversing.  For this a special visitor exists (`NodeTransformer`) that\nallows modifications.",
      "relationships": []
    },
    {
      "id": "stdlib.ast.Num",
      "name": "Num",
      "module": "ast",
      "type": "class",
      "signature": "(*args, **kwargs)",
      "description": "Deprecated AST node class. Use ast.Constant instead",
      "relationships": [
        {
          "target": "Constant",
          "type": "base_class"
        },
        {
          "target": "expr",
          "type": "base_class"
        },
        {
          "target": "AST",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.ast.Str",
      "name": "Str",
      "module": "ast",
      "type": "class",
      "signature": "(*args, **kwargs)",
      "description": "Deprecated AST node class. Use ast.Constant instead",
      "relationships": [
        {
          "target": "Constant",
          "type": "base_class"
        },
        {
          "target": "expr",
          "type": "base_class"
        },
        {
          "target": "AST",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.ast.auto",
      "name": "auto",
      "module": "ast",
      "type": "class",
      "signature": "()",
      "description": "Instances are replaced with an appropriate value in Enum class suites.",
      "relationships": []
    },
    {
      "id": "stdlib.ast.contextmanager",
      "name": "contextmanager",
      "module": "ast",
      "type": "function",
      "signature": "(func)",
      "description": "@contextmanager decorator.\n\nTypical usage:\n\n    @contextmanager\n    def some_generator(<arguments>):\n        <setup>\n        try:\n            yield <value>\n        finally:\n            <cleanup>\n\nThis makes this:\n\n    with some_generator(<arguments>) as <variable>:\n        <body>\n\nequivalent to this:\n\n    <setup>\n    try:\n        <variable> = <value>\n        <body>\n    finally:\n        <cleanup>",
      "relationships": [
        {
          "target": "stdlib.ast.wraps",
          "type": "calls"
        },
        {
          "target": "stdlib.ast._GeneratorContextManager",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ast.copy_location",
      "name": "copy_location",
      "module": "ast",
      "type": "function",
      "signature": "(new_node, old_node)",
      "description": "Copy source location (`lineno`, `col_offset`, `end_lineno`, and `end_col_offset`\nattributes) from *old_node* to *new_node* if possible, and return *new_node*.",
      "relationships": [
        {
          "target": "stdlib.ast.getattr",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.setattr",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.hasattr",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.startswith",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ast.dump",
      "name": "dump",
      "module": "ast",
      "type": "function",
      "signature": "(node, annotate_fields=True, include_attributes=False, *, indent=None)",
      "description": "Return a formatted dump of the tree in node.  This is mainly useful for\ndebugging purposes.  If annotate_fields is true (by default),\nthe returned string will show the names and the values for fields.\nIf annotate_fields is false, the result string will be more compact by\nomitting unambiguous field names.  Attributes such as line\nnumbers and column offsets are not dumped by default.  If this is wanted,\ninclude_attributes can be set to true.  If indent is a non-negative\ninteger or string, then the tree will be pretty-printed with that indent\nlevel. None (the default) selects the single line representation.",
      "relationships": [
        {
          "target": "stdlib.ast.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.ast._format",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.type",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.repr",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.ast._format",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.getattr",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.append",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.append",
          "type": "calls"
        },
        {
          "target": "stdlib.ast._format",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.append",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.len",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.getattr",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.getattr",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.join",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.getattr",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.join",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.join",
          "type": "calls"
        },
        {
          "target": "stdlib.ast._format",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ast.fix_missing_locations",
      "name": "fix_missing_locations",
      "module": "ast",
      "type": "function",
      "signature": "(node)",
      "description": "When you compile a node tree with compile(), the compiler expects lineno and\ncol_offset attributes for every node that supports them.  This is rather\ntedious to fill in for generated nodes, so this helper adds these attributes\nrecursively where not already set, by setting them to the values of the\nparent node.  It works recursively starting at *node*.",
      "relationships": [
        {
          "target": "stdlib.ast._fix",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.iter_child_nodes",
          "type": "calls"
        },
        {
          "target": "stdlib.ast._fix",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.hasattr",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.getattr",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.hasattr",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.getattr",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ast.get_docstring",
      "name": "get_docstring",
      "module": "ast",
      "type": "function",
      "signature": "(node, clean=True)",
      "description": "Return the docstring for the given node or None if no docstring can\nbe found.  If the node provided does not have docstrings a TypeError\nwill be raised.\n\nIf *clean* is `True`, all tabs are expanded to spaces and any whitespace\nthat can be uniformly removed from the second line onwards is removed.",
      "relationships": [
        {
          "target": "stdlib.ast.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.cleandoc",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.isinstance",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ast.get_source_segment",
      "name": "get_source_segment",
      "module": "ast",
      "type": "function",
      "signature": "(source, node, *, padded=False)",
      "description": "Get source code segment of the *source* that generated *node*.\n\nIf some location information (`lineno`, `end_lineno`, `col_offset`,\nor `end_col_offset`) is missing, return None.\n\nIf *padded* is `True`, the first line of a multi-line statement will\nbe padded with spaces to match its original position.",
      "relationships": [
        {
          "target": "stdlib.ast._splitlines_no_ff",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.decode",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.insert",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.append",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.join",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.decode",
          "type": "calls"
        },
        {
          "target": "stdlib.ast._pad_whitespace",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.decode",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.decode",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.encode",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.encode",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.encode",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.encode",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ast.increment_lineno",
      "name": "increment_lineno",
      "module": "ast",
      "type": "function",
      "signature": "(node, n=1)",
      "description": "Increment the line number and end line number of each node in the tree\nstarting at *node* by *n*. This is useful to \"move code\" to a different\nlocation in a file.",
      "relationships": [
        {
          "target": "stdlib.ast.walk",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.getattr",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.getattr",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ast.iter_child_nodes",
      "name": "iter_child_nodes",
      "module": "ast",
      "type": "function",
      "signature": "(node)",
      "description": "Yield all direct child nodes of *node*, that is, all fields that are nodes\nand all items of fields that are lists of nodes.",
      "relationships": [
        {
          "target": "stdlib.ast.iter_fields",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.isinstance",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ast.iter_fields",
      "name": "iter_fields",
      "module": "ast",
      "type": "function",
      "signature": "(node)",
      "description": "Yield a tuple of ``(fieldname, value)`` for each field in ``node._fields``\nthat is present on *node*.",
      "relationships": [
        {
          "target": "stdlib.ast.getattr",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ast.literal_eval",
      "name": "literal_eval",
      "module": "ast",
      "type": "function",
      "signature": "(node_or_string)",
      "description": "Safely evaluate an expression node or a string containing a Python\nexpression.  The string or node provided may only consist of the following\nPython literal structures: strings, bytes, numbers, tuples, lists, dicts,\nsets, booleans, and None.",
      "relationships": [
        {
          "target": "stdlib.ast.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.ast._convert",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.parse",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.ast._convert_num",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.ast._convert_signed_num",
          "type": "calls"
        },
        {
          "target": "stdlib.ast._raise_malformed_node",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.ast._convert_num",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.type",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.tuple",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.map",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.list",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.map",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.set",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.map",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.set",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.dict",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.len",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.len",
          "type": "calls"
        },
        {
          "target": "stdlib.ast._raise_malformed_node",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.zip",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.ast._convert_signed_num",
          "type": "calls"
        },
        {
          "target": "stdlib.ast._convert_num",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.map",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.map",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.isinstance",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ast.main",
      "name": "main",
      "module": "ast",
      "type": "function",
      "signature": "()",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.ast.ArgumentParser",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.add_argument",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.add_argument",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.add_argument",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.add_argument",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.add_argument",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.parse_args",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.parse",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.print",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.read",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.dump",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.FileType",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ast.nullcontext",
      "name": "nullcontext",
      "module": "ast",
      "type": "class",
      "signature": "(enter_result=None)",
      "description": "Context manager that does no additional processing.\n\nUsed as a stand-in for a normal context manager, when a particular\nblock of code is only sometimes used with a normal context manager:\n\ncm = optional_cm if condition else nullcontext()\nwith cm:\n    # Perform operation, using optional_cm if condition is True",
      "relationships": [
        {
          "target": "AbstractContextManager",
          "type": "base_class"
        },
        {
          "target": "ABC",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.ast.parse",
      "name": "parse",
      "module": "ast",
      "type": "function",
      "signature": "(source, filename='<unknown>', mode='exec', *, type_comments=False, feature_version=None)",
      "description": "Parse the source into an AST node.\nEquivalent to compile(source, filename, mode, PyCF_ONLY_AST).\nPass type_comments=True to get back type comments where the syntax allows.",
      "relationships": [
        {
          "target": "stdlib.ast.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.compile",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ast.unparse",
      "name": "unparse",
      "module": "ast",
      "type": "function",
      "signature": "(ast_obj)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.ast._Unparser",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.visit",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ast.walk",
      "name": "walk",
      "module": "ast",
      "type": "function",
      "signature": "(node)",
      "description": "Recursively yield all descendant nodes in the tree starting at *node*\n(including *node* itself), in no specified order.  This is useful if you\nonly want to modify nodes in place and don't care about the context.",
      "relationships": [
        {
          "target": "stdlib.ast.deque",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.popleft",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.extend",
          "type": "calls"
        },
        {
          "target": "stdlib.ast.iter_child_nodes",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.asynchat.async_chat",
      "name": "async_chat",
      "module": "asynchat",
      "type": "class",
      "signature": "(sock=None, map=None)",
      "description": "This is an abstract class.  You must derive from this class, and add\nthe two methods collect_incoming_data() and found_terminator()",
      "relationships": [
        {
          "target": "dispatcher",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.asynchat.find_prefix_at_end",
      "name": "find_prefix_at_end",
      "module": "asynchat",
      "type": "function",
      "signature": "(haystack, needle)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.asynchat.len",
          "type": "calls"
        },
        {
          "target": "stdlib.asynchat.endswith",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.asynchat.simple_producer",
      "name": "simple_producer",
      "module": "asynchat",
      "type": "class",
      "signature": "(data, buffer_size=512)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.asyncio.AbstractChildWatcher",
      "name": "AbstractChildWatcher",
      "module": "asyncio",
      "type": "class",
      "signature": "()",
      "description": "Abstract base class for monitoring child processes.\n\nObjects derived from this class monitor a collection of subprocesses and\nreport their termination or interruption by a signal.\n\nNew callbacks are registered with .add_child_handler(). Starting a new\nprocess must be done within a 'with' block to allow the watcher to suspend\nits activity until the new process if fully registered (this is needed to\nprevent a race condition in some implementations).\n\nExample:\n    with watcher:\n        proc = subprocess.Popen(\"sleep 1\")\n        watcher.add_child_handler(proc.pid, callback)\n\nNotes:\n    Implementations of this class must be thread-safe.\n\n    Since child watcher objects may catch the SIGCHLD signal and call\n    waitpid(-1), there should be only one active object per process.",
      "relationships": []
    },
    {
      "id": "stdlib.asyncio.AbstractEventLoop",
      "name": "AbstractEventLoop",
      "module": "asyncio",
      "type": "class",
      "signature": "()",
      "description": "Abstract event loop.",
      "relationships": []
    },
    {
      "id": "stdlib.asyncio.AbstractEventLoopPolicy",
      "name": "AbstractEventLoopPolicy",
      "module": "asyncio",
      "type": "class",
      "signature": "()",
      "description": "Abstract policy for accessing the event loop.",
      "relationships": []
    },
    {
      "id": "stdlib.asyncio.AbstractServer",
      "name": "AbstractServer",
      "module": "asyncio",
      "type": "class",
      "signature": "()",
      "description": "Abstract server returned by create_server().",
      "relationships": []
    },
    {
      "id": "stdlib.asyncio.BaseEventLoop",
      "name": "BaseEventLoop",
      "module": "asyncio",
      "type": "class",
      "signature": "()",
      "description": "Abstract event loop.",
      "relationships": [
        {
          "target": "AbstractEventLoop",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.asyncio.BaseProtocol",
      "name": "BaseProtocol",
      "module": "asyncio",
      "type": "class",
      "signature": "()",
      "description": "Common base class for protocol interfaces.\n\nUsually user implements protocols that derived from BaseProtocol\nlike Protocol or ProcessProtocol.\n\nThe only case when BaseProtocol should be implemented directly is\nwrite-only transport like write pipe",
      "relationships": []
    },
    {
      "id": "stdlib.asyncio.BaseTransport",
      "name": "BaseTransport",
      "module": "asyncio",
      "type": "class",
      "signature": "(extra=None)",
      "description": "Base class for transports.",
      "relationships": []
    },
    {
      "id": "stdlib.asyncio.BoundedSemaphore",
      "name": "BoundedSemaphore",
      "module": "asyncio",
      "type": "class",
      "signature": "(value=1, *, loop=None)",
      "description": "A bounded semaphore implementation.\n\nThis raises ValueError in release() if it would increase the value\nabove the initial value.",
      "relationships": [
        {
          "target": "Semaphore",
          "type": "base_class"
        },
        {
          "target": "_ContextManagerMixin",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.asyncio.BufferedProtocol",
      "name": "BufferedProtocol",
      "module": "asyncio",
      "type": "class",
      "signature": "()",
      "description": "Interface for stream protocol with manual buffer control.\n\nImportant: this has been added to asyncio in Python 3.7\n*on a provisional basis*!  Consider it as an experimental API that\nmight be changed or removed in Python 3.8.\n\nEvent methods, such as `create_server` and `create_connection`,\naccept factories that return protocols that implement this interface.\n\nThe idea of BufferedProtocol is that it allows to manually allocate\nand control the receive buffer.  Event loops can then use the buffer\nprovided by the protocol to avoid unnecessary data copies.  This\ncan result in noticeable performance improvement for protocols that\nreceive big amounts of data.  Sophisticated protocols can allocate\nthe buffer only once at creation time.\n\nState machine of calls:\n\n  start -> CM [-> GB [-> BU?]]* [-> ER?] -> CL -> end\n\n* CM: connection_made()\n* GB: get_buffer()\n* BU: buffer_updated()\n* ER: eof_received()\n* CL: connection_lost()",
      "relationships": [
        {
          "target": "BaseProtocol",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.asyncio.Condition",
      "name": "Condition",
      "module": "asyncio",
      "type": "class",
      "signature": "(lock=None, *, loop=None)",
      "description": "Asynchronous equivalent to threading.Condition.\n\nThis class implements condition variable objects. A condition variable\nallows one or more coroutines to wait until they are notified by another\ncoroutine.\n\nA new Lock object is created and used as the underlying lock.",
      "relationships": [
        {
          "target": "_ContextManagerMixin",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.asyncio.DatagramProtocol",
      "name": "DatagramProtocol",
      "module": "asyncio",
      "type": "class",
      "signature": "()",
      "description": "Interface for datagram protocol.",
      "relationships": [
        {
          "target": "BaseProtocol",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.asyncio.DatagramTransport",
      "name": "DatagramTransport",
      "module": "asyncio",
      "type": "class",
      "signature": "(extra=None)",
      "description": "Interface for datagram (UDP) transports.",
      "relationships": [
        {
          "target": "BaseTransport",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.asyncio.DefaultEventLoopPolicy",
      "name": "DefaultEventLoopPolicy",
      "module": "asyncio",
      "type": "class",
      "signature": "()",
      "description": "UNIX event loop policy with a watcher for child processes.",
      "relationships": [
        {
          "target": "BaseDefaultEventLoopPolicy",
          "type": "base_class"
        },
        {
          "target": "AbstractEventLoopPolicy",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.asyncio.Event",
      "name": "Event",
      "module": "asyncio",
      "type": "class",
      "signature": "(*, loop=None)",
      "description": "Asynchronous equivalent to threading.Event.\n\nClass implementing event objects. An event manages a flag that can be set\nto true with the set() method and reset to false with the clear() method.\nThe wait() method blocks until the flag is true. The flag is initially\nfalse.",
      "relationships": []
    },
    {
      "id": "stdlib.asyncio.FastChildWatcher",
      "name": "FastChildWatcher",
      "module": "asyncio",
      "type": "class",
      "signature": "()",
      "description": "'Fast' child watcher implementation.\n\nThis implementation reaps every terminated processes by calling\nos.waitpid(-1) directly, possibly breaking other code spawning processes\nand waiting for their termination.\n\nThere is no noticeable overhead when handling a big number of children\n(O(1) each time a child terminates).",
      "relationships": [
        {
          "target": "BaseChildWatcher",
          "type": "base_class"
        },
        {
          "target": "AbstractChildWatcher",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.asyncio.Future",
      "name": "Future",
      "module": "asyncio",
      "type": "class",
      "signature": "(*, loop=None)",
      "description": "This class is *almost* compatible with concurrent.futures.Future.\n\nDifferences:\n\n- result() and exception() do not take a timeout argument and\n  raise an exception when the future isn't done yet.\n\n- Callbacks registered with add_done_callback() are always called\n  via the event loop's call_soon_threadsafe().\n\n- This class is not compatible with the wait() and as_completed()\n  methods in the concurrent.futures package.",
      "relationships": []
    },
    {
      "id": "stdlib.asyncio.Handle",
      "name": "Handle",
      "module": "asyncio",
      "type": "class",
      "signature": "(callback, args, loop, context=None)",
      "description": "Object returned by callback registration methods.",
      "relationships": []
    },
    {
      "id": "stdlib.asyncio.IncompleteReadError",
      "name": "IncompleteReadError",
      "module": "asyncio",
      "type": "class",
      "signature": "(partial, expected)",
      "description": "Incomplete read error. Attributes:\n\n- partial: read bytes string before the end of stream was reached\n- expected: total number of expected bytes (or None if unknown)",
      "relationships": [
        {
          "target": "EOFError",
          "type": "base_class"
        },
        {
          "target": "Exception",
          "type": "base_class"
        },
        {
          "target": "BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.asyncio.LifoQueue",
      "name": "LifoQueue",
      "module": "asyncio",
      "type": "class",
      "signature": "(maxsize=0, *, loop=None)",
      "description": "A subclass of Queue that retrieves most recently added entries first.",
      "relationships": [
        {
          "target": "Queue",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.asyncio.LimitOverrunError",
      "name": "LimitOverrunError",
      "module": "asyncio",
      "type": "class",
      "signature": "(message, consumed)",
      "description": "Reached the buffer limit while looking for a separator.\n\nAttributes:\n- consumed: total number of to be consumed bytes.",
      "relationships": [
        {
          "target": "Exception",
          "type": "base_class"
        },
        {
          "target": "BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.asyncio.Lock",
      "name": "Lock",
      "module": "asyncio",
      "type": "class",
      "signature": "(*, loop=None)",
      "description": "Primitive lock objects.\n\nA primitive lock is a synchronization primitive that is not owned\nby a particular coroutine when locked.  A primitive lock is in one\nof two states, 'locked' or 'unlocked'.\n\nIt is created in the unlocked state.  It has two basic methods,\nacquire() and release().  When the state is unlocked, acquire()\nchanges the state to locked and returns immediately.  When the\nstate is locked, acquire() blocks until a call to release() in\nanother coroutine changes it to unlocked, then the acquire() call\nresets it to locked and returns.  The release() method should only\nbe called in the locked state; it changes the state to unlocked\nand returns immediately.  If an attempt is made to release an\nunlocked lock, a RuntimeError will be raised.\n\nWhen more than one coroutine is blocked in acquire() waiting for\nthe state to turn to unlocked, only one coroutine proceeds when a\nrelease() call resets the state to unlocked; first coroutine which\nis blocked in acquire() is being processed.\n\nacquire() is a coroutine and should be called with 'await'.\n\nLocks also support the asynchronous context management protocol.\n'async with lock' statement should be used.\n\nUsage:\n\n    lock = Lock()\n    ...\n    await lock.acquire()\n    try:\n        ...\n    finally:\n        lock.release()\n\nContext manager usage:\n\n    lock = Lock()\n    ...\n    async with lock:\n         ...\n\nLock objects can be tested for locking state:\n\n    if not lock.locked():\n       await lock.acquire()\n    else:\n       # lock is acquired\n       ...",
      "relationships": [
        {
          "target": "_ContextManagerMixin",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.asyncio.MultiLoopChildWatcher",
      "name": "MultiLoopChildWatcher",
      "module": "asyncio",
      "type": "class",
      "signature": "()",
      "description": "A watcher that doesn't require running loop in the main thread.\n\nThis implementation registers a SIGCHLD signal handler on\ninstantiation (which may conflict with other code that\ninstall own handler for this signal).\n\nThe solution is safe but it has a significant overhead when\nhandling a big number of processes (*O(n)* each time a\nSIGCHLD is received).",
      "relationships": [
        {
          "target": "AbstractChildWatcher",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.asyncio.PidfdChildWatcher",
      "name": "PidfdChildWatcher",
      "module": "asyncio",
      "type": "class",
      "signature": "()",
      "description": "Child watcher implementation using Linux's pid file descriptors.\n\nThis child watcher polls process file descriptors (pidfds) to await child\nprocess termination. In some respects, PidfdChildWatcher is a \"Goldilocks\"\nchild watcher implementation. It doesn't require signals or threads, doesn't\ninterfere with any processes launched outside the event loop, and scales\nlinearly with the number of subprocesses launched by the event loop. The\nmain disadvantage is that pidfds are specific to Linux, and only work on\nrecent (5.3+) kernels.",
      "relationships": [
        {
          "target": "AbstractChildWatcher",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.asyncio.PriorityQueue",
      "name": "PriorityQueue",
      "module": "asyncio",
      "type": "class",
      "signature": "(maxsize=0, *, loop=None)",
      "description": "A subclass of Queue; retrieves entries in priority order (lowest first).\n\nEntries are typically tuples of the form: (priority number, data).",
      "relationships": [
        {
          "target": "Queue",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.asyncio.Protocol",
      "name": "Protocol",
      "module": "asyncio",
      "type": "class",
      "signature": "()",
      "description": "Interface for stream protocol.\n\nThe user should implement this interface.  They can inherit from\nthis class but don't need to.  The implementations here do\nnothing (they don't raise exceptions).\n\nWhen the user wants to requests a transport, they pass a protocol\nfactory to a utility function (e.g., EventLoop.create_connection()).\n\nWhen the connection is made successfully, connection_made() is\ncalled with a suitable transport object.  Then data_received()\nwill be called 0 or more times with data (bytes) received from the\ntransport; finally, connection_lost() will be called exactly once\nwith either an exception object or None as an argument.\n\nState machine of calls:\n\n  start -> CM [-> DR*] [-> ER?] -> CL -> end\n\n* CM: connection_made()\n* DR: data_received()\n* ER: eof_received()\n* CL: connection_lost()",
      "relationships": [
        {
          "target": "BaseProtocol",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.asyncio.Queue",
      "name": "Queue",
      "module": "asyncio",
      "type": "class",
      "signature": "(maxsize=0, *, loop=None)",
      "description": "A queue, useful for coordinating producer and consumer coroutines.\n\nIf maxsize is less than or equal to zero, the queue size is infinite. If it\nis an integer greater than 0, then \"await put()\" will block when the\nqueue reaches maxsize, until an item is removed by get().\n\nUnlike the standard library Queue, you can reliably know this Queue's size\nwith qsize(), since your single-threaded asyncio application won't be\ninterrupted between calling qsize() and doing an operation on the Queue.",
      "relationships": []
    },
    {
      "id": "stdlib.asyncio.ReadTransport",
      "name": "ReadTransport",
      "module": "asyncio",
      "type": "class",
      "signature": "(extra=None)",
      "description": "Interface for read-only transports.",
      "relationships": [
        {
          "target": "BaseTransport",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.asyncio.SafeChildWatcher",
      "name": "SafeChildWatcher",
      "module": "asyncio",
      "type": "class",
      "signature": "()",
      "description": "'Safe' child watcher implementation.\n\nThis implementation avoids disrupting other code spawning processes by\npolling explicitly each process in the SIGCHLD handler instead of calling\nos.waitpid(-1).\n\nThis is a safe solution but it has a significant overhead when handling a\nbig number of children (O(n) each time SIGCHLD is raised)",
      "relationships": [
        {
          "target": "BaseChildWatcher",
          "type": "base_class"
        },
        {
          "target": "AbstractChildWatcher",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.asyncio.SelectorEventLoop",
      "name": "SelectorEventLoop",
      "module": "asyncio",
      "type": "class",
      "signature": "(selector=None)",
      "description": "Unix event loop.\n\nAdds signal handling and UNIX Domain Socket support to SelectorEventLoop.",
      "relationships": [
        {
          "target": "BaseSelectorEventLoop",
          "type": "base_class"
        },
        {
          "target": "BaseEventLoop",
          "type": "base_class"
        },
        {
          "target": "AbstractEventLoop",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.asyncio.Semaphore",
      "name": "Semaphore",
      "module": "asyncio",
      "type": "class",
      "signature": "(value=1, *, loop=None)",
      "description": "A Semaphore implementation.\n\nA semaphore manages an internal counter which is decremented by each\nacquire() call and incremented by each release() call. The counter\ncan never go below zero; when acquire() finds that it is zero, it blocks,\nwaiting until some other thread calls release().\n\nSemaphores also support the context management protocol.\n\nThe optional argument gives the initial value for the internal\ncounter; it defaults to 1. If the value given is less than 0,\nValueError is raised.",
      "relationships": [
        {
          "target": "_ContextManagerMixin",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.asyncio.StreamReader",
      "name": "StreamReader",
      "module": "asyncio",
      "type": "class",
      "signature": "(limit=65536, loop=None)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.asyncio.StreamReaderProtocol",
      "name": "StreamReaderProtocol",
      "module": "asyncio",
      "type": "class",
      "signature": "(stream_reader, client_connected_cb=None, loop=None)",
      "description": "Helper class to adapt between Protocol and StreamReader.\n\n(This is a helper class instead of making StreamReader itself a\nProtocol subclass, because the StreamReader has other potential\nuses, and to prevent the user of the StreamReader to accidentally\ncall inappropriate methods of the protocol.)",
      "relationships": [
        {
          "target": "FlowControlMixin",
          "type": "base_class"
        },
        {
          "target": "Protocol",
          "type": "base_class"
        },
        {
          "target": "BaseProtocol",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.asyncio.StreamWriter",
      "name": "StreamWriter",
      "module": "asyncio",
      "type": "class",
      "signature": "(transport, protocol, reader, loop)",
      "description": "Wraps a Transport.\n\nThis exposes write(), writelines(), [can_]write_eof(),\nget_extra_info() and close().  It adds drain() which returns an\noptional Future on which you can wait for flow control.  It also\nadds a transport property which references the Transport\ndirectly.",
      "relationships": []
    },
    {
      "id": "stdlib.asyncio.SubprocessProtocol",
      "name": "SubprocessProtocol",
      "module": "asyncio",
      "type": "class",
      "signature": "()",
      "description": "Interface for protocol for subprocess calls.",
      "relationships": [
        {
          "target": "BaseProtocol",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.asyncio.SubprocessTransport",
      "name": "SubprocessTransport",
      "module": "asyncio",
      "type": "class",
      "signature": "(extra=None)",
      "description": "Base class for transports.",
      "relationships": [
        {
          "target": "BaseTransport",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.asyncio.Task",
      "name": "Task",
      "module": "asyncio",
      "type": "class",
      "signature": "(coro, *, loop=None, name=None)",
      "description": "A coroutine wrapped in a Future.",
      "relationships": [
        {
          "target": "Future",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.asyncio.ThreadedChildWatcher",
      "name": "ThreadedChildWatcher",
      "module": "asyncio",
      "type": "class",
      "signature": "()",
      "description": "Threaded child watcher implementation.\n\nThe watcher uses a thread per process\nfor waiting for the process finish.\n\nIt doesn't require subscription on POSIX signal\nbut a thread creation is not free.\n\nThe watcher has O(1) complexity, its performance doesn't depend\non amount of spawn processes.",
      "relationships": [
        {
          "target": "AbstractChildWatcher",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.asyncio.TimerHandle",
      "name": "TimerHandle",
      "module": "asyncio",
      "type": "class",
      "signature": "(when, callback, args, loop, context=None)",
      "description": "Object returned by timed callback registration methods.",
      "relationships": [
        {
          "target": "Handle",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.asyncio.Transport",
      "name": "Transport",
      "module": "asyncio",
      "type": "class",
      "signature": "(extra=None)",
      "description": "Interface representing a bidirectional transport.\n\nThere may be several implementations, but typically, the user does\nnot implement new transports; rather, the platform provides some\nuseful transports that are implemented using the platform's best\npractices.\n\nThe user never instantiates a transport directly; they call a\nutility function, passing it a protocol factory and other\ninformation necessary to create the transport and protocol.  (E.g.\nEventLoop.create_connection() or EventLoop.create_server().)\n\nThe utility function will asynchronously create a transport and a\nprotocol and hook them up by calling the protocol's\nconnection_made() method, passing it the transport.\n\nThe implementation here raises NotImplemented for every method\nexcept writelines(), which calls write() in a loop.",
      "relationships": [
        {
          "target": "ReadTransport",
          "type": "base_class"
        },
        {
          "target": "WriteTransport",
          "type": "base_class"
        },
        {
          "target": "BaseTransport",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.asyncio.WriteTransport",
      "name": "WriteTransport",
      "module": "asyncio",
      "type": "class",
      "signature": "(extra=None)",
      "description": "Interface for write-only transports.",
      "relationships": [
        {
          "target": "BaseTransport",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.asyncio.all_tasks",
      "name": "all_tasks",
      "module": "asyncio",
      "type": "function",
      "signature": "(loop=None)",
      "description": "Return a set of all tasks for the loop.",
      "relationships": [
        {
          "target": "stdlib.asyncio.get_running_loop",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.list",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio._get_loop",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.done",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.asyncio.as_completed",
      "name": "as_completed",
      "module": "asyncio",
      "type": "function",
      "signature": "(fs, *, loop=None, timeout=None)",
      "description": "Return an iterator whose values are coroutines.\n\nWhen waiting for the yielded coroutines you'll get the results (or\nexceptions!) of the original Futures (or coroutines), in the order\nin which and as soon as they complete.\n\nThis differs from PEP 3148; the proper way to use this is:\n\n    for f in as_completed(fs):\n        result = await f  # The 'await' may raise.\n        # Use result.\n\nIf a timeout is specified, the 'await' will raise\nTimeoutError when the timeout occurs before all Futures are done.\n\nNote: The futures 'f' are not necessarily members of fs.",
      "relationships": [
        {
          "target": "stdlib.asyncio.Queue",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.range",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.isfuture",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.iscoroutine",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.get_event_loop",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.warn",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.ensure_future",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.clear",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.remove",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.put_nowait",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.result",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.add_done_callback",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.call_later",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.len",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.set",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.remove_done_callback",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.put_nowait",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.cancel",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.get",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio._wait_for_one",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.type",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.asyncio.coroutine",
      "name": "coroutine",
      "module": "asyncio",
      "type": "function",
      "signature": "(func)",
      "description": "Decorator to mark coroutines.\n\nIf the coroutine is not yielded from before it is destroyed,\nan error message is logged.",
      "relationships": [
        {
          "target": "stdlib.asyncio.warn",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.iscoroutinefunction",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.isgeneratorfunction",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.coroutine",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.wraps",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.wraps",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.func",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.CoroWrapper",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.getattr",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.getattr",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.isfuture",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.isgenerator",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.coro",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.await_meth",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.asyncio.create_subprocess_exec",
      "name": "create_subprocess_exec",
      "module": "asyncio",
      "type": "function",
      "signature": "(program, *args, stdin=None, stdout=None, stderr=None, loop=None, limit=65536, **kwds)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.asyncio.Process",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.get_event_loop",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.warn",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.SubprocessStreamProtocol",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.subprocess_exec",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.asyncio.create_subprocess_shell",
      "name": "create_subprocess_shell",
      "module": "asyncio",
      "type": "function",
      "signature": "(cmd, stdin=None, stdout=None, stderr=None, loop=None, limit=65536, **kwds)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.asyncio.Process",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.get_event_loop",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.warn",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.SubprocessStreamProtocol",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.subprocess_shell",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.asyncio.create_task",
      "name": "create_task",
      "module": "asyncio",
      "type": "function",
      "signature": "(coro, *, name=None)",
      "description": "Schedule the execution of a coroutine object in a spawn task.\n\nReturn a Task object.",
      "relationships": [
        {
          "target": "stdlib.asyncio.get_running_loop",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.create_task",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio._set_task_name",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.asyncio.current_task",
      "name": "current_task",
      "module": "asyncio",
      "type": "function",
      "signature": "(loop=None)",
      "description": "Return a currently executed task.",
      "relationships": [
        {
          "target": "stdlib.asyncio.get",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.get_running_loop",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.asyncio.ensure_future",
      "name": "ensure_future",
      "module": "asyncio",
      "type": "function",
      "signature": "(coro_or_future, *, loop=None)",
      "description": "Wrap a coroutine or an awaitable in a future.\n\nIf the argument is a Future, it is returned directly.",
      "relationships": [
        {
          "target": "stdlib.asyncio.iscoroutine",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.create_task",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.isfuture",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.get_event_loop",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.isawaitable",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.ensure_future",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio._get_loop",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio._wrap_awaitable",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.asyncio.gather",
      "name": "gather",
      "module": "asyncio",
      "type": "function",
      "signature": "(*coros_or_futures, loop=None, return_exceptions=False)",
      "description": "Return a future aggregating results from the given coroutines/futures.\n\nCoroutines will be wrapped in a future and scheduled in the event\nloop. They will not necessarily be scheduled in the same order as\npassed in.\n\nAll futures must share the same event loop.  If all the tasks are\ndone successfully, the returned future's result is the list of\nresults (in the order of the original sequence, not necessarily\nthe order of results arrival).  If *return_exceptions* is True,\nexceptions in the tasks are treated the same as successful\nresults, and gathered in the result list; otherwise, the first\nraised exception will be immediately propagated to the returned\nfuture.\n\nCancellation: if the outer Future is cancelled, all children (that\nhave not completed yet) are also cancelled.  If any child is\ncancelled, this is treated as if it raised CancelledError --\nthe outer Future is *not* cancelled in this case.  (This is to\nprevent the cancellation of one child to cause other children to\nbe cancelled.)\n\nIf *return_exceptions* is False, cancelling gather() after it\nhas been marked done won't cancel any submitted awaitables.\nFor instance, gather can be marked done after propagating an\nexception to the caller, therefore, calling ``gather.cancel()``\nafter catching an exception (raised by one of the awaitables) from\ngather won't cancel any other awaitables.",
      "relationships": [
        {
          "target": "stdlib.asyncio._GatheringFuture",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.create_future",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.set_result",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.done",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.append",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.get_event_loop",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.warn",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.cancelled",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.ensure_future",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.add_done_callback",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.cancelled",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.exception",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio._make_cancelled_error",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.set_exception",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.exception",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.cancelled",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.append",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio._make_cancelled_error",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.set_exception",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.set_result",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio._get_loop",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.set_exception",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.CancelledError",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.exception",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.result",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.asyncio.get_child_watcher",
      "name": "get_child_watcher",
      "module": "asyncio",
      "type": "function",
      "signature": "()",
      "description": "Equivalent to calling get_event_loop_policy().get_child_watcher().",
      "relationships": [
        {
          "target": "stdlib.asyncio.get_child_watcher",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.get_event_loop_policy",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.asyncio.get_event_loop_policy",
      "name": "get_event_loop_policy",
      "module": "asyncio",
      "type": "function",
      "signature": "()",
      "description": "Get the current event loop policy.",
      "relationships": [
        {
          "target": "stdlib.asyncio._init_event_loop_policy",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.asyncio.iscoroutine",
      "name": "iscoroutine",
      "module": "asyncio",
      "type": "function",
      "signature": "(obj)",
      "description": "Return True if obj is a coroutine object.",
      "relationships": [
        {
          "target": "stdlib.asyncio.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.type",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.len",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.add",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.type",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.asyncio.iscoroutinefunction",
      "name": "iscoroutinefunction",
      "module": "asyncio",
      "type": "function",
      "signature": "(func)",
      "description": "Return True if func is a decorated coroutine function.",
      "relationships": [
        {
          "target": "stdlib.asyncio.iscoroutinefunction",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.getattr",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.asyncio.isfuture",
      "name": "isfuture",
      "module": "asyncio",
      "type": "function",
      "signature": "(obj)",
      "description": "Check for a Future.\n\nThis returns True when obj is a Future instance or is advertising\nitself as duck-type compatible by setting _asyncio_future_blocking.\nSee comment in Future for more details.",
      "relationships": [
        {
          "target": "stdlib.asyncio.hasattr",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.asyncio.new_event_loop",
      "name": "new_event_loop",
      "module": "asyncio",
      "type": "function",
      "signature": "()",
      "description": "Equivalent to calling get_event_loop_policy().new_event_loop().",
      "relationships": [
        {
          "target": "stdlib.asyncio.new_event_loop",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.get_event_loop_policy",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.asyncio.open_connection",
      "name": "open_connection",
      "module": "asyncio",
      "type": "function",
      "signature": "(host=None, port=None, *, loop=None, limit=65536, **kwds)",
      "description": "A wrapper for create_connection() returning a (reader, writer) pair.\n\nThe reader returned is a StreamReader instance; the writer is a\nStreamWriter instance.\n\nThe arguments are all the usual arguments to create_connection()\nexcept protocol_factory; most common are positional host and port,\nwith various optional keyword arguments following.\n\nAdditional optional keyword arguments are loop (to set the event loop\ninstance to use) and limit (to set the buffer limit passed to the\nStreamReader).\n\n(If you want to customize the StreamReader and/or\nStreamReaderProtocol classes, just copy the code -- there's\nreally nothing special here except some convenience.)",
      "relationships": [
        {
          "target": "stdlib.asyncio.StreamReader",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.StreamReaderProtocol",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.StreamWriter",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.get_event_loop",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.warn",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.create_connection",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.asyncio.open_unix_connection",
      "name": "open_unix_connection",
      "module": "asyncio",
      "type": "function",
      "signature": "(path=None, *, loop=None, limit=65536, **kwds)",
      "description": "Similar to `open_connection` but works with UNIX Domain Sockets.",
      "relationships": [
        {
          "target": "stdlib.asyncio.StreamReader",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.StreamReaderProtocol",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.StreamWriter",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.get_event_loop",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.warn",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.create_unix_connection",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.asyncio.run",
      "name": "run",
      "module": "asyncio",
      "type": "function",
      "signature": "(main, *, debug=None)",
      "description": "Execute the coroutine and return the result.\n\nThis function runs the passed coroutine, taking care of\nmanaging the asyncio event loop and finalizing asynchronous\ngenerators.\n\nThis function cannot be called when another asyncio event loop is\nrunning in the same thread.\n\nIf debug is True, the event loop will be run in debug mode.\n\nThis function always creates a new event loop and closes it at the end.\nIt should be used as a main entry point for asyncio programs, and should\nideally only be called once.\n\nExample:\n\n    async def main():\n        await asyncio.sleep(1)\n        print('hello')\n\n    asyncio.run(main())",
      "relationships": [
        {
          "target": "stdlib.asyncio.new_event_loop",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio._get_running_loop",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.RuntimeError",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.iscoroutine",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.set_event_loop",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.run_until_complete",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.format",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.set_debug",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio._cancel_all_tasks",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.run_until_complete",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.run_until_complete",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.set_event_loop",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.close",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.shutdown_asyncgens",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.shutdown_default_executor",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.asyncio.run_coroutine_threadsafe",
      "name": "run_coroutine_threadsafe",
      "module": "asyncio",
      "type": "function",
      "signature": "(coro, loop)",
      "description": "Submit a coroutine object to a given event loop.\n\nReturn a concurrent.futures.Future to access the result.",
      "relationships": [
        {
          "target": "stdlib.asyncio.Future",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.call_soon_threadsafe",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.iscoroutine",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio._chain_future",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.ensure_future",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.set_running_or_notify_cancel",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.set_exception",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.asyncio.set_child_watcher",
      "name": "set_child_watcher",
      "module": "asyncio",
      "type": "function",
      "signature": "(watcher)",
      "description": "Equivalent to calling\nget_event_loop_policy().set_child_watcher(watcher).",
      "relationships": [
        {
          "target": "stdlib.asyncio.set_child_watcher",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.get_event_loop_policy",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.asyncio.set_event_loop",
      "name": "set_event_loop",
      "module": "asyncio",
      "type": "function",
      "signature": "(loop)",
      "description": "Equivalent to calling get_event_loop_policy().set_event_loop(loop).",
      "relationships": [
        {
          "target": "stdlib.asyncio.set_event_loop",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.get_event_loop_policy",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.asyncio.set_event_loop_policy",
      "name": "set_event_loop_policy",
      "module": "asyncio",
      "type": "function",
      "signature": "(policy)",
      "description": "Set the current event loop policy.\n\nIf policy is None, the default policy is restored.",
      "relationships": [
        {
          "target": "stdlib.asyncio.isinstance",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.asyncio.shield",
      "name": "shield",
      "module": "asyncio",
      "type": "function",
      "signature": "(arg, *, loop=None)",
      "description": "Wait for a future, shielding it from cancellation.\n\nThe statement\n\n    res = await shield(something())\n\nis exactly equivalent to the statement\n\n    res = await something()\n\n*except* that if the coroutine containing it is cancelled, the\ntask running in something() is not cancelled.  From the POV of\nsomething(), the cancellation did not happen.  But its caller is\nstill cancelled, so the yield-from expression still raises\nCancelledError.  Note: If something() is cancelled by other means\nthis will still cancel shield().\n\nIf you want to completely ignore cancellation (not recommended)\nyou can combine shield() with a try/except clause, as follows:\n\n    try:\n        res = await shield(something())\n    except CancelledError:\n        res = None",
      "relationships": [
        {
          "target": "stdlib.asyncio.ensure_future",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.done",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio._get_loop",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.create_future",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.add_done_callback",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.add_done_callback",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.warn",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.cancelled",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.cancelled",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.cancel",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.exception",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.done",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.remove_done_callback",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.cancelled",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.exception",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.set_exception",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.set_result",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.result",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.asyncio.sleep",
      "name": "sleep",
      "module": "asyncio",
      "type": "function",
      "signature": "(delay, result=None, *, loop=None)",
      "description": "Coroutine that completes after a given time (in seconds).",
      "relationships": [
        {
          "target": "stdlib.asyncio.create_future",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.call_later",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.get_running_loop",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.warn",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.cancel",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.__sleep0",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.asyncio.start_server",
      "name": "start_server",
      "module": "asyncio",
      "type": "function",
      "signature": "(client_connected_cb, host=None, port=None, *, loop=None, limit=65536, **kwds)",
      "description": "Start a socket server, call back for each client connected.\n\nThe first parameter, `client_connected_cb`, takes two parameters:\nclient_reader, client_writer.  client_reader is a StreamReader\nobject, while client_writer is a StreamWriter object.  This\nparameter can either be a plain callback function or a coroutine;\nif it is a coroutine, it will be automatically converted into a\nTask.\n\nThe rest of the arguments are all the usual arguments to\nloop.create_server() except protocol_factory; most common are\npositional host and port, with various optional keyword arguments\nfollowing.  The return value is the same as loop.create_server().\n\nAdditional optional keyword arguments are loop (to set the event loop\ninstance to use) and limit (to set the buffer limit passed to the\nStreamReader).\n\nThe return value is the same as loop.create_server(), i.e. a\nServer object which can be used to stop the service.",
      "relationships": [
        {
          "target": "stdlib.asyncio.get_event_loop",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.warn",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.StreamReader",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.StreamReaderProtocol",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.create_server",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.asyncio.start_unix_server",
      "name": "start_unix_server",
      "module": "asyncio",
      "type": "function",
      "signature": "(client_connected_cb, path=None, *, loop=None, limit=65536, **kwds)",
      "description": "Similar to `start_server` but works with UNIX Domain Sockets.",
      "relationships": [
        {
          "target": "stdlib.asyncio.get_event_loop",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.warn",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.StreamReader",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.StreamReaderProtocol",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.create_unix_server",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.asyncio.to_thread",
      "name": "to_thread",
      "module": "asyncio",
      "type": "function",
      "signature": "(func, /, *args, **kwargs)",
      "description": "Asynchronously run function *func* in a separate thread.\n\nAny *args and **kwargs supplied for this function are directly passed\nto *func*. Also, the current :class:`contextvars.Context` is propogated,\nallowing context variables from the main thread to be accessed in the\nseparate thread.\n\nReturn a coroutine that can be awaited to get the eventual result of *func*.",
      "relationships": [
        {
          "target": "stdlib.asyncio.get_running_loop",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.copy_context",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.partial",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.run_in_executor",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.asyncio.wait",
      "name": "wait",
      "module": "asyncio",
      "type": "function",
      "signature": "(fs, *, loop=None, timeout=None, return_when='ALL_COMPLETED')",
      "description": "Wait for the Futures and coroutines given by fs to complete.\n\nThe fs iterable must not be empty.\n\nCoroutines will be wrapped in Tasks.\n\nReturns two sets of Future: (done, pending).\n\nUsage:\n\n    done, pending = await asyncio.wait(fs)\n\nNote: This does not raise TimeoutError! Futures that aren't done\nwhen the timeout occurs are returned in the second set.",
      "relationships": [
        {
          "target": "stdlib.asyncio.set",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.any",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.isfuture",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.iscoroutine",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.get_running_loop",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.warn",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.warn",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.ensure_future",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio._wait",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.iscoroutine",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.type",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.asyncio.wait_for",
      "name": "wait_for",
      "module": "asyncio",
      "type": "function",
      "signature": "(fut, timeout, *, loop=None)",
      "description": "Wait for the single Future or coroutine to complete, with timeout.\n\nCoroutine will be wrapped in Task.\n\nReturns result of the Future or coroutine.  When a timeout occurs,\nit cancels the task and raises TimeoutError.  To avoid the task\ncancellation, wrap it in shield().\n\nIf the wait is cancelled, the task is also cancelled.\n\nThis function is a coroutine.",
      "relationships": [
        {
          "target": "stdlib.asyncio.create_future",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.call_later",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.partial",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.ensure_future",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.add_done_callback",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.get_running_loop",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.warn",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.ensure_future",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.done",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.done",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.cancel",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.result",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio._cancel_and_wait",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.result",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.TimeoutError",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.result",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.remove_done_callback",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.TimeoutError",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.done",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio._cancel_and_wait",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.result",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.TimeoutError",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.result",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.remove_done_callback",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.TimeoutError",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio._cancel_and_wait",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.asyncio.wrap_future",
      "name": "wrap_future",
      "module": "asyncio",
      "type": "function",
      "signature": "(future, *, loop=None)",
      "description": "Wrap concurrent.futures.Future object.",
      "relationships": [
        {
          "target": "stdlib.asyncio.isfuture",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.create_future",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio._chain_future",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncio.get_event_loop",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.asyncore.close_all",
      "name": "close_all",
      "module": "asyncore",
      "type": "function",
      "signature": "(map=None, ignore_all=False)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.asyncore.list",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncore.clear",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncore.values",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncore.close",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.asyncore.compact_traceback",
      "name": "compact_traceback",
      "module": "asyncore",
      "type": "function",
      "signature": "()",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.asyncore.exc_info",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncore.join",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncore.AssertionError",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncore.append",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncore.str",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.asyncore.dispatcher",
      "name": "dispatcher",
      "module": "asyncore",
      "type": "class",
      "signature": "(sock=None, map=None)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.asyncore.dispatcher_with_send",
      "name": "dispatcher_with_send",
      "module": "asyncore",
      "type": "class",
      "signature": "(sock=None, map=None)",
      "description": "",
      "relationships": [
        {
          "target": "dispatcher",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.asyncore.file_dispatcher",
      "name": "file_dispatcher",
      "module": "asyncore",
      "type": "class",
      "signature": "(fd, map=None)",
      "description": "",
      "relationships": [
        {
          "target": "dispatcher",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.asyncore.file_wrapper",
      "name": "file_wrapper",
      "module": "asyncore",
      "type": "class",
      "signature": "(fd)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.asyncore.loop",
      "name": "loop",
      "module": "asyncore",
      "type": "function",
      "signature": "(timeout=30.0, use_poll=False, map=None, count=None)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.asyncore.hasattr",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncore.poll_fun",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncore.poll_fun",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.asyncore.poll",
      "name": "poll",
      "module": "asyncore",
      "type": "function",
      "signature": "(timeout=0.0, map=None)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.asyncore.list",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncore.select",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncore.items",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncore.readable",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncore.writable",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncore.sleep",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncore.get",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncore.read",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncore.get",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncore.write",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncore.get",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncore._exception",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncore.append",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncore.append",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncore.append",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.asyncore.poll2",
      "name": "poll2",
      "module": "asyncore",
      "type": "function",
      "signature": "(timeout=0.0, map=None)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.asyncore.poll",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncore.int",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncore.list",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncore.poll",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncore.items",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncore.readable",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncore.get",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncore.readwrite",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncore.writable",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncore.register",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.asyncore.poll3",
      "name": "poll3",
      "module": "asyncore",
      "type": "function",
      "signature": "(timeout=0.0, map=None)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.asyncore.poll",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncore.int",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncore.list",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncore.poll",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncore.items",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncore.readable",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncore.get",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncore.readwrite",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncore.writable",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncore.register",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.asyncore.read",
      "name": "read",
      "module": "asyncore",
      "type": "function",
      "signature": "(obj)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.asyncore.handle_read_event",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncore.handle_error",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.asyncore.readwrite",
      "name": "readwrite",
      "module": "asyncore",
      "type": "function",
      "signature": "(obj, flags)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.asyncore.handle_read_event",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncore.handle_write_event",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncore.handle_expt_event",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncore.handle_close",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncore.handle_error",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncore.handle_error",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncore.handle_close",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.asyncore.write",
      "name": "write",
      "module": "asyncore",
      "type": "function",
      "signature": "(obj)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.asyncore.handle_write_event",
          "type": "calls"
        },
        {
          "target": "stdlib.asyncore.handle_error",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.base64.a85decode",
      "name": "a85decode",
      "module": "base64",
      "type": "function",
      "signature": "(b, *, foldspaces=False, adobe=False, ignorechars=b' \\t\\n\\r\\x0b')",
      "description": "Decode the Ascii85 encoded bytes-like object or ASCII string b.\n\nfoldspaces is a flag that specifies whether the 'y' short sequence should be\naccepted as shorthand for 4 consecutive spaces (ASCII 0x20). This feature is\nnot supported by the \"standard\" Adobe encoding.\n\nadobe controls whether the input sequence is in Adobe Ascii85 format (i.e.\nis framed with <~ and ~>).\n\nignorechars should be a byte string containing characters to ignore from the\ninput. This should only contain whitespace characters, and by default\ncontains all whitespace characters in ASCII.\n\nThe result is returned as a bytes object.",
      "relationships": [
        {
          "target": "stdlib.base64._bytes_from_decode_data",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.join",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.startswith",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.Struct",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.len",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.endswith",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.curr_append",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.format",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.len",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.curr_clear",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.decoded_append",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.decoded_append",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.decoded_append",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.packI",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.ValueError",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.base64.a85encode",
      "name": "a85encode",
      "module": "base64",
      "type": "function",
      "signature": "(b, *, foldspaces=False, wrapcol=0, pad=False, adobe=False)",
      "description": "Encode bytes-like object b using Ascii85 and return a bytes object.\n\nfoldspaces is an optional flag that uses the special short sequence 'y'\ninstead of 4 consecutive spaces (ASCII 0x20) as supported by 'btoa'. This\nfeature is not supported by the \"standard\" Adobe encoding.\n\nwrapcol controls whether the output should have newline (b'\\n') characters\nadded to it. If this is non-zero, each output line will be at most this\nmany characters long.\n\npad controls whether the input is padded to a multiple of 4 before\nencoding. Note that the btoa implementation always pads.\n\nadobe controls whether the encoded byte sequence is framed with <~ and ~>,\nwhich is used by the Adobe implementation.",
      "relationships": [
        {
          "target": "stdlib.base64._85encode",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.max",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.join",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.bytes",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.range",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.range",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.append",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.len",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.len",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.base64.b16decode",
      "name": "b16decode",
      "module": "base64",
      "type": "function",
      "signature": "(s, casefold=False)",
      "description": "Decode the Base16 encoded bytes-like object or ASCII string s.\n\nOptional casefold is a flag specifying whether a lowercase alphabet is\nacceptable as input.  For security purposes, the default is False.\n\nThe result is returned as a bytes object.  A binascii.Error is raised if\ns is incorrectly padded or if there are non-alphabet characters present\nin the input.",
      "relationships": [
        {
          "target": "stdlib.base64._bytes_from_decode_data",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.search",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.unhexlify",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.upper",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.Error",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.base64.b16encode",
      "name": "b16encode",
      "module": "base64",
      "type": "function",
      "signature": "(s)",
      "description": "Encode the bytes-like object s using Base16 and return a bytes object.\n    ",
      "relationships": [
        {
          "target": "stdlib.base64.upper",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.hexlify",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.base64.b32decode",
      "name": "b32decode",
      "module": "base64",
      "type": "function",
      "signature": "(s, casefold=False, map01=None)",
      "description": "Decode the Base32 encoded bytes-like object or ASCII string s.\n\nOptional casefold is a flag specifying whether a lowercase alphabet is\nacceptable as input.  For security purposes, the default is False.\n\nRFC 3548 allows for optional mapping of the digit 0 (zero) to the\nletter O (oh), and for optional mapping of the digit 1 (one) to\neither the letter I (eye) or letter L (el).  The optional argument\nmap01 when not None, specifies which letter the digit 1 should be\nmapped to (when map01 is not None, the digit 0 is always mapped to\nthe letter O).  For security purposes the default is None, so that\n0 and 1 are not allowed in the input.\n\nThe result is returned as a bytes object.  A binascii.Error is raised if\nthe input is incorrectly padded or if there are non-alphabet\ncharacters present in the input.",
      "relationships": [
        {
          "target": "stdlib.base64._bytes_from_decode_data",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.len",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.rstrip",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.bytearray",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.range",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.bytes",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.len",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.Error",
          "type": "calls"
        },
        {
          "target": "stdlib.base64._bytes_from_decode_data",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.repr",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.translate",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.upper",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.len",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.len",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.to_bytes",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.Error",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.to_bytes",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.len",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.maketrans",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.enumerate",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.Error",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.base64.b32encode",
      "name": "b32encode",
      "module": "base64",
      "type": "function",
      "signature": "(s)",
      "description": "Encode the bytes-like object s using Base32 and return a bytes object.\n    ",
      "relationships": [
        {
          "target": "stdlib.base64.bytearray",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.range",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.bytes",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.tobytes",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.len",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.len",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.from_bytes",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.bytes",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.memoryview",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.base64.b64decode",
      "name": "b64decode",
      "module": "base64",
      "type": "function",
      "signature": "(s, altchars=None, validate=False)",
      "description": "Decode the Base64 encoded bytes-like object or ASCII string s.\n\nOptional altchars must be a bytes-like object or ASCII string of length 2\nwhich specifies the alternative alphabet used instead of the '+' and '/'\ncharacters.\n\nThe result is returned as a bytes object.  A binascii.Error is raised if\ns is incorrectly padded.\n\nIf validate is False (the default), characters that are neither in the\nnormal base-64 alphabet nor the alternative alphabet are discarded prior\nto the padding check.  If validate is True, these non-alphabet characters\nin the input result in a binascii.Error.",
      "relationships": [
        {
          "target": "stdlib.base64._bytes_from_decode_data",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.a2b_base64",
          "type": "calls"
        },
        {
          "target": "stdlib.base64._bytes_from_decode_data",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.repr",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.translate",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.Error",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.len",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.maketrans",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.fullmatch",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.base64.b64encode",
      "name": "b64encode",
      "module": "base64",
      "type": "function",
      "signature": "(s, altchars=None)",
      "description": "Encode the bytes-like object s using Base64 and return a bytes object.\n\nOptional altchars should be a byte string of length 2 which specifies an\nalternative alphabet for the '+' and '/' characters.  This allows an\napplication to e.g. generate url or filesystem safe Base64 strings.",
      "relationships": [
        {
          "target": "stdlib.base64.b2a_base64",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.repr",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.translate",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.len",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.maketrans",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.base64.b85decode",
      "name": "b85decode",
      "module": "base64",
      "type": "function",
      "signature": "(b)",
      "description": "Decode the base85-encoded bytes-like object or ASCII string b\n\nThe result is returned as a bytes object.",
      "relationships": [
        {
          "target": "stdlib.base64._bytes_from_decode_data",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.range",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.join",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.enumerate",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.Struct",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.len",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.len",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.append",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.enumerate",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.packI",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.ValueError",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.base64.b85encode",
      "name": "b85encode",
      "module": "base64",
      "type": "function",
      "signature": "(b, pad=False)",
      "description": "Encode bytes-like object b in base85 format and return a bytes object.\n\nIf pad is true, the input is padded with b'\\0' so its length is a multiple of\n4 bytes before encoding.",
      "relationships": [
        {
          "target": "stdlib.base64._85encode",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.bytes",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.base64.decode",
      "name": "decode",
      "module": "base64",
      "type": "function",
      "signature": "(input, output)",
      "description": "Decode a file; input and output are binary files.",
      "relationships": [
        {
          "target": "stdlib.base64.readline",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.a2b_base64",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.write",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.base64.decodebytes",
      "name": "decodebytes",
      "module": "base64",
      "type": "function",
      "signature": "(s)",
      "description": "Decode a bytestring of base-64 data into a bytes object.",
      "relationships": [
        {
          "target": "stdlib.base64._input_type_check",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.a2b_base64",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.base64.encode",
      "name": "encode",
      "module": "base64",
      "type": "function",
      "signature": "(input, output)",
      "description": "Encode a file; input and output are binary files.",
      "relationships": [
        {
          "target": "stdlib.base64.read",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.b2a_base64",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.write",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.len",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.read",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.len",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.base64.encodebytes",
      "name": "encodebytes",
      "module": "base64",
      "type": "function",
      "signature": "(s)",
      "description": "Encode a bytestring into a bytes object containing multiple lines\nof base-64 data.",
      "relationships": [
        {
          "target": "stdlib.base64._input_type_check",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.range",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.join",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.len",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.append",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.b2a_base64",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.base64.main",
      "name": "main",
      "module": "base64",
      "type": "function",
      "signature": "()",
      "description": "Small main program",
      "relationships": [
        {
          "target": "stdlib.base64.getopt",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.func",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.print",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.print",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.exit",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.test",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.open",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.func",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.base64.standard_b64decode",
      "name": "standard_b64decode",
      "module": "base64",
      "type": "function",
      "signature": "(s)",
      "description": "Decode bytes encoded with the standard Base64 alphabet.\n\nArgument s is a bytes-like object or ASCII string to decode.  The result\nis returned as a bytes object.  A binascii.Error is raised if the input\nis incorrectly padded.  Characters that are not in the standard alphabet\nare discarded prior to the padding check.",
      "relationships": [
        {
          "target": "stdlib.base64.b64decode",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.base64.standard_b64encode",
      "name": "standard_b64encode",
      "module": "base64",
      "type": "function",
      "signature": "(s)",
      "description": "Encode bytes-like object s using the standard Base64 alphabet.\n\nThe result is returned as a bytes object.",
      "relationships": [
        {
          "target": "stdlib.base64.b64encode",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.base64.test",
      "name": "test",
      "module": "base64",
      "type": "function",
      "signature": "()",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.base64.print",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.encodebytes",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.print",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.decodebytes",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.print",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.repr",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.repr",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.repr",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.base64.urlsafe_b64decode",
      "name": "urlsafe_b64decode",
      "module": "base64",
      "type": "function",
      "signature": "(s)",
      "description": "Decode bytes using the URL- and filesystem-safe Base64 alphabet.\n\nArgument s is a bytes-like object or ASCII string to decode.  The result\nis returned as a bytes object.  A binascii.Error is raised if the input\nis incorrectly padded.  Characters that are not in the URL-safe base-64\nalphabet, and are not a plus '+' or slash '/', are discarded prior to the\npadding check.\n\nThe alphabet uses '-' instead of '+' and '_' instead of '/'.",
      "relationships": [
        {
          "target": "stdlib.base64._bytes_from_decode_data",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.translate",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.b64decode",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.base64.urlsafe_b64encode",
      "name": "urlsafe_b64encode",
      "module": "base64",
      "type": "function",
      "signature": "(s)",
      "description": "Encode bytes using the URL- and filesystem-safe Base64 alphabet.\n\nArgument s is a bytes-like object to encode.  The result is returned as a\nbytes object.  The alphabet uses '-' instead of '+' and '_' instead of\n'/'.",
      "relationships": [
        {
          "target": "stdlib.base64.translate",
          "type": "calls"
        },
        {
          "target": "stdlib.base64.b64encode",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.bdb.Bdb",
      "name": "Bdb",
      "module": "bdb",
      "type": "class",
      "signature": "(skip=None)",
      "description": "Generic Python debugger base class.\n\nThis class takes care of details of the trace facility;\na derived class should implement user interaction.\nThe standard debugger class (pdb.Pdb) is an example.\n\nThe optional skip argument must be an iterable of glob-style\nmodule name patterns.  The debugger will not step into frames\nthat originate in a module that matches one of these patterns.\nWhether a frame is considered to originate in a certain module\nis determined by the __name__ in the frame globals.",
      "relationships": []
    },
    {
      "id": "stdlib.bdb.Breakpoint",
      "name": "Breakpoint",
      "module": "bdb",
      "type": "class",
      "signature": "(file, line, temporary=False, cond=None, funcname=None)",
      "description": "Breakpoint class.\n\nImplements temporary breakpoints, ignore counts, disabling and\n(re)-enabling, and conditionals.\n\nBreakpoints are indexed by number through bpbynumber and by\nthe (file, line) tuple using bplist.  The former points to a\nsingle instance of class Breakpoint.  The latter points to a\nlist of such instances since there may be more than one\nbreakpoint per line.\n\nWhen creating a breakpoint, its associated filename should be\nin canonical form.  If funcname is defined, a breakpoint hit will be\ncounted when the first line of that function is executed.  A\nconditional breakpoint always counts a hit.",
      "relationships": []
    },
    {
      "id": "stdlib.bdb.Tdb",
      "name": "Tdb",
      "module": "bdb",
      "type": "class",
      "signature": "(skip=None)",
      "description": "Generic Python debugger base class.\n\nThis class takes care of details of the trace facility;\na derived class should implement user interaction.\nThe standard debugger class (pdb.Pdb) is an example.\n\nThe optional skip argument must be an iterable of glob-style\nmodule name patterns.  The debugger will not step into frames\nthat originate in a module that matches one of these patterns.\nWhether a frame is considered to originate in a certain module\nis determined by the __name__ in the frame globals.",
      "relationships": [
        {
          "target": "Bdb",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.bdb.bar",
      "name": "bar",
      "module": "bdb",
      "type": "function",
      "signature": "(a)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.bdb.print",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.bdb.checkfuncname",
      "name": "checkfuncname",
      "module": "bdb",
      "type": "function",
      "signature": "(b, frame)",
      "description": "Return True if break should happen here.\n\nWhether a break should happen depends on the way that b (the breakpoint)\nwas set.  If it was set via line number, check if b.line is the same as\nthe one in the frame.  If it was set via function name, check if this is\nthe right function and if it is on the first executable line.",
      "relationships": []
    },
    {
      "id": "stdlib.bdb.effective",
      "name": "effective",
      "module": "bdb",
      "type": "function",
      "signature": "(file, line, frame)",
      "description": "Determine which breakpoint for this file:line is to be acted upon.\n\nCalled only if we know there is a breakpoint at this location.  Return\nthe breakpoint that was triggered and a boolean that indicates if it is\nok to delete a temporary breakpoint.  Return (None, None) if there is no\nmatching breakpoint.",
      "relationships": [
        {
          "target": "stdlib.bdb.checkfuncname",
          "type": "calls"
        },
        {
          "target": "stdlib.bdb.eval",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.bdb.foo",
      "name": "foo",
      "module": "bdb",
      "type": "function",
      "signature": "(n)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.bdb.print",
          "type": "calls"
        },
        {
          "target": "stdlib.bdb.bar",
          "type": "calls"
        },
        {
          "target": "stdlib.bdb.print",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.bdb.set_trace",
      "name": "set_trace",
      "module": "bdb",
      "type": "function",
      "signature": "()",
      "description": "Start debugging with a Bdb instance from the caller's frame.",
      "relationships": [
        {
          "target": "stdlib.bdb.set_trace",
          "type": "calls"
        },
        {
          "target": "stdlib.bdb.Bdb",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.bdb.test",
      "name": "test",
      "module": "bdb",
      "type": "function",
      "signature": "()",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.bdb.Tdb",
          "type": "calls"
        },
        {
          "target": "stdlib.bdb.run",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.binhex.BinHex",
      "name": "BinHex",
      "module": "binhex",
      "type": "class",
      "signature": "(name_finfo_dlen_rlen, ofp)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.binhex.FInfo",
      "name": "FInfo",
      "module": "binhex",
      "type": "class",
      "signature": "()",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.binhex.HexBin",
      "name": "HexBin",
      "module": "binhex",
      "type": "class",
      "signature": "(ifp)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.binhex.binhex",
      "name": "binhex",
      "module": "binhex",
      "type": "function",
      "signature": "(inp, out)",
      "description": "binhex(infilename, outfilename): create binhex-encoded copy of a file",
      "relationships": [
        {
          "target": "stdlib.binhex.getfileinfo",
          "type": "calls"
        },
        {
          "target": "stdlib.binhex.BinHex",
          "type": "calls"
        },
        {
          "target": "stdlib.binhex.openrsrc",
          "type": "calls"
        },
        {
          "target": "stdlib.binhex.close",
          "type": "calls"
        },
        {
          "target": "stdlib.binhex.close",
          "type": "calls"
        },
        {
          "target": "stdlib.binhex.open",
          "type": "calls"
        },
        {
          "target": "stdlib.binhex.close_data",
          "type": "calls"
        },
        {
          "target": "stdlib.binhex.read",
          "type": "calls"
        },
        {
          "target": "stdlib.binhex.write_rsrc",
          "type": "calls"
        },
        {
          "target": "stdlib.binhex.read",
          "type": "calls"
        },
        {
          "target": "stdlib.binhex.write",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.binhex.getfileinfo",
      "name": "getfileinfo",
      "module": "binhex",
      "type": "function",
      "signature": "(name)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.binhex.FInfo",
          "type": "calls"
        },
        {
          "target": "stdlib.binhex.split",
          "type": "calls"
        },
        {
          "target": "stdlib.binhex.replace",
          "type": "calls"
        },
        {
          "target": "stdlib.binhex.open",
          "type": "calls"
        },
        {
          "target": "stdlib.binhex.read",
          "type": "calls"
        },
        {
          "target": "stdlib.binhex.seek",
          "type": "calls"
        },
        {
          "target": "stdlib.binhex.tell",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.binhex.hexbin",
      "name": "hexbin",
      "module": "binhex",
      "type": "function",
      "signature": "(inp, out)",
      "description": "hexbin(infilename, outfilename) - Decode binhexed file",
      "relationships": [
        {
          "target": "stdlib.binhex.HexBin",
          "type": "calls"
        },
        {
          "target": "stdlib.binhex.close_data",
          "type": "calls"
        },
        {
          "target": "stdlib.binhex.read_rsrc",
          "type": "calls"
        },
        {
          "target": "stdlib.binhex.close",
          "type": "calls"
        },
        {
          "target": "stdlib.binhex.open",
          "type": "calls"
        },
        {
          "target": "stdlib.binhex.openrsrc",
          "type": "calls"
        },
        {
          "target": "stdlib.binhex.write",
          "type": "calls"
        },
        {
          "target": "stdlib.binhex.close",
          "type": "calls"
        },
        {
          "target": "stdlib.binhex.read",
          "type": "calls"
        },
        {
          "target": "stdlib.binhex.write",
          "type": "calls"
        },
        {
          "target": "stdlib.binhex.read_rsrc",
          "type": "calls"
        },
        {
          "target": "stdlib.binhex.write",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.binhex.openrsrc",
      "name": "openrsrc",
      "module": "binhex",
      "type": "class",
      "signature": "(*args)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.bz2.BZ2Compressor",
      "name": "BZ2Compressor",
      "module": "bz2",
      "type": "class",
      "signature": "(compresslevel=9, /)",
      "description": "Create a compressor object for compressing data incrementally.\n\n  compresslevel\n    Compression level, as a number between 1 and 9.\n\nFor one-shot compression, use the compress() function instead.",
      "relationships": []
    },
    {
      "id": "stdlib.bz2.BZ2Decompressor",
      "name": "BZ2Decompressor",
      "module": "bz2",
      "type": "class",
      "signature": "()",
      "description": "Create a decompressor object for decompressing data incrementally.\n\nFor one-shot decompression, use the decompress() function instead.",
      "relationships": []
    },
    {
      "id": "stdlib.bz2.BZ2File",
      "name": "BZ2File",
      "module": "bz2",
      "type": "class",
      "signature": "(filename, mode='r', *, compresslevel=9)",
      "description": "A file object providing transparent bzip2 (de)compression.\n\nA BZ2File can act as a wrapper for an existing file object, or refer\ndirectly to a named file on disk.\n\nNote that BZ2File provides a *binary* file interface - data read is\nreturned as bytes, and data to be written should be given as bytes.",
      "relationships": [
        {
          "target": "BaseStream",
          "type": "base_class"
        },
        {
          "target": "BufferedIOBase",
          "type": "base_class"
        },
        {
          "target": "_BufferedIOBase",
          "type": "base_class"
        },
        {
          "target": "IOBase",
          "type": "base_class"
        },
        {
          "target": "_IOBase",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.bz2.RLock",
      "name": "RLock",
      "module": "bz2",
      "type": "function",
      "signature": "(*args, **kwargs)",
      "description": "Factory function that returns a new reentrant lock.\n\nA reentrant lock must be released by the thread that acquired it. Once a\nthread has acquired a reentrant lock, the same thread may acquire it again\nwithout blocking; the thread must release it once for each time it has\nacquired it.",
      "relationships": [
        {
          "target": "stdlib.bz2._CRLock",
          "type": "calls"
        },
        {
          "target": "stdlib.bz2._PyRLock",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.bz2.compress",
      "name": "compress",
      "module": "bz2",
      "type": "function",
      "signature": "(data, compresslevel=9)",
      "description": "Compress a block of data.\n\ncompresslevel, if given, must be a number between 1 and 9.\n\nFor incremental compression, use a BZ2Compressor object instead.",
      "relationships": [
        {
          "target": "stdlib.bz2.BZ2Compressor",
          "type": "calls"
        },
        {
          "target": "stdlib.bz2.compress",
          "type": "calls"
        },
        {
          "target": "stdlib.bz2.flush",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.bz2.decompress",
      "name": "decompress",
      "module": "bz2",
      "type": "function",
      "signature": "(data)",
      "description": "Decompress a block of data.\n\nFor incremental decompression, use a BZ2Decompressor object instead.",
      "relationships": [
        {
          "target": "stdlib.bz2.join",
          "type": "calls"
        },
        {
          "target": "stdlib.bz2.BZ2Decompressor",
          "type": "calls"
        },
        {
          "target": "stdlib.bz2.append",
          "type": "calls"
        },
        {
          "target": "stdlib.bz2.decompress",
          "type": "calls"
        },
        {
          "target": "stdlib.bz2.ValueError",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.bz2.open",
      "name": "open",
      "module": "bz2",
      "type": "function",
      "signature": "(filename, mode='rb', compresslevel=9, encoding=None, errors=None, newline=None)",
      "description": "Open a bzip2-compressed file in binary or text mode.\n\nThe filename argument can be an actual filename (a str, bytes, or\nPathLike object), or an existing file object to read from or write\nto.\n\nThe mode argument can be \"r\", \"rb\", \"w\", \"wb\", \"x\", \"xb\", \"a\" or\n\"ab\" for binary mode, or \"rt\", \"wt\", \"xt\" or \"at\" for text mode.\nThe default mode is \"rb\", and the default compresslevel is 9.\n\nFor binary mode, this function is equivalent to the BZ2File\nconstructor: BZ2File(filename, mode, compresslevel). In this case,\nthe encoding, errors and newline arguments must not be provided.\n\nFor text mode, a BZ2File object is created, and wrapped in an\nio.TextIOWrapper instance with the specified encoding, error\nhandling behavior, and line ending(s).",
      "relationships": [
        {
          "target": "stdlib.bz2.replace",
          "type": "calls"
        },
        {
          "target": "stdlib.bz2.BZ2File",
          "type": "calls"
        },
        {
          "target": "stdlib.bz2.TextIOWrapper",
          "type": "calls"
        },
        {
          "target": "stdlib.bz2.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.bz2.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.bz2.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.bz2.ValueError",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.cProfile.label",
      "name": "label",
      "module": "cProfile",
      "type": "function",
      "signature": "(code)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.cProfile.isinstance",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.cProfile.main",
      "name": "main",
      "module": "cProfile",
      "type": "function",
      "signature": "()",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.cProfile.OptionParser",
          "type": "calls"
        },
        {
          "target": "stdlib.cProfile.add_option",
          "type": "calls"
        },
        {
          "target": "stdlib.cProfile.add_option",
          "type": "calls"
        },
        {
          "target": "stdlib.cProfile.add_option",
          "type": "calls"
        },
        {
          "target": "stdlib.cProfile.parse_args",
          "type": "calls"
        },
        {
          "target": "stdlib.cProfile.print_usage",
          "type": "calls"
        },
        {
          "target": "stdlib.cProfile.exit",
          "type": "calls"
        },
        {
          "target": "stdlib.cProfile.abspath",
          "type": "calls"
        },
        {
          "target": "stdlib.cProfile.len",
          "type": "calls"
        },
        {
          "target": "stdlib.cProfile.print_usage",
          "type": "calls"
        },
        {
          "target": "stdlib.cProfile.sorted",
          "type": "calls"
        },
        {
          "target": "stdlib.cProfile.insert",
          "type": "calls"
        },
        {
          "target": "stdlib.cProfile.runctx",
          "type": "calls"
        },
        {
          "target": "stdlib.cProfile.dirname",
          "type": "calls"
        },
        {
          "target": "stdlib.cProfile.open",
          "type": "calls"
        },
        {
          "target": "stdlib.cProfile.compile",
          "type": "calls"
        },
        {
          "target": "stdlib.cProfile.exit",
          "type": "calls"
        },
        {
          "target": "stdlib.cProfile.read",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.cProfile.run",
      "name": "run",
      "module": "cProfile",
      "type": "function",
      "signature": "(statement, filename=None, sort=-1)",
      "description": "Run statement under profiler optionally saving results in filename\n\nThis function takes a single argument that can be passed to the\n\"exec\" statement, and an optional file name.  In all cases this\nroutine attempts to \"exec\" its first argument and gather profiling\nstatistics from the execution. If no file name is present, then this\nfunction automatically prints a simple profiling report, sorted by the\nstandard name string (file/line/function-name) that is presented in\neach line.",
      "relationships": [
        {
          "target": "stdlib.cProfile.run",
          "type": "calls"
        },
        {
          "target": "stdlib.cProfile._Utils",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.cProfile.runctx",
      "name": "runctx",
      "module": "cProfile",
      "type": "function",
      "signature": "(statement, globals, locals, filename=None, sort=-1)",
      "description": "Run statement under profiler, supplying your own globals and locals,\noptionally saving results in filename.\n\nstatement and filename have the same semantics as profile.run",
      "relationships": [
        {
          "target": "stdlib.cProfile.runctx",
          "type": "calls"
        },
        {
          "target": "stdlib.cProfile._Utils",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.calendar.Calendar",
      "name": "Calendar",
      "module": "calendar",
      "type": "class",
      "signature": "(firstweekday=0)",
      "description": "Base calendar class. This class doesn't do any formatting. It simply\nprovides data to subclasses.",
      "relationships": []
    },
    {
      "id": "stdlib.calendar.HTMLCalendar",
      "name": "HTMLCalendar",
      "module": "calendar",
      "type": "class",
      "signature": "(firstweekday=0)",
      "description": "This calendar returns complete HTML pages.",
      "relationships": [
        {
          "target": "Calendar",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.calendar.IllegalMonthError",
      "name": "IllegalMonthError",
      "module": "calendar",
      "type": "class",
      "signature": "(month)",
      "description": "Inappropriate argument value (of correct type).",
      "relationships": [
        {
          "target": "ValueError",
          "type": "base_class"
        },
        {
          "target": "Exception",
          "type": "base_class"
        },
        {
          "target": "BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.calendar.IllegalWeekdayError",
      "name": "IllegalWeekdayError",
      "module": "calendar",
      "type": "class",
      "signature": "(weekday)",
      "description": "Inappropriate argument value (of correct type).",
      "relationships": [
        {
          "target": "ValueError",
          "type": "base_class"
        },
        {
          "target": "Exception",
          "type": "base_class"
        },
        {
          "target": "BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.calendar.LocaleHTMLCalendar",
      "name": "LocaleHTMLCalendar",
      "module": "calendar",
      "type": "class",
      "signature": "(firstweekday=0, locale=None)",
      "description": "This class can be passed a locale name in the constructor and will return\nmonth and weekday names in the specified locale. If this locale includes\nan encoding all strings containing month and weekday names will be returned\nas unicode.",
      "relationships": [
        {
          "target": "HTMLCalendar",
          "type": "base_class"
        },
        {
          "target": "Calendar",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.calendar.LocaleTextCalendar",
      "name": "LocaleTextCalendar",
      "module": "calendar",
      "type": "class",
      "signature": "(firstweekday=0, locale=None)",
      "description": "This class can be passed a locale name in the constructor and will return\nmonth and weekday names in the specified locale. If this locale includes\nan encoding all strings containing month and weekday names will be returned\nas unicode.",
      "relationships": [
        {
          "target": "TextCalendar",
          "type": "base_class"
        },
        {
          "target": "Calendar",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.calendar.TextCalendar",
      "name": "TextCalendar",
      "module": "calendar",
      "type": "class",
      "signature": "(firstweekday=0)",
      "description": "Subclass of Calendar that outputs a calendar as a simple plain text\nsimilar to the UNIX program cal.",
      "relationships": [
        {
          "target": "Calendar",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.calendar.different_locale",
      "name": "different_locale",
      "module": "calendar",
      "type": "class",
      "signature": "(locale)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.calendar.format",
      "name": "format",
      "module": "calendar",
      "type": "function",
      "signature": "(cols, colwidth=20, spacing=6)",
      "description": "Prints multi-column formatting for year calendars",
      "relationships": [
        {
          "target": "stdlib.calendar.print",
          "type": "calls"
        },
        {
          "target": "stdlib.calendar.formatstring",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.calendar.formatstring",
      "name": "formatstring",
      "module": "calendar",
      "type": "function",
      "signature": "(cols, colwidth=20, spacing=6)",
      "description": "Returns a string formatted from n strings, centered within n columns.",
      "relationships": [
        {
          "target": "stdlib.calendar.join",
          "type": "calls"
        },
        {
          "target": "stdlib.calendar.center",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.calendar.isleap",
      "name": "isleap",
      "module": "calendar",
      "type": "function",
      "signature": "(year)",
      "description": "Return True for leap years, False for non-leap years.",
      "relationships": []
    },
    {
      "id": "stdlib.calendar.leapdays",
      "name": "leapdays",
      "module": "calendar",
      "type": "function",
      "signature": "(y1, y2)",
      "description": "Return number of leap years in range [y1, y2).\nAssume y1 <= y2.",
      "relationships": []
    },
    {
      "id": "stdlib.calendar.main",
      "name": "main",
      "module": "calendar",
      "type": "function",
      "signature": "(args)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.calendar.ArgumentParser",
          "type": "calls"
        },
        {
          "target": "stdlib.calendar.add_argument_group",
          "type": "calls"
        },
        {
          "target": "stdlib.calendar.add_argument_group",
          "type": "calls"
        },
        {
          "target": "stdlib.calendar.add_argument",
          "type": "calls"
        },
        {
          "target": "stdlib.calendar.add_argument",
          "type": "calls"
        },
        {
          "target": "stdlib.calendar.add_argument",
          "type": "calls"
        },
        {
          "target": "stdlib.calendar.add_argument",
          "type": "calls"
        },
        {
          "target": "stdlib.calendar.add_argument",
          "type": "calls"
        },
        {
          "target": "stdlib.calendar.add_argument",
          "type": "calls"
        },
        {
          "target": "stdlib.calendar.add_argument",
          "type": "calls"
        },
        {
          "target": "stdlib.calendar.add_argument",
          "type": "calls"
        },
        {
          "target": "stdlib.calendar.add_argument",
          "type": "calls"
        },
        {
          "target": "stdlib.calendar.add_argument",
          "type": "calls"
        },
        {
          "target": "stdlib.calendar.parse_args",
          "type": "calls"
        },
        {
          "target": "stdlib.calendar.error",
          "type": "calls"
        },
        {
          "target": "stdlib.calendar.exit",
          "type": "calls"
        },
        {
          "target": "stdlib.calendar.dict",
          "type": "calls"
        },
        {
          "target": "stdlib.calendar.dict",
          "type": "calls"
        },
        {
          "target": "stdlib.calendar.write",
          "type": "calls"
        },
        {
          "target": "stdlib.calendar.LocaleHTMLCalendar",
          "type": "calls"
        },
        {
          "target": "stdlib.calendar.HTMLCalendar",
          "type": "calls"
        },
        {
          "target": "stdlib.calendar.getdefaultencoding",
          "type": "calls"
        },
        {
          "target": "stdlib.calendar.write",
          "type": "calls"
        },
        {
          "target": "stdlib.calendar.LocaleTextCalendar",
          "type": "calls"
        },
        {
          "target": "stdlib.calendar.TextCalendar",
          "type": "calls"
        },
        {
          "target": "stdlib.calendar.formatyear",
          "type": "calls"
        },
        {
          "target": "stdlib.calendar.encode",
          "type": "calls"
        },
        {
          "target": "stdlib.calendar.formatyearpage",
          "type": "calls"
        },
        {
          "target": "stdlib.calendar.write",
          "type": "calls"
        },
        {
          "target": "stdlib.calendar.error",
          "type": "calls"
        },
        {
          "target": "stdlib.calendar.exit",
          "type": "calls"
        },
        {
          "target": "stdlib.calendar.formatyear",
          "type": "calls"
        },
        {
          "target": "stdlib.calendar.formatmonth",
          "type": "calls"
        },
        {
          "target": "stdlib.calendar.formatyearpage",
          "type": "calls"
        },
        {
          "target": "stdlib.calendar.today",
          "type": "calls"
        },
        {
          "target": "stdlib.calendar.today",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.calendar.monthrange",
      "name": "monthrange",
      "module": "calendar",
      "type": "function",
      "signature": "(year, month)",
      "description": "Return weekday (0-6 ~ Mon-Sun) and number of days (28-31) for\nyear, month.",
      "relationships": [
        {
          "target": "stdlib.calendar.weekday",
          "type": "calls"
        },
        {
          "target": "stdlib.calendar.IllegalMonthError",
          "type": "calls"
        },
        {
          "target": "stdlib.calendar.isleap",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.calendar.setfirstweekday",
      "name": "setfirstweekday",
      "module": "calendar",
      "type": "function",
      "signature": "(firstweekday)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.calendar.IllegalWeekdayError",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.calendar.timegm",
      "name": "timegm",
      "module": "calendar",
      "type": "function",
      "signature": "(tuple)",
      "description": "Unrelated but handy function to calculate Unix timestamp from GMT.",
      "relationships": [
        {
          "target": "stdlib.calendar.toordinal",
          "type": "calls"
        },
        {
          "target": "stdlib.calendar.date",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.calendar.weekday",
      "name": "weekday",
      "module": "calendar",
      "type": "function",
      "signature": "(year, month, day)",
      "description": "Return weekday (0-6 ~ Mon-Sun) for year, month (1-12), day (1-31).",
      "relationships": [
        {
          "target": "stdlib.calendar.weekday",
          "type": "calls"
        },
        {
          "target": "stdlib.calendar.date",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.cgi.BytesIO",
      "name": "BytesIO",
      "module": "cgi",
      "type": "class",
      "signature": "(initial_bytes=b'')",
      "description": "Buffered I/O implementation using an in-memory bytes buffer.",
      "relationships": [
        {
          "target": "_BufferedIOBase",
          "type": "base_class"
        },
        {
          "target": "_IOBase",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.cgi.FeedParser",
      "name": "FeedParser",
      "module": "cgi",
      "type": "class",
      "signature": "(_factory=None, *, policy=Compat32())",
      "description": "A feed-style parser of email.",
      "relationships": []
    },
    {
      "id": "stdlib.cgi.FieldStorage",
      "name": "FieldStorage",
      "module": "cgi",
      "type": "class",
      "signature": "(fp=None, headers=None, outerboundary=b'', environ=environ({'OSLogRateLimit': '64', 'MallocNanoZone': '0', 'USER': 'anthonycardillo', 'COMMAND_MODE': 'unix2003', '__CFBundleIdentifier': 'com.todesktop.230313mzl4w4u92', 'PATH': '/Users/anthonycardillo/Documents/personal/polyester/.venv/bin:/opt/homebrew/opt/postgresql@16/bin:/Users/anthonycardillo/.bun/bin:/Users/anthonycardillo/.bun/bin:/Users/anthonycardillo/.nvm/versions/node/v22.21.0/bin:/opt/homebrew/bin:/opt/homebrew/sbin:/usr/local/bin:/System/Cryptexes/App/usr/bin:/usr/bin:/bin:/usr/sbin:/sbin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/local/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/appleinternal/bin:/opt/pmk/env/global/bin:/Library/Apple/usr/bin:/opt/homebrew/opt/postgresql@16/bin:/Users/anthonycardillo/.bun/bin:/Users/anthonycardillo/.nvm/versions/node/v22.21.0/bin:/Users/anthonycardillo/.cursor/extensions/ms-python.debugpy-2025.18.0-darwin-arm64/bundled/scripts/noConfigScripts', 'LOGNAME': 'anthonycardillo', 'SSH_AUTH_SOCK': '/private/tmp/com.apple.launchd.fAtscmMPP1/Listeners', 'HOME': '/Users/anthonycardillo', 'SHELL': '/bin/zsh', 'TMPDIR': '/var/folders/6c/95f1yxcd673848zqjnj46_ww0000gn/T/', '__CF_USER_TEXT_ENCODING': '0x1F5:0x0:0x52', 'XPC_SERVICE_NAME': '0', 'XPC_FLAGS': '0x0', 'ORIGINAL_XDG_CURRENT_DESKTOP': 'undefined', 'CURSOR_TRACE_ID': '09c74175785640a8ac5df17c65b4361b', 'SHLVL': '1', 'PWD': '/Users/anthonycardillo/Documents/personal/polyester', 'OLDPWD': '/Users/anthonycardillo/Documents/personal/polyester', 'LANG': 'C.UTF-8', 'HOMEBREW_PREFIX': '/opt/homebrew', 'HOMEBREW_CELLAR': '/opt/homebrew/Cellar', 'HOMEBREW_REPOSITORY': '/opt/homebrew', 'INFOPATH': '/opt/homebrew/share/info:/opt/homebrew/share/info:', 'NVM_DIR': '/Users/anthonycardillo/.nvm', 'NVM_CD_FLAGS': '-q', 'NVM_BIN': '/Users/anthonycardillo/.nvm/versions/node/v22.21.0/bin', 'NVM_INC': '/Users/anthonycardillo/.nvm/versions/node/v22.21.0/include/node', 'BUN_INSTALL': '/Users/anthonycardillo/.bun', 'TERM_PROGRAM': 'vscode', 'TERM_PROGRAM_VERSION': '2.3.40', 'COLORTERM': 'truecolor', 'PYDEVD_DISABLE_FILE_VALIDATION': '1', 'VSCODE_DEBUGPY_ADAPTER_ENDPOINTS': '/Users/anthonycardillo/.cursor/extensions/ms-python.debugpy-2025.18.0-darwin-arm64/.noConfigDebugAdapterEndpoints/endpoint-bfdb369faf213a96.txt', 'BUNDLED_DEBUGPY_PATH': '/Users/anthonycardillo/.cursor/extensions/ms-python.debugpy-2025.18.0-darwin-arm64/bundled/libs/debugpy', 'GIT_ASKPASS': '/Applications/Cursor.app/Contents/Resources/app/extensions/git/dist/askpass.sh', 'VSCODE_GIT_ASKPASS_NODE': '/Applications/Cursor.app/Contents/Frameworks/Cursor Helper (Plugin).app/Contents/MacOS/Cursor Helper (Plugin)', 'VSCODE_GIT_ASKPASS_EXTRA_ARGS': '', 'VSCODE_GIT_ASKPASS_MAIN': '/Applications/Cursor.app/Contents/Resources/app/extensions/git/dist/askpass-main.js', 'VSCODE_GIT_IPC_HANDLE': '/var/folders/6c/95f1yxcd673848zqjnj46_ww0000gn/T/vscode-git-6a534ea802.sock', 'VSCODE_GIT_IPC_AUTH_TOKEN': '202d91e1cac1e6fc0c336e8f97ca643be8b35e2b331169aadb2c67f58384013f', 'VSCODE_INJECTION': '1', 'ZDOTDIR': '/Users/anthonycardillo', 'USER_ZDOTDIR': '/Users/anthonycardillo', 'TERM': 'xterm-256color', 'VSCODE_PROFILE_INITIALIZED': '1', 'VIRTUAL_ENV': '/Users/anthonycardillo/Documents/personal/polyester/.venv', 'VIRTUAL_ENV_PROMPT': '.venv', 'PS1': '(.venv) %n@%m %1~ %# ', '_': '/Users/anthonycardillo/Documents/personal/polyester/.venv/bin/python'}), keep_blank_values=0, strict_parsing=0, limit=None, encoding='utf-8', errors='replace', max_num_fields=None, separator='&')",
      "description": "Store a sequence of fields, reading multipart/form-data.\n\nThis class provides naming, typing, files stored on disk, and\nmore.  At the top level, it is accessible like a dictionary, whose\nkeys are the field names.  (Note: None can occur as a field name.)\nThe items are either a Python list (if there's multiple values) or\nanother FieldStorage or MiniFieldStorage object.  If it's a single\nobject, it has the following attributes:\n\nname: the field name, if specified; otherwise None\n\nfilename: the filename, if specified; otherwise None; this is the\n    client side filename, *not* the file name on which it is\n    stored (that's a temporary file you don't deal with)\n\nvalue: the value as a *string*; for file uploads, this\n    transparently reads the file every time you request the value\n    and returns *bytes*\n\nfile: the file(-like) object from which you can read the data *as\n    bytes* ; None if the data is stored a simple string\n\ntype: the content-type, or None if not specified\n\ntype_options: dictionary of options specified on the content-type\n    line\n\ndisposition: content-disposition, or None if not specified\n\ndisposition_options: dictionary of corresponding options\n\nheaders: a dictionary(-like) object (sometimes email.message.Message or a\n    subclass thereof) containing *all* headers\n\nThe class is subclassable, mostly for the purpose of overriding\nthe make_file() method, which is called internally to come up with\na file open for reading and writing.  This makes it possible to\noverride the default choice of storing all files in a temporary\ndirectory and unlinking them as soon as they have been opened.",
      "relationships": []
    },
    {
      "id": "stdlib.cgi.Mapping",
      "name": "Mapping",
      "module": "cgi",
      "type": "class",
      "signature": "()",
      "description": "",
      "relationships": [
        {
          "target": "Collection",
          "type": "base_class"
        },
        {
          "target": "Sized",
          "type": "base_class"
        },
        {
          "target": "Iterable",
          "type": "base_class"
        },
        {
          "target": "Container",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.cgi.Message",
      "name": "Message",
      "module": "cgi",
      "type": "class",
      "signature": "(policy=Compat32())",
      "description": "Basic message object.\n\nA message object is defined as something that has a bunch of RFC 2822\nheaders and a payload.  It may optionally have an envelope header\n(a.k.a. Unix-From or From_ header).  If the message is a container (i.e. a\nmultipart or a message/rfc822), then the payload is a list of Message\nobjects, otherwise it is a string.\n\nMessage objects implement part of the `mapping' interface, which assumes\nthere is exactly one occurrence of the header per message.  Some headers\ndo in fact appear multiple times (e.g. Received) and for those headers,\nyou must use the explicit API to set or get all the headers.  Not all of\nthe mapping methods are implemented.",
      "relationships": []
    },
    {
      "id": "stdlib.cgi.MiniFieldStorage",
      "name": "MiniFieldStorage",
      "module": "cgi",
      "type": "class",
      "signature": "(name, value)",
      "description": "Like FieldStorage, for use when no file uploads are possible.",
      "relationships": []
    },
    {
      "id": "stdlib.cgi.StringIO",
      "name": "StringIO",
      "module": "cgi",
      "type": "class",
      "signature": "(initial_value='', newline='\\n')",
      "description": "Text I/O implementation using an in-memory buffer.\n\nThe initial_value argument sets the value of object.  The newline\nargument is like the one of TextIOWrapper's constructor.",
      "relationships": [
        {
          "target": "_TextIOBase",
          "type": "base_class"
        },
        {
          "target": "_IOBase",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.cgi.TextIOWrapper",
      "name": "TextIOWrapper",
      "module": "cgi",
      "type": "class",
      "signature": "(buffer, encoding=None, errors=None, newline=None, line_buffering=False, write_through=False)",
      "description": "Character and line based layer over a BufferedIOBase object, buffer.\n\nencoding gives the name of the encoding that the stream will be\ndecoded or encoded with. It defaults to locale.getpreferredencoding(False).\n\nerrors determines the strictness of encoding and decoding (see\nhelp(codecs.Codec) or the documentation for codecs.register) and\ndefaults to \"strict\".\n\nnewline controls how line endings are handled. It can be None, '',\n'\\n', '\\r', and '\\r\\n'.  It works as follows:\n\n* On input, if newline is None, universal newlines mode is\n  enabled. Lines in the input can end in '\\n', '\\r', or '\\r\\n', and\n  these are translated into '\\n' before being returned to the\n  caller. If it is '', universal newline mode is enabled, but line\n  endings are returned to the caller untranslated. If it has any of\n  the other legal values, input lines are only terminated by the given\n  string, and the line ending is returned to the caller untranslated.\n\n* On output, if newline is None, any '\\n' characters written are\n  translated to the system default line separator, os.linesep. If\n  newline is '' or '\\n', no translation takes place. If newline is any\n  of the other legal values, any '\\n' characters written are translated\n  to the given string.\n\nIf line_buffering is True, a call to flush is implied when a call to\nwrite contains a newline character.",
      "relationships": [
        {
          "target": "_TextIOBase",
          "type": "base_class"
        },
        {
          "target": "_IOBase",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.cgi.closelog",
      "name": "closelog",
      "module": "cgi",
      "type": "function",
      "signature": "()",
      "description": "Close the log file.",
      "relationships": [
        {
          "target": "stdlib.cgi.close",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.cgi.dolog",
      "name": "dolog",
      "module": "cgi",
      "type": "function",
      "signature": "(fmt, *args)",
      "description": "Write a log message to the log file.  See initlog() for docs.",
      "relationships": [
        {
          "target": "stdlib.cgi.write",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.cgi.initlog",
      "name": "initlog",
      "module": "cgi",
      "type": "function",
      "signature": "(*allargs)",
      "description": "Write a log message, if there is a log file.\n\nEven though this function is called initlog(), you should always\nuse log(); log is a variable that is set either to initlog\n(initially), to dolog (once the log file has been opened), or to\nnolog (when logging is disabled).\n\nThe first argument is a format string; the remaining arguments (if\nany) are arguments to the % operator, so e.g.\n    log(\"%s: %s\", \"a\", \"b\")\nwill write \"a: b\" to the log file, followed by a newline.\n\nIf the global logfp is not None, it should be a file object to\nwhich log data is written.\n\nIf the global logfp is None, the global logfile may be a string\ngiving a filename to open, in append mode.  This file should be\nworld writable!!!  If the file can't be opened, logging is\nsilently disabled (since there is no safe place where we could\nsend an error message).",
      "relationships": [
        {
          "target": "stdlib.cgi.log",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.open",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.cgi.log",
      "name": "log",
      "module": "cgi",
      "type": "function",
      "signature": "(*allargs)",
      "description": "Write a log message, if there is a log file.\n\nEven though this function is called initlog(), you should always\nuse log(); log is a variable that is set either to initlog\n(initially), to dolog (once the log file has been opened), or to\nnolog (when logging is disabled).\n\nThe first argument is a format string; the remaining arguments (if\nany) are arguments to the % operator, so e.g.\n    log(\"%s: %s\", \"a\", \"b\")\nwill write \"a: b\" to the log file, followed by a newline.\n\nIf the global logfp is not None, it should be a file object to\nwhich log data is written.\n\nIf the global logfp is None, the global logfile may be a string\ngiving a filename to open, in append mode.  This file should be\nworld writable!!!  If the file can't be opened, logging is\nsilently disabled (since there is no safe place where we could\nsend an error message).",
      "relationships": [
        {
          "target": "stdlib.cgi.log",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.open",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.cgi.nolog",
      "name": "nolog",
      "module": "cgi",
      "type": "function",
      "signature": "(*allargs)",
      "description": "Dummy function, assigned to log when logging is disabled.",
      "relationships": []
    },
    {
      "id": "stdlib.cgi.parse",
      "name": "parse",
      "module": "cgi",
      "type": "function",
      "signature": "(fp=None, environ=environ({'OSLogRateLimit': '64', 'MallocNanoZone': '0', 'USER': 'anthonycardillo', 'COMMAND_MODE': 'unix2003', '__CFBundleIdentifier': 'com.todesktop.230313mzl4w4u92', 'PATH': '/Users/anthonycardillo/Documents/personal/polyester/.venv/bin:/opt/homebrew/opt/postgresql@16/bin:/Users/anthonycardillo/.bun/bin:/Users/anthonycardillo/.bun/bin:/Users/anthonycardillo/.nvm/versions/node/v22.21.0/bin:/opt/homebrew/bin:/opt/homebrew/sbin:/usr/local/bin:/System/Cryptexes/App/usr/bin:/usr/bin:/bin:/usr/sbin:/sbin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/local/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/appleinternal/bin:/opt/pmk/env/global/bin:/Library/Apple/usr/bin:/opt/homebrew/opt/postgresql@16/bin:/Users/anthonycardillo/.bun/bin:/Users/anthonycardillo/.nvm/versions/node/v22.21.0/bin:/Users/anthonycardillo/.cursor/extensions/ms-python.debugpy-2025.18.0-darwin-arm64/bundled/scripts/noConfigScripts', 'LOGNAME': 'anthonycardillo', 'SSH_AUTH_SOCK': '/private/tmp/com.apple.launchd.fAtscmMPP1/Listeners', 'HOME': '/Users/anthonycardillo', 'SHELL': '/bin/zsh', 'TMPDIR': '/var/folders/6c/95f1yxcd673848zqjnj46_ww0000gn/T/', '__CF_USER_TEXT_ENCODING': '0x1F5:0x0:0x52', 'XPC_SERVICE_NAME': '0', 'XPC_FLAGS': '0x0', 'ORIGINAL_XDG_CURRENT_DESKTOP': 'undefined', 'CURSOR_TRACE_ID': '09c74175785640a8ac5df17c65b4361b', 'SHLVL': '1', 'PWD': '/Users/anthonycardillo/Documents/personal/polyester', 'OLDPWD': '/Users/anthonycardillo/Documents/personal/polyester', 'LANG': 'C.UTF-8', 'HOMEBREW_PREFIX': '/opt/homebrew', 'HOMEBREW_CELLAR': '/opt/homebrew/Cellar', 'HOMEBREW_REPOSITORY': '/opt/homebrew', 'INFOPATH': '/opt/homebrew/share/info:/opt/homebrew/share/info:', 'NVM_DIR': '/Users/anthonycardillo/.nvm', 'NVM_CD_FLAGS': '-q', 'NVM_BIN': '/Users/anthonycardillo/.nvm/versions/node/v22.21.0/bin', 'NVM_INC': '/Users/anthonycardillo/.nvm/versions/node/v22.21.0/include/node', 'BUN_INSTALL': '/Users/anthonycardillo/.bun', 'TERM_PROGRAM': 'vscode', 'TERM_PROGRAM_VERSION': '2.3.40', 'COLORTERM': 'truecolor', 'PYDEVD_DISABLE_FILE_VALIDATION': '1', 'VSCODE_DEBUGPY_ADAPTER_ENDPOINTS': '/Users/anthonycardillo/.cursor/extensions/ms-python.debugpy-2025.18.0-darwin-arm64/.noConfigDebugAdapterEndpoints/endpoint-bfdb369faf213a96.txt', 'BUNDLED_DEBUGPY_PATH': '/Users/anthonycardillo/.cursor/extensions/ms-python.debugpy-2025.18.0-darwin-arm64/bundled/libs/debugpy', 'GIT_ASKPASS': '/Applications/Cursor.app/Contents/Resources/app/extensions/git/dist/askpass.sh', 'VSCODE_GIT_ASKPASS_NODE': '/Applications/Cursor.app/Contents/Frameworks/Cursor Helper (Plugin).app/Contents/MacOS/Cursor Helper (Plugin)', 'VSCODE_GIT_ASKPASS_EXTRA_ARGS': '', 'VSCODE_GIT_ASKPASS_MAIN': '/Applications/Cursor.app/Contents/Resources/app/extensions/git/dist/askpass-main.js', 'VSCODE_GIT_IPC_HANDLE': '/var/folders/6c/95f1yxcd673848zqjnj46_ww0000gn/T/vscode-git-6a534ea802.sock', 'VSCODE_GIT_IPC_AUTH_TOKEN': '202d91e1cac1e6fc0c336e8f97ca643be8b35e2b331169aadb2c67f58384013f', 'VSCODE_INJECTION': '1', 'ZDOTDIR': '/Users/anthonycardillo', 'USER_ZDOTDIR': '/Users/anthonycardillo', 'TERM': 'xterm-256color', 'VSCODE_PROFILE_INITIALIZED': '1', 'VIRTUAL_ENV': '/Users/anthonycardillo/Documents/personal/polyester/.venv', 'VIRTUAL_ENV_PROMPT': '.venv', 'PS1': '(.venv) %n@%m %1~ %# ', '_': '/Users/anthonycardillo/Documents/personal/polyester/.venv/bin/python'}), keep_blank_values=0, strict_parsing=0, separator='&')",
      "description": "Parse a query in the environment or from a file (default stdin)\n\nArguments, all optional:\n\nfp              : file pointer; default: sys.stdin.buffer\n\nenviron         : environment dictionary; default: os.environ\n\nkeep_blank_values: flag indicating whether blank values in\n    percent-encoded forms should be treated as blank strings.\n    A true value indicates that blanks should be retained as\n    blank strings.  The default false value indicates that\n    blank values are to be ignored and treated as if they were\n    not included.\n\nstrict_parsing: flag indicating what to do with parsing errors.\n    If false (the default), errors are silently ignored.\n    If true, errors raise a ValueError exception.\n\nseparator: str. The symbol to use for separating the query arguments.\n    Defaults to &.",
      "relationships": [
        {
          "target": "stdlib.cgi.hasattr",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.parse_qs",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.parse_header",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.parse_multipart",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.int",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.decode",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.read",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.cgi.parse_header",
      "name": "parse_header",
      "module": "cgi",
      "type": "function",
      "signature": "(line)",
      "description": "Parse a Content-type like header.\n\nReturn the main content-type and a dictionary of options.",
      "relationships": [
        {
          "target": "stdlib.cgi._parseparam",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.__next__",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.find",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.lower",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.strip",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.replace",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.strip",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.len",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.replace",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.cgi.parse_multipart",
      "name": "parse_multipart",
      "module": "cgi",
      "type": "function",
      "signature": "(fp, pdict, encoding='utf-8', errors='replace', separator='&')",
      "description": "Parse multipart input.\n\nArguments:\nfp   : input file\npdict: dictionary containing other parameters of content-type header\nencoding, errors: request encoding and error handler, passed to\n    FieldStorage\n\nReturns a dictionary just like parse_qs(): keys are the field names, each\nvalue is a list of values for that field. For non-file fields, the value\nis a list of strings.",
      "relationships": [
        {
          "target": "stdlib.cgi.decode",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.format",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.Message",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.set_type",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.FieldStorage",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.getlist",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.cgi.print_arguments",
      "name": "print_arguments",
      "module": "cgi",
      "type": "function",
      "signature": "()",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.cgi.print",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.print",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.print",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.print",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.print",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.cgi.print_directory",
      "name": "print_directory",
      "module": "cgi",
      "type": "function",
      "signature": "()",
      "description": "Dump the current directory as HTML.",
      "relationships": [
        {
          "target": "stdlib.cgi.print",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.print",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.print",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.getcwd",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.print",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.print",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.escape",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.escape",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.str",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.cgi.print_environ",
      "name": "print_environ",
      "module": "cgi",
      "type": "function",
      "signature": "(environ=environ({'OSLogRateLimit': '64', 'MallocNanoZone': '0', 'USER': 'anthonycardillo', 'COMMAND_MODE': 'unix2003', '__CFBundleIdentifier': 'com.todesktop.230313mzl4w4u92', 'PATH': '/Users/anthonycardillo/Documents/personal/polyester/.venv/bin:/opt/homebrew/opt/postgresql@16/bin:/Users/anthonycardillo/.bun/bin:/Users/anthonycardillo/.bun/bin:/Users/anthonycardillo/.nvm/versions/node/v22.21.0/bin:/opt/homebrew/bin:/opt/homebrew/sbin:/usr/local/bin:/System/Cryptexes/App/usr/bin:/usr/bin:/bin:/usr/sbin:/sbin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/local/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/appleinternal/bin:/opt/pmk/env/global/bin:/Library/Apple/usr/bin:/opt/homebrew/opt/postgresql@16/bin:/Users/anthonycardillo/.bun/bin:/Users/anthonycardillo/.nvm/versions/node/v22.21.0/bin:/Users/anthonycardillo/.cursor/extensions/ms-python.debugpy-2025.18.0-darwin-arm64/bundled/scripts/noConfigScripts', 'LOGNAME': 'anthonycardillo', 'SSH_AUTH_SOCK': '/private/tmp/com.apple.launchd.fAtscmMPP1/Listeners', 'HOME': '/Users/anthonycardillo', 'SHELL': '/bin/zsh', 'TMPDIR': '/var/folders/6c/95f1yxcd673848zqjnj46_ww0000gn/T/', '__CF_USER_TEXT_ENCODING': '0x1F5:0x0:0x52', 'XPC_SERVICE_NAME': '0', 'XPC_FLAGS': '0x0', 'ORIGINAL_XDG_CURRENT_DESKTOP': 'undefined', 'CURSOR_TRACE_ID': '09c74175785640a8ac5df17c65b4361b', 'SHLVL': '1', 'PWD': '/Users/anthonycardillo/Documents/personal/polyester', 'OLDPWD': '/Users/anthonycardillo/Documents/personal/polyester', 'LANG': 'C.UTF-8', 'HOMEBREW_PREFIX': '/opt/homebrew', 'HOMEBREW_CELLAR': '/opt/homebrew/Cellar', 'HOMEBREW_REPOSITORY': '/opt/homebrew', 'INFOPATH': '/opt/homebrew/share/info:/opt/homebrew/share/info:', 'NVM_DIR': '/Users/anthonycardillo/.nvm', 'NVM_CD_FLAGS': '-q', 'NVM_BIN': '/Users/anthonycardillo/.nvm/versions/node/v22.21.0/bin', 'NVM_INC': '/Users/anthonycardillo/.nvm/versions/node/v22.21.0/include/node', 'BUN_INSTALL': '/Users/anthonycardillo/.bun', 'TERM_PROGRAM': 'vscode', 'TERM_PROGRAM_VERSION': '2.3.40', 'COLORTERM': 'truecolor', 'PYDEVD_DISABLE_FILE_VALIDATION': '1', 'VSCODE_DEBUGPY_ADAPTER_ENDPOINTS': '/Users/anthonycardillo/.cursor/extensions/ms-python.debugpy-2025.18.0-darwin-arm64/.noConfigDebugAdapterEndpoints/endpoint-bfdb369faf213a96.txt', 'BUNDLED_DEBUGPY_PATH': '/Users/anthonycardillo/.cursor/extensions/ms-python.debugpy-2025.18.0-darwin-arm64/bundled/libs/debugpy', 'GIT_ASKPASS': '/Applications/Cursor.app/Contents/Resources/app/extensions/git/dist/askpass.sh', 'VSCODE_GIT_ASKPASS_NODE': '/Applications/Cursor.app/Contents/Frameworks/Cursor Helper (Plugin).app/Contents/MacOS/Cursor Helper (Plugin)', 'VSCODE_GIT_ASKPASS_EXTRA_ARGS': '', 'VSCODE_GIT_ASKPASS_MAIN': '/Applications/Cursor.app/Contents/Resources/app/extensions/git/dist/askpass-main.js', 'VSCODE_GIT_IPC_HANDLE': '/var/folders/6c/95f1yxcd673848zqjnj46_ww0000gn/T/vscode-git-6a534ea802.sock', 'VSCODE_GIT_IPC_AUTH_TOKEN': '202d91e1cac1e6fc0c336e8f97ca643be8b35e2b331169aadb2c67f58384013f', 'VSCODE_INJECTION': '1', 'ZDOTDIR': '/Users/anthonycardillo', 'USER_ZDOTDIR': '/Users/anthonycardillo', 'TERM': 'xterm-256color', 'VSCODE_PROFILE_INITIALIZED': '1', 'VIRTUAL_ENV': '/Users/anthonycardillo/Documents/personal/polyester/.venv', 'VIRTUAL_ENV_PROMPT': '.venv', 'PS1': '(.venv) %n@%m %1~ %# ', '_': '/Users/anthonycardillo/Documents/personal/polyester/.venv/bin/python'}))",
      "description": "Dump the shell environment as HTML.",
      "relationships": [
        {
          "target": "stdlib.cgi.sorted",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.print",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.print",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.print",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.print",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.print",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.keys",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.print",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.escape",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.escape",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.cgi.print_environ_usage",
      "name": "print_environ_usage",
      "module": "cgi",
      "type": "function",
      "signature": "()",
      "description": "Dump a list of environment variables used by CGI as HTML.",
      "relationships": [
        {
          "target": "stdlib.cgi.print",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.cgi.print_exception",
      "name": "print_exception",
      "module": "cgi",
      "type": "function",
      "signature": "(type=None, value=None, tb=None, limit=None)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.cgi.print",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.print",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.print",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.exc_info",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.format_tb",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.format_exception_only",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.escape",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.escape",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.join",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.cgi.print_form",
      "name": "print_form",
      "module": "cgi",
      "type": "function",
      "signature": "(form)",
      "description": "Dump the contents of a form as HTML.",
      "relationships": [
        {
          "target": "stdlib.cgi.sorted",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.print",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.print",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.print",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.print",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.print",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.keys",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.print",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.print",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.print",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.print",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.escape",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.escape",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.escape",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.repr",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.repr",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.type",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.cgi.test",
      "name": "test",
      "module": "cgi",
      "type": "function",
      "signature": "(environ=environ({'OSLogRateLimit': '64', 'MallocNanoZone': '0', 'USER': 'anthonycardillo', 'COMMAND_MODE': 'unix2003', '__CFBundleIdentifier': 'com.todesktop.230313mzl4w4u92', 'PATH': '/Users/anthonycardillo/Documents/personal/polyester/.venv/bin:/opt/homebrew/opt/postgresql@16/bin:/Users/anthonycardillo/.bun/bin:/Users/anthonycardillo/.bun/bin:/Users/anthonycardillo/.nvm/versions/node/v22.21.0/bin:/opt/homebrew/bin:/opt/homebrew/sbin:/usr/local/bin:/System/Cryptexes/App/usr/bin:/usr/bin:/bin:/usr/sbin:/sbin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/local/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/bin:/var/run/com.apple.security.cryptexd/codex.system/bootstrap/usr/appleinternal/bin:/opt/pmk/env/global/bin:/Library/Apple/usr/bin:/opt/homebrew/opt/postgresql@16/bin:/Users/anthonycardillo/.bun/bin:/Users/anthonycardillo/.nvm/versions/node/v22.21.0/bin:/Users/anthonycardillo/.cursor/extensions/ms-python.debugpy-2025.18.0-darwin-arm64/bundled/scripts/noConfigScripts', 'LOGNAME': 'anthonycardillo', 'SSH_AUTH_SOCK': '/private/tmp/com.apple.launchd.fAtscmMPP1/Listeners', 'HOME': '/Users/anthonycardillo', 'SHELL': '/bin/zsh', 'TMPDIR': '/var/folders/6c/95f1yxcd673848zqjnj46_ww0000gn/T/', '__CF_USER_TEXT_ENCODING': '0x1F5:0x0:0x52', 'XPC_SERVICE_NAME': '0', 'XPC_FLAGS': '0x0', 'ORIGINAL_XDG_CURRENT_DESKTOP': 'undefined', 'CURSOR_TRACE_ID': '09c74175785640a8ac5df17c65b4361b', 'SHLVL': '1', 'PWD': '/Users/anthonycardillo/Documents/personal/polyester', 'OLDPWD': '/Users/anthonycardillo/Documents/personal/polyester', 'LANG': 'C.UTF-8', 'HOMEBREW_PREFIX': '/opt/homebrew', 'HOMEBREW_CELLAR': '/opt/homebrew/Cellar', 'HOMEBREW_REPOSITORY': '/opt/homebrew', 'INFOPATH': '/opt/homebrew/share/info:/opt/homebrew/share/info:', 'NVM_DIR': '/Users/anthonycardillo/.nvm', 'NVM_CD_FLAGS': '-q', 'NVM_BIN': '/Users/anthonycardillo/.nvm/versions/node/v22.21.0/bin', 'NVM_INC': '/Users/anthonycardillo/.nvm/versions/node/v22.21.0/include/node', 'BUN_INSTALL': '/Users/anthonycardillo/.bun', 'TERM_PROGRAM': 'vscode', 'TERM_PROGRAM_VERSION': '2.3.40', 'COLORTERM': 'truecolor', 'PYDEVD_DISABLE_FILE_VALIDATION': '1', 'VSCODE_DEBUGPY_ADAPTER_ENDPOINTS': '/Users/anthonycardillo/.cursor/extensions/ms-python.debugpy-2025.18.0-darwin-arm64/.noConfigDebugAdapterEndpoints/endpoint-bfdb369faf213a96.txt', 'BUNDLED_DEBUGPY_PATH': '/Users/anthonycardillo/.cursor/extensions/ms-python.debugpy-2025.18.0-darwin-arm64/bundled/libs/debugpy', 'GIT_ASKPASS': '/Applications/Cursor.app/Contents/Resources/app/extensions/git/dist/askpass.sh', 'VSCODE_GIT_ASKPASS_NODE': '/Applications/Cursor.app/Contents/Frameworks/Cursor Helper (Plugin).app/Contents/MacOS/Cursor Helper (Plugin)', 'VSCODE_GIT_ASKPASS_EXTRA_ARGS': '', 'VSCODE_GIT_ASKPASS_MAIN': '/Applications/Cursor.app/Contents/Resources/app/extensions/git/dist/askpass-main.js', 'VSCODE_GIT_IPC_HANDLE': '/var/folders/6c/95f1yxcd673848zqjnj46_ww0000gn/T/vscode-git-6a534ea802.sock', 'VSCODE_GIT_IPC_AUTH_TOKEN': '202d91e1cac1e6fc0c336e8f97ca643be8b35e2b331169aadb2c67f58384013f', 'VSCODE_INJECTION': '1', 'ZDOTDIR': '/Users/anthonycardillo', 'USER_ZDOTDIR': '/Users/anthonycardillo', 'TERM': 'xterm-256color', 'VSCODE_PROFILE_INITIALIZED': '1', 'VIRTUAL_ENV': '/Users/anthonycardillo/Documents/personal/polyester/.venv', 'VIRTUAL_ENV_PROMPT': '.venv', 'PS1': '(.venv) %n@%m %1~ %# ', '_': '/Users/anthonycardillo/Documents/personal/polyester/.venv/bin/python'}))",
      "description": "Robust test CGI script, usable as main program.\n\nWrite minimal HTTP headers and dump all information provided to\nthe script in HTML form.",
      "relationships": [
        {
          "target": "stdlib.cgi.print",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.print",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.print",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.FieldStorage",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.print_directory",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.print_arguments",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.print_form",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.print_environ",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.print_environ_usage",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.print",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.g",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.FieldStorage",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.print_directory",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.print_arguments",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.print_form",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.print_environ",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.exec",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.f",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.print_exception",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.print_exception",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.cgi.valid_boundary",
      "name": "valid_boundary",
      "module": "cgi",
      "type": "function",
      "signature": "(s)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.cgi.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.cgi.match",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.cgitb.Hook",
      "name": "Hook",
      "module": "cgitb",
      "type": "class",
      "signature": "(display=1, logdir=None, context=5, file=None, format='html')",
      "description": "A hook to replace sys.excepthook that shows tracebacks in HTML.",
      "relationships": []
    },
    {
      "id": "stdlib.cgitb.enable",
      "name": "enable",
      "module": "cgitb",
      "type": "function",
      "signature": "(display=1, logdir=None, context=5, format='html')",
      "description": "Install an exception handler that formats tracebacks as HTML.\n\nThe optional argument 'display' can be set to 0 to suppress sending the\ntraceback to the browser, and 'logdir' can be set to a directory to cause\ntracebacks to be written to files there.",
      "relationships": [
        {
          "target": "stdlib.cgitb.Hook",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.cgitb.grey",
      "name": "grey",
      "module": "cgitb",
      "type": "function",
      "signature": "(text)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.cgitb.html",
      "name": "html",
      "module": "cgitb",
      "type": "function",
      "signature": "(einfo, context=5)",
      "description": "Return a nice HTML document describing a given traceback.",
      "relationships": [
        {
          "target": "stdlib.cgitb.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.ctime",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.getinnerframes",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.dir",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.time",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.getargvalues",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.scanvars",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.append",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.append",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.repr",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.append",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.heading",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.small",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.abspath",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.getattr",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.join",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.escape",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.strong",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.formatargvalues",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.getline",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.append",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.append",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.small",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.join",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.strong",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.escape",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.join",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.join",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.split",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.strong",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.escape",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.escape",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.small",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.append",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.append",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.grey",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.escape",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.str",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.format_exception",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.escape",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.strong",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.strong",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.join",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.str",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.str",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.str",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.preformat",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.preformat",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.grey",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.strong",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.repr",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.repr",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.len",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.split",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.str",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.cgitb.lookup",
      "name": "lookup",
      "module": "cgitb",
      "type": "function",
      "signature": "(name, frame, locals)",
      "description": "Find the value for a given name in the given environment.",
      "relationships": [
        {
          "target": "stdlib.cgitb.type",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.type",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.hasattr",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.getattr",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.cgitb.reset",
      "name": "reset",
      "module": "cgitb",
      "type": "function",
      "signature": "()",
      "description": "Return a string that resets the CGI and browser to a known state.",
      "relationships": []
    },
    {
      "id": "stdlib.cgitb.scanvars",
      "name": "scanvars",
      "module": "cgitb",
      "type": "function",
      "signature": "(reader, frame, locals)",
      "description": "Scan one logical line of Python and look up values of variables used.",
      "relationships": [
        {
          "target": "stdlib.cgitb.generate_tokens",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.lookup",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.append",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.getattr",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.append",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.cgitb.small",
      "name": "small",
      "module": "cgitb",
      "type": "function",
      "signature": "(text)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.cgitb.strong",
      "name": "strong",
      "module": "cgitb",
      "type": "function",
      "signature": "(text)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.cgitb.text",
      "name": "text",
      "module": "cgitb",
      "type": "function",
      "signature": "(einfo, context=5)",
      "description": "Return a plain text document describing a given traceback.",
      "relationships": [
        {
          "target": "stdlib.cgitb.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.ctime",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.getinnerframes",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.dir",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.time",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.getargvalues",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.scanvars",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.append",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.append",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.repr",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.append",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.join",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.getattr",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.join",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.join",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.str",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.abspath",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.formatargvalues",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.getline",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.append",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.append",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.append",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.join",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.str",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.str",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.join",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.format_exception",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.split",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.rstrip",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.repr",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.repr",
          "type": "calls"
        },
        {
          "target": "stdlib.cgitb.split",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.chunk.Chunk",
      "name": "Chunk",
      "module": "chunk",
      "type": "class",
      "signature": "(file, align=True, bigendian=True, inclheader=False)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.cmd.Cmd",
      "name": "Cmd",
      "module": "cmd",
      "type": "class",
      "signature": "(completekey='tab', stdin=None, stdout=None)",
      "description": "A simple framework for writing line-oriented command interpreters.\n\nThese are often useful for test harnesses, administrative tools, and\nprototypes that will later be wrapped in a more sophisticated interface.\n\nA Cmd instance or subclass instance is a line-oriented interpreter\nframework.  There is no good reason to instantiate Cmd itself; rather,\nit's useful as a superclass of an interpreter class you define yourself\nin order to inherit Cmd's methods and encapsulate action methods.",
      "relationships": []
    },
    {
      "id": "stdlib.code.CommandCompiler",
      "name": "CommandCompiler",
      "module": "code",
      "type": "class",
      "signature": "()",
      "description": "Instances of this class have __call__ methods identical in\nsignature to compile_command; the difference is that if the\ninstance compiles program text containing a __future__ statement,\nthe instance 'remembers' and compiles all subsequent program texts\nwith the statement in force.",
      "relationships": []
    },
    {
      "id": "stdlib.code.InteractiveConsole",
      "name": "InteractiveConsole",
      "module": "code",
      "type": "class",
      "signature": "(locals=None, filename='<console>')",
      "description": "Closely emulate the behavior of the interactive Python interpreter.\n\nThis class builds on InteractiveInterpreter and adds prompting\nusing the familiar sys.ps1 and sys.ps2, and input buffering.",
      "relationships": [
        {
          "target": "InteractiveInterpreter",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.code.InteractiveInterpreter",
      "name": "InteractiveInterpreter",
      "module": "code",
      "type": "class",
      "signature": "(locals=None)",
      "description": "Base class for InteractiveConsole.\n\nThis class deals with parsing and interpreter state (the user's\nnamespace); it doesn't deal with input buffering or prompting or\ninput file naming (the filename is always passed in explicitly).",
      "relationships": []
    },
    {
      "id": "stdlib.code.compile_command",
      "name": "compile_command",
      "module": "code",
      "type": "function",
      "signature": "(source, filename='<input>', symbol='single')",
      "description": "Compile a command and determine whether it is incomplete.\n\nArguments:\n\nsource -- the source string; may contain \\n characters\nfilename -- optional filename from which source was read; default\n            \"<input>\"\nsymbol -- optional grammar start symbol; \"single\" (default), \"exec\"\n          or \"eval\"\n\nReturn value / exceptions raised:\n\n- Return a code object if the command is complete and valid\n- Return None if the command is incomplete\n- Raise SyntaxError, ValueError or OverflowError if the command is a\n  syntax error (OverflowError and ValueError can be produced by\n  malformed literals).",
      "relationships": [
        {
          "target": "stdlib.code._maybe_compile",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.code.interact",
      "name": "interact",
      "module": "code",
      "type": "function",
      "signature": "(banner=None, readfunc=None, local=None, exitmsg=None)",
      "description": "Closely emulate the interactive Python interpreter.\n\nThis is a backwards compatible interface to the InteractiveConsole\nclass.  When readfunc is not specified, it attempts to import the\nreadline module to enable GNU readline if it is available.\n\nArguments (all optional, all default to None):\n\nbanner -- passed to InteractiveConsole.interact()\nreadfunc -- if not None, replaces InteractiveConsole.raw_input()\nlocal -- passed to InteractiveInterpreter.__init__()\nexitmsg -- passed to InteractiveConsole.interact()",
      "relationships": [
        {
          "target": "stdlib.code.InteractiveConsole",
          "type": "calls"
        },
        {
          "target": "stdlib.code.interact",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.codecs.BufferedIncrementalDecoder",
      "name": "BufferedIncrementalDecoder",
      "module": "codecs",
      "type": "class",
      "signature": "(errors='strict')",
      "description": "This subclass of IncrementalDecoder can be used as the baseclass for an\nincremental decoder if the decoder must be able to handle incomplete\nbyte sequences.",
      "relationships": [
        {
          "target": "IncrementalDecoder",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.codecs.BufferedIncrementalEncoder",
      "name": "BufferedIncrementalEncoder",
      "module": "codecs",
      "type": "class",
      "signature": "(errors='strict')",
      "description": "This subclass of IncrementalEncoder can be used as the baseclass for an\nincremental encoder if the encoder must keep some of the output in a\nbuffer between calls to encode().",
      "relationships": [
        {
          "target": "IncrementalEncoder",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.codecs.Codec",
      "name": "Codec",
      "module": "codecs",
      "type": "class",
      "signature": "()",
      "description": "Defines the interface for stateless encoders/decoders.\n\nThe .encode()/.decode() methods may use different error\nhandling schemes by providing the errors argument. These\nstring values are predefined:\n\n 'strict' - raise a ValueError error (or a subclass)\n 'ignore' - ignore the character and continue with the next\n 'replace' - replace with a suitable replacement character;\n            Python will use the official U+FFFD REPLACEMENT\n            CHARACTER for the builtin Unicode codecs on\n            decoding and '?' on encoding.\n 'surrogateescape' - replace with private code points U+DCnn.\n 'xmlcharrefreplace' - Replace with the appropriate XML\n                       character reference (only for encoding).\n 'backslashreplace'  - Replace with backslashed escape sequences.\n 'namereplace'       - Replace with \\N{...} escape sequences\n                       (only for encoding).\n\nThe set of allowed values can be extended via register_error.",
      "relationships": []
    },
    {
      "id": "stdlib.codecs.CodecInfo",
      "name": "CodecInfo",
      "module": "codecs",
      "type": "class",
      "signature": "(encode, decode, streamreader=None, streamwriter=None, incrementalencoder=None, incrementaldecoder=None, name=None, *, _is_text_encoding=None)",
      "description": "Codec details when looking up the codec registry",
      "relationships": [
        {
          "target": "tuple",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.codecs.EncodedFile",
      "name": "EncodedFile",
      "module": "codecs",
      "type": "function",
      "signature": "(file, data_encoding, file_encoding=None, errors='strict')",
      "description": "Return a wrapped version of file which provides transparent\nencoding translation.\n\nData written to the wrapped file is decoded according\nto the given data_encoding and then encoded to the underlying\nfile using file_encoding. The intermediate data type\nwill usually be Unicode but depends on the specified codecs.\n\nBytes read from the file are decoded using file_encoding and then\npassed back to the caller encoded using data_encoding.\n\nIf file_encoding is not given, it defaults to data_encoding.\n\nerrors may be given to define the error handling. It defaults\nto 'strict' which causes ValueErrors to be raised in case an\nencoding error occurs.\n\nThe returned wrapped file object provides two extra attributes\n.data_encoding and .file_encoding which reflect the given\nparameters of the same name. The attributes can be used for\nintrospection by Python programs.",
      "relationships": [
        {
          "target": "stdlib.codecs.lookup",
          "type": "calls"
        },
        {
          "target": "stdlib.codecs.lookup",
          "type": "calls"
        },
        {
          "target": "stdlib.codecs.StreamRecoder",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.codecs.IncrementalDecoder",
      "name": "IncrementalDecoder",
      "module": "codecs",
      "type": "class",
      "signature": "(errors='strict')",
      "description": "An IncrementalDecoder decodes an input in multiple steps. The input can\nbe passed piece by piece to the decode() method. The IncrementalDecoder\nremembers the state of the decoding process between calls to decode().",
      "relationships": []
    },
    {
      "id": "stdlib.codecs.IncrementalEncoder",
      "name": "IncrementalEncoder",
      "module": "codecs",
      "type": "class",
      "signature": "(errors='strict')",
      "description": "An IncrementalEncoder encodes an input in multiple steps. The input can\nbe passed piece by piece to the encode() method. The IncrementalEncoder\nremembers the state of the encoding process between calls to encode().",
      "relationships": []
    },
    {
      "id": "stdlib.codecs.StreamReader",
      "name": "StreamReader",
      "module": "codecs",
      "type": "class",
      "signature": "(stream, errors='strict')",
      "description": "Defines the interface for stateless encoders/decoders.\n\nThe .encode()/.decode() methods may use different error\nhandling schemes by providing the errors argument. These\nstring values are predefined:\n\n 'strict' - raise a ValueError error (or a subclass)\n 'ignore' - ignore the character and continue with the next\n 'replace' - replace with a suitable replacement character;\n            Python will use the official U+FFFD REPLACEMENT\n            CHARACTER for the builtin Unicode codecs on\n            decoding and '?' on encoding.\n 'surrogateescape' - replace with private code points U+DCnn.\n 'xmlcharrefreplace' - Replace with the appropriate XML\n                       character reference (only for encoding).\n 'backslashreplace'  - Replace with backslashed escape sequences.\n 'namereplace'       - Replace with \\N{...} escape sequences\n                       (only for encoding).\n\nThe set of allowed values can be extended via register_error.",
      "relationships": [
        {
          "target": "Codec",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.codecs.StreamReaderWriter",
      "name": "StreamReaderWriter",
      "module": "codecs",
      "type": "class",
      "signature": "(stream, Reader, Writer, errors='strict')",
      "description": "StreamReaderWriter instances allow wrapping streams which\nwork in both read and write modes.\n\nThe design is such that one can use the factory functions\nreturned by the codec.lookup() function to construct the\ninstance.",
      "relationships": []
    },
    {
      "id": "stdlib.codecs.StreamRecoder",
      "name": "StreamRecoder",
      "module": "codecs",
      "type": "class",
      "signature": "(stream, encode, decode, Reader, Writer, errors='strict')",
      "description": "StreamRecoder instances translate data from one encoding to another.\n\nThey use the complete set of APIs returned by the\ncodecs.lookup() function to implement their task.\n\nData written to the StreamRecoder is first decoded into an\nintermediate format (depending on the \"decode\" codec) and then\nwritten to the underlying stream using an instance of the provided\nWriter class.\n\nIn the other direction, data is read from the underlying stream using\na Reader instance and then encoded and returned to the caller.",
      "relationships": []
    },
    {
      "id": "stdlib.codecs.StreamWriter",
      "name": "StreamWriter",
      "module": "codecs",
      "type": "class",
      "signature": "(stream, errors='strict')",
      "description": "Defines the interface for stateless encoders/decoders.\n\nThe .encode()/.decode() methods may use different error\nhandling schemes by providing the errors argument. These\nstring values are predefined:\n\n 'strict' - raise a ValueError error (or a subclass)\n 'ignore' - ignore the character and continue with the next\n 'replace' - replace with a suitable replacement character;\n            Python will use the official U+FFFD REPLACEMENT\n            CHARACTER for the builtin Unicode codecs on\n            decoding and '?' on encoding.\n 'surrogateescape' - replace with private code points U+DCnn.\n 'xmlcharrefreplace' - Replace with the appropriate XML\n                       character reference (only for encoding).\n 'backslashreplace'  - Replace with backslashed escape sequences.\n 'namereplace'       - Replace with \\N{...} escape sequences\n                       (only for encoding).\n\nThe set of allowed values can be extended via register_error.",
      "relationships": [
        {
          "target": "Codec",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.codecs.getdecoder",
      "name": "getdecoder",
      "module": "codecs",
      "type": "function",
      "signature": "(encoding)",
      "description": "Lookup up the codec for the given encoding and return\nits decoder function.\n\nRaises a LookupError in case the encoding cannot be found.",
      "relationships": [
        {
          "target": "stdlib.codecs.lookup",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.codecs.getencoder",
      "name": "getencoder",
      "module": "codecs",
      "type": "function",
      "signature": "(encoding)",
      "description": "Lookup up the codec for the given encoding and return\nits encoder function.\n\nRaises a LookupError in case the encoding cannot be found.",
      "relationships": [
        {
          "target": "stdlib.codecs.lookup",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.codecs.getincrementaldecoder",
      "name": "getincrementaldecoder",
      "module": "codecs",
      "type": "function",
      "signature": "(encoding)",
      "description": "Lookup up the codec for the given encoding and return\nits IncrementalDecoder class or factory function.\n\nRaises a LookupError in case the encoding cannot be found\nor the codecs doesn't provide an incremental decoder.",
      "relationships": [
        {
          "target": "stdlib.codecs.lookup",
          "type": "calls"
        },
        {
          "target": "stdlib.codecs.LookupError",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.codecs.getincrementalencoder",
      "name": "getincrementalencoder",
      "module": "codecs",
      "type": "function",
      "signature": "(encoding)",
      "description": "Lookup up the codec for the given encoding and return\nits IncrementalEncoder class or factory function.\n\nRaises a LookupError in case the encoding cannot be found\nor the codecs doesn't provide an incremental encoder.",
      "relationships": [
        {
          "target": "stdlib.codecs.lookup",
          "type": "calls"
        },
        {
          "target": "stdlib.codecs.LookupError",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.codecs.getreader",
      "name": "getreader",
      "module": "codecs",
      "type": "function",
      "signature": "(encoding)",
      "description": "Lookup up the codec for the given encoding and return\nits StreamReader class or factory function.\n\nRaises a LookupError in case the encoding cannot be found.",
      "relationships": [
        {
          "target": "stdlib.codecs.lookup",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.codecs.getwriter",
      "name": "getwriter",
      "module": "codecs",
      "type": "function",
      "signature": "(encoding)",
      "description": "Lookup up the codec for the given encoding and return\nits StreamWriter class or factory function.\n\nRaises a LookupError in case the encoding cannot be found.",
      "relationships": [
        {
          "target": "stdlib.codecs.lookup",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.codecs.iterdecode",
      "name": "iterdecode",
      "module": "codecs",
      "type": "function",
      "signature": "(iterator, encoding, errors='strict', **kwargs)",
      "description": "Decoding iterator.\n\nDecodes the input strings from the iterator using an IncrementalDecoder.\n\nerrors and kwargs are passed through to the IncrementalDecoder\nconstructor.",
      "relationships": [
        {
          "target": "stdlib.codecs.decode",
          "type": "calls"
        },
        {
          "target": "stdlib.codecs.getincrementaldecoder",
          "type": "calls"
        },
        {
          "target": "stdlib.codecs.decode",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.codecs.iterencode",
      "name": "iterencode",
      "module": "codecs",
      "type": "function",
      "signature": "(iterator, encoding, errors='strict', **kwargs)",
      "description": "Encoding iterator.\n\nEncodes the input strings from the iterator using an IncrementalEncoder.\n\nerrors and kwargs are passed through to the IncrementalEncoder\nconstructor.",
      "relationships": [
        {
          "target": "stdlib.codecs.encode",
          "type": "calls"
        },
        {
          "target": "stdlib.codecs.getincrementalencoder",
          "type": "calls"
        },
        {
          "target": "stdlib.codecs.encode",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.codecs.make_encoding_map",
      "name": "make_encoding_map",
      "module": "codecs",
      "type": "function",
      "signature": "(decoding_map)",
      "description": "Creates an encoding map from a decoding map.\n\nIf a target mapping in the decoding map occurs multiple\ntimes, then that target is mapped to None (undefined mapping),\ncausing an exception when encountered by the charmap codec\nduring translation.\n\nOne example where this happens is cp875.py which decodes\nmultiple character to \\u001a.",
      "relationships": [
        {
          "target": "stdlib.codecs.items",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.codecs.make_identity_dict",
      "name": "make_identity_dict",
      "module": "codecs",
      "type": "function",
      "signature": "(rng)",
      "description": "make_identity_dict(rng) -> dict\n\nReturn a dictionary where elements of the rng sequence are\nmapped to themselves.",
      "relationships": []
    },
    {
      "id": "stdlib.codecs.open",
      "name": "open",
      "module": "codecs",
      "type": "function",
      "signature": "(filename, mode='r', encoding=None, errors='strict', buffering=-1)",
      "description": "Open an encoded file using the given mode and return\na wrapped version providing transparent encoding/decoding.\n\nNote: The wrapped version will only accept the object format\ndefined by the codecs, i.e. Unicode objects for most builtin\ncodecs. Output is also codec dependent and will usually be\nUnicode as well.\n\nUnderlying encoded files are always opened in binary mode.\nThe default file mode is 'r', meaning to open the file in read mode.\n\nencoding specifies the encoding which is to be used for the\nfile.\n\nerrors may be given to define the error handling. It defaults\nto 'strict' which causes ValueErrors to be raised in case an\nencoding error occurs.\n\nbuffering has the same meaning as for the builtin open() API.\nIt defaults to -1 which means that the default buffer size will\nbe used.\n\nThe returned wrapped file object provides an extra attribute\n.encoding which allows querying the used encoding. This\nattribute is only available if an encoding was specified as\nparameter.",
      "relationships": [
        {
          "target": "stdlib.codecs.open",
          "type": "calls"
        },
        {
          "target": "stdlib.codecs.lookup",
          "type": "calls"
        },
        {
          "target": "stdlib.codecs.StreamReaderWriter",
          "type": "calls"
        },
        {
          "target": "stdlib.codecs.close",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.codeop.CommandCompiler",
      "name": "CommandCompiler",
      "module": "codeop",
      "type": "class",
      "signature": "()",
      "description": "Instances of this class have __call__ methods identical in\nsignature to compile_command; the difference is that if the\ninstance compiles program text containing a __future__ statement,\nthe instance 'remembers' and compiles all subsequent program texts\nwith the statement in force.",
      "relationships": []
    },
    {
      "id": "stdlib.codeop.Compile",
      "name": "Compile",
      "module": "codeop",
      "type": "class",
      "signature": "()",
      "description": "Instances of this class behave much like the built-in compile\nfunction, but if one is used to compile text containing a future\nstatement, it \"remembers\" and compiles all subsequent program texts\nwith the statement in force.",
      "relationships": []
    },
    {
      "id": "stdlib.codeop.compile_command",
      "name": "compile_command",
      "module": "codeop",
      "type": "function",
      "signature": "(source, filename='<input>', symbol='single')",
      "description": "Compile a command and determine whether it is incomplete.\n\nArguments:\n\nsource -- the source string; may contain \\n characters\nfilename -- optional filename from which source was read; default\n            \"<input>\"\nsymbol -- optional grammar start symbol; \"single\" (default), \"exec\"\n          or \"eval\"\n\nReturn value / exceptions raised:\n\n- Return a code object if the command is complete and valid\n- Return None if the command is incomplete\n- Raise SyntaxError, ValueError or OverflowError if the command is a\n  syntax error (OverflowError and ValueError can be produced by\n  malformed literals).",
      "relationships": [
        {
          "target": "stdlib.codeop._maybe_compile",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.collections.ChainMap",
      "name": "ChainMap",
      "module": "collections",
      "type": "class",
      "signature": "(*maps)",
      "description": "A ChainMap groups multiple dicts (or other mappings) together\nto create a single, updateable view.\n\nThe underlying mappings are stored in a list.  That list is public and can\nbe accessed or updated using the *maps* attribute.  There is no other\nstate.\n\nLookups search the underlying mappings successively until a key is found.\nIn contrast, writes, updates, and deletions only operate on the first\nmapping.",
      "relationships": [
        {
          "target": "MutableMapping",
          "type": "base_class"
        },
        {
          "target": "Mapping",
          "type": "base_class"
        },
        {
          "target": "Collection",
          "type": "base_class"
        },
        {
          "target": "Sized",
          "type": "base_class"
        },
        {
          "target": "Iterable",
          "type": "base_class"
        },
        {
          "target": "Container",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.collections.Counter",
      "name": "Counter",
      "module": "collections",
      "type": "class",
      "signature": "(iterable=None, /, **kwds)",
      "description": "Dict subclass for counting hashable items.  Sometimes called a bag\nor multiset.  Elements are stored as dictionary keys and their counts\nare stored as dictionary values.\n\n>>> c = Counter('abcdeabcdabcaba')  # count elements from a string\n\n>>> c.most_common(3)                # three most common elements\n[('a', 5), ('b', 4), ('c', 3)]\n>>> sorted(c)                       # list all unique elements\n['a', 'b', 'c', 'd', 'e']\n>>> ''.join(sorted(c.elements()))   # list elements with repetitions\n'aaaaabbbbcccdde'\n>>> sum(c.values())                 # total of all counts\n15\n\n>>> c['a']                          # count of letter 'a'\n5\n>>> for elem in 'shazam':           # update counts from an iterable\n...     c[elem] += 1                # by adding 1 to each element's count\n>>> c['a']                          # now there are seven 'a'\n7\n>>> del c['b']                      # remove all 'b'\n>>> c['b']                          # now there are zero 'b'\n0\n\n>>> d = Counter('simsalabim')       # make another counter\n>>> c.update(d)                     # add in the second counter\n>>> c['a']                          # now there are nine 'a'\n9\n\n>>> c.clear()                       # empty the counter\n>>> c\nCounter()\n\nNote:  If a count is set to zero or reduced to zero, it will remain\nin the counter until the entry is deleted or the counter is cleared:\n\n>>> c = Counter('aaabbc')\n>>> c['b'] -= 2                     # reduce the count of 'b' by two\n>>> c.most_common()                 # 'b' is still in, but its count is zero\n[('a', 3), ('c', 1), ('b', 0)]",
      "relationships": [
        {
          "target": "dict",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.collections.UserDict",
      "name": "UserDict",
      "module": "collections",
      "type": "class",
      "signature": "(dict=None, /, **kwargs)",
      "description": "",
      "relationships": [
        {
          "target": "MutableMapping",
          "type": "base_class"
        },
        {
          "target": "Mapping",
          "type": "base_class"
        },
        {
          "target": "Collection",
          "type": "base_class"
        },
        {
          "target": "Sized",
          "type": "base_class"
        },
        {
          "target": "Iterable",
          "type": "base_class"
        },
        {
          "target": "Container",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.collections.UserList",
      "name": "UserList",
      "module": "collections",
      "type": "class",
      "signature": "(initlist=None)",
      "description": "A more or less complete user-defined wrapper around list objects.",
      "relationships": [
        {
          "target": "MutableSequence",
          "type": "base_class"
        },
        {
          "target": "Sequence",
          "type": "base_class"
        },
        {
          "target": "Reversible",
          "type": "base_class"
        },
        {
          "target": "Collection",
          "type": "base_class"
        },
        {
          "target": "Sized",
          "type": "base_class"
        },
        {
          "target": "Iterable",
          "type": "base_class"
        },
        {
          "target": "Container",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.collections.UserString",
      "name": "UserString",
      "module": "collections",
      "type": "class",
      "signature": "(seq)",
      "description": "All the operations on a read-only sequence.\n\nConcrete subclasses must override __new__ or __init__,\n__getitem__, and __len__.",
      "relationships": [
        {
          "target": "Sequence",
          "type": "base_class"
        },
        {
          "target": "Reversible",
          "type": "base_class"
        },
        {
          "target": "Collection",
          "type": "base_class"
        },
        {
          "target": "Sized",
          "type": "base_class"
        },
        {
          "target": "Iterable",
          "type": "base_class"
        },
        {
          "target": "Container",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.collections.namedtuple",
      "name": "namedtuple",
      "module": "collections",
      "type": "function",
      "signature": "(typename, field_names, *, rename=False, defaults=None, module=None)",
      "description": "Returns a new subclass of tuple with named fields.\n\n>>> Point = namedtuple('Point', ['x', 'y'])\n>>> Point.__doc__                   # docstring for the new class\n'Point(x, y)'\n>>> p = Point(11, y=22)             # instantiate with positional args or keywords\n>>> p[0] + p[1]                     # indexable like a plain tuple\n33\n>>> x, y = p                        # unpack like a regular tuple\n>>> x, y\n(11, 22)\n>>> p.x + p.y                       # fields also accessible by name\n33\n>>> d = p._asdict()                 # convert to a dictionary\n>>> d['x']\n11\n>>> Point(**d)                      # convert from a dictionary\nPoint(x=11, y=22)\n>>> p._replace(x=100)               # _replace() is like str.replace() but targets named fields\nPoint(x=100, y=22)",
      "relationships": [
        {
          "target": "stdlib.collections.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.collections.list",
          "type": "calls"
        },
        {
          "target": "stdlib.collections.intern",
          "type": "calls"
        },
        {
          "target": "stdlib.collections.set",
          "type": "calls"
        },
        {
          "target": "stdlib.collections.tuple",
          "type": "calls"
        },
        {
          "target": "stdlib.collections.len",
          "type": "calls"
        },
        {
          "target": "stdlib.collections.join",
          "type": "calls"
        },
        {
          "target": "stdlib.collections.eval",
          "type": "calls"
        },
        {
          "target": "stdlib.collections.enumerate",
          "type": "calls"
        },
        {
          "target": "stdlib.collections.type",
          "type": "calls"
        },
        {
          "target": "stdlib.collections.split",
          "type": "calls"
        },
        {
          "target": "stdlib.collections.map",
          "type": "calls"
        },
        {
          "target": "stdlib.collections.str",
          "type": "calls"
        },
        {
          "target": "stdlib.collections.set",
          "type": "calls"
        },
        {
          "target": "stdlib.collections.enumerate",
          "type": "calls"
        },
        {
          "target": "stdlib.collections._iskeyword",
          "type": "calls"
        },
        {
          "target": "stdlib.collections.add",
          "type": "calls"
        },
        {
          "target": "stdlib.collections.tuple",
          "type": "calls"
        },
        {
          "target": "stdlib.collections.dict",
          "type": "calls"
        },
        {
          "target": "stdlib.collections.map",
          "type": "calls"
        },
        {
          "target": "stdlib.collections.tuple_new",
          "type": "calls"
        },
        {
          "target": "stdlib.collections._make",
          "type": "calls"
        },
        {
          "target": "stdlib.collections._dict",
          "type": "calls"
        },
        {
          "target": "stdlib.collections._tuple",
          "type": "calls"
        },
        {
          "target": "stdlib.collections.intern",
          "type": "calls"
        },
        {
          "target": "stdlib.collections._tuplegetter",
          "type": "calls"
        },
        {
          "target": "stdlib.collections.add",
          "type": "calls"
        },
        {
          "target": "stdlib.collections.type",
          "type": "calls"
        },
        {
          "target": "stdlib.collections.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.collections.isidentifier",
          "type": "calls"
        },
        {
          "target": "stdlib.collections.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.collections.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.collections.startswith",
          "type": "calls"
        },
        {
          "target": "stdlib.collections.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.collections.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.collections.len",
          "type": "calls"
        },
        {
          "target": "stdlib.collections.len",
          "type": "calls"
        },
        {
          "target": "stdlib.collections.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.collections.reversed",
          "type": "calls"
        },
        {
          "target": "stdlib.collections.join",
          "type": "calls"
        },
        {
          "target": "stdlib.collections._len",
          "type": "calls"
        },
        {
          "target": "stdlib.collections.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.collections._map",
          "type": "calls"
        },
        {
          "target": "stdlib.collections.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.collections._zip",
          "type": "calls"
        },
        {
          "target": "stdlib.collections.get",
          "type": "calls"
        },
        {
          "target": "stdlib.collections.replace",
          "type": "calls"
        },
        {
          "target": "stdlib.collections._iskeyword",
          "type": "calls"
        },
        {
          "target": "stdlib.collections.startswith",
          "type": "calls"
        },
        {
          "target": "stdlib.collections.list",
          "type": "calls"
        },
        {
          "target": "stdlib.collections.isidentifier",
          "type": "calls"
        },
        {
          "target": "stdlib.collections.zip",
          "type": "calls"
        },
        {
          "target": "stdlib.collections.reversed",
          "type": "calls"
        },
        {
          "target": "stdlib.collections.reversed",
          "type": "calls"
        },
        {
          "target": "stdlib.collections.len",
          "type": "calls"
        },
        {
          "target": "stdlib.collections.list",
          "type": "calls"
        },
        {
          "target": "stdlib.collections._getframe",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.colorsys.hls_to_rgb",
      "name": "hls_to_rgb",
      "module": "colorsys",
      "type": "function",
      "signature": "(h, l, s)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.colorsys._v",
          "type": "calls"
        },
        {
          "target": "stdlib.colorsys._v",
          "type": "calls"
        },
        {
          "target": "stdlib.colorsys._v",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.colorsys.hsv_to_rgb",
      "name": "hsv_to_rgb",
      "module": "colorsys",
      "type": "function",
      "signature": "(h, s, v)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.colorsys.int",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.colorsys.rgb_to_hls",
      "name": "rgb_to_hls",
      "module": "colorsys",
      "type": "function",
      "signature": "(r, g, b)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.colorsys.max",
          "type": "calls"
        },
        {
          "target": "stdlib.colorsys.min",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.colorsys.rgb_to_hsv",
      "name": "rgb_to_hsv",
      "module": "colorsys",
      "type": "function",
      "signature": "(r, g, b)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.colorsys.max",
          "type": "calls"
        },
        {
          "target": "stdlib.colorsys.min",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.colorsys.rgb_to_yiq",
      "name": "rgb_to_yiq",
      "module": "colorsys",
      "type": "function",
      "signature": "(r, g, b)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.colorsys.yiq_to_rgb",
      "name": "yiq_to_rgb",
      "module": "colorsys",
      "type": "function",
      "signature": "(y, i, q)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.compileall.Path",
      "name": "Path",
      "module": "compileall",
      "type": "class",
      "signature": "(*args, **kwargs)",
      "description": "PurePath subclass that can make system calls.\n\nPath represents a filesystem path but unlike PurePath, also offers\nmethods to do system calls on path objects. Depending on your system,\ninstantiating a Path will return either a PosixPath or a WindowsPath\nobject. You can also instantiate a PosixPath or WindowsPath directly,\nbut cannot instantiate a WindowsPath on a POSIX system or vice versa.",
      "relationships": [
        {
          "target": "PurePath",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.compileall.compile_dir",
      "name": "compile_dir",
      "module": "compileall",
      "type": "function",
      "signature": "(dir, maxlevels=None, ddir=None, force=False, rx=None, quiet=0, legacy=False, optimize=-1, workers=1, invalidation_mode=None, *, stripdir=None, prependdir=None, limit_sl_dest=None, hardlink_dupes=False)",
      "description": "Byte-compile all modules in the given directory tree.\n\nArguments (only dir is required):\n\ndir:       the directory to byte-compile\nmaxlevels: maximum recursion level (default `sys.getrecursionlimit()`)\nddir:      the directory that will be prepended to the path to the\n           file as it is compiled into each byte-code file.\nforce:     if True, force compilation, even if timestamps are up-to-date\nquiet:     full output with False or 0, errors only with 1,\n           no output with 2\nlegacy:    if True, produce legacy pyc paths instead of PEP 3147 paths\noptimize:  int or list of optimization levels or -1 for level of\n           the interpreter. Multiple levels leads to multiple compiled\n           files each with one optimization level.\nworkers:   maximum number of parallel workers\ninvalidation_mode: how the up-to-dateness of the pyc will be checked\nstripdir:  part of path to left-strip from source file path\nprependdir: path to prepend to beginning of original file path, applied\n           after stripdir\nlimit_sl_dest: ignore symlinks if they are pointing outside of\n               the defined path\nhardlink_dupes: hardlink duplicated pyc files",
      "relationships": [
        {
          "target": "stdlib.compileall._walk_dir",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.getrecursionlimit",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.ProcessPoolExecutor",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.map",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.min",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.partial",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.compile_file",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.compileall.compile_file",
      "name": "compile_file",
      "module": "compileall",
      "type": "function",
      "signature": "(fullname, ddir=None, force=False, rx=None, quiet=0, legacy=False, optimize=-1, invalidation_mode=None, *, stripdir=None, prependdir=None, limit_sl_dest=None, hardlink_dupes=False)",
      "description": "Byte-compile one file.\n\nArguments (only fullname is required):\n\nfullname:  the file to byte-compile\nddir:      if given, the directory name compiled in to the\n           byte-code file.\nforce:     if True, force compilation, even if timestamps are up-to-date\nquiet:     full output with False or 0, errors only with 1,\n           no output with 2\nlegacy:    if True, produce legacy pyc paths instead of PEP 3147 paths\noptimize:  int or list of optimization levels or -1 for level of\n           the interpreter. Multiple levels leads to multiple compiled\n           files each with one optimization level.\ninvalidation_mode: how the up-to-dateness of the pyc will be checked\nstripdir:  part of path to left-strip from source file path\nprependdir: path to prepend to beginning of original file path, applied\n           after stripdir\nlimit_sl_dest: ignore symlinks if they are pointing outside of\n               the defined path.\nhardlink_dupes: hardlink duplicated pyc files",
      "relationships": [
        {
          "target": "stdlib.compileall.basename",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.sorted",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.isfile",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.fspath",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.join",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.split",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.split",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.list",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.zip",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.join",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.set",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.search",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.islink",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.join",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.join",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.len",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.resolve",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.remove",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.resolve",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.print",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.enumerate",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.Path",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.cache_from_source",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.cache_from_source",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.int",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.pack",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.values",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.format",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.compile",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.encode",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.decode",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.print",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.print",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.Path",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.cmp",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.stat",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.open",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.read",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.unlink",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.link",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.print",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.print",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.print",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.print",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.format",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.format",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.compileall.compile_path",
      "name": "compile_path",
      "module": "compileall",
      "type": "function",
      "signature": "(skip_curdir=1, maxlevels=0, force=False, quiet=0, legacy=False, optimize=-1, invalidation_mode=None)",
      "description": "Byte-compile all module on sys.path.\n\nArguments (all optional):\n\nskip_curdir: if true, skip current directory (default True)\nmaxlevels:   max recursion level (default 0)\nforce: as for compile_dir() (default False)\nquiet: as for compile_dir() (default 0)\nlegacy: as for compile_dir() (default False)\noptimize: as for compile_dir() (default -1)\ninvalidation_mode: as for compiler_dir()",
      "relationships": [
        {
          "target": "stdlib.compileall.print",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.compile_dir",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.compileall.main",
      "name": "main",
      "module": "compileall",
      "type": "function",
      "signature": "()",
      "description": "Script main program.",
      "relationships": [
        {
          "target": "stdlib.compileall.ArgumentParser",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.add_argument",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.add_argument",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.add_argument",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.add_argument",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.add_argument",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.add_argument",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.add_argument",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.add_argument",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.add_argument",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.add_argument",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.add_argument",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.add_argument",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.add_argument",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.add_argument",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.add_argument",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.add_argument",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.parse_args",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.replace",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.compile",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.error",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.error",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.upper",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.sorted",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.len",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.compile_path",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.lower",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.replace",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.isfile",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.print",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.open",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.append",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.print",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.strip",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.format",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.compile_file",
          "type": "calls"
        },
        {
          "target": "stdlib.compileall.compile_dir",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.configparser.BasicInterpolation",
      "name": "BasicInterpolation",
      "module": "configparser",
      "type": "class",
      "signature": "()",
      "description": "Interpolation as implemented in the classic ConfigParser.\n\nThe option values can contain format strings which refer to other values in\nthe same section, or values in the special default section.\n\nFor example:\n\n    something: %(dir)s/whatever\n\nwould resolve the \"%(dir)s\" to the value of dir.  All reference\nexpansions are done late, on demand. If a user needs to use a bare % in\na configuration file, she can escape it by writing %%. Other % usage\nis considered a user error and raises `InterpolationSyntaxError'.",
      "relationships": [
        {
          "target": "Interpolation",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.configparser.ConfigParser",
      "name": "ConfigParser",
      "module": "configparser",
      "type": "class",
      "signature": "(defaults=None, dict_type=<class 'dict'>, allow_no_value=False, *, delimiters=('=', ':'), comment_prefixes=('#', ';'), inline_comment_prefixes=None, strict=True, empty_lines_in_values=True, default_section='DEFAULT', interpolation=<object object at 0x1086f90f0>, converters=<object object at 0x1086f90f0>)",
      "description": "ConfigParser implementing interpolation.",
      "relationships": [
        {
          "target": "RawConfigParser",
          "type": "base_class"
        },
        {
          "target": "MutableMapping",
          "type": "base_class"
        },
        {
          "target": "Mapping",
          "type": "base_class"
        },
        {
          "target": "Collection",
          "type": "base_class"
        },
        {
          "target": "Sized",
          "type": "base_class"
        },
        {
          "target": "Iterable",
          "type": "base_class"
        },
        {
          "target": "Container",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.configparser.ConverterMapping",
      "name": "ConverterMapping",
      "module": "configparser",
      "type": "class",
      "signature": "(parser)",
      "description": "Enables reuse of get*() methods between the parser and section proxies.\n\nIf a parser class implements a getter directly, the value for the given\nkey will be ``None``. The presence of the converter name here enables\nsection proxies to find and use the implementation on the parser class.",
      "relationships": [
        {
          "target": "MutableMapping",
          "type": "base_class"
        },
        {
          "target": "Mapping",
          "type": "base_class"
        },
        {
          "target": "Collection",
          "type": "base_class"
        },
        {
          "target": "Sized",
          "type": "base_class"
        },
        {
          "target": "Iterable",
          "type": "base_class"
        },
        {
          "target": "Container",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.configparser.DuplicateOptionError",
      "name": "DuplicateOptionError",
      "module": "configparser",
      "type": "class",
      "signature": "(section, option, source=None, lineno=None)",
      "description": "Raised by strict parsers when an option is repeated in an input source.\n\nCurrent implementation raises this exception only when an option is found\nmore than once in a single file, string or dictionary.",
      "relationships": [
        {
          "target": "Error",
          "type": "base_class"
        },
        {
          "target": "Exception",
          "type": "base_class"
        },
        {
          "target": "BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.configparser.DuplicateSectionError",
      "name": "DuplicateSectionError",
      "module": "configparser",
      "type": "class",
      "signature": "(section, source=None, lineno=None)",
      "description": "Raised when a section is repeated in an input source.\n\nPossible repetitions that raise this exception are: multiple creation\nusing the API or in strict parsers when a section is found more than once\nin a single input file, string or dictionary.",
      "relationships": [
        {
          "target": "Error",
          "type": "base_class"
        },
        {
          "target": "Exception",
          "type": "base_class"
        },
        {
          "target": "BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.configparser.Error",
      "name": "Error",
      "module": "configparser",
      "type": "class",
      "signature": "(msg='')",
      "description": "Base class for ConfigParser exceptions.",
      "relationships": [
        {
          "target": "Exception",
          "type": "base_class"
        },
        {
          "target": "BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.configparser.ExtendedInterpolation",
      "name": "ExtendedInterpolation",
      "module": "configparser",
      "type": "class",
      "signature": "()",
      "description": "Advanced variant of interpolation, supports the syntax used by\n`zc.buildout'. Enables interpolation between sections.",
      "relationships": [
        {
          "target": "Interpolation",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.configparser.Interpolation",
      "name": "Interpolation",
      "module": "configparser",
      "type": "class",
      "signature": "()",
      "description": "Dummy interpolation that passes the value through with no changes.",
      "relationships": []
    },
    {
      "id": "stdlib.configparser.InterpolationDepthError",
      "name": "InterpolationDepthError",
      "module": "configparser",
      "type": "class",
      "signature": "(option, section, rawval)",
      "description": "Raised when substitutions are nested too deeply.",
      "relationships": [
        {
          "target": "InterpolationError",
          "type": "base_class"
        },
        {
          "target": "Error",
          "type": "base_class"
        },
        {
          "target": "Exception",
          "type": "base_class"
        },
        {
          "target": "BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.configparser.InterpolationError",
      "name": "InterpolationError",
      "module": "configparser",
      "type": "class",
      "signature": "(option, section, msg)",
      "description": "Base class for interpolation-related exceptions.",
      "relationships": [
        {
          "target": "Error",
          "type": "base_class"
        },
        {
          "target": "Exception",
          "type": "base_class"
        },
        {
          "target": "BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.configparser.InterpolationMissingOptionError",
      "name": "InterpolationMissingOptionError",
      "module": "configparser",
      "type": "class",
      "signature": "(option, section, rawval, reference)",
      "description": "A string substitution required a setting which was not available.",
      "relationships": [
        {
          "target": "InterpolationError",
          "type": "base_class"
        },
        {
          "target": "Error",
          "type": "base_class"
        },
        {
          "target": "Exception",
          "type": "base_class"
        },
        {
          "target": "BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.configparser.InterpolationSyntaxError",
      "name": "InterpolationSyntaxError",
      "module": "configparser",
      "type": "class",
      "signature": "(option, section, msg)",
      "description": "Raised when the source text contains invalid syntax.\n\nCurrent implementation raises this exception when the source text into\nwhich substitutions are made does not conform to the required syntax.",
      "relationships": [
        {
          "target": "InterpolationError",
          "type": "base_class"
        },
        {
          "target": "Error",
          "type": "base_class"
        },
        {
          "target": "Exception",
          "type": "base_class"
        },
        {
          "target": "BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.configparser.LegacyInterpolation",
      "name": "LegacyInterpolation",
      "module": "configparser",
      "type": "class",
      "signature": "()",
      "description": "Deprecated interpolation used in old versions of ConfigParser.\nUse BasicInterpolation or ExtendedInterpolation instead.",
      "relationships": [
        {
          "target": "Interpolation",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.configparser.MissingSectionHeaderError",
      "name": "MissingSectionHeaderError",
      "module": "configparser",
      "type": "class",
      "signature": "(filename, lineno, line)",
      "description": "Raised when a key-value pair is found before any section header.",
      "relationships": [
        {
          "target": "ParsingError",
          "type": "base_class"
        },
        {
          "target": "Error",
          "type": "base_class"
        },
        {
          "target": "Exception",
          "type": "base_class"
        },
        {
          "target": "BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.configparser.MutableMapping",
      "name": "MutableMapping",
      "module": "configparser",
      "type": "class",
      "signature": "()",
      "description": "",
      "relationships": [
        {
          "target": "Mapping",
          "type": "base_class"
        },
        {
          "target": "Collection",
          "type": "base_class"
        },
        {
          "target": "Sized",
          "type": "base_class"
        },
        {
          "target": "Iterable",
          "type": "base_class"
        },
        {
          "target": "Container",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.configparser.NoOptionError",
      "name": "NoOptionError",
      "module": "configparser",
      "type": "class",
      "signature": "(option, section)",
      "description": "A requested option was not found.",
      "relationships": [
        {
          "target": "Error",
          "type": "base_class"
        },
        {
          "target": "Exception",
          "type": "base_class"
        },
        {
          "target": "BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.configparser.NoSectionError",
      "name": "NoSectionError",
      "module": "configparser",
      "type": "class",
      "signature": "(section)",
      "description": "Raised when no section matches a requested option.",
      "relationships": [
        {
          "target": "Error",
          "type": "base_class"
        },
        {
          "target": "Exception",
          "type": "base_class"
        },
        {
          "target": "BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.configparser.ParsingError",
      "name": "ParsingError",
      "module": "configparser",
      "type": "class",
      "signature": "(source=None, filename=None)",
      "description": "Raised when a configuration file does not follow legal syntax.",
      "relationships": [
        {
          "target": "Error",
          "type": "base_class"
        },
        {
          "target": "Exception",
          "type": "base_class"
        },
        {
          "target": "BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.configparser.RawConfigParser",
      "name": "RawConfigParser",
      "module": "configparser",
      "type": "class",
      "signature": "(defaults=None, dict_type=<class 'dict'>, allow_no_value=False, *, delimiters=('=', ':'), comment_prefixes=('#', ';'), inline_comment_prefixes=None, strict=True, empty_lines_in_values=True, default_section='DEFAULT', interpolation=<object object at 0x1086f90f0>, converters=<object object at 0x1086f90f0>)",
      "description": "ConfigParser that does not do interpolation.",
      "relationships": [
        {
          "target": "MutableMapping",
          "type": "base_class"
        },
        {
          "target": "Mapping",
          "type": "base_class"
        },
        {
          "target": "Collection",
          "type": "base_class"
        },
        {
          "target": "Sized",
          "type": "base_class"
        },
        {
          "target": "Iterable",
          "type": "base_class"
        },
        {
          "target": "Container",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.configparser.SafeConfigParser",
      "name": "SafeConfigParser",
      "module": "configparser",
      "type": "class",
      "signature": "(*args, **kwargs)",
      "description": "ConfigParser alias for backwards compatibility purposes.",
      "relationships": [
        {
          "target": "ConfigParser",
          "type": "base_class"
        },
        {
          "target": "RawConfigParser",
          "type": "base_class"
        },
        {
          "target": "MutableMapping",
          "type": "base_class"
        },
        {
          "target": "Mapping",
          "type": "base_class"
        },
        {
          "target": "Collection",
          "type": "base_class"
        },
        {
          "target": "Sized",
          "type": "base_class"
        },
        {
          "target": "Iterable",
          "type": "base_class"
        },
        {
          "target": "Container",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.configparser.SectionProxy",
      "name": "SectionProxy",
      "module": "configparser",
      "type": "class",
      "signature": "(parser, name)",
      "description": "A proxy for a single section from a parser.",
      "relationships": [
        {
          "target": "MutableMapping",
          "type": "base_class"
        },
        {
          "target": "Mapping",
          "type": "base_class"
        },
        {
          "target": "Collection",
          "type": "base_class"
        },
        {
          "target": "Sized",
          "type": "base_class"
        },
        {
          "target": "Iterable",
          "type": "base_class"
        },
        {
          "target": "Container",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.contextlib.AbstractAsyncContextManager",
      "name": "AbstractAsyncContextManager",
      "module": "contextlib",
      "type": "class",
      "signature": "()",
      "description": "An abstract base class for asynchronous context managers.",
      "relationships": [
        {
          "target": "ABC",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.contextlib.AbstractContextManager",
      "name": "AbstractContextManager",
      "module": "contextlib",
      "type": "class",
      "signature": "()",
      "description": "An abstract base class for context managers.",
      "relationships": [
        {
          "target": "ABC",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.contextlib.AsyncExitStack",
      "name": "AsyncExitStack",
      "module": "contextlib",
      "type": "class",
      "signature": "()",
      "description": "Async context manager for dynamic management of a stack of exit\ncallbacks.\n\nFor example:\n    async with AsyncExitStack() as stack:\n        connections = [await stack.enter_async_context(get_connection())\n            for i in range(5)]\n        # All opened connections will automatically be released at the\n        # end of the async with statement, even if attempts to open a\n        # connection later in the list raise an exception.",
      "relationships": [
        {
          "target": "_BaseExitStack",
          "type": "base_class"
        },
        {
          "target": "AbstractAsyncContextManager",
          "type": "base_class"
        },
        {
          "target": "ABC",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.contextlib.ContextDecorator",
      "name": "ContextDecorator",
      "module": "contextlib",
      "type": "class",
      "signature": "()",
      "description": "A base class or mixin that enables context managers to work as decorators.",
      "relationships": []
    },
    {
      "id": "stdlib.contextlib.ExitStack",
      "name": "ExitStack",
      "module": "contextlib",
      "type": "class",
      "signature": "()",
      "description": "Context manager for dynamic management of a stack of exit callbacks.\n\nFor example:\n    with ExitStack() as stack:\n        files = [stack.enter_context(open(fname)) for fname in filenames]\n        # All opened files will automatically be closed at the end of\n        # the with statement, even if attempts to open files later\n        # in the list raise an exception.",
      "relationships": [
        {
          "target": "_BaseExitStack",
          "type": "base_class"
        },
        {
          "target": "AbstractContextManager",
          "type": "base_class"
        },
        {
          "target": "ABC",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.contextlib.asynccontextmanager",
      "name": "asynccontextmanager",
      "module": "contextlib",
      "type": "function",
      "signature": "(func)",
      "description": "@asynccontextmanager decorator.\n\nTypical usage:\n\n    @asynccontextmanager\n    async def some_async_generator(<arguments>):\n        <setup>\n        try:\n            yield <value>\n        finally:\n            <cleanup>\n\nThis makes this:\n\n    async with some_async_generator(<arguments>) as <variable>:\n        <body>\n\nequivalent to this:\n\n    <setup>\n    try:\n        <variable> = <value>\n        <body>\n    finally:\n        <cleanup>",
      "relationships": [
        {
          "target": "stdlib.contextlib.wraps",
          "type": "calls"
        },
        {
          "target": "stdlib.contextlib._AsyncGeneratorContextManager",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.contextlib.closing",
      "name": "closing",
      "module": "contextlib",
      "type": "class",
      "signature": "(thing)",
      "description": "Context to automatically close something at the end of a block.\n\nCode like this:\n\n    with closing(<module>.open(<arguments>)) as f:\n        <block>\n\nis equivalent to this:\n\n    f = <module>.open(<arguments>)\n    try:\n        <block>\n    finally:\n        f.close()",
      "relationships": [
        {
          "target": "AbstractContextManager",
          "type": "base_class"
        },
        {
          "target": "ABC",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.contextlib.contextmanager",
      "name": "contextmanager",
      "module": "contextlib",
      "type": "function",
      "signature": "(func)",
      "description": "@contextmanager decorator.\n\nTypical usage:\n\n    @contextmanager\n    def some_generator(<arguments>):\n        <setup>\n        try:\n            yield <value>\n        finally:\n            <cleanup>\n\nThis makes this:\n\n    with some_generator(<arguments>) as <variable>:\n        <body>\n\nequivalent to this:\n\n    <setup>\n    try:\n        <variable> = <value>\n        <body>\n    finally:\n        <cleanup>",
      "relationships": [
        {
          "target": "stdlib.contextlib.wraps",
          "type": "calls"
        },
        {
          "target": "stdlib.contextlib._GeneratorContextManager",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.contextlib.nullcontext",
      "name": "nullcontext",
      "module": "contextlib",
      "type": "class",
      "signature": "(enter_result=None)",
      "description": "Context manager that does no additional processing.\n\nUsed as a stand-in for a normal context manager, when a particular\nblock of code is only sometimes used with a normal context manager:\n\ncm = optional_cm if condition else nullcontext()\nwith cm:\n    # Perform operation, using optional_cm if condition is True",
      "relationships": [
        {
          "target": "AbstractContextManager",
          "type": "base_class"
        },
        {
          "target": "ABC",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.contextlib.redirect_stderr",
      "name": "redirect_stderr",
      "module": "contextlib",
      "type": "class",
      "signature": "(new_target)",
      "description": "Context manager for temporarily redirecting stderr to another file.",
      "relationships": [
        {
          "target": "_RedirectStream",
          "type": "base_class"
        },
        {
          "target": "AbstractContextManager",
          "type": "base_class"
        },
        {
          "target": "ABC",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.contextlib.redirect_stdout",
      "name": "redirect_stdout",
      "module": "contextlib",
      "type": "class",
      "signature": "(new_target)",
      "description": "Context manager for temporarily redirecting stdout to another file.\n\n# How to send help() to stderr\nwith redirect_stdout(sys.stderr):\n    help(dir)\n\n# How to write help() to a file\nwith open('help.txt', 'w') as f:\n    with redirect_stdout(f):\n        help(pow)",
      "relationships": [
        {
          "target": "_RedirectStream",
          "type": "base_class"
        },
        {
          "target": "AbstractContextManager",
          "type": "base_class"
        },
        {
          "target": "ABC",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.contextlib.suppress",
      "name": "suppress",
      "module": "contextlib",
      "type": "class",
      "signature": "(*exceptions)",
      "description": "Context manager to suppress specified exceptions\n\nAfter the exception is suppressed, execution proceeds with the next\nstatement following the with statement.\n\n     with suppress(FileNotFoundError):\n         os.remove(somefile)\n     # Execution still resumes here if the file was already removed",
      "relationships": [
        {
          "target": "AbstractContextManager",
          "type": "base_class"
        },
        {
          "target": "ABC",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.contextlib.wraps",
      "name": "wraps",
      "module": "contextlib",
      "type": "function",
      "signature": "(wrapped, assigned=('__module__', '__name__', '__qualname__', '__doc__', '__annotations__'), updated=('__dict__',))",
      "description": "Decorator factory to apply update_wrapper() to a wrapper function\n\nReturns a decorator that invokes update_wrapper() with the decorated\nfunction as the wrapper argument and the arguments to wraps() as the\nremaining arguments. Default arguments are as for update_wrapper().\nThis is a convenience function to simplify applying partial() to\nupdate_wrapper().",
      "relationships": [
        {
          "target": "stdlib.contextlib.partial",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.copy.copy",
      "name": "copy",
      "module": "copy",
      "type": "function",
      "signature": "(x)",
      "description": "Shallow copy operation on arbitrary Python objects.\n\nSee the module's __doc__ string for more info.",
      "relationships": [
        {
          "target": "stdlib.copy.type",
          "type": "calls"
        },
        {
          "target": "stdlib.copy.get",
          "type": "calls"
        },
        {
          "target": "stdlib.copy.issubclass",
          "type": "calls"
        },
        {
          "target": "stdlib.copy.getattr",
          "type": "calls"
        },
        {
          "target": "stdlib.copy.get",
          "type": "calls"
        },
        {
          "target": "stdlib.copy.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.copy._reconstruct",
          "type": "calls"
        },
        {
          "target": "stdlib.copy.copier",
          "type": "calls"
        },
        {
          "target": "stdlib.copy._copy_immutable",
          "type": "calls"
        },
        {
          "target": "stdlib.copy.copier",
          "type": "calls"
        },
        {
          "target": "stdlib.copy.reductor",
          "type": "calls"
        },
        {
          "target": "stdlib.copy.getattr",
          "type": "calls"
        },
        {
          "target": "stdlib.copy.reductor",
          "type": "calls"
        },
        {
          "target": "stdlib.copy.getattr",
          "type": "calls"
        },
        {
          "target": "stdlib.copy.reductor",
          "type": "calls"
        },
        {
          "target": "stdlib.copy.Error",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.copy.deepcopy",
      "name": "deepcopy",
      "module": "copy",
      "type": "function",
      "signature": "(x, memo=None, _nil=[])",
      "description": "Deep copy operation on arbitrary Python objects.\n\nSee the module's __doc__ string for more info.",
      "relationships": [
        {
          "target": "stdlib.copy.id",
          "type": "calls"
        },
        {
          "target": "stdlib.copy.get",
          "type": "calls"
        },
        {
          "target": "stdlib.copy.type",
          "type": "calls"
        },
        {
          "target": "stdlib.copy.get",
          "type": "calls"
        },
        {
          "target": "stdlib.copy.copier",
          "type": "calls"
        },
        {
          "target": "stdlib.copy.issubclass",
          "type": "calls"
        },
        {
          "target": "stdlib.copy._keep_alive",
          "type": "calls"
        },
        {
          "target": "stdlib.copy._deepcopy_atomic",
          "type": "calls"
        },
        {
          "target": "stdlib.copy.getattr",
          "type": "calls"
        },
        {
          "target": "stdlib.copy.copier",
          "type": "calls"
        },
        {
          "target": "stdlib.copy.get",
          "type": "calls"
        },
        {
          "target": "stdlib.copy.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.copy.reductor",
          "type": "calls"
        },
        {
          "target": "stdlib.copy.getattr",
          "type": "calls"
        },
        {
          "target": "stdlib.copy._reconstruct",
          "type": "calls"
        },
        {
          "target": "stdlib.copy.reductor",
          "type": "calls"
        },
        {
          "target": "stdlib.copy.getattr",
          "type": "calls"
        },
        {
          "target": "stdlib.copy.reductor",
          "type": "calls"
        },
        {
          "target": "stdlib.copy.Error",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.copyreg.add_extension",
      "name": "add_extension",
      "module": "copyreg",
      "type": "function",
      "signature": "(module, name, code)",
      "description": "Register an extension code.",
      "relationships": [
        {
          "target": "stdlib.copyreg.int",
          "type": "calls"
        },
        {
          "target": "stdlib.copyreg.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.copyreg.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.copyreg.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.copyreg.get",
          "type": "calls"
        },
        {
          "target": "stdlib.copyreg.get",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.copyreg.clear_extension_cache",
      "name": "clear_extension_cache",
      "module": "copyreg",
      "type": "function",
      "signature": "()",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.copyreg.clear",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.copyreg.constructor",
      "name": "constructor",
      "module": "copyreg",
      "type": "function",
      "signature": "(object)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.copyreg.callable",
          "type": "calls"
        },
        {
          "target": "stdlib.copyreg.TypeError",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.copyreg.pickle",
      "name": "pickle",
      "module": "copyreg",
      "type": "function",
      "signature": "(ob_type, pickle_function, constructor_ob=None)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.copyreg.callable",
          "type": "calls"
        },
        {
          "target": "stdlib.copyreg.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.copyreg.constructor",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.copyreg.pickle_complex",
      "name": "pickle_complex",
      "module": "copyreg",
      "type": "function",
      "signature": "(c)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.copyreg.remove_extension",
      "name": "remove_extension",
      "module": "copyreg",
      "type": "function",
      "signature": "(module, name, code)",
      "description": "Unregister an extension code.  For testing only.",
      "relationships": [
        {
          "target": "stdlib.copyreg.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.copyreg.get",
          "type": "calls"
        },
        {
          "target": "stdlib.copyreg.get",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.crypt.crypt",
      "name": "crypt",
      "module": "crypt",
      "type": "function",
      "signature": "(word, salt=None)",
      "description": "Return a string representing the one-way hash of a password, with a salt\nprepended.\n\nIf ``salt`` is not specified or is ``None``, the strongest\navailable method will be selected and a salt generated.  Otherwise,\n``salt`` may be one of the ``crypt.METHOD_*`` values, or a string as\nreturned by ``crypt.mksalt()``.",
      "relationships": [
        {
          "target": "stdlib.crypt.crypt",
          "type": "calls"
        },
        {
          "target": "stdlib.crypt.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.crypt.mksalt",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.crypt.mksalt",
      "name": "mksalt",
      "module": "crypt",
      "type": "function",
      "signature": "(method=None, *, rounds=None)",
      "description": "Generate a salt for the specified method.\n\nIf not specified, the strongest available method will be used.",
      "relationships": [
        {
          "target": "stdlib.crypt.join",
          "type": "calls"
        },
        {
          "target": "stdlib.crypt.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.crypt.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.crypt.bit_length",
          "type": "calls"
        },
        {
          "target": "stdlib.crypt.choice",
          "type": "calls"
        },
        {
          "target": "stdlib.crypt.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.crypt.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.crypt.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.crypt.range",
          "type": "calls"
        },
        {
          "target": "stdlib.crypt.ValueError",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.csv.Dialect",
      "name": "Dialect",
      "module": "csv",
      "type": "class",
      "signature": "()",
      "description": "Describe a CSV dialect.\n\nThis must be subclassed (see csv.excel).  Valid attributes are:\ndelimiter, quotechar, escapechar, doublequote, skipinitialspace,\nlineterminator, quoting.",
      "relationships": []
    },
    {
      "id": "stdlib.csv.DictReader",
      "name": "DictReader",
      "module": "csv",
      "type": "class",
      "signature": "(f, fieldnames=None, restkey=None, restval=None, dialect='excel', *args, **kwds)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.csv.DictWriter",
      "name": "DictWriter",
      "module": "csv",
      "type": "class",
      "signature": "(f, fieldnames, restval='', extrasaction='raise', dialect='excel', *args, **kwds)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.csv.Sniffer",
      "name": "Sniffer",
      "module": "csv",
      "type": "class",
      "signature": "()",
      "description": "\"Sniffs\" the format of a CSV file (i.e. delimiter, quotechar)\nReturns a Dialect object.",
      "relationships": []
    },
    {
      "id": "stdlib.csv.StringIO",
      "name": "StringIO",
      "module": "csv",
      "type": "class",
      "signature": "(initial_value='', newline='\\n')",
      "description": "Text I/O implementation using an in-memory buffer.\n\nThe initial_value argument sets the value of object.  The newline\nargument is like the one of TextIOWrapper's constructor.",
      "relationships": [
        {
          "target": "_TextIOBase",
          "type": "base_class"
        },
        {
          "target": "_IOBase",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.csv.excel",
      "name": "excel",
      "module": "csv",
      "type": "class",
      "signature": "()",
      "description": "Describe the usual properties of Excel-generated CSV files.",
      "relationships": [
        {
          "target": "Dialect",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.csv.excel_tab",
      "name": "excel_tab",
      "module": "csv",
      "type": "class",
      "signature": "()",
      "description": "Describe the usual properties of Excel-generated TAB-delimited files.",
      "relationships": [
        {
          "target": "excel",
          "type": "base_class"
        },
        {
          "target": "Dialect",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.csv.unix_dialect",
      "name": "unix_dialect",
      "module": "csv",
      "type": "class",
      "signature": "()",
      "description": "Describe the usual properties of Unix-generated CSV files.",
      "relationships": [
        {
          "target": "Dialect",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.ctypes.ARRAY",
      "name": "ARRAY",
      "module": "ctypes",
      "type": "function",
      "signature": "(typ, len)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.ctypes.CDLL",
      "name": "CDLL",
      "module": "ctypes",
      "type": "class",
      "signature": "(name, mode=4, handle=None, use_errno=False, use_last_error=False, winmode=None)",
      "description": "An instance of this class represents a loaded dll/shared\nlibrary, exporting functions using the standard C calling\nconvention (named 'cdecl' on Windows).\n\nThe exported functions can be accessed as attributes, or by\nindexing with the function name.  Examples:\n\n<obj>.qsort -> callable object\n<obj>['qsort'] -> callable object\n\nCalling the functions releases the Python GIL during the call and\nreacquires it afterwards.",
      "relationships": []
    },
    {
      "id": "stdlib.ctypes.CFUNCTYPE",
      "name": "CFUNCTYPE",
      "module": "ctypes",
      "type": "function",
      "signature": "(restype, *argtypes, **kw)",
      "description": "CFUNCTYPE(restype, *argtypes,\n             use_errno=False, use_last_error=False) -> function prototype.\n\nrestype: the result type\nargtypes: a sequence specifying the argument types\n\nThe function prototype can be called in different ways to create a\ncallable object:\n\nprototype(integer address) -> foreign function\nprototype(callable) -> create and return a C callable function from callable\nprototype(integer index, method name[, paramflags]) -> foreign function calling a COM method\nprototype((ordinal number, dll object)[, paramflags]) -> foreign function exported by ordinal\nprototype((function name, dll object)[, paramflags]) -> foreign function exported by name",
      "relationships": [
        {
          "target": "stdlib.ctypes.pop",
          "type": "calls"
        },
        {
          "target": "stdlib.ctypes.pop",
          "type": "calls"
        },
        {
          "target": "stdlib.ctypes.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.ctypes.keys",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ctypes.LibraryLoader",
      "name": "LibraryLoader",
      "module": "ctypes",
      "type": "class",
      "signature": "(dlltype)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.ctypes.PYFUNCTYPE",
      "name": "PYFUNCTYPE",
      "module": "ctypes",
      "type": "function",
      "signature": "(restype, *argtypes)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.ctypes.PyDLL",
      "name": "PyDLL",
      "module": "ctypes",
      "type": "class",
      "signature": "(name, mode=4, handle=None, use_errno=False, use_last_error=False, winmode=None)",
      "description": "This class represents the Python library itself.  It allows\naccessing Python API functions.  The GIL is not released, and\nPython exceptions are handled correctly.",
      "relationships": [
        {
          "target": "CDLL",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.ctypes.SetPointerType",
      "name": "SetPointerType",
      "module": "ctypes",
      "type": "function",
      "signature": "(pointer, cls)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.ctypes.set_type",
          "type": "calls"
        },
        {
          "target": "stdlib.ctypes.get",
          "type": "calls"
        },
        {
          "target": "stdlib.ctypes.RuntimeError",
          "type": "calls"
        },
        {
          "target": "stdlib.ctypes.id",
          "type": "calls"
        },
        {
          "target": "stdlib.ctypes.RuntimeError",
          "type": "calls"
        },
        {
          "target": "stdlib.ctypes.id",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ctypes.c_buffer",
      "name": "c_buffer",
      "module": "ctypes",
      "type": "function",
      "signature": "(init, size=None)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.ctypes.create_string_buffer",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ctypes.cast",
      "name": "cast",
      "module": "ctypes",
      "type": "function",
      "signature": "(obj, typ)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.ctypes._cast",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ctypes.create_string_buffer",
      "name": "create_string_buffer",
      "module": "ctypes",
      "type": "function",
      "signature": "(init, size=None)",
      "description": "create_string_buffer(aBytes) -> character array\ncreate_string_buffer(anInteger) -> character array\ncreate_string_buffer(aBytes, anInteger) -> character array",
      "relationships": [
        {
          "target": "stdlib.ctypes.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.ctypes.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.ctypes.audit",
          "type": "calls"
        },
        {
          "target": "stdlib.ctypes.buftype",
          "type": "calls"
        },
        {
          "target": "stdlib.ctypes.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.ctypes.audit",
          "type": "calls"
        },
        {
          "target": "stdlib.ctypes.buftype",
          "type": "calls"
        },
        {
          "target": "stdlib.ctypes.len",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ctypes.create_unicode_buffer",
      "name": "create_unicode_buffer",
      "module": "ctypes",
      "type": "function",
      "signature": "(init, size=None)",
      "description": "create_unicode_buffer(aString) -> character array\ncreate_unicode_buffer(anInteger) -> character array\ncreate_unicode_buffer(aString, anInteger) -> character array",
      "relationships": [
        {
          "target": "stdlib.ctypes.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.ctypes.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.ctypes.audit",
          "type": "calls"
        },
        {
          "target": "stdlib.ctypes.buftype",
          "type": "calls"
        },
        {
          "target": "stdlib.ctypes.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.ctypes.audit",
          "type": "calls"
        },
        {
          "target": "stdlib.ctypes.buftype",
          "type": "calls"
        },
        {
          "target": "stdlib.ctypes.sizeof",
          "type": "calls"
        },
        {
          "target": "stdlib.ctypes.sum",
          "type": "calls"
        },
        {
          "target": "stdlib.ctypes.len",
          "type": "calls"
        },
        {
          "target": "stdlib.ctypes.ord",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ctypes.string_at",
      "name": "string_at",
      "module": "ctypes",
      "type": "function",
      "signature": "(ptr, size=-1)",
      "description": "string_at(addr[, size]) -> string\n\nReturn the string at addr.",
      "relationships": [
        {
          "target": "stdlib.ctypes._string_at",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ctypes.wstring_at",
      "name": "wstring_at",
      "module": "ctypes",
      "type": "function",
      "signature": "(ptr, size=-1)",
      "description": "wstring_at(addr[, size]) -> string\n\nReturn the string at addr.",
      "relationships": [
        {
          "target": "stdlib.ctypes._wstring_at",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.curses.initscr",
      "name": "initscr",
      "module": "curses",
      "type": "function",
      "signature": "()",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.curses.setupterm",
          "type": "calls"
        },
        {
          "target": "stdlib.curses.initscr",
          "type": "calls"
        },
        {
          "target": "stdlib.curses.items",
          "type": "calls"
        },
        {
          "target": "stdlib.curses.get",
          "type": "calls"
        },
        {
          "target": "stdlib.curses.fileno",
          "type": "calls"
        },
        {
          "target": "stdlib.curses.setattr",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.curses.start_color",
      "name": "start_color",
      "module": "curses",
      "type": "function",
      "signature": "()",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.curses.start_color",
          "type": "calls"
        },
        {
          "target": "stdlib.curses.hasattr",
          "type": "calls"
        },
        {
          "target": "stdlib.curses.hasattr",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.curses.window",
      "name": "window",
      "module": "curses",
      "type": "class",
      "signature": "()",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.curses.wrapper",
      "name": "wrapper",
      "module": "curses",
      "type": "function",
      "signature": "(func, /, *args, **kwds)",
      "description": "Wrapper function that initializes curses and calls another function,\nrestoring normal keyboard/screen behavior on error.\nThe callable object 'func' is then passed the main window 'stdscr'\nas its first argument, followed by any other arguments passed to\nwrapper().",
      "relationships": [
        {
          "target": "stdlib.curses.initscr",
          "type": "calls"
        },
        {
          "target": "stdlib.curses.noecho",
          "type": "calls"
        },
        {
          "target": "stdlib.curses.cbreak",
          "type": "calls"
        },
        {
          "target": "stdlib.curses.keypad",
          "type": "calls"
        },
        {
          "target": "stdlib.curses.func",
          "type": "calls"
        },
        {
          "target": "stdlib.curses.start_color",
          "type": "calls"
        },
        {
          "target": "stdlib.curses.locals",
          "type": "calls"
        },
        {
          "target": "stdlib.curses.keypad",
          "type": "calls"
        },
        {
          "target": "stdlib.curses.echo",
          "type": "calls"
        },
        {
          "target": "stdlib.curses.nocbreak",
          "type": "calls"
        },
        {
          "target": "stdlib.curses.endwin",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.dataclasses.Field",
      "name": "Field",
      "module": "dataclasses",
      "type": "class",
      "signature": "(default, default_factory, init, repr, hash, compare, metadata)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.dataclasses.InitVar",
      "name": "InitVar",
      "module": "dataclasses",
      "type": "class",
      "signature": "(type)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.dataclasses.asdict",
      "name": "asdict",
      "module": "dataclasses",
      "type": "function",
      "signature": "(obj, *, dict_factory=<class 'dict'>)",
      "description": "Return the fields of a dataclass instance as a new dictionary mapping\nfield names to field values.\n\nExample usage:\n\n  @dataclass\n  class C:\n      x: int\n      y: int\n\n  c = C(1, 2)\n  assert asdict(c) == {'x': 1, 'y': 2}\n\nIf given, 'dict_factory' will be used instead of built-in dict.\nThe function applies recursively to field values that are\ndataclass instances. This will also look into built-in containers:\ntuples, lists, and dicts.",
      "relationships": [
        {
          "target": "stdlib.dataclasses._asdict_inner",
          "type": "calls"
        },
        {
          "target": "stdlib.dataclasses._is_dataclass_instance",
          "type": "calls"
        },
        {
          "target": "stdlib.dataclasses.TypeError",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.dataclasses.astuple",
      "name": "astuple",
      "module": "dataclasses",
      "type": "function",
      "signature": "(obj, *, tuple_factory=<class 'tuple'>)",
      "description": "Return the fields of a dataclass instance as a new tuple of field values.\n\nExample usage::\n\n  @dataclass\n  class C:\n      x: int\n      y: int\n\nc = C(1, 2)\nassert astuple(c) == (1, 2)\n\nIf given, 'tuple_factory' will be used instead of built-in tuple.\nThe function applies recursively to field values that are\ndataclass instances. This will also look into built-in containers:\ntuples, lists, and dicts.",
      "relationships": [
        {
          "target": "stdlib.dataclasses._astuple_inner",
          "type": "calls"
        },
        {
          "target": "stdlib.dataclasses._is_dataclass_instance",
          "type": "calls"
        },
        {
          "target": "stdlib.dataclasses.TypeError",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.dataclasses.dataclass",
      "name": "dataclass",
      "module": "dataclasses",
      "type": "function",
      "signature": "(cls=None, /, *, init=True, repr=True, eq=True, order=False, unsafe_hash=False, frozen=False)",
      "description": "Returns the same class as was passed in, with dunder methods\nadded based on the fields defined in the class.\n\nExamines PEP 526 __annotations__ to determine fields.\n\nIf init is true, an __init__() method is added to the class. If\nrepr is true, a __repr__() method is added. If order is true, rich\ncomparison dunder methods are added. If unsafe_hash is true, a\n__hash__() method function is added. If frozen is true, fields may\nnot be assigned to after instance creation.",
      "relationships": [
        {
          "target": "stdlib.dataclasses.wrap",
          "type": "calls"
        },
        {
          "target": "stdlib.dataclasses._process_class",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.dataclasses.field",
      "name": "field",
      "module": "dataclasses",
      "type": "function",
      "signature": "(*, default=<dataclasses._MISSING_TYPE object at 0x1089d4400>, default_factory=<dataclasses._MISSING_TYPE object at 0x1089d4400>, init=True, repr=True, hash=None, compare=True, metadata=None)",
      "description": "Return an object to identify dataclass fields.\n\ndefault is the default value of the field.  default_factory is a\n0-argument function called to initialize a field's value.  If init\nis True, the field will be a parameter to the class's __init__()\nfunction.  If repr is True, the field will be included in the\nobject's repr().  If hash is True, the field will be included in\nthe object's hash().  If compare is True, the field will be used\nin comparison functions.  metadata, if specified, must be a\nmapping which is stored but not otherwise examined by dataclass.\n\nIt is an error to specify both default and default_factory.",
      "relationships": [
        {
          "target": "stdlib.dataclasses.Field",
          "type": "calls"
        },
        {
          "target": "stdlib.dataclasses.ValueError",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.dataclasses.fields",
      "name": "fields",
      "module": "dataclasses",
      "type": "function",
      "signature": "(class_or_instance)",
      "description": "Return a tuple describing the fields of this dataclass.\n\nAccepts a dataclass or an instance of one. Tuple elements are of\ntype Field.",
      "relationships": [
        {
          "target": "stdlib.dataclasses.tuple",
          "type": "calls"
        },
        {
          "target": "stdlib.dataclasses.getattr",
          "type": "calls"
        },
        {
          "target": "stdlib.dataclasses.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.dataclasses.values",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.dataclasses.is_dataclass",
      "name": "is_dataclass",
      "module": "dataclasses",
      "type": "function",
      "signature": "(obj)",
      "description": "Returns True if obj is a dataclass or an instance of a\ndataclass.",
      "relationships": [
        {
          "target": "stdlib.dataclasses.hasattr",
          "type": "calls"
        },
        {
          "target": "stdlib.dataclasses.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.dataclasses.type",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.dataclasses.make_dataclass",
      "name": "make_dataclass",
      "module": "dataclasses",
      "type": "function",
      "signature": "(cls_name, fields, *, bases=(), namespace=None, init=True, repr=True, eq=True, order=False, unsafe_hash=False, frozen=False)",
      "description": "Return a new dynamically created dataclass.\n\nThe dataclass name will be 'cls_name'.  'fields' is an iterable\nof either (name), (name, type) or (name, type, Field) objects. If type is\nomitted, use the string 'typing.Any'.  Field objects are created by\nthe equivalent of calling 'field(name, type [, Field-info])'.\n\n  C = make_dataclass('C', ['x', ('y', int), ('z', int, field(init=False))], bases=(Base,))\n\nis equivalent to:\n\n  @dataclass\n  class C(Base):\n      x: 'typing.Any'\n      y: int\n      z: int = field(init=False)\n\nFor the bases and namespace parameters, see the builtin type() function.\n\nThe parameters init, repr, eq, order, unsafe_hash, and frozen are passed to\ndataclass().",
      "relationships": [
        {
          "target": "stdlib.dataclasses.set",
          "type": "calls"
        },
        {
          "target": "stdlib.dataclasses.new_class",
          "type": "calls"
        },
        {
          "target": "stdlib.dataclasses.dataclass",
          "type": "calls"
        },
        {
          "target": "stdlib.dataclasses.copy",
          "type": "calls"
        },
        {
          "target": "stdlib.dataclasses.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.dataclasses.iskeyword",
          "type": "calls"
        },
        {
          "target": "stdlib.dataclasses.add",
          "type": "calls"
        },
        {
          "target": "stdlib.dataclasses.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.dataclasses.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.dataclasses.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.dataclasses.update",
          "type": "calls"
        },
        {
          "target": "stdlib.dataclasses.len",
          "type": "calls"
        },
        {
          "target": "stdlib.dataclasses.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.dataclasses.isidentifier",
          "type": "calls"
        },
        {
          "target": "stdlib.dataclasses.len",
          "type": "calls"
        },
        {
          "target": "stdlib.dataclasses.TypeError",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.dataclasses.replace",
      "name": "replace",
      "module": "dataclasses",
      "type": "function",
      "signature": "(obj, /, **changes)",
      "description": "Return a new object replacing specified fields with new values.\n\nThis is especially useful for frozen classes.  Example usage:\n\n  @dataclass(frozen=True)\n  class C:\n      x: int\n      y: int\n\n  c = C(1, 2)\n  c1 = replace(c, x=3)\n  assert c1.x == 3 and c1.y == 2\n  ",
      "relationships": [
        {
          "target": "stdlib.dataclasses.values",
          "type": "calls"
        },
        {
          "target": "stdlib.dataclasses.__class__",
          "type": "calls"
        },
        {
          "target": "stdlib.dataclasses._is_dataclass_instance",
          "type": "calls"
        },
        {
          "target": "stdlib.dataclasses.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.dataclasses.getattr",
          "type": "calls"
        },
        {
          "target": "stdlib.dataclasses.getattr",
          "type": "calls"
        },
        {
          "target": "stdlib.dataclasses.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.dataclasses.ValueError",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.dbm.open",
      "name": "open",
      "module": "dbm",
      "type": "function",
      "signature": "(file, flag='r', mode=438)",
      "description": "Open or create database at path given by *file*.\n\nOptional argument *flag* can be 'r' (default) for read-only access, 'w'\nfor read-write access of an existing database, 'c' for read-write access\nto a new or existing database, and 'n' for read-write access to a new\ndatabase.\n\nNote: 'r' and 'w' fail if the database doesn't exist; 'c' creates it\nonly if it doesn't exist; and 'n' always creates a new database.",
      "relationships": [
        {
          "target": "stdlib.dbm.open",
          "type": "calls"
        },
        {
          "target": "stdlib.dbm.whichdb",
          "type": "calls"
        },
        {
          "target": "stdlib.dbm.ImportError",
          "type": "calls"
        },
        {
          "target": "stdlib.dbm.__import__",
          "type": "calls"
        },
        {
          "target": "stdlib.dbm.format",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.dbm.whichdb",
      "name": "whichdb",
      "module": "dbm",
      "type": "function",
      "signature": "(filename)",
      "description": "Guess which db package to use to open a db file.\n\nReturn values:\n\n- None if the database file can't be read;\n- empty string if the file can be read but can't be recognized\n- the name of the dbm submodule (e.g. \"ndbm\" or \"gnu\") if recognized.\n\nImporting the given module may still fail, and opening the\ndatabase using that module may still fail.",
      "relationships": [
        {
          "target": "stdlib.dbm.open",
          "type": "calls"
        },
        {
          "target": "stdlib.dbm.close",
          "type": "calls"
        },
        {
          "target": "stdlib.dbm.open",
          "type": "calls"
        },
        {
          "target": "stdlib.dbm.close",
          "type": "calls"
        },
        {
          "target": "stdlib.dbm.stat",
          "type": "calls"
        },
        {
          "target": "stdlib.dbm.open",
          "type": "calls"
        },
        {
          "target": "stdlib.dbm.open",
          "type": "calls"
        },
        {
          "target": "stdlib.dbm.read",
          "type": "calls"
        },
        {
          "target": "stdlib.dbm.len",
          "type": "calls"
        },
        {
          "target": "stdlib.dbm.unpack",
          "type": "calls"
        },
        {
          "target": "stdlib.dbm.unpack",
          "type": "calls"
        },
        {
          "target": "stdlib.dbm.stat",
          "type": "calls"
        },
        {
          "target": "stdlib.dbm.close",
          "type": "calls"
        },
        {
          "target": "stdlib.dbm.open",
          "type": "calls"
        },
        {
          "target": "stdlib.dbm.close",
          "type": "calls"
        },
        {
          "target": "stdlib.dbm.read",
          "type": "calls"
        },
        {
          "target": "stdlib.dbm.open",
          "type": "calls"
        },
        {
          "target": "stdlib.dbm.close",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.decimal.Context",
      "name": "Context",
      "module": "decimal",
      "type": "class",
      "signature": "(prec=None, rounding=None, Emin=None, Emax=None, capitals=None, clamp=None, flags=None, traps=None)",
      "description": "The context affects almost all operations and controls rounding,\nOver/Underflow, raising of exceptions and much more.  A new context\ncan be constructed as follows:\n\n    >>> c = Context(prec=28, Emin=-425000000, Emax=425000000,\n    ...             rounding=ROUND_HALF_EVEN, capitals=1, clamp=1,\n    ...             traps=[InvalidOperation, DivisionByZero, Overflow],\n    ...             flags=[])\n    >>>",
      "relationships": []
    },
    {
      "id": "stdlib.decimal.Decimal",
      "name": "Decimal",
      "module": "decimal",
      "type": "class",
      "signature": "(value='0', context=None)",
      "description": "Construct a new Decimal object. 'value' can be an integer, string, tuple,\nor another Decimal object. If no value is given, return Decimal('0'). The\ncontext does not affect the conversion and is only passed to determine if\nthe InvalidOperation trap is active.",
      "relationships": []
    },
    {
      "id": "stdlib.decimal.DecimalTuple",
      "name": "DecimalTuple",
      "module": "decimal",
      "type": "class",
      "signature": "(sign, digits, exponent)",
      "description": "DecimalTuple(sign, digits, exponent)",
      "relationships": [
        {
          "target": "tuple",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.difflib.Differ",
      "name": "Differ",
      "module": "difflib",
      "type": "class",
      "signature": "(linejunk=None, charjunk=None)",
      "description": "Differ is a class for comparing sequences of lines of text, and\nproducing human-readable differences or deltas.  Differ uses\nSequenceMatcher both to compare sequences of lines, and to compare\nsequences of characters within similar (near-matching) lines.\n\nEach line of a Differ delta begins with a two-letter code:\n\n    '- '    line unique to sequence 1\n    '+ '    line unique to sequence 2\n    '  '    line common to both sequences\n    '? '    line not present in either input sequence\n\nLines beginning with '? ' attempt to guide the eye to intraline\ndifferences, and were not present in either input sequence.  These lines\ncan be confusing if the sequences contain tab characters.\n\nNote that Differ makes no claim to produce a *minimal* diff.  To the\ncontrary, minimal diffs are often counter-intuitive, because they synch\nup anywhere possible, sometimes accidental matches 100 pages apart.\nRestricting synch points to contiguous matches preserves some notion of\nlocality, at the occasional cost of producing a longer diff.\n\nExample: Comparing two texts.\n\nFirst we set up the texts, sequences of individual single-line strings\nending with newlines (such sequences can also be obtained from the\n`readlines()` method of file-like objects):\n\n>>> text1 = '''  1. Beautiful is better than ugly.\n...   2. Explicit is better than implicit.\n...   3. Simple is better than complex.\n...   4. Complex is better than complicated.\n... '''.splitlines(keepends=True)\n>>> len(text1)\n4\n>>> text1[0][-1]\n'\\n'\n>>> text2 = '''  1. Beautiful is better than ugly.\n...   3.   Simple is better than complex.\n...   4. Complicated is better than complex.\n...   5. Flat is better than nested.\n... '''.splitlines(keepends=True)\n\nNext we instantiate a Differ object:\n\n>>> d = Differ()\n\nNote that when instantiating a Differ object we may pass functions to\nfilter out line and character 'junk'.  See Differ.__init__ for details.\n\nFinally, we compare the two:\n\n>>> result = list(d.compare(text1, text2))\n\n'result' is a list of strings, so let's pretty-print it:\n\n>>> from pprint import pprint as _pprint\n>>> _pprint(result)\n['    1. Beautiful is better than ugly.\\n',\n '-   2. Explicit is better than implicit.\\n',\n '-   3. Simple is better than complex.\\n',\n '+   3.   Simple is better than complex.\\n',\n '?     ++\\n',\n '-   4. Complex is better than complicated.\\n',\n '?            ^                     ---- ^\\n',\n '+   4. Complicated is better than complex.\\n',\n '?           ++++ ^                      ^\\n',\n '+   5. Flat is better than nested.\\n']\n\nAs a single multi-line string it looks like this:\n\n>>> print(''.join(result), end=\"\")\n    1. Beautiful is better than ugly.\n-   2. Explicit is better than implicit.\n-   3. Simple is better than complex.\n+   3.   Simple is better than complex.\n?     ++\n-   4. Complex is better than complicated.\n?            ^                     ---- ^\n+   4. Complicated is better than complex.\n?           ++++ ^                      ^\n+   5. Flat is better than nested.\n\nMethods:\n\n__init__(linejunk=None, charjunk=None)\n    Construct a text differencer, with optional filters.\n\ncompare(a, b)\n    Compare two sequences of lines; generate the resulting delta.",
      "relationships": []
    },
    {
      "id": "stdlib.difflib.HtmlDiff",
      "name": "HtmlDiff",
      "module": "difflib",
      "type": "class",
      "signature": "(tabsize=8, wrapcolumn=None, linejunk=None, charjunk=<function IS_CHARACTER_JUNK at 0x108a360d0>)",
      "description": "For producing HTML side by side comparison with change highlights.\n\nThis class can be used to create an HTML table (or a complete HTML file\ncontaining the table) showing a side by side, line by line comparison\nof text with inter-line and intra-line change highlights.  The table can\nbe generated in either full or contextual difference mode.\n\nThe following methods are provided for HTML generation:\n\nmake_table -- generates HTML for a single side by side table\nmake_file -- generates complete HTML file with a single side by side table\n\nSee tools/scripts/diff.py for an example usage of this class.",
      "relationships": []
    },
    {
      "id": "stdlib.difflib.IS_CHARACTER_JUNK",
      "name": "IS_CHARACTER_JUNK",
      "module": "difflib",
      "type": "function",
      "signature": "(ch, ws=' \\t')",
      "description": "Return True for ignorable character: iff `ch` is a space or tab.\n\nExamples:\n\n>>> IS_CHARACTER_JUNK(' ')\nTrue\n>>> IS_CHARACTER_JUNK('\\t')\nTrue\n>>> IS_CHARACTER_JUNK('\\n')\nFalse\n>>> IS_CHARACTER_JUNK('x')\nFalse",
      "relationships": []
    },
    {
      "id": "stdlib.difflib.IS_LINE_JUNK",
      "name": "IS_LINE_JUNK",
      "module": "difflib",
      "type": "function",
      "signature": "(line, pat=<built-in method match of re.Pattern object at 0x1089d66c0>)",
      "description": "Return True for ignorable line: iff `line` is blank or contains a single '#'.\n\nExamples:\n\n>>> IS_LINE_JUNK('\\n')\nTrue\n>>> IS_LINE_JUNK('  #   \\n')\nTrue\n>>> IS_LINE_JUNK('hello\\n')\nFalse",
      "relationships": [
        {
          "target": "stdlib.difflib.compile",
          "type": "calls"
        },
        {
          "target": "stdlib.difflib.pat",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.difflib.Match",
      "name": "Match",
      "module": "difflib",
      "type": "class",
      "signature": "(a, b, size)",
      "description": "Match(a, b, size)",
      "relationships": [
        {
          "target": "tuple",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.difflib.SequenceMatcher",
      "name": "SequenceMatcher",
      "module": "difflib",
      "type": "class",
      "signature": "(isjunk=None, a='', b='', autojunk=True)",
      "description": "SequenceMatcher is a flexible class for comparing pairs of sequences of\nany type, so long as the sequence elements are hashable.  The basic\nalgorithm predates, and is a little fancier than, an algorithm\npublished in the late 1980's by Ratcliff and Obershelp under the\nhyperbolic name \"gestalt pattern matching\".  The basic idea is to find\nthe longest contiguous matching subsequence that contains no \"junk\"\nelements (R-O doesn't address junk).  The same idea is then applied\nrecursively to the pieces of the sequences to the left and to the right\nof the matching subsequence.  This does not yield minimal edit\nsequences, but does tend to yield matches that \"look right\" to people.\n\nSequenceMatcher tries to compute a \"human-friendly diff\" between two\nsequences.  Unlike e.g. UNIX(tm) diff, the fundamental notion is the\nlongest *contiguous* & junk-free matching subsequence.  That's what\ncatches peoples' eyes.  The Windows(tm) windiff has another interesting\nnotion, pairing up elements that appear uniquely in each sequence.\nThat, and the method here, appear to yield more intuitive difference\nreports than does diff.  This method appears to be the least vulnerable\nto synching up on blocks of \"junk lines\", though (like blank lines in\nordinary text files, or maybe \"<P>\" lines in HTML files).  That may be\nbecause this is the only method of the 3 that has a *concept* of\n\"junk\" <wink>.\n\nExample, comparing two strings, and considering blanks to be \"junk\":\n\n>>> s = SequenceMatcher(lambda x: x == \" \",\n...                     \"private Thread currentThread;\",\n...                     \"private volatile Thread currentThread;\")\n>>>\n\n.ratio() returns a float in [0, 1], measuring the \"similarity\" of the\nsequences.  As a rule of thumb, a .ratio() value over 0.6 means the\nsequences are close matches:\n\n>>> print(round(s.ratio(), 3))\n0.866\n>>>\n\nIf you're only interested in where the sequences match,\n.get_matching_blocks() is handy:\n\n>>> for block in s.get_matching_blocks():\n...     print(\"a[%d] and b[%d] match for %d elements\" % block)\na[0] and b[0] match for 8 elements\na[8] and b[17] match for 21 elements\na[29] and b[38] match for 0 elements\n\nNote that the last tuple returned by .get_matching_blocks() is always a\ndummy, (len(a), len(b), 0), and this is the only case in which the last\ntuple element (number of elements matched) is 0.\n\nIf you want to know how to change the first sequence into the second,\nuse .get_opcodes():\n\n>>> for opcode in s.get_opcodes():\n...     print(\"%6s a[%d:%d] b[%d:%d]\" % opcode)\n equal a[0:8] b[0:8]\ninsert a[8:8] b[8:17]\n equal a[8:29] b[17:38]\n\nSee the Differ class for a fancy human-friendly file differencer, which\nuses SequenceMatcher both to compare sequences of lines, and to compare\nsequences of characters within similar (near-matching) lines.\n\nSee also function get_close_matches() in this module, which shows how\nsimple code building on SequenceMatcher can be used to do useful work.\n\nTiming:  Basic R-O is cubic time worst case and quadratic time expected\ncase.  SequenceMatcher is quadratic time for the worst case and has\nexpected-case behavior dependent in a complicated way on how many\nelements the sequences have in common; best case time is linear.\n\nMethods:\n\n__init__(isjunk=None, a='', b='')\n    Construct a SequenceMatcher.\n\nset_seqs(a, b)\n    Set the two sequences to be compared.\n\nset_seq1(a)\n    Set the first sequence to be compared.\n\nset_seq2(b)\n    Set the second sequence to be compared.\n\nfind_longest_match(alo=0, ahi=None, blo=0, bhi=None)\n    Find longest matching block in a[alo:ahi] and b[blo:bhi].\n\nget_matching_blocks()\n    Return list of triples describing matching subsequences.\n\nget_opcodes()\n    Return list of 5-tuples describing how to turn a into b.\n\nratio()\n    Return a measure of the sequences' similarity (float in [0,1]).\n\nquick_ratio()\n    Return an upper bound on .ratio() relatively quickly.\n\nreal_quick_ratio()\n    Return an upper bound on ratio() very quickly.",
      "relationships": []
    },
    {
      "id": "stdlib.difflib.context_diff",
      "name": "context_diff",
      "module": "difflib",
      "type": "function",
      "signature": "(a, b, fromfile='', tofile='', fromfiledate='', tofiledate='', n=3, lineterm='\\n')",
      "description": "Compare two sequences of lines; generate the delta as a context diff.\n\nContext diffs are a compact way of showing line changes and a few\nlines of context.  The number of context lines is set by 'n' which\ndefaults to three.\n\nBy default, the diff control lines (those with *** or ---) are\ncreated with a trailing newline.  This is helpful so that inputs\ncreated from file.readlines() result in diffs that are suitable for\nfile.writelines() since both the inputs and outputs have trailing\nnewlines.\n\nFor inputs that do not have trailing newlines, set the lineterm\nargument to \"\" so that the output will be uniformly newline free.\n\nThe context diff format normally has a header for filenames and\nmodification times.  Any or all of these may be specified using\nstrings for 'fromfile', 'tofile', 'fromfiledate', and 'tofiledate'.\nThe modification times are normally expressed in the ISO 8601 format.\nIf not specified, the strings default to blanks.\n\nExample:\n\n>>> print(''.join(context_diff('one\\ntwo\\nthree\\nfour\\n'.splitlines(True),\n...       'zero\\none\\ntree\\nfour\\n'.splitlines(True), 'Original', 'Current')),\n...       end=\"\")\n*** Original\n--- Current\n***************\n*** 1,4 ****\n  one\n! two\n! three\n  four\n--- 1,4 ----\n+ zero\n  one\n! tree\n  four",
      "relationships": [
        {
          "target": "stdlib.difflib._check_types",
          "type": "calls"
        },
        {
          "target": "stdlib.difflib.dict",
          "type": "calls"
        },
        {
          "target": "stdlib.difflib.get_grouped_opcodes",
          "type": "calls"
        },
        {
          "target": "stdlib.difflib._format_range_context",
          "type": "calls"
        },
        {
          "target": "stdlib.difflib.any",
          "type": "calls"
        },
        {
          "target": "stdlib.difflib._format_range_context",
          "type": "calls"
        },
        {
          "target": "stdlib.difflib.any",
          "type": "calls"
        },
        {
          "target": "stdlib.difflib.SequenceMatcher",
          "type": "calls"
        },
        {
          "target": "stdlib.difflib.format",
          "type": "calls"
        },
        {
          "target": "stdlib.difflib.format",
          "type": "calls"
        },
        {
          "target": "stdlib.difflib.format",
          "type": "calls"
        },
        {
          "target": "stdlib.difflib.format",
          "type": "calls"
        },
        {
          "target": "stdlib.difflib.format",
          "type": "calls"
        },
        {
          "target": "stdlib.difflib.format",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.difflib.diff_bytes",
      "name": "diff_bytes",
      "module": "difflib",
      "type": "function",
      "signature": "(dfunc, a, b, fromfile=b'', tofile=b'', fromfiledate=b'', tofiledate=b'', n=3, lineterm=b'\\n')",
      "description": "Compare `a` and `b`, two sequences of lines represented as bytes rather\nthan str. This is a wrapper for `dfunc`, which is typically either\nunified_diff() or context_diff(). Inputs are losslessly converted to\nstrings so that `dfunc` only has to worry about strings, and encoded\nback to bytes on return. This is necessary to compare files with\nunknown or inconsistent encoding. All other inputs (except `n`) must be\nbytes rather than str.",
      "relationships": [
        {
          "target": "stdlib.difflib.list",
          "type": "calls"
        },
        {
          "target": "stdlib.difflib.list",
          "type": "calls"
        },
        {
          "target": "stdlib.difflib.decode",
          "type": "calls"
        },
        {
          "target": "stdlib.difflib.decode",
          "type": "calls"
        },
        {
          "target": "stdlib.difflib.decode",
          "type": "calls"
        },
        {
          "target": "stdlib.difflib.decode",
          "type": "calls"
        },
        {
          "target": "stdlib.difflib.decode",
          "type": "calls"
        },
        {
          "target": "stdlib.difflib.dfunc",
          "type": "calls"
        },
        {
          "target": "stdlib.difflib.map",
          "type": "calls"
        },
        {
          "target": "stdlib.difflib.map",
          "type": "calls"
        },
        {
          "target": "stdlib.difflib.decode",
          "type": "calls"
        },
        {
          "target": "stdlib.difflib.encode",
          "type": "calls"
        },
        {
          "target": "stdlib.difflib.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.difflib.type",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.difflib.get_close_matches",
      "name": "get_close_matches",
      "module": "difflib",
      "type": "function",
      "signature": "(word, possibilities, n=3, cutoff=0.6)",
      "description": "Use SequenceMatcher to return list of the best \"good enough\" matches.\n\nword is a sequence for which close matches are desired (typically a\nstring).\n\npossibilities is a list of sequences against which to match word\n(typically a list of strings).\n\nOptional arg n (default 3) is the maximum number of close matches to\nreturn.  n must be > 0.\n\nOptional arg cutoff (default 0.6) is a float in [0, 1].  Possibilities\nthat don't score at least that similar to word are ignored.\n\nThe best (no more than n) matches among the possibilities are returned\nin a list, sorted by similarity score, most similar first.\n\n>>> get_close_matches(\"appel\", [\"ape\", \"apple\", \"peach\", \"puppy\"])\n['apple', 'ape']\n>>> import keyword as _keyword\n>>> get_close_matches(\"wheel\", _keyword.kwlist)\n['while']\n>>> get_close_matches(\"Apple\", _keyword.kwlist)\n[]\n>>> get_close_matches(\"accept\", _keyword.kwlist)\n['except']",
      "relationships": [
        {
          "target": "stdlib.difflib.SequenceMatcher",
          "type": "calls"
        },
        {
          "target": "stdlib.difflib.set_seq2",
          "type": "calls"
        },
        {
          "target": "stdlib.difflib._nlargest",
          "type": "calls"
        },
        {
          "target": "stdlib.difflib.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.difflib.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.difflib.set_seq1",
          "type": "calls"
        },
        {
          "target": "stdlib.difflib.append",
          "type": "calls"
        },
        {
          "target": "stdlib.difflib.real_quick_ratio",
          "type": "calls"
        },
        {
          "target": "stdlib.difflib.quick_ratio",
          "type": "calls"
        },
        {
          "target": "stdlib.difflib.ratio",
          "type": "calls"
        },
        {
          "target": "stdlib.difflib.ratio",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.difflib.ndiff",
      "name": "ndiff",
      "module": "difflib",
      "type": "function",
      "signature": "(a, b, linejunk=None, charjunk=<function IS_CHARACTER_JUNK at 0x108a360d0>)",
      "description": "Compare `a` and `b` (lists of strings); return a `Differ`-style delta.\n\nOptional keyword parameters `linejunk` and `charjunk` are for filter\nfunctions, or can be None:\n\n- linejunk: A function that should accept a single string argument and\n  return true iff the string is junk.  The default is None, and is\n  recommended; the underlying SequenceMatcher class has an adaptive\n  notion of \"noise\" lines.\n\n- charjunk: A function that accepts a character (string of length\n  1), and returns true iff the character is junk. The default is\n  the module-level function IS_CHARACTER_JUNK, which filters out\n  whitespace characters (a blank or tab; note: it's a bad idea to\n  include newline in this!).\n\nTools/scripts/ndiff.py is a command-line front-end to this function.\n\nExample:\n\n>>> diff = ndiff('one\\ntwo\\nthree\\n'.splitlines(keepends=True),\n...              'ore\\ntree\\nemu\\n'.splitlines(keepends=True))\n>>> print(''.join(diff), end=\"\")\n- one\n?  ^\n+ ore\n?  ^\n- two\n- three\n?  -\n+ tree\n+ emu",
      "relationships": [
        {
          "target": "stdlib.difflib.compare",
          "type": "calls"
        },
        {
          "target": "stdlib.difflib.Differ",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.difflib.restore",
      "name": "restore",
      "module": "difflib",
      "type": "function",
      "signature": "(delta, which)",
      "description": "Generate one of the two sequences that generated a delta.\n\nGiven a `delta` produced by `Differ.compare()` or `ndiff()`, extract\nlines originating from file 1 or 2 (parameter `which`), stripping off line\nprefixes.\n\nExamples:\n\n>>> diff = ndiff('one\\ntwo\\nthree\\n'.splitlines(keepends=True),\n...              'ore\\ntree\\nemu\\n'.splitlines(keepends=True))\n>>> diff = list(diff)\n>>> print(''.join(restore(diff, 1)), end=\"\")\none\ntwo\nthree\n>>> print(''.join(restore(diff, 2)), end=\"\")\nore\ntree\nemu",
      "relationships": [
        {
          "target": "stdlib.difflib.int",
          "type": "calls"
        },
        {
          "target": "stdlib.difflib.ValueError",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.difflib.unified_diff",
      "name": "unified_diff",
      "module": "difflib",
      "type": "function",
      "signature": "(a, b, fromfile='', tofile='', fromfiledate='', tofiledate='', n=3, lineterm='\\n')",
      "description": "Compare two sequences of lines; generate the delta as a unified diff.\n\nUnified diffs are a compact way of showing line changes and a few\nlines of context.  The number of context lines is set by 'n' which\ndefaults to three.\n\nBy default, the diff control lines (those with ---, +++, or @@) are\ncreated with a trailing newline.  This is helpful so that inputs\ncreated from file.readlines() result in diffs that are suitable for\nfile.writelines() since both the inputs and outputs have trailing\nnewlines.\n\nFor inputs that do not have trailing newlines, set the lineterm\nargument to \"\" so that the output will be uniformly newline free.\n\nThe unidiff format normally has a header for filenames and modification\ntimes.  Any or all of these may be specified using strings for\n'fromfile', 'tofile', 'fromfiledate', and 'tofiledate'.\nThe modification times are normally expressed in the ISO 8601 format.\n\nExample:\n\n>>> for line in unified_diff('one two three four'.split(),\n...             'zero one tree four'.split(), 'Original', 'Current',\n...             '2005-01-26 23:30:50', '2010-04-02 10:20:52',\n...             lineterm=''):\n...     print(line)                 # doctest: +NORMALIZE_WHITESPACE\n--- Original        2005-01-26 23:30:50\n+++ Current         2010-04-02 10:20:52\n@@ -1,4 +1,4 @@\n+zero\n one\n-two\n-three\n+tree\n four",
      "relationships": [
        {
          "target": "stdlib.difflib._check_types",
          "type": "calls"
        },
        {
          "target": "stdlib.difflib.get_grouped_opcodes",
          "type": "calls"
        },
        {
          "target": "stdlib.difflib._format_range_unified",
          "type": "calls"
        },
        {
          "target": "stdlib.difflib._format_range_unified",
          "type": "calls"
        },
        {
          "target": "stdlib.difflib.SequenceMatcher",
          "type": "calls"
        },
        {
          "target": "stdlib.difflib.format",
          "type": "calls"
        },
        {
          "target": "stdlib.difflib.format",
          "type": "calls"
        },
        {
          "target": "stdlib.difflib.format",
          "type": "calls"
        },
        {
          "target": "stdlib.difflib.format",
          "type": "calls"
        },
        {
          "target": "stdlib.difflib.format",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.dis.Bytecode",
      "name": "Bytecode",
      "module": "dis",
      "type": "class",
      "signature": "(x, *, first_line=None, current_offset=None)",
      "description": "The bytecode operations of a piece of code\n\nInstantiate this with a function, method, other compiled object, string of\ncode, or a code object (as returned by compile()).\n\nIterating over this yields the bytecode operations as Instruction instances.",
      "relationships": []
    },
    {
      "id": "stdlib.dis.Instruction",
      "name": "Instruction",
      "module": "dis",
      "type": "class",
      "signature": "(opname, opcode, arg, argval, argrepr, offset, starts_line, is_jump_target)",
      "description": "Details for a bytecode operation\n\nDefined fields:\n  opname - human readable name for operation\n  opcode - numeric code for operation\n  arg - numeric argument to operation (if any), otherwise None\n  argval - resolved arg value (if known), otherwise same as arg\n  argrepr - human readable description of operation argument\n  offset - start index of operation within bytecode sequence\n  starts_line - line started by this opcode (if any), otherwise None\n  is_jump_target - True if other code jumps to here, otherwise False",
      "relationships": [
        {
          "target": "_Instruction",
          "type": "base_class"
        },
        {
          "target": "tuple",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.dis.code_info",
      "name": "code_info",
      "module": "dis",
      "type": "function",
      "signature": "(x)",
      "description": "Formatted details of methods, functions, or code.",
      "relationships": [
        {
          "target": "stdlib.dis._format_code_info",
          "type": "calls"
        },
        {
          "target": "stdlib.dis._get_code_object",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.dis.dis",
      "name": "dis",
      "module": "dis",
      "type": "function",
      "signature": "(x=None, *, file=None, depth=None)",
      "description": "Disassemble classes, methods, functions, and other compiled objects.\n\nWith no argument, disassemble the last traceback.\n\nCompiled objects currently include generator objects, async generator\nobjects, and coroutine objects, all of which store their code object\nin a special attribute.",
      "relationships": [
        {
          "target": "stdlib.dis.hasattr",
          "type": "calls"
        },
        {
          "target": "stdlib.dis.hasattr",
          "type": "calls"
        },
        {
          "target": "stdlib.dis.hasattr",
          "type": "calls"
        },
        {
          "target": "stdlib.dis.distb",
          "type": "calls"
        },
        {
          "target": "stdlib.dis.hasattr",
          "type": "calls"
        },
        {
          "target": "stdlib.dis.sorted",
          "type": "calls"
        },
        {
          "target": "stdlib.dis.hasattr",
          "type": "calls"
        },
        {
          "target": "stdlib.dis.hasattr",
          "type": "calls"
        },
        {
          "target": "stdlib.dis.items",
          "type": "calls"
        },
        {
          "target": "stdlib.dis.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.dis._disassemble_recursive",
          "type": "calls"
        },
        {
          "target": "stdlib.dis.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.dis.hasattr",
          "type": "calls"
        },
        {
          "target": "stdlib.dis.print",
          "type": "calls"
        },
        {
          "target": "stdlib.dis.print",
          "type": "calls"
        },
        {
          "target": "stdlib.dis._disassemble_bytes",
          "type": "calls"
        },
        {
          "target": "stdlib.dis.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.dis.dis",
          "type": "calls"
        },
        {
          "target": "stdlib.dis._disassemble_str",
          "type": "calls"
        },
        {
          "target": "stdlib.dis.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.dis.print",
          "type": "calls"
        },
        {
          "target": "stdlib.dis.type",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.dis.disassemble",
      "name": "disassemble",
      "module": "dis",
      "type": "function",
      "signature": "(co, lasti=-1, *, file=None)",
      "description": "Disassemble a code object.",
      "relationships": [
        {
          "target": "stdlib.dis.dict",
          "type": "calls"
        },
        {
          "target": "stdlib.dis._disassemble_bytes",
          "type": "calls"
        },
        {
          "target": "stdlib.dis.findlinestarts",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.dis.disco",
      "name": "disco",
      "module": "dis",
      "type": "function",
      "signature": "(co, lasti=-1, *, file=None)",
      "description": "Disassemble a code object.",
      "relationships": [
        {
          "target": "stdlib.dis.dict",
          "type": "calls"
        },
        {
          "target": "stdlib.dis._disassemble_bytes",
          "type": "calls"
        },
        {
          "target": "stdlib.dis.findlinestarts",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.dis.distb",
      "name": "distb",
      "module": "dis",
      "type": "function",
      "signature": "(tb=None, *, file=None)",
      "description": "Disassemble a traceback (default: last traceback).",
      "relationships": [
        {
          "target": "stdlib.dis.disassemble",
          "type": "calls"
        },
        {
          "target": "stdlib.dis.RuntimeError",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.dis.findlabels",
      "name": "findlabels",
      "module": "dis",
      "type": "function",
      "signature": "(code)",
      "description": "Detect all offsets in a byte code which are jump targets.\n\nReturn the list of offsets.",
      "relationships": [
        {
          "target": "stdlib.dis._unpack_opargs",
          "type": "calls"
        },
        {
          "target": "stdlib.dis.append",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.dis.findlinestarts",
      "name": "findlinestarts",
      "module": "dis",
      "type": "function",
      "signature": "(code)",
      "description": "Find the offsets in a byte code which are start of lines in the source.\n\nGenerate pairs (offset, lineno) as described in Python/compile.c.",
      "relationships": [
        {
          "target": "stdlib.dis.len",
          "type": "calls"
        },
        {
          "target": "stdlib.dis.zip",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.dis.get_instructions",
      "name": "get_instructions",
      "module": "dis",
      "type": "function",
      "signature": "(x, *, first_line=None)",
      "description": "Iterator for the opcodes in methods, functions or code\n\nGenerates a series of Instruction named tuples giving the details of\neach operations in the supplied code.\n\nIf *first_line* is not None, it indicates the line number that should\nbe reported for the first source line in the disassembled code.\nOtherwise, the source line information (if any) is taken directly from\nthe disassembled code object.",
      "relationships": [
        {
          "target": "stdlib.dis._get_code_object",
          "type": "calls"
        },
        {
          "target": "stdlib.dis.dict",
          "type": "calls"
        },
        {
          "target": "stdlib.dis._get_instructions_bytes",
          "type": "calls"
        },
        {
          "target": "stdlib.dis.findlinestarts",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.dis.pretty_flags",
      "name": "pretty_flags",
      "module": "dis",
      "type": "function",
      "signature": "(flags)",
      "description": "Return pretty representation of code flags.",
      "relationships": [
        {
          "target": "stdlib.dis.range",
          "type": "calls"
        },
        {
          "target": "stdlib.dis.join",
          "type": "calls"
        },
        {
          "target": "stdlib.dis.append",
          "type": "calls"
        },
        {
          "target": "stdlib.dis.append",
          "type": "calls"
        },
        {
          "target": "stdlib.dis.hex",
          "type": "calls"
        },
        {
          "target": "stdlib.dis.get",
          "type": "calls"
        },
        {
          "target": "stdlib.dis.hex",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.dis.show_code",
      "name": "show_code",
      "module": "dis",
      "type": "function",
      "signature": "(co, *, file=None)",
      "description": "Print details of methods, functions, or code to *file*.\n\nIf *file* is not provided, the output is printed on stdout.",
      "relationships": [
        {
          "target": "stdlib.dis.print",
          "type": "calls"
        },
        {
          "target": "stdlib.dis.code_info",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.doctest.DebugRunner",
      "name": "DebugRunner",
      "module": "doctest",
      "type": "class",
      "signature": "(checker=None, verbose=None, optionflags=0)",
      "description": "Run doc tests but raise an exception as soon as there is a failure.\n\nIf an unexpected exception occurs, an UnexpectedException is raised.\nIt contains the test, the example, and the original exception:\n\n  >>> runner = DebugRunner(verbose=False)\n  >>> test = DocTestParser().get_doctest('>>> raise KeyError\\n42',\n  ...                                    {}, 'foo', 'foo.py', 0)\n  >>> try:\n  ...     runner.run(test)\n  ... except UnexpectedException as f:\n  ...     failure = f\n\n  >>> failure.test is test\n  True\n\n  >>> failure.example.want\n  '42\\n'\n\n  >>> exc_info = failure.exc_info\n  >>> raise exc_info[1] # Already has the traceback\n  Traceback (most recent call last):\n  ...\n  KeyError\n\nWe wrap the original exception to give the calling application\naccess to the test and example information.\n\nIf the output doesn't match, then a DocTestFailure is raised:\n\n  >>> test = DocTestParser().get_doctest('''\n  ...      >>> x = 1\n  ...      >>> x\n  ...      2\n  ...      ''', {}, 'foo', 'foo.py', 0)\n\n  >>> try:\n  ...    runner.run(test)\n  ... except DocTestFailure as f:\n  ...    failure = f\n\nDocTestFailure objects provide access to the test:\n\n  >>> failure.test is test\n  True\n\nAs well as to the example:\n\n  >>> failure.example.want\n  '2\\n'\n\nand the actual output:\n\n  >>> failure.got\n  '1\\n'\n\nIf a failure or error occurs, the globals are left intact:\n\n  >>> del test.globs['__builtins__']\n  >>> test.globs\n  {'x': 1}\n\n  >>> test = DocTestParser().get_doctest('''\n  ...      >>> x = 2\n  ...      >>> raise KeyError\n  ...      ''', {}, 'foo', 'foo.py', 0)\n\n  >>> runner.run(test)\n  Traceback (most recent call last):\n  ...\n  doctest.UnexpectedException: <DocTest foo from foo.py:0 (2 examples)>\n\n  >>> del test.globs['__builtins__']\n  >>> test.globs\n  {'x': 2}\n\nBut the globals are cleared if there is no error:\n\n  >>> test = DocTestParser().get_doctest('''\n  ...      >>> x = 2\n  ...      ''', {}, 'foo', 'foo.py', 0)\n\n  >>> runner.run(test)\n  TestResults(failed=0, attempted=1)\n\n  >>> test.globs\n  {}",
      "relationships": [
        {
          "target": "DocTestRunner",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.doctest.DocFileCase",
      "name": "DocFileCase",
      "module": "doctest",
      "type": "class",
      "signature": "(test, optionflags=0, setUp=None, tearDown=None, checker=None)",
      "description": "A class whose instances are single test cases.\n\nBy default, the test code itself should be placed in a method named\n'runTest'.\n\nIf the fixture may be used for many test cases, create as\nmany test methods as are needed. When instantiating such a TestCase\nsubclass, specify in the constructor arguments the name of the test method\nthat the instance is to execute.\n\nTest authors should subclass TestCase for their own tests. Construction\nand deconstruction of the test's environment ('fixture') can be\nimplemented by overriding the 'setUp' and 'tearDown' methods respectively.\n\nIf it is necessary to override the __init__ method, the base class\n__init__ method must always be called. It is important that subclasses\nshould not change the signature of their __init__ method, since instances\nof the classes are instantiated automatically by parts of the framework\nin order to be run.\n\nWhen subclassing TestCase, you can set these attributes:\n* failureException: determines which exception will be raised when\n    the instance's assertion methods fail; test methods raising this\n    exception will be deemed to have 'failed' rather than 'errored'.\n* longMessage: determines whether long messages (including repr of\n    objects used in assert methods) will be printed on failure in *addition*\n    to any explicit message passed.\n* maxDiff: sets the maximum length of a diff in failure messages\n    by assert methods using difflib. It is looked up as an instance\n    attribute so can be configured by individual tests if required.",
      "relationships": [
        {
          "target": "DocTestCase",
          "type": "base_class"
        },
        {
          "target": "TestCase",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.doctest.DocFileSuite",
      "name": "DocFileSuite",
      "module": "doctest",
      "type": "function",
      "signature": "(*paths, **kw)",
      "description": "A unittest suite for one or more doctest files.\n\nThe path to each doctest file is given as a string; the\ninterpretation of that string depends on the keyword argument\n\"module_relative\".\n\nA number of options may be provided as keyword arguments:\n\nmodule_relative\n  If \"module_relative\" is True, then the given file paths are\n  interpreted as os-independent module-relative paths.  By\n  default, these paths are relative to the calling module's\n  directory; but if the \"package\" argument is specified, then\n  they are relative to that package.  To ensure os-independence,\n  \"filename\" should use \"/\" characters to separate path\n  segments, and may not be an absolute path (i.e., it may not\n  begin with \"/\").\n\n  If \"module_relative\" is False, then the given file paths are\n  interpreted as os-specific paths.  These paths may be absolute\n  or relative (to the current working directory).\n\npackage\n  A Python package or the name of a Python package whose directory\n  should be used as the base directory for module relative paths.\n  If \"package\" is not specified, then the calling module's\n  directory is used as the base directory for module relative\n  filenames.  It is an error to specify \"package\" if\n  \"module_relative\" is False.\n\nsetUp\n  A set-up function.  This is called before running the\n  tests in each file. The setUp function will be passed a DocTest\n  object.  The setUp function can access the test globals as the\n  globs attribute of the test passed.\n\ntearDown\n  A tear-down function.  This is called after running the\n  tests in each file.  The tearDown function will be passed a DocTest\n  object.  The tearDown function can access the test globals as the\n  globs attribute of the test passed.\n\nglobs\n  A dictionary containing initial global variables for the tests.\n\noptionflags\n  A set of doctest option flags expressed as an integer.\n\nparser\n  A DocTestParser (or subclass) that should be used to extract\n  tests from the files.\n\nencoding\n  An encoding that will be used to convert the files to unicode.",
      "relationships": [
        {
          "target": "stdlib.doctest._DocTestSuite",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.get",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest._normalize_module",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.addTest",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.get",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.DocFileTest",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.doctest.DocFileTest",
      "name": "DocFileTest",
      "module": "doctest",
      "type": "function",
      "signature": "(path, module_relative=True, package=None, globs=None, parser=<doctest.DocTestParser object at 0x108ba4190>, encoding=None, **options)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.doctest.DocTestParser",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest._load_testfile",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.basename",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.get_doctest",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.DocFileCase",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.copy",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.ValueError",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.doctest.DocTest",
      "name": "DocTest",
      "module": "doctest",
      "type": "class",
      "signature": "(examples, globs, name, filename, lineno, docstring)",
      "description": "A collection of doctest examples that should be run in a single\nnamespace.  Each `DocTest` defines the following attributes:\n\n  - examples: the list of examples.\n\n  - globs: The namespace (aka globals) that the examples should\n    be run in.\n\n  - name: A name identifying the DocTest (typically, the name of\n    the object whose docstring this DocTest was extracted from).\n\n  - filename: The name of the file that this DocTest was extracted\n    from, or `None` if the filename is unknown.\n\n  - lineno: The line number within filename where this DocTest\n    begins, or `None` if the line number is unavailable.  This\n    line number is zero-based, with respect to the beginning of\n    the file.\n\n  - docstring: The string that the examples were extracted from,\n    or `None` if the string is unavailable.",
      "relationships": []
    },
    {
      "id": "stdlib.doctest.DocTestCase",
      "name": "DocTestCase",
      "module": "doctest",
      "type": "class",
      "signature": "(test, optionflags=0, setUp=None, tearDown=None, checker=None)",
      "description": "A class whose instances are single test cases.\n\nBy default, the test code itself should be placed in a method named\n'runTest'.\n\nIf the fixture may be used for many test cases, create as\nmany test methods as are needed. When instantiating such a TestCase\nsubclass, specify in the constructor arguments the name of the test method\nthat the instance is to execute.\n\nTest authors should subclass TestCase for their own tests. Construction\nand deconstruction of the test's environment ('fixture') can be\nimplemented by overriding the 'setUp' and 'tearDown' methods respectively.\n\nIf it is necessary to override the __init__ method, the base class\n__init__ method must always be called. It is important that subclasses\nshould not change the signature of their __init__ method, since instances\nof the classes are instantiated automatically by parts of the framework\nin order to be run.\n\nWhen subclassing TestCase, you can set these attributes:\n* failureException: determines which exception will be raised when\n    the instance's assertion methods fail; test methods raising this\n    exception will be deemed to have 'failed' rather than 'errored'.\n* longMessage: determines whether long messages (including repr of\n    objects used in assert methods) will be printed on failure in *addition*\n    to any explicit message passed.\n* maxDiff: sets the maximum length of a diff in failure messages\n    by assert methods using difflib. It is looked up as an instance\n    attribute so can be configured by individual tests if required.",
      "relationships": [
        {
          "target": "TestCase",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.doctest.DocTestFailure",
      "name": "DocTestFailure",
      "module": "doctest",
      "type": "class",
      "signature": "(test, example, got)",
      "description": "A DocTest example has failed in debugging mode.\n\nThe exception instance has variables:\n\n- test: the DocTest object being run\n\n- example: the Example object that failed\n\n- got: the actual output",
      "relationships": [
        {
          "target": "Exception",
          "type": "base_class"
        },
        {
          "target": "BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.doctest.DocTestFinder",
      "name": "DocTestFinder",
      "module": "doctest",
      "type": "class",
      "signature": "(verbose=False, parser=<doctest.DocTestParser object at 0x108b902e0>, recurse=True, exclude_empty=True)",
      "description": "A class used to extract the DocTests that are relevant to a given\nobject, from its docstring and the docstrings of its contained\nobjects.  Doctests can currently be extracted from the following\nobject types: modules, functions, classes, methods, staticmethods,\nclassmethods, and properties.",
      "relationships": []
    },
    {
      "id": "stdlib.doctest.DocTestParser",
      "name": "DocTestParser",
      "module": "doctest",
      "type": "class",
      "signature": "()",
      "description": "A class used to parse strings containing doctest examples.",
      "relationships": []
    },
    {
      "id": "stdlib.doctest.DocTestRunner",
      "name": "DocTestRunner",
      "module": "doctest",
      "type": "class",
      "signature": "(checker=None, verbose=None, optionflags=0)",
      "description": "A class used to run DocTest test cases, and accumulate statistics.\nThe `run` method is used to process a single DocTest case.  It\nreturns a tuple `(f, t)`, where `t` is the number of test cases\ntried, and `f` is the number of test cases that failed.\n\n    >>> tests = DocTestFinder().find(_TestClass)\n    >>> runner = DocTestRunner(verbose=False)\n    >>> tests.sort(key = lambda test: test.name)\n    >>> for test in tests:\n    ...     print(test.name, '->', runner.run(test))\n    _TestClass -> TestResults(failed=0, attempted=2)\n    _TestClass.__init__ -> TestResults(failed=0, attempted=2)\n    _TestClass.get -> TestResults(failed=0, attempted=2)\n    _TestClass.square -> TestResults(failed=0, attempted=1)\n\nThe `summarize` method prints a summary of all the test cases that\nhave been run by the runner, and returns an aggregated `(f, t)`\ntuple:\n\n    >>> runner.summarize(verbose=1)\n    4 items passed all tests:\n       2 tests in _TestClass\n       2 tests in _TestClass.__init__\n       2 tests in _TestClass.get\n       1 tests in _TestClass.square\n    7 tests in 4 items.\n    7 passed and 0 failed.\n    Test passed.\n    TestResults(failed=0, attempted=7)\n\nThe aggregated number of tried examples and failed examples is\nalso available via the `tries` and `failures` attributes:\n\n    >>> runner.tries\n    7\n    >>> runner.failures\n    0\n\nThe comparison between expected outputs and actual outputs is done\nby an `OutputChecker`.  This comparison may be customized with a\nnumber of option flags; see the documentation for `testmod` for\nmore information.  If the option flags are insufficient, then the\ncomparison may also be customized by passing a subclass of\n`OutputChecker` to the constructor.\n\nThe test runner's display output can be controlled in two ways.\nFirst, an output function (`out) can be passed to\n`TestRunner.run`; this function will be called with strings that\nshould be displayed.  It defaults to `sys.stdout.write`.  If\ncapturing the output is not sufficient, then the display output\ncan be also customized by subclassing DocTestRunner, and\noverriding the methods `report_start`, `report_success`,\n`report_unexpected_exception`, and `report_failure`.",
      "relationships": []
    },
    {
      "id": "stdlib.doctest.DocTestSuite",
      "name": "DocTestSuite",
      "module": "doctest",
      "type": "function",
      "signature": "(module=None, globs=None, extraglobs=None, test_finder=None, **options)",
      "description": "Convert doctest tests for a module to a unittest test suite.\n\nThis converts each documentation string in a module that\ncontains doctest tests to a unittest test case.  If any of the\ntests in a doc string fail, then the test case fails.  An exception\nis raised showing the name of the file containing the test and a\n(sometimes approximate) line number.\n\nThe `module` argument provides the module to be tested.  The argument\ncan be either a module or a module name.\n\nIf no argument is given, the calling module is used.\n\nA number of options may be provided as keyword arguments:\n\nsetUp\n  A set-up function.  This is called before running the\n  tests in each file. The setUp function will be passed a DocTest\n  object.  The setUp function can access the test globals as the\n  globs attribute of the test passed.\n\ntearDown\n  A tear-down function.  This is called after running the\n  tests in each file.  The tearDown function will be passed a DocTest\n  object.  The tearDown function can access the test globals as the\n  globs attribute of the test passed.\n\nglobs\n  A dictionary containing initial global variables for the tests.\n\noptionflags\n   A set of doctest option flags expressed as an integer.",
      "relationships": [
        {
          "target": "stdlib.doctest._normalize_module",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.find",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.sort",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest._DocTestSuite",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.DocTestFinder",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest._DocTestSuite",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.addTest",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.addTest",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.SkipDocTestCase",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.len",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.DocTestCase",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.doctest.Example",
      "name": "Example",
      "module": "doctest",
      "type": "class",
      "signature": "(source, want, exc_msg=None, lineno=0, indent=0, options=None)",
      "description": "A single doctest example, consisting of source code and expected\noutput.  `Example` defines the following attributes:\n\n  - source: A single Python statement, always ending with a newline.\n    The constructor adds a newline if needed.\n\n  - want: The expected output from running the source code (either\n    from stdout, or a traceback in case of exception).  `want` ends\n    with a newline unless it's empty, in which case it's an empty\n    string.  The constructor adds a newline if needed.\n\n  - exc_msg: The exception message generated by the example, if\n    the example is expected to generate an exception; or `None` if\n    it is not expected to generate an exception.  This exception\n    message is compared against the return value of\n    `traceback.format_exception_only()`.  `exc_msg` ends with a\n    newline unless it's `None`.  The constructor adds a newline\n    if needed.\n\n  - lineno: The line number within the DocTest string containing\n    this Example where the Example begins.  This line number is\n    zero-based, with respect to the beginning of the DocTest.\n\n  - indent: The example's indentation in the DocTest string.\n    I.e., the number of space characters that precede the\n    example's first prompt.\n\n  - options: A dictionary mapping from option flags to True or\n    False, which is used to override default options for this\n    example.  Any option flags not contained in this dictionary\n    are left at their default value (as specified by the\n    DocTestRunner's optionflags).  By default, no options are set.",
      "relationships": []
    },
    {
      "id": "stdlib.doctest.OutputChecker",
      "name": "OutputChecker",
      "module": "doctest",
      "type": "class",
      "signature": "()",
      "description": "A class used to check the whether the actual output from a doctest\nexample matches the expected output.  `OutputChecker` defines two\nmethods: `check_output`, which compares a given pair of outputs,\nand returns true if they match; and `output_difference`, which\nreturns a string describing the differences between two outputs.",
      "relationships": []
    },
    {
      "id": "stdlib.doctest.SkipDocTestCase",
      "name": "SkipDocTestCase",
      "module": "doctest",
      "type": "class",
      "signature": "(module)",
      "description": "A class whose instances are single test cases.\n\nBy default, the test code itself should be placed in a method named\n'runTest'.\n\nIf the fixture may be used for many test cases, create as\nmany test methods as are needed. When instantiating such a TestCase\nsubclass, specify in the constructor arguments the name of the test method\nthat the instance is to execute.\n\nTest authors should subclass TestCase for their own tests. Construction\nand deconstruction of the test's environment ('fixture') can be\nimplemented by overriding the 'setUp' and 'tearDown' methods respectively.\n\nIf it is necessary to override the __init__ method, the base class\n__init__ method must always be called. It is important that subclasses\nshould not change the signature of their __init__ method, since instances\nof the classes are instantiated automatically by parts of the framework\nin order to be run.\n\nWhen subclassing TestCase, you can set these attributes:\n* failureException: determines which exception will be raised when\n    the instance's assertion methods fail; test methods raising this\n    exception will be deemed to have 'failed' rather than 'errored'.\n* longMessage: determines whether long messages (including repr of\n    objects used in assert methods) will be printed on failure in *addition*\n    to any explicit message passed.\n* maxDiff: sets the maximum length of a diff in failure messages\n    by assert methods using difflib. It is looked up as an instance\n    attribute so can be configured by individual tests if required.",
      "relationships": [
        {
          "target": "DocTestCase",
          "type": "base_class"
        },
        {
          "target": "TestCase",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.doctest.StringIO",
      "name": "StringIO",
      "module": "doctest",
      "type": "class",
      "signature": "(initial_value='', newline='\\n')",
      "description": "Text I/O implementation using an in-memory buffer.\n\nThe initial_value argument sets the value of object.  The newline\nargument is like the one of TextIOWrapper's constructor.",
      "relationships": [
        {
          "target": "_TextIOBase",
          "type": "base_class"
        },
        {
          "target": "_IOBase",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.doctest.TestResults",
      "name": "TestResults",
      "module": "doctest",
      "type": "class",
      "signature": "(failed, attempted)",
      "description": "TestResults(failed, attempted)",
      "relationships": [
        {
          "target": "tuple",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.doctest.UnexpectedException",
      "name": "UnexpectedException",
      "module": "doctest",
      "type": "class",
      "signature": "(test, example, exc_info)",
      "description": "A DocTest example has encountered an unexpected exception\n\nThe exception instance has variables:\n\n- test: the DocTest object being run\n\n- example: the Example object that failed\n\n- exc_info: the exception info",
      "relationships": [
        {
          "target": "Exception",
          "type": "base_class"
        },
        {
          "target": "BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.doctest.debug",
      "name": "debug",
      "module": "doctest",
      "type": "function",
      "signature": "(module, name, pm=False)",
      "description": "Debug a single doctest docstring.\n\nProvide the module (or dotted name of the module) containing the\ntest to be debugged and the name (within the module) of the object\nwith the docstring with tests to be debugged.",
      "relationships": [
        {
          "target": "stdlib.doctest._normalize_module",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.testsource",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.debug_script",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.doctest.debug_script",
      "name": "debug_script",
      "module": "doctest",
      "type": "function",
      "signature": "(src, pm=False, globs=None)",
      "description": "Debug a test script.  `src` is the script, as a string.",
      "relationships": [
        {
          "target": "stdlib.doctest.copy",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.run",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.exec",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.print",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.Pdb",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.reset",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.interaction",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.Pdb",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.exc_info",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.exc_info",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.doctest.debug_src",
      "name": "debug_src",
      "module": "doctest",
      "type": "function",
      "signature": "(src, pm=False, globs=None)",
      "description": "Debug a single doctest docstring, in argument `src`'",
      "relationships": [
        {
          "target": "stdlib.doctest.script_from_examples",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.debug_script",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.doctest.namedtuple",
      "name": "namedtuple",
      "module": "doctest",
      "type": "function",
      "signature": "(typename, field_names, *, rename=False, defaults=None, module=None)",
      "description": "Returns a new subclass of tuple with named fields.\n\n>>> Point = namedtuple('Point', ['x', 'y'])\n>>> Point.__doc__                   # docstring for the new class\n'Point(x, y)'\n>>> p = Point(11, y=22)             # instantiate with positional args or keywords\n>>> p[0] + p[1]                     # indexable like a plain tuple\n33\n>>> x, y = p                        # unpack like a regular tuple\n>>> x, y\n(11, 22)\n>>> p.x + p.y                       # fields also accessible by name\n33\n>>> d = p._asdict()                 # convert to a dictionary\n>>> d['x']\n11\n>>> Point(**d)                      # convert from a dictionary\nPoint(x=11, y=22)\n>>> p._replace(x=100)               # _replace() is like str.replace() but targets named fields\nPoint(x=100, y=22)",
      "relationships": [
        {
          "target": "stdlib.doctest.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.list",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.intern",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.set",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.tuple",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.len",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.join",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.eval",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.enumerate",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.type",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.split",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.map",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.str",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.set",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.enumerate",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest._iskeyword",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.add",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.tuple",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.dict",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.map",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.tuple_new",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest._make",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest._dict",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest._tuple",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.intern",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest._tuplegetter",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.add",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.type",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.isidentifier",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.startswith",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.len",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.len",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.reversed",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.join",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest._len",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest._map",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest._zip",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.get",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.replace",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest._iskeyword",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.startswith",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.list",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.isidentifier",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.zip",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.reversed",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.reversed",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.len",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.list",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest._getframe",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.doctest.register_optionflag",
      "name": "register_optionflag",
      "module": "doctest",
      "type": "function",
      "signature": "(name)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.doctest.setdefault",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.len",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.doctest.run_docstring_examples",
      "name": "run_docstring_examples",
      "module": "doctest",
      "type": "function",
      "signature": "(f, globs, verbose=False, name='NoName', compileflags=None, optionflags=0)",
      "description": "Test examples in the given object's docstring (`f`), using `globs`\nas globals.  Optional argument `name` is used in failure messages.\nIf the optional argument `verbose` is true, then generate output\neven if there are no failures.\n\n`compileflags` gives the set of flags that should be used by the\nPython compiler when running the examples.  If not specified, then\nit will default to the set of future-import flags that apply to\n`globs`.\n\nOptional keyword arg `optionflags` specifies options for the\ntesting and output.  See the documentation for `testmod` for more\ninformation.",
      "relationships": [
        {
          "target": "stdlib.doctest.DocTestFinder",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.DocTestRunner",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.find",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.run",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.doctest.script_from_examples",
      "name": "script_from_examples",
      "module": "doctest",
      "type": "function",
      "signature": "(s)",
      "description": "Extract script from text with examples.\n\nConverts text with examples to a Python script.  Example input is\nconverted to regular code.  Example output and all other words\nare converted to comments:\n\n>>> text = '''\n...       Here are examples of simple math.\n...\n...           Python has super accurate integer addition\n...\n...           >>> 2 + 2\n...           5\n...\n...           And very friendly error messages:\n...\n...           >>> 1/0\n...           To Infinity\n...           And\n...           Beyond\n...\n...           You can use logic if you want:\n...\n...           >>> if 0:\n...           ...    blah\n...           ...    blah\n...           ...\n...\n...           Ho hum\n...           '''\n\n>>> print(script_from_examples(text))\n# Here are examples of simple math.\n#\n#     Python has super accurate integer addition\n#\n2 + 2\n# Expected:\n## 5\n#\n#     And very friendly error messages:\n#\n1/0\n# Expected:\n## To Infinity\n## And\n## Beyond\n#\n#     You can use logic if you want:\n#\nif 0:\n   blah\n   blah\n#\n#     Ho hum\n<BLANKLINE>",
      "relationships": [
        {
          "target": "stdlib.doctest.parse",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.pop",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.pop",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.join",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.DocTestParser",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.append",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.append",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest._comment_line",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.split",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.split",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.doctest.set_unittest_reportflags",
      "name": "set_unittest_reportflags",
      "module": "doctest",
      "type": "function",
      "signature": "(flags)",
      "description": "Sets the unittest option flags.\n\nThe old flag is returned so that a runner could restore the old\nvalue if it wished to:\n\n  >>> import doctest\n  >>> old = doctest._unittest_reportflags\n  >>> doctest.set_unittest_reportflags(REPORT_NDIFF |\n  ...                          REPORT_ONLY_FIRST_FAILURE) == old\n  True\n\n  >>> doctest._unittest_reportflags == (REPORT_NDIFF |\n  ...                                   REPORT_ONLY_FIRST_FAILURE)\n  True\n\nOnly reporting flags can be set:\n\n  >>> doctest.set_unittest_reportflags(ELLIPSIS)\n  Traceback (most recent call last):\n  ...\n  ValueError: ('Only reporting flags allowed', 8)\n\n  >>> doctest.set_unittest_reportflags(old) == (REPORT_NDIFF |\n  ...                                   REPORT_ONLY_FIRST_FAILURE)\n  True",
      "relationships": [
        {
          "target": "stdlib.doctest.ValueError",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.doctest.testfile",
      "name": "testfile",
      "module": "doctest",
      "type": "function",
      "signature": "(filename, module_relative=True, name=None, package=None, globs=None, verbose=None, report=True, optionflags=0, extraglobs=None, raise_on_error=False, parser=<doctest.DocTestParser object at 0x108ba40a0>, encoding=None)",
      "description": "Test examples in the given file.  Return (#failures, #tests).\n\nOptional keyword arg \"module_relative\" specifies how filenames\nshould be interpreted:\n\n  - If \"module_relative\" is True (the default), then \"filename\"\n     specifies a module-relative path.  By default, this path is\n     relative to the calling module's directory; but if the\n     \"package\" argument is specified, then it is relative to that\n     package.  To ensure os-independence, \"filename\" should use\n     \"/\" characters to separate path segments, and should not\n     be an absolute path (i.e., it may not begin with \"/\").\n\n  - If \"module_relative\" is False, then \"filename\" specifies an\n    os-specific path.  The path may be absolute or relative (to\n    the current working directory).\n\nOptional keyword arg \"name\" gives the name of the test; by default\nuse the file's basename.\n\nOptional keyword argument \"package\" is a Python package or the\nname of a Python package whose directory should be used as the\nbase directory for a module relative filename.  If no package is\nspecified, then the calling module's directory is used as the base\ndirectory for module relative filenames.  It is an error to\nspecify \"package\" if \"module_relative\" is False.\n\nOptional keyword arg \"globs\" gives a dict to be used as the globals\nwhen executing examples; by default, use {}.  A copy of this dict\nis actually used for each docstring, so that each docstring's\nexamples start with a clean slate.\n\nOptional keyword arg \"extraglobs\" gives a dictionary that should be\nmerged into the globals that are used to execute examples.  By\ndefault, no extra globals are used.\n\nOptional keyword arg \"verbose\" prints lots of stuff if true, prints\nonly failures if false; by default, it's true iff \"-v\" is in sys.argv.\n\nOptional keyword arg \"report\" prints a summary at the end when true,\nelse prints nothing at the end.  In verbose mode, the summary is\ndetailed, else very brief (in fact, empty if all tests passed).\n\nOptional keyword arg \"optionflags\" or's together module constants,\nand defaults to 0.  Possible values (see the docs for details):\n\n    DONT_ACCEPT_TRUE_FOR_1\n    DONT_ACCEPT_BLANKLINE\n    NORMALIZE_WHITESPACE\n    ELLIPSIS\n    SKIP\n    IGNORE_EXCEPTION_DETAIL\n    REPORT_UDIFF\n    REPORT_CDIFF\n    REPORT_NDIFF\n    REPORT_ONLY_FIRST_FAILURE\n\nOptional keyword arg \"raise_on_error\" raises an exception on the\nfirst unexpected exception or failure. This allows failures to be\npost-mortem debugged.\n\nOptional keyword arg \"parser\" specifies a DocTestParser (or\nsubclass) that should be used to extract tests from the files.\n\nOptional keyword arg \"encoding\" specifies an encoding that should\nbe used to convert the file to unicode.\n\nAdvanced tomfoolery:  testmod runs methods of a local instance of\nclass doctest.Tester, then merges the results into (or creates)\nglobal Tester instance doctest.master.  Methods of doctest.master\ncan be called directly too, if you want to do something unusual.\nPassing report=0 to testmod is especially useful then, to delay\ndisplaying a summary.  Invoke doctest.master.summarize(verbose)\nwhen you're done fiddling.",
      "relationships": [
        {
          "target": "stdlib.doctest.DocTestParser",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest._load_testfile",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.get_doctest",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.run",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.TestResults",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.basename",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.copy",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.update",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.DebugRunner",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.DocTestRunner",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.summarize",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.merge",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.doctest.testmod",
      "name": "testmod",
      "module": "doctest",
      "type": "function",
      "signature": "(m=None, name=None, globs=None, verbose=None, report=True, optionflags=0, extraglobs=None, raise_on_error=False, exclude_empty=False)",
      "description": "m=None, name=None, globs=None, verbose=None, report=True,\n   optionflags=0, extraglobs=None, raise_on_error=False,\n   exclude_empty=False\n\nTest examples in docstrings in functions and classes reachable\nfrom module m (or the current module if m is not supplied), starting\nwith m.__doc__.\n\nAlso test examples reachable from dict m.__test__ if it exists and is\nnot None.  m.__test__ maps names to functions, classes and strings;\nfunction and class docstrings are tested even if the name is private;\nstrings are tested directly, as if they were docstrings.\n\nReturn (#failures, #tests).\n\nSee help(doctest) for an overview.\n\nOptional keyword arg \"name\" gives the name of the module; by default\nuse m.__name__.\n\nOptional keyword arg \"globs\" gives a dict to be used as the globals\nwhen executing examples; by default, use m.__dict__.  A copy of this\ndict is actually used for each docstring, so that each docstring's\nexamples start with a clean slate.\n\nOptional keyword arg \"extraglobs\" gives a dictionary that should be\nmerged into the globals that are used to execute examples.  By\ndefault, no extra globals are used.  This is new in 2.4.\n\nOptional keyword arg \"verbose\" prints lots of stuff if true, prints\nonly failures if false; by default, it's true iff \"-v\" is in sys.argv.\n\nOptional keyword arg \"report\" prints a summary at the end when true,\nelse prints nothing at the end.  In verbose mode, the summary is\ndetailed, else very brief (in fact, empty if all tests passed).\n\nOptional keyword arg \"optionflags\" or's together module constants,\nand defaults to 0.  This is new in 2.3.  Possible values (see the\ndocs for details):\n\n    DONT_ACCEPT_TRUE_FOR_1\n    DONT_ACCEPT_BLANKLINE\n    NORMALIZE_WHITESPACE\n    ELLIPSIS\n    SKIP\n    IGNORE_EXCEPTION_DETAIL\n    REPORT_UDIFF\n    REPORT_CDIFF\n    REPORT_NDIFF\n    REPORT_ONLY_FIRST_FAILURE\n\nOptional keyword arg \"raise_on_error\" raises an exception on the\nfirst unexpected exception or failure. This allows failures to be\npost-mortem debugged.\n\nAdvanced tomfoolery:  testmod runs methods of a local instance of\nclass doctest.Tester, then merges the results into (or creates)\nglobal Tester instance doctest.master.  Methods of doctest.master\ncan be called directly too, if you want to do something unusual.\nPassing report=0 to testmod is especially useful then, to delay\ndisplaying a summary.  Invoke doctest.master.summarize(verbose)\nwhen you're done fiddling.",
      "relationships": [
        {
          "target": "stdlib.doctest.DocTestFinder",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.find",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.TestResults",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.get",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.ismodule",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.DebugRunner",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.DocTestRunner",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.run",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.summarize",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.merge",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.doctest.testsource",
      "name": "testsource",
      "module": "doctest",
      "type": "function",
      "signature": "(module, name)",
      "description": "Extract the test sources from a doctest docstring as a script.\n\nProvide the module (or dotted name of the module) containing the\ntest to be debugged and the name (within the module) of the object\nwith the doc string with tests to be debugged.",
      "relationships": [
        {
          "target": "stdlib.doctest._normalize_module",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.find",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.script_from_examples",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.doctest.DocTestFinder",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.email.message_from_binary_file",
      "name": "message_from_binary_file",
      "module": "email",
      "type": "function",
      "signature": "(fp, *args, **kws)",
      "description": "Read a binary file and parse its contents into a Message object model.\n\nOptional _class and strict are passed to the Parser constructor.",
      "relationships": [
        {
          "target": "stdlib.email.parse",
          "type": "calls"
        },
        {
          "target": "stdlib.email.BytesParser",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.email.message_from_bytes",
      "name": "message_from_bytes",
      "module": "email",
      "type": "function",
      "signature": "(s, *args, **kws)",
      "description": "Parse a bytes string into a Message object model.\n\nOptional _class and strict are passed to the Parser constructor.",
      "relationships": [
        {
          "target": "stdlib.email.parsebytes",
          "type": "calls"
        },
        {
          "target": "stdlib.email.BytesParser",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.email.message_from_file",
      "name": "message_from_file",
      "module": "email",
      "type": "function",
      "signature": "(fp, *args, **kws)",
      "description": "Read a file and parse its contents into a Message object model.\n\nOptional _class and strict are passed to the Parser constructor.",
      "relationships": [
        {
          "target": "stdlib.email.parse",
          "type": "calls"
        },
        {
          "target": "stdlib.email.Parser",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.email.message_from_string",
      "name": "message_from_string",
      "module": "email",
      "type": "function",
      "signature": "(s, *args, **kws)",
      "description": "Parse a string into a Message object model.\n\nOptional _class and strict are passed to the Parser constructor.",
      "relationships": [
        {
          "target": "stdlib.email.parsestr",
          "type": "calls"
        },
        {
          "target": "stdlib.email.Parser",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.encodings.normalize_encoding",
      "name": "normalize_encoding",
      "module": "encodings",
      "type": "function",
      "signature": "(encoding)",
      "description": "Normalize an encoding name.\n\nNormalization works as follows: all non-alphanumeric\ncharacters except the dot used for Python package names are\ncollapsed and replaced with a single underscore, e.g. '  -;#'\nbecomes '_'. Leading and trailing underscores are removed.\n\nNote that encoding names should be ASCII only.",
      "relationships": [
        {
          "target": "stdlib.encodings.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.encodings.join",
          "type": "calls"
        },
        {
          "target": "stdlib.encodings.str",
          "type": "calls"
        },
        {
          "target": "stdlib.encodings.isalnum",
          "type": "calls"
        },
        {
          "target": "stdlib.encodings.append",
          "type": "calls"
        },
        {
          "target": "stdlib.encodings.append",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.encodings.search_function",
      "name": "search_function",
      "module": "encodings",
      "type": "function",
      "signature": "(encoding)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.encodings.get",
          "type": "calls"
        },
        {
          "target": "stdlib.encodings.normalize_encoding",
          "type": "calls"
        },
        {
          "target": "stdlib.encodings.getregentry",
          "type": "calls"
        },
        {
          "target": "stdlib.encodings.get",
          "type": "calls"
        },
        {
          "target": "stdlib.encodings.get",
          "type": "calls"
        },
        {
          "target": "stdlib.encodings.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.encodings.CodecInfo",
          "type": "calls"
        },
        {
          "target": "stdlib.encodings.getaliases",
          "type": "calls"
        },
        {
          "target": "stdlib.encodings.replace",
          "type": "calls"
        },
        {
          "target": "stdlib.encodings.__import__",
          "type": "calls"
        },
        {
          "target": "stdlib.encodings.CodecRegistryError",
          "type": "calls"
        },
        {
          "target": "stdlib.encodings.CodecRegistryError",
          "type": "calls"
        },
        {
          "target": "stdlib.encodings.len",
          "type": "calls"
        },
        {
          "target": "stdlib.encodings.callable",
          "type": "calls"
        },
        {
          "target": "stdlib.encodings.callable",
          "type": "calls"
        },
        {
          "target": "stdlib.encodings.len",
          "type": "calls"
        },
        {
          "target": "stdlib.encodings.callable",
          "type": "calls"
        },
        {
          "target": "stdlib.encodings.callable",
          "type": "calls"
        },
        {
          "target": "stdlib.encodings.len",
          "type": "calls"
        },
        {
          "target": "stdlib.encodings.callable",
          "type": "calls"
        },
        {
          "target": "stdlib.encodings.len",
          "type": "calls"
        },
        {
          "target": "stdlib.encodings.callable",
          "type": "calls"
        },
        {
          "target": "stdlib.encodings.len",
          "type": "calls"
        },
        {
          "target": "stdlib.encodings.split",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ensurepip.bootstrap",
      "name": "bootstrap",
      "module": "ensurepip",
      "type": "function",
      "signature": "(*, root=None, upgrade=False, user=False, altinstall=False, default_pip=False, verbosity=0)",
      "description": "Bootstrap pip into the current Python installation (or the given root\ndirectory).\n\nNote that calling this function will alter both sys.path and os.environ.",
      "relationships": [
        {
          "target": "stdlib.ensurepip._bootstrap",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ensurepip.version",
      "name": "version",
      "module": "ensurepip",
      "type": "function",
      "signature": "()",
      "description": "Returns a string specifying the bundled version of pip.",
      "relationships": []
    },
    {
      "id": "stdlib.enum.DynamicClassAttribute",
      "name": "DynamicClassAttribute",
      "module": "enum",
      "type": "class",
      "signature": "(fget=None, fset=None, fdel=None, doc=None)",
      "description": "Route attribute access on a class to __getattr__.\n\nThis is a descriptor, used to define attributes that act differently when\naccessed through an instance and through a class.  Instance access remains\nnormal, but access to an attribute through a class will be routed to the\nclass's __getattr__ method; this is done by raising AttributeError.\n\nThis allows one to have properties active on an instance, and have virtual\nattributes on the class with the same name (see Enum for an example).",
      "relationships": []
    },
    {
      "id": "stdlib.enum.Enum",
      "name": "Enum",
      "module": "enum",
      "type": "class",
      "signature": "(value, names=None, *, module=None, qualname=None, type=None, start=1)",
      "description": "Generic enumeration.\n\nDerive from this class to define new enumerations.",
      "relationships": []
    },
    {
      "id": "stdlib.enum.EnumMeta",
      "name": "EnumMeta",
      "module": "enum",
      "type": "class",
      "signature": "(cls, bases, classdict, **kwds)",
      "description": "Metaclass for Enum",
      "relationships": [
        {
          "target": "type",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.enum.Flag",
      "name": "Flag",
      "module": "enum",
      "type": "class",
      "signature": "(value, names=None, *, module=None, qualname=None, type=None, start=1)",
      "description": "Support for flags",
      "relationships": [
        {
          "target": "Enum",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.enum.IntEnum",
      "name": "IntEnum",
      "module": "enum",
      "type": "class",
      "signature": "(value, names=None, *, module=None, qualname=None, type=None, start=1)",
      "description": "Enum where members are also (and must be) ints",
      "relationships": [
        {
          "target": "int",
          "type": "base_class"
        },
        {
          "target": "Enum",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.enum.IntFlag",
      "name": "IntFlag",
      "module": "enum",
      "type": "class",
      "signature": "(value, names=None, *, module=None, qualname=None, type=None, start=1)",
      "description": "Support for integer-based Flags",
      "relationships": [
        {
          "target": "int",
          "type": "base_class"
        },
        {
          "target": "Flag",
          "type": "base_class"
        },
        {
          "target": "Enum",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.enum.auto",
      "name": "auto",
      "module": "enum",
      "type": "class",
      "signature": "()",
      "description": "Instances are replaced with an appropriate value in Enum class suites.",
      "relationships": []
    },
    {
      "id": "stdlib.enum.unique",
      "name": "unique",
      "module": "enum",
      "type": "function",
      "signature": "(enumeration)",
      "description": "Class decorator for enumerations ensuring unique member values.",
      "relationships": [
        {
          "target": "stdlib.enum.items",
          "type": "calls"
        },
        {
          "target": "stdlib.enum.join",
          "type": "calls"
        },
        {
          "target": "stdlib.enum.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.enum.append",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.filecmp.clear_cache",
      "name": "clear_cache",
      "module": "filecmp",
      "type": "function",
      "signature": "()",
      "description": "Clear the filecmp cache.",
      "relationships": [
        {
          "target": "stdlib.filecmp.clear",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.filecmp.cmp",
      "name": "cmp",
      "module": "filecmp",
      "type": "function",
      "signature": "(f1, f2, shallow=True)",
      "description": "Compare two files.\n\nArguments:\n\nf1 -- First file name\n\nf2 -- Second file name\n\nshallow -- Just check stat signature (do not read the files).\n           defaults to True.\n\nReturn value:\n\nTrue if the files are the same, False otherwise.\n\nThis function uses a cache for past comparisons and the results,\nwith cache entries invalidated if their stat information\nchanges.  The cache may be cleared by calling clear_cache().",
      "relationships": [
        {
          "target": "stdlib.filecmp._sig",
          "type": "calls"
        },
        {
          "target": "stdlib.filecmp._sig",
          "type": "calls"
        },
        {
          "target": "stdlib.filecmp.get",
          "type": "calls"
        },
        {
          "target": "stdlib.filecmp.stat",
          "type": "calls"
        },
        {
          "target": "stdlib.filecmp.stat",
          "type": "calls"
        },
        {
          "target": "stdlib.filecmp._do_cmp",
          "type": "calls"
        },
        {
          "target": "stdlib.filecmp.len",
          "type": "calls"
        },
        {
          "target": "stdlib.filecmp.clear_cache",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.filecmp.cmpfiles",
      "name": "cmpfiles",
      "module": "filecmp",
      "type": "function",
      "signature": "(a, b, common, shallow=True)",
      "description": "Compare common files in two directories.\n\na, b -- directory names\ncommon -- list of file names found in both directories\nshallow -- if true, do comparison based solely on stat() information\n\nReturns a tuple of three lists:\n  files that compare equal\n  files that are different\n  filenames that aren't regular files.",
      "relationships": [
        {
          "target": "stdlib.filecmp.join",
          "type": "calls"
        },
        {
          "target": "stdlib.filecmp.join",
          "type": "calls"
        },
        {
          "target": "stdlib.filecmp.append",
          "type": "calls"
        },
        {
          "target": "stdlib.filecmp._cmp",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.filecmp.demo",
      "name": "demo",
      "module": "filecmp",
      "type": "function",
      "signature": "()",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.filecmp.getopt",
          "type": "calls"
        },
        {
          "target": "stdlib.filecmp.dircmp",
          "type": "calls"
        },
        {
          "target": "stdlib.filecmp.len",
          "type": "calls"
        },
        {
          "target": "stdlib.filecmp.GetoptError",
          "type": "calls"
        },
        {
          "target": "stdlib.filecmp.report_full_closure",
          "type": "calls"
        },
        {
          "target": "stdlib.filecmp.report",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.filecmp.dircmp",
      "name": "dircmp",
      "module": "filecmp",
      "type": "class",
      "signature": "(a, b, ignore=None, hide=None)",
      "description": "A class that manages the comparison of 2 directories.\n\ndircmp(a, b, ignore=None, hide=None)\n  A and B are directories.\n  IGNORE is a list of names to ignore,\n    defaults to DEFAULT_IGNORES.\n  HIDE is a list of names to hide,\n    defaults to [os.curdir, os.pardir].\n\nHigh level usage:\n  x = dircmp(dir1, dir2)\n  x.report() -> prints a report on the differences between dir1 and dir2\n   or\n  x.report_partial_closure() -> prints report on differences between dir1\n        and dir2, and reports on common immediate subdirectories.\n  x.report_full_closure() -> like report_partial_closure,\n        but fully recursive.\n\nAttributes:\n left_list, right_list: The files in dir1 and dir2,\n    filtered by hide and ignore.\n common: a list of names in both dir1 and dir2.\n left_only, right_only: names only in dir1, dir2.\n common_dirs: subdirectories in both dir1 and dir2.\n common_files: files in both dir1 and dir2.\n common_funny: names in both dir1 and dir2 where the type differs between\n    dir1 and dir2, or the name is not stat-able.\n same_files: list of identical files.\n diff_files: list of filenames which differ.\n funny_files: list of files which could not be compared.\n subdirs: a dictionary of dircmp objects, keyed by names in common_dirs.\n ",
      "relationships": []
    },
    {
      "id": "stdlib.filecmp.filterfalse",
      "name": "filterfalse",
      "module": "filecmp",
      "type": "class",
      "signature": "(function, iterable, /)",
      "description": "Return those items of iterable for which function(item) is false.\n\nIf function is None, return the items that are false.",
      "relationships": []
    },
    {
      "id": "stdlib.fileinput.FileInput",
      "name": "FileInput",
      "module": "fileinput",
      "type": "class",
      "signature": "(files=None, inplace=False, backup='', *, mode='r', openhook=None)",
      "description": "FileInput([files[, inplace[, backup]]], *, mode=None, openhook=None)\n\nClass FileInput is the implementation of the module; its methods\nfilename(), lineno(), fileline(), isfirstline(), isstdin(), fileno(),\nnextfile() and close() correspond to the functions of the same name\nin the module.\nIn addition it has a readline() method which returns the next\ninput line, and a __getitem__() method which implements the\nsequence behavior. The sequence must be accessed in strictly\nsequential order; random access and readline() cannot be mixed.",
      "relationships": []
    },
    {
      "id": "stdlib.fileinput.close",
      "name": "close",
      "module": "fileinput",
      "type": "function",
      "signature": "()",
      "description": "Close the sequence.",
      "relationships": [
        {
          "target": "stdlib.fileinput.close",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.fileinput.filelineno",
      "name": "filelineno",
      "module": "fileinput",
      "type": "function",
      "signature": "()",
      "description": "Return the line number in the current file. Before the first line\nhas been read, returns 0. After the last line of the last file has\nbeen read, returns the line number of that line within the file.",
      "relationships": [
        {
          "target": "stdlib.fileinput.filelineno",
          "type": "calls"
        },
        {
          "target": "stdlib.fileinput.RuntimeError",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.fileinput.filename",
      "name": "filename",
      "module": "fileinput",
      "type": "function",
      "signature": "()",
      "description": "Return the name of the file currently being read.\nBefore the first line has been read, returns None.",
      "relationships": [
        {
          "target": "stdlib.fileinput.filename",
          "type": "calls"
        },
        {
          "target": "stdlib.fileinput.RuntimeError",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.fileinput.fileno",
      "name": "fileno",
      "module": "fileinput",
      "type": "function",
      "signature": "()",
      "description": "Return the file number of the current file. When no file is currently\nopened, returns -1.",
      "relationships": [
        {
          "target": "stdlib.fileinput.fileno",
          "type": "calls"
        },
        {
          "target": "stdlib.fileinput.RuntimeError",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.fileinput.hook_compressed",
      "name": "hook_compressed",
      "module": "fileinput",
      "type": "function",
      "signature": "(filename, mode)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.fileinput.splitext",
          "type": "calls"
        },
        {
          "target": "stdlib.fileinput.open",
          "type": "calls"
        },
        {
          "target": "stdlib.fileinput.BZ2File",
          "type": "calls"
        },
        {
          "target": "stdlib.fileinput.open",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.fileinput.hook_encoded",
      "name": "hook_encoded",
      "module": "fileinput",
      "type": "function",
      "signature": "(encoding, errors=None)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.fileinput.open",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.fileinput.input",
      "name": "input",
      "module": "fileinput",
      "type": "function",
      "signature": "(files=None, inplace=False, backup='', *, mode='r', openhook=None)",
      "description": "Return an instance of the FileInput class, which can be iterated.\n\nThe parameters are passed to the constructor of the FileInput class.\nThe returned instance, in addition to being an iterator,\nkeeps global state for the functions of this module,.",
      "relationships": [
        {
          "target": "stdlib.fileinput.FileInput",
          "type": "calls"
        },
        {
          "target": "stdlib.fileinput.RuntimeError",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.fileinput.isfirstline",
      "name": "isfirstline",
      "module": "fileinput",
      "type": "function",
      "signature": "()",
      "description": "Returns true the line just read is the first line of its file,\notherwise returns false.",
      "relationships": [
        {
          "target": "stdlib.fileinput.isfirstline",
          "type": "calls"
        },
        {
          "target": "stdlib.fileinput.RuntimeError",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.fileinput.isstdin",
      "name": "isstdin",
      "module": "fileinput",
      "type": "function",
      "signature": "()",
      "description": "Returns true if the last line was read from sys.stdin,\notherwise returns false.",
      "relationships": [
        {
          "target": "stdlib.fileinput.isstdin",
          "type": "calls"
        },
        {
          "target": "stdlib.fileinput.RuntimeError",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.fileinput.lineno",
      "name": "lineno",
      "module": "fileinput",
      "type": "function",
      "signature": "()",
      "description": "Return the cumulative line number of the line that has just been read.\nBefore the first line has been read, returns 0. After the last line\nof the last file has been read, returns the line number of that line.",
      "relationships": [
        {
          "target": "stdlib.fileinput.lineno",
          "type": "calls"
        },
        {
          "target": "stdlib.fileinput.RuntimeError",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.fileinput.nextfile",
      "name": "nextfile",
      "module": "fileinput",
      "type": "function",
      "signature": "()",
      "description": "Close the current file so that the next iteration will read the first\nline from the next file (if any); lines not read from the file will\nnot count towards the cumulative line count. The filename is not\nchanged until after the first line of the next file has been read.\nBefore the first line has been read, this function has no effect;\nit cannot be used to skip the first file. After the last line of the\nlast file has been read, this function has no effect.",
      "relationships": [
        {
          "target": "stdlib.fileinput.nextfile",
          "type": "calls"
        },
        {
          "target": "stdlib.fileinput.RuntimeError",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.fnmatch.filter",
      "name": "filter",
      "module": "fnmatch",
      "type": "function",
      "signature": "(names, pat)",
      "description": "Construct a list from those elements of the iterable NAMES that match PAT.",
      "relationships": [
        {
          "target": "stdlib.fnmatch.normcase",
          "type": "calls"
        },
        {
          "target": "stdlib.fnmatch._compile_pattern",
          "type": "calls"
        },
        {
          "target": "stdlib.fnmatch.match",
          "type": "calls"
        },
        {
          "target": "stdlib.fnmatch.match",
          "type": "calls"
        },
        {
          "target": "stdlib.fnmatch.append",
          "type": "calls"
        },
        {
          "target": "stdlib.fnmatch.normcase",
          "type": "calls"
        },
        {
          "target": "stdlib.fnmatch.append",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.fnmatch.fnmatch",
      "name": "fnmatch",
      "module": "fnmatch",
      "type": "function",
      "signature": "(name, pat)",
      "description": "Test whether FILENAME matches PATTERN.\n\nPatterns are Unix shell style:\n\n*       matches everything\n?       matches any single character\n[seq]   matches any character in seq\n[!seq]  matches any char not in seq\n\nAn initial period in FILENAME is not special.\nBoth FILENAME and PATTERN are first case-normalized\nif the operating system requires it.\nIf you don't want this, use fnmatchcase(FILENAME, PATTERN).",
      "relationships": [
        {
          "target": "stdlib.fnmatch.normcase",
          "type": "calls"
        },
        {
          "target": "stdlib.fnmatch.normcase",
          "type": "calls"
        },
        {
          "target": "stdlib.fnmatch.fnmatchcase",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.fnmatch.fnmatchcase",
      "name": "fnmatchcase",
      "module": "fnmatch",
      "type": "function",
      "signature": "(name, pat)",
      "description": "Test whether FILENAME matches PATTERN, including case.\n\nThis is a version of fnmatch() which doesn't case-normalize\nits arguments.",
      "relationships": [
        {
          "target": "stdlib.fnmatch._compile_pattern",
          "type": "calls"
        },
        {
          "target": "stdlib.fnmatch.match",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.fnmatch.translate",
      "name": "translate",
      "module": "fnmatch",
      "type": "function",
      "signature": "(pat)",
      "description": "Translate a shell PATTERN to a regular expression.\n\nThere is no way to quote meta-characters.",
      "relationships": [
        {
          "target": "stdlib.fnmatch.object",
          "type": "calls"
        },
        {
          "target": "stdlib.fnmatch.join",
          "type": "calls"
        },
        {
          "target": "stdlib.fnmatch.len",
          "type": "calls"
        },
        {
          "target": "stdlib.fnmatch.len",
          "type": "calls"
        },
        {
          "target": "stdlib.fnmatch.add",
          "type": "calls"
        },
        {
          "target": "stdlib.fnmatch.join",
          "type": "calls"
        },
        {
          "target": "stdlib.fnmatch.add",
          "type": "calls"
        },
        {
          "target": "stdlib.fnmatch.append",
          "type": "calls"
        },
        {
          "target": "stdlib.fnmatch.add",
          "type": "calls"
        },
        {
          "target": "stdlib.fnmatch.add",
          "type": "calls"
        },
        {
          "target": "stdlib.fnmatch._nextgroupnum",
          "type": "calls"
        },
        {
          "target": "stdlib.fnmatch.add",
          "type": "calls"
        },
        {
          "target": "stdlib.fnmatch.add",
          "type": "calls"
        },
        {
          "target": "stdlib.fnmatch.add",
          "type": "calls"
        },
        {
          "target": "stdlib.fnmatch.add",
          "type": "calls"
        },
        {
          "target": "stdlib.fnmatch.add",
          "type": "calls"
        },
        {
          "target": "stdlib.fnmatch.sub",
          "type": "calls"
        },
        {
          "target": "stdlib.fnmatch.add",
          "type": "calls"
        },
        {
          "target": "stdlib.fnmatch.escape",
          "type": "calls"
        },
        {
          "target": "stdlib.fnmatch.replace",
          "type": "calls"
        },
        {
          "target": "stdlib.fnmatch.append",
          "type": "calls"
        },
        {
          "target": "stdlib.fnmatch.join",
          "type": "calls"
        },
        {
          "target": "stdlib.fnmatch.find",
          "type": "calls"
        },
        {
          "target": "stdlib.fnmatch.append",
          "type": "calls"
        },
        {
          "target": "stdlib.fnmatch.replace",
          "type": "calls"
        },
        {
          "target": "stdlib.fnmatch.replace",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.formatter.AbstractFormatter",
      "name": "AbstractFormatter",
      "module": "formatter",
      "type": "class",
      "signature": "(writer)",
      "description": "The standard formatter.\n\nThis implementation has demonstrated wide applicability to many writers,\nand may be used directly in most circumstances.  It has been used to\nimplement a full-featured World Wide Web browser.",
      "relationships": []
    },
    {
      "id": "stdlib.formatter.AbstractWriter",
      "name": "AbstractWriter",
      "module": "formatter",
      "type": "class",
      "signature": "()",
      "description": "A writer which can be used in debugging formatters, but not much else.\n\nEach method simply announces itself by printing its name and\narguments on standard output.",
      "relationships": [
        {
          "target": "NullWriter",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.formatter.DumbWriter",
      "name": "DumbWriter",
      "module": "formatter",
      "type": "class",
      "signature": "(file=None, maxcol=72)",
      "description": "Simple writer class which writes output on the file object passed in\nas the file parameter or, if file is omitted, on standard output.  The\noutput is simply word-wrapped to the number of columns specified by\nthe maxcol parameter.  This class is suitable for reflowing a sequence\nof paragraphs.",
      "relationships": [
        {
          "target": "NullWriter",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.formatter.NullFormatter",
      "name": "NullFormatter",
      "module": "formatter",
      "type": "class",
      "signature": "(writer=None)",
      "description": "A formatter which does nothing.\n\nIf the writer parameter is omitted, a NullWriter instance is created.\nNo methods of the writer are called by NullFormatter instances.\n\nImplementations should inherit from this class if implementing a writer\ninterface but don't need to inherit any implementation.",
      "relationships": []
    },
    {
      "id": "stdlib.formatter.NullWriter",
      "name": "NullWriter",
      "module": "formatter",
      "type": "class",
      "signature": "()",
      "description": "Minimal writer interface to use in testing & inheritance.\n\nA writer which only provides the interface definition; no actions are\ntaken on any methods.  This should be the base class for all writers\nwhich do not need to inherit any implementation methods.",
      "relationships": []
    },
    {
      "id": "stdlib.formatter.test",
      "name": "test",
      "module": "formatter",
      "type": "function",
      "signature": "(file=None)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.formatter.DumbWriter",
          "type": "calls"
        },
        {
          "target": "stdlib.formatter.AbstractFormatter",
          "type": "calls"
        },
        {
          "target": "stdlib.formatter.end_paragraph",
          "type": "calls"
        },
        {
          "target": "stdlib.formatter.open",
          "type": "calls"
        },
        {
          "target": "stdlib.formatter.open",
          "type": "calls"
        },
        {
          "target": "stdlib.formatter.close",
          "type": "calls"
        },
        {
          "target": "stdlib.formatter.end_paragraph",
          "type": "calls"
        },
        {
          "target": "stdlib.formatter.add_flowing_data",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.fractions.Decimal",
      "name": "Decimal",
      "module": "fractions",
      "type": "class",
      "signature": "(value='0', context=None)",
      "description": "Construct a new Decimal object. 'value' can be an integer, string, tuple,\nor another Decimal object. If no value is given, return Decimal('0'). The\ncontext does not affect the conversion and is only passed to determine if\nthe InvalidOperation trap is active.",
      "relationships": []
    },
    {
      "id": "stdlib.fractions.Fraction",
      "name": "Fraction",
      "module": "fractions",
      "type": "class",
      "signature": "(numerator=0, denominator=None, *, _normalize=True)",
      "description": "This class implements rational numbers.\n\nIn the two-argument form of the constructor, Fraction(8, 6) will\nproduce a rational number equivalent to 4/3. Both arguments must\nbe Rational. The numerator defaults to 0 and the denominator\ndefaults to 1 so that Fraction(3) == 3 and Fraction() == 0.\n\nFractions can also be constructed from:\n\n  - numeric strings similar to those accepted by the\n    float constructor (for example, '-2.3' or '1e10')\n\n  - strings of the form '123/456'\n\n  - float and Decimal instances\n\n  - other Rational instances (including integers)",
      "relationships": [
        {
          "target": "Rational",
          "type": "base_class"
        },
        {
          "target": "Real",
          "type": "base_class"
        },
        {
          "target": "Complex",
          "type": "base_class"
        },
        {
          "target": "Number",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.ftplib.FTP",
      "name": "FTP",
      "module": "ftplib",
      "type": "class",
      "signature": "(host='', user='', passwd='', acct='', timeout=<object object at 0x102f70e60>, source_address=None, *, encoding='utf-8')",
      "description": "An FTP client class.\n\nTo create a connection, call the class using these arguments:\n        host, user, passwd, acct, timeout, source_address, encoding\n\nThe first four arguments are all strings, and have default value ''.\nThe parameter \u00b4timeout\u00b4 must be numeric and defaults to None if not\npassed, meaning that no timeout will be set on any ftp socket(s).\nIf a timeout is passed, then this is now the default timeout for all ftp\nsocket operations for this instance.\nThe last parameter is the encoding of filenames, which defaults to utf-8.\n\nThen use self.connect() with optional host and port argument.\n\nTo download a file, use ftp.retrlines('RETR ' + filename),\nor ftp.retrbinary() with slightly different arguments.\nTo upload a file, use ftp.storlines() or ftp.storbinary(),\nwhich have an open file as argument (see their definitions\nbelow for details).\nThe download/upload functions first issue appropriate TYPE\nand PORT or PASV commands.",
      "relationships": []
    },
    {
      "id": "stdlib.ftplib.FTP_TLS",
      "name": "FTP_TLS",
      "module": "ftplib",
      "type": "class",
      "signature": "(host='', user='', passwd='', acct='', keyfile=None, certfile=None, context=None, timeout=<object object at 0x102f70e60>, source_address=None, *, encoding='utf-8')",
      "description": "A FTP subclass which adds TLS support to FTP as described\nin RFC-4217.\n\nConnect as usual to port 21 implicitly securing the FTP control\nconnection before authenticating.\n\nSecuring the data connection requires user to explicitly ask\nfor it by calling prot_p() method.\n\nUsage example:\n>>> from ftplib import FTP_TLS\n>>> ftps = FTP_TLS('ftp.python.org')\n>>> ftps.login()  # login anonymously previously securing control channel\n'230 Guest login ok, access restrictions apply.'\n>>> ftps.prot_p()  # switch to secure data connection\n'200 Protection level set to P'\n>>> ftps.retrlines('LIST')  # list directory content securely\ntotal 9\ndrwxr-xr-x   8 root     wheel        1024 Jan  3  1994 .\ndrwxr-xr-x   8 root     wheel        1024 Jan  3  1994 ..\ndrwxr-xr-x   2 root     wheel        1024 Jan  3  1994 bin\ndrwxr-xr-x   2 root     wheel        1024 Jan  3  1994 etc\nd-wxrwxr-x   2 ftp      wheel        1024 Sep  5 13:43 incoming\ndrwxr-xr-x   2 root     wheel        1024 Nov 17  1993 lib\ndrwxr-xr-x   6 1094     wheel        1024 Sep 13 19:07 pub\ndrwxr-xr-x   3 root     wheel        1024 Jan  3  1994 usr\n-rw-r--r--   1 root     root          312 Aug  1  1994 welcome.msg\n'226 Transfer complete.'\n>>> ftps.quit()\n'221 Goodbye.'\n>>>",
      "relationships": [
        {
          "target": "FTP",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.ftplib.ftpcp",
      "name": "ftpcp",
      "module": "ftplib",
      "type": "function",
      "signature": "(source, sourcename, target, targetname='', type='I')",
      "description": "Copy file from one FTP-instance to another.",
      "relationships": [
        {
          "target": "stdlib.ftplib.voidcmd",
          "type": "calls"
        },
        {
          "target": "stdlib.ftplib.voidcmd",
          "type": "calls"
        },
        {
          "target": "stdlib.ftplib.parse227",
          "type": "calls"
        },
        {
          "target": "stdlib.ftplib.sendport",
          "type": "calls"
        },
        {
          "target": "stdlib.ftplib.sendcmd",
          "type": "calls"
        },
        {
          "target": "stdlib.ftplib.sendcmd",
          "type": "calls"
        },
        {
          "target": "stdlib.ftplib.voidresp",
          "type": "calls"
        },
        {
          "target": "stdlib.ftplib.voidresp",
          "type": "calls"
        },
        {
          "target": "stdlib.ftplib.sendcmd",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ftplib.parse150",
      "name": "parse150",
      "module": "ftplib",
      "type": "function",
      "signature": "(resp)",
      "description": "Parse the '150' response for a RETR request.\nReturns the expected transfer size or None; size is not guaranteed to\nbe present in the 150 message.",
      "relationships": [
        {
          "target": "stdlib.ftplib.match",
          "type": "calls"
        },
        {
          "target": "stdlib.ftplib.int",
          "type": "calls"
        },
        {
          "target": "stdlib.ftplib.error_reply",
          "type": "calls"
        },
        {
          "target": "stdlib.ftplib.compile",
          "type": "calls"
        },
        {
          "target": "stdlib.ftplib.group",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ftplib.parse227",
      "name": "parse227",
      "module": "ftplib",
      "type": "function",
      "signature": "(resp)",
      "description": "Parse the '227' response for a PASV request.\nRaises error_proto if it does not contain '(h1,h2,h3,h4,p1,p2)'\nReturn ('host.addr.as.numbers', port#) tuple.",
      "relationships": [
        {
          "target": "stdlib.ftplib.search",
          "type": "calls"
        },
        {
          "target": "stdlib.ftplib.groups",
          "type": "calls"
        },
        {
          "target": "stdlib.ftplib.join",
          "type": "calls"
        },
        {
          "target": "stdlib.ftplib.error_reply",
          "type": "calls"
        },
        {
          "target": "stdlib.ftplib.compile",
          "type": "calls"
        },
        {
          "target": "stdlib.ftplib.error_proto",
          "type": "calls"
        },
        {
          "target": "stdlib.ftplib.int",
          "type": "calls"
        },
        {
          "target": "stdlib.ftplib.int",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ftplib.parse229",
      "name": "parse229",
      "module": "ftplib",
      "type": "function",
      "signature": "(resp, peer)",
      "description": "Parse the '229' response for an EPSV request.\nRaises error_proto if it does not contain '(|||port|)'\nReturn ('host.addr.as.numbers', port#) tuple.",
      "relationships": [
        {
          "target": "stdlib.ftplib.find",
          "type": "calls"
        },
        {
          "target": "stdlib.ftplib.find",
          "type": "calls"
        },
        {
          "target": "stdlib.ftplib.split",
          "type": "calls"
        },
        {
          "target": "stdlib.ftplib.int",
          "type": "calls"
        },
        {
          "target": "stdlib.ftplib.error_reply",
          "type": "calls"
        },
        {
          "target": "stdlib.ftplib.error_proto",
          "type": "calls"
        },
        {
          "target": "stdlib.ftplib.error_proto",
          "type": "calls"
        },
        {
          "target": "stdlib.ftplib.error_proto",
          "type": "calls"
        },
        {
          "target": "stdlib.ftplib.len",
          "type": "calls"
        },
        {
          "target": "stdlib.ftplib.error_proto",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ftplib.parse257",
      "name": "parse257",
      "module": "ftplib",
      "type": "function",
      "signature": "(resp)",
      "description": "Parse the '257' response for a MKD or PWD request.\nThis is a response to a MKD or PWD request: a directory name.\nReturns the directoryname in the 257 reply.",
      "relationships": [
        {
          "target": "stdlib.ftplib.len",
          "type": "calls"
        },
        {
          "target": "stdlib.ftplib.error_reply",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ftplib.print_line",
      "name": "print_line",
      "module": "ftplib",
      "type": "function",
      "signature": "(line)",
      "description": "Default retrlines callback to print a line.",
      "relationships": [
        {
          "target": "stdlib.ftplib.print",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ftplib.test",
      "name": "test",
      "module": "ftplib",
      "type": "function",
      "signature": "()",
      "description": "Test program.\nUsage: ftp [-d] [-r[file]] host [-l[dir]] [-d[dir]] [-p] [file] ...\n\n-d dir\n-l list\n-p password",
      "relationships": [
        {
          "target": "stdlib.ftplib.FTP",
          "type": "calls"
        },
        {
          "target": "stdlib.ftplib.set_debuglevel",
          "type": "calls"
        },
        {
          "target": "stdlib.ftplib.login",
          "type": "calls"
        },
        {
          "target": "stdlib.ftplib.quit",
          "type": "calls"
        },
        {
          "target": "stdlib.ftplib.len",
          "type": "calls"
        },
        {
          "target": "stdlib.ftplib.print",
          "type": "calls"
        },
        {
          "target": "stdlib.ftplib.exit",
          "type": "calls"
        },
        {
          "target": "stdlib.ftplib.netrc",
          "type": "calls"
        },
        {
          "target": "stdlib.ftplib.authenticators",
          "type": "calls"
        },
        {
          "target": "stdlib.ftplib.dir",
          "type": "calls"
        },
        {
          "target": "stdlib.ftplib.write",
          "type": "calls"
        },
        {
          "target": "stdlib.ftplib.write",
          "type": "calls"
        },
        {
          "target": "stdlib.ftplib.sendcmd",
          "type": "calls"
        },
        {
          "target": "stdlib.ftplib.set_pasv",
          "type": "calls"
        },
        {
          "target": "stdlib.ftplib.retrbinary",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.functools.cache",
      "name": "cache",
      "module": "functools",
      "type": "function",
      "signature": "(user_function, /)",
      "description": "Simple lightweight unbounded cache.  Sometimes called \"memoize\".",
      "relationships": [
        {
          "target": "stdlib.functools.lru_cache",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.functools.cached_property",
      "name": "cached_property",
      "module": "functools",
      "type": "class",
      "signature": "(func)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.functools.lru_cache",
      "name": "lru_cache",
      "module": "functools",
      "type": "function",
      "signature": "(maxsize=128, typed=False)",
      "description": "Least-recently-used cache decorator.\n\nIf *maxsize* is set to None, the LRU features are disabled and the cache\ncan grow without bound.\n\nIf *typed* is True, arguments of different types will be cached separately.\nFor example, f(3.0) and f(3) will be treated as distinct calls with\ndistinct results.\n\nArguments to the cached function must be hashable.\n\nView the cache statistics named tuple (hits, misses, maxsize, currsize)\nwith f.cache_info().  Clear the cache and statistics with f.cache_clear().\nAccess the underlying function with f.__wrapped__.\n\nSee:  http://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU)",
      "relationships": [
        {
          "target": "stdlib.functools.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.functools._lru_cache_wrapper",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.update_wrapper",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.callable",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.functools._lru_cache_wrapper",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.update_wrapper",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.TypeError",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.functools.namedtuple",
      "name": "namedtuple",
      "module": "functools",
      "type": "function",
      "signature": "(typename, field_names, *, rename=False, defaults=None, module=None)",
      "description": "Returns a new subclass of tuple with named fields.\n\n>>> Point = namedtuple('Point', ['x', 'y'])\n>>> Point.__doc__                   # docstring for the new class\n'Point(x, y)'\n>>> p = Point(11, y=22)             # instantiate with positional args or keywords\n>>> p[0] + p[1]                     # indexable like a plain tuple\n33\n>>> x, y = p                        # unpack like a regular tuple\n>>> x, y\n(11, 22)\n>>> p.x + p.y                       # fields also accessible by name\n33\n>>> d = p._asdict()                 # convert to a dictionary\n>>> d['x']\n11\n>>> Point(**d)                      # convert from a dictionary\nPoint(x=11, y=22)\n>>> p._replace(x=100)               # _replace() is like str.replace() but targets named fields\nPoint(x=100, y=22)",
      "relationships": [
        {
          "target": "stdlib.functools.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.list",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.intern",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.set",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.tuple",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.len",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.join",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.eval",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.enumerate",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.type",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.split",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.map",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.str",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.set",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.enumerate",
          "type": "calls"
        },
        {
          "target": "stdlib.functools._iskeyword",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.add",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.tuple",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.dict",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.map",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.tuple_new",
          "type": "calls"
        },
        {
          "target": "stdlib.functools._make",
          "type": "calls"
        },
        {
          "target": "stdlib.functools._dict",
          "type": "calls"
        },
        {
          "target": "stdlib.functools._tuple",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.intern",
          "type": "calls"
        },
        {
          "target": "stdlib.functools._tuplegetter",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.add",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.type",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.isidentifier",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.startswith",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.len",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.len",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.reversed",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.join",
          "type": "calls"
        },
        {
          "target": "stdlib.functools._len",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.functools._map",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.functools._zip",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.get",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.replace",
          "type": "calls"
        },
        {
          "target": "stdlib.functools._iskeyword",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.startswith",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.list",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.isidentifier",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.zip",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.reversed",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.reversed",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.len",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.list",
          "type": "calls"
        },
        {
          "target": "stdlib.functools._getframe",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.functools.partialmethod",
      "name": "partialmethod",
      "module": "functools",
      "type": "class",
      "signature": "(func, /, *args, **keywords)",
      "description": "Method descriptor with partial application of the given arguments\nand keywords.\n\nSupports wrapping existing descriptors and handles non-descriptor\ncallables as instance methods.",
      "relationships": []
    },
    {
      "id": "stdlib.functools.recursive_repr",
      "name": "recursive_repr",
      "module": "functools",
      "type": "function",
      "signature": "(fillvalue='...')",
      "description": "Decorator to make a repr function return fillvalue for a recursive call",
      "relationships": [
        {
          "target": "stdlib.functools.set",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.getattr",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.getattr",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.getattr",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.getattr",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.getattr",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.add",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.id",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.get_ident",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.user_function",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.discard",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.functools.singledispatch",
      "name": "singledispatch",
      "module": "functools",
      "type": "function",
      "signature": "(func)",
      "description": "Single-dispatch generic function decorator.\n\nTransforms a function into a generic function, which can have different\nbehaviours depending upon the type of its first argument. The decorated\nfunction acts as the default implementation, and additional\nimplementations can be registered using the register() attribute of the\ngeneric function.",
      "relationships": [
        {
          "target": "stdlib.functools.WeakKeyDictionary",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.getattr",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.MappingProxyType",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.update_wrapper",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.clear",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.get_cache_token",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.getattr",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.next",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.hasattr",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.get_cache_token",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.dispatch",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.clear",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.iter",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.register",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.items",
          "type": "calls"
        },
        {
          "target": "stdlib.functools._find_impl",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.get_type_hints",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.functools.singledispatchmethod",
      "name": "singledispatchmethod",
      "module": "functools",
      "type": "class",
      "signature": "(func)",
      "description": "Single-dispatch generic method descriptor.\n\nSupports wrapping existing descriptors and handles non-descriptor\ncallables as instance methods.",
      "relationships": []
    },
    {
      "id": "stdlib.functools.total_ordering",
      "name": "total_ordering",
      "module": "functools",
      "type": "function",
      "signature": "(cls)",
      "description": "Class decorator that fills in missing ordering methods",
      "relationships": [
        {
          "target": "stdlib.functools.max",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.setattr",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.getattr",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.getattr",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.functools.update_wrapper",
      "name": "update_wrapper",
      "module": "functools",
      "type": "function",
      "signature": "(wrapper, wrapped, assigned=('__module__', '__name__', '__qualname__', '__doc__', '__annotations__'), updated=('__dict__',))",
      "description": "Update a wrapper function to look like the wrapped function\n\nwrapper is the function to be updated\nwrapped is the original function\nassigned is a tuple naming the attributes assigned directly\nfrom the wrapped function to the wrapper function (defaults to\nfunctools.WRAPPER_ASSIGNMENTS)\nupdated is a tuple naming the attributes of the wrapper that\nare updated with the corresponding attribute from the wrapped\nfunction (defaults to functools.WRAPPER_UPDATES)",
      "relationships": [
        {
          "target": "stdlib.functools.update",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.getattr",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.setattr",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.getattr",
          "type": "calls"
        },
        {
          "target": "stdlib.functools.getattr",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.functools.wraps",
      "name": "wraps",
      "module": "functools",
      "type": "function",
      "signature": "(wrapped, assigned=('__module__', '__name__', '__qualname__', '__doc__', '__annotations__'), updated=('__dict__',))",
      "description": "Decorator factory to apply update_wrapper() to a wrapper function\n\nReturns a decorator that invokes update_wrapper() with the decorated\nfunction as the wrapper argument and the arguments to wraps() as the\nremaining arguments. Default arguments are as for update_wrapper().\nThis is a convenience function to simplify applying partial() to\nupdate_wrapper().",
      "relationships": [
        {
          "target": "stdlib.functools.partial",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.genericpath.commonprefix",
      "name": "commonprefix",
      "module": "genericpath",
      "type": "function",
      "signature": "(m)",
      "description": "Given a list of pathnames, returns the longest common leading component",
      "relationships": [
        {
          "target": "stdlib.genericpath.min",
          "type": "calls"
        },
        {
          "target": "stdlib.genericpath.max",
          "type": "calls"
        },
        {
          "target": "stdlib.genericpath.enumerate",
          "type": "calls"
        },
        {
          "target": "stdlib.genericpath.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.genericpath.tuple",
          "type": "calls"
        },
        {
          "target": "stdlib.genericpath.map",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.genericpath.exists",
      "name": "exists",
      "module": "genericpath",
      "type": "function",
      "signature": "(path)",
      "description": "Test whether a path exists.  Returns False for broken symbolic links",
      "relationships": [
        {
          "target": "stdlib.genericpath.stat",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.genericpath.getatime",
      "name": "getatime",
      "module": "genericpath",
      "type": "function",
      "signature": "(filename)",
      "description": "Return the last access time of a file, reported by os.stat().",
      "relationships": [
        {
          "target": "stdlib.genericpath.stat",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.genericpath.getctime",
      "name": "getctime",
      "module": "genericpath",
      "type": "function",
      "signature": "(filename)",
      "description": "Return the metadata change time of a file, reported by os.stat().",
      "relationships": [
        {
          "target": "stdlib.genericpath.stat",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.genericpath.getmtime",
      "name": "getmtime",
      "module": "genericpath",
      "type": "function",
      "signature": "(filename)",
      "description": "Return the last modification time of a file, reported by os.stat().",
      "relationships": [
        {
          "target": "stdlib.genericpath.stat",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.genericpath.getsize",
      "name": "getsize",
      "module": "genericpath",
      "type": "function",
      "signature": "(filename)",
      "description": "Return the size of a file, reported by os.stat().",
      "relationships": [
        {
          "target": "stdlib.genericpath.stat",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.genericpath.isdir",
      "name": "isdir",
      "module": "genericpath",
      "type": "function",
      "signature": "(s)",
      "description": "Return true if the pathname refers to an existing directory.",
      "relationships": [
        {
          "target": "stdlib.genericpath.S_ISDIR",
          "type": "calls"
        },
        {
          "target": "stdlib.genericpath.stat",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.genericpath.isfile",
      "name": "isfile",
      "module": "genericpath",
      "type": "function",
      "signature": "(path)",
      "description": "Test whether a path is a regular file",
      "relationships": [
        {
          "target": "stdlib.genericpath.S_ISREG",
          "type": "calls"
        },
        {
          "target": "stdlib.genericpath.stat",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.genericpath.samefile",
      "name": "samefile",
      "module": "genericpath",
      "type": "function",
      "signature": "(f1, f2)",
      "description": "Test whether two pathnames reference the same actual file or directory\n\nThis is determined by the device number and i-node number and\nraises an exception if an os.stat() call on either pathname fails.",
      "relationships": [
        {
          "target": "stdlib.genericpath.stat",
          "type": "calls"
        },
        {
          "target": "stdlib.genericpath.stat",
          "type": "calls"
        },
        {
          "target": "stdlib.genericpath.samestat",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.genericpath.sameopenfile",
      "name": "sameopenfile",
      "module": "genericpath",
      "type": "function",
      "signature": "(fp1, fp2)",
      "description": "Test whether two open file objects reference the same file",
      "relationships": [
        {
          "target": "stdlib.genericpath.fstat",
          "type": "calls"
        },
        {
          "target": "stdlib.genericpath.fstat",
          "type": "calls"
        },
        {
          "target": "stdlib.genericpath.samestat",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.genericpath.samestat",
      "name": "samestat",
      "module": "genericpath",
      "type": "function",
      "signature": "(s1, s2)",
      "description": "Test whether two stat buffers reference the same file",
      "relationships": []
    },
    {
      "id": "stdlib.getopt.GetoptError",
      "name": "GetoptError",
      "module": "getopt",
      "type": "class",
      "signature": "(msg, opt='')",
      "description": "Common base class for all non-exit exceptions.",
      "relationships": [
        {
          "target": "Exception",
          "type": "base_class"
        },
        {
          "target": "BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.getopt.do_longs",
      "name": "do_longs",
      "module": "getopt",
      "type": "function",
      "signature": "(opts, opt, longopts, args)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.getopt.long_has_args",
          "type": "calls"
        },
        {
          "target": "stdlib.getopt.append",
          "type": "calls"
        },
        {
          "target": "stdlib.getopt.index",
          "type": "calls"
        },
        {
          "target": "stdlib.getopt.GetoptError",
          "type": "calls"
        },
        {
          "target": "stdlib.getopt.GetoptError",
          "type": "calls"
        },
        {
          "target": "stdlib.getopt._",
          "type": "calls"
        },
        {
          "target": "stdlib.getopt._",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.getopt.do_shorts",
      "name": "do_shorts",
      "module": "getopt",
      "type": "function",
      "signature": "(opts, optstring, shortopts, args)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.getopt.short_has_arg",
          "type": "calls"
        },
        {
          "target": "stdlib.getopt.append",
          "type": "calls"
        },
        {
          "target": "stdlib.getopt.GetoptError",
          "type": "calls"
        },
        {
          "target": "stdlib.getopt._",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.getopt.error",
      "name": "error",
      "module": "getopt",
      "type": "class",
      "signature": "(msg, opt='')",
      "description": "Common base class for all non-exit exceptions.",
      "relationships": [
        {
          "target": "Exception",
          "type": "base_class"
        },
        {
          "target": "BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.getopt.getopt",
      "name": "getopt",
      "module": "getopt",
      "type": "function",
      "signature": "(args, shortopts, longopts=[])",
      "description": "getopt(args, options[, long_options]) -> opts, args\n\nParses command line options and parameter list.  args is the\nargument list to be parsed, without the leading reference to the\nrunning program.  Typically, this means \"sys.argv[1:]\".  shortopts\nis the string of option letters that the script wants to\nrecognize, with options that require an argument followed by a\ncolon (i.e., the same format that Unix getopt() uses).  If\nspecified, longopts is a list of strings with the names of the\nlong options which should be supported.  The leading '--'\ncharacters should not be included in the option name.  Options\nwhich require an argument should be followed by an equal sign\n('=').\n\nThe return value consists of two elements: the first is a list of\n(option, value) pairs; the second is the list of program arguments\nleft after the option list was stripped (this is a trailing slice\nof the first argument).  Each option-and-value pair returned has\nthe option as its first element, prefixed with a hyphen (e.g.,\n'-x'), and the option argument as its second element, or an empty\nstring if the option has no argument.  The options occur in the\nlist in the same order in which they were found, thus allowing\nmultiple occurrences.  Long and short options may be mixed.",
      "relationships": [
        {
          "target": "stdlib.getopt.type",
          "type": "calls"
        },
        {
          "target": "stdlib.getopt.type",
          "type": "calls"
        },
        {
          "target": "stdlib.getopt.list",
          "type": "calls"
        },
        {
          "target": "stdlib.getopt.startswith",
          "type": "calls"
        },
        {
          "target": "stdlib.getopt.startswith",
          "type": "calls"
        },
        {
          "target": "stdlib.getopt.do_longs",
          "type": "calls"
        },
        {
          "target": "stdlib.getopt.do_shorts",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.getopt.gnu_getopt",
      "name": "gnu_getopt",
      "module": "getopt",
      "type": "function",
      "signature": "(args, shortopts, longopts=[])",
      "description": "getopt(args, options[, long_options]) -> opts, args\n\nThis function works like getopt(), except that GNU style scanning\nmode is used by default. This means that option and non-option\narguments may be intermixed. The getopt() function stops\nprocessing options as soon as a non-option argument is\nencountered.\n\nIf the first character of the option string is `+', or if the\nenvironment variable POSIXLY_CORRECT is set, then option\nprocessing stops as soon as a non-option argument is encountered.",
      "relationships": [
        {
          "target": "stdlib.getopt.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.getopt.startswith",
          "type": "calls"
        },
        {
          "target": "stdlib.getopt.list",
          "type": "calls"
        },
        {
          "target": "stdlib.getopt.get",
          "type": "calls"
        },
        {
          "target": "stdlib.getopt.do_longs",
          "type": "calls"
        },
        {
          "target": "stdlib.getopt.do_shorts",
          "type": "calls"
        },
        {
          "target": "stdlib.getopt.append",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.getopt.long_has_args",
      "name": "long_has_args",
      "module": "getopt",
      "type": "function",
      "signature": "(opt, longopts)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.getopt.endswith",
          "type": "calls"
        },
        {
          "target": "stdlib.getopt.GetoptError",
          "type": "calls"
        },
        {
          "target": "stdlib.getopt.len",
          "type": "calls"
        },
        {
          "target": "stdlib.getopt.GetoptError",
          "type": "calls"
        },
        {
          "target": "stdlib.getopt.len",
          "type": "calls"
        },
        {
          "target": "stdlib.getopt.startswith",
          "type": "calls"
        },
        {
          "target": "stdlib.getopt._",
          "type": "calls"
        },
        {
          "target": "stdlib.getopt._",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.getopt.short_has_arg",
      "name": "short_has_arg",
      "module": "getopt",
      "type": "function",
      "signature": "(opt, shortopts)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.getopt.range",
          "type": "calls"
        },
        {
          "target": "stdlib.getopt.GetoptError",
          "type": "calls"
        },
        {
          "target": "stdlib.getopt.len",
          "type": "calls"
        },
        {
          "target": "stdlib.getopt.startswith",
          "type": "calls"
        },
        {
          "target": "stdlib.getopt._",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.getpass.fallback_getpass",
      "name": "fallback_getpass",
      "module": "getpass",
      "type": "function",
      "signature": "(prompt='Password: ', stream=None)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.getpass.warn",
          "type": "calls"
        },
        {
          "target": "stdlib.getpass.print",
          "type": "calls"
        },
        {
          "target": "stdlib.getpass._raw_input",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.getpass.getpass",
      "name": "getpass",
      "module": "getpass",
      "type": "function",
      "signature": "(prompt='Password: ', stream=None)",
      "description": "Prompt for a password, with echo turned off.\n\nArgs:\n  prompt: Written on stream to ask for the input.  Default: 'Password: '\n  stream: A writable file object to display the prompt.  Defaults to\n          the tty.  If no tty is available defaults to sys.stderr.\nReturns:\n  The seKr3t input.\nRaises:\n  EOFError: If our input tty or stdin was closed.\n  GetPassWarning: When we were unable to turn echo off on the input.\n\nAlways restores terminal settings before returning.",
      "relationships": [
        {
          "target": "stdlib.getpass.ExitStack",
          "type": "calls"
        },
        {
          "target": "stdlib.getpass.write",
          "type": "calls"
        },
        {
          "target": "stdlib.getpass.open",
          "type": "calls"
        },
        {
          "target": "stdlib.getpass.FileIO",
          "type": "calls"
        },
        {
          "target": "stdlib.getpass.enter_context",
          "type": "calls"
        },
        {
          "target": "stdlib.getpass.TextIOWrapper",
          "type": "calls"
        },
        {
          "target": "stdlib.getpass.enter_context",
          "type": "calls"
        },
        {
          "target": "stdlib.getpass.close",
          "type": "calls"
        },
        {
          "target": "stdlib.getpass.tcgetattr",
          "type": "calls"
        },
        {
          "target": "stdlib.getpass.hasattr",
          "type": "calls"
        },
        {
          "target": "stdlib.getpass.fileno",
          "type": "calls"
        },
        {
          "target": "stdlib.getpass.tcsetattr",
          "type": "calls"
        },
        {
          "target": "stdlib.getpass._raw_input",
          "type": "calls"
        },
        {
          "target": "stdlib.getpass.tcsetattr",
          "type": "calls"
        },
        {
          "target": "stdlib.getpass.flush",
          "type": "calls"
        },
        {
          "target": "stdlib.getpass.fallback_getpass",
          "type": "calls"
        },
        {
          "target": "stdlib.getpass.fallback_getpass",
          "type": "calls"
        },
        {
          "target": "stdlib.getpass.close",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.getpass.getuser",
      "name": "getuser",
      "module": "getpass",
      "type": "function",
      "signature": "()",
      "description": "Get the username from the environment or password database.\n\nFirst try various environment variables, then the password\ndatabase.  This works on Windows as long as USERNAME is set.",
      "relationships": [
        {
          "target": "stdlib.getpass.get",
          "type": "calls"
        },
        {
          "target": "stdlib.getpass.getpwuid",
          "type": "calls"
        },
        {
          "target": "stdlib.getpass.getuid",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.getpass.unix_getpass",
      "name": "unix_getpass",
      "module": "getpass",
      "type": "function",
      "signature": "(prompt='Password: ', stream=None)",
      "description": "Prompt for a password, with echo turned off.\n\nArgs:\n  prompt: Written on stream to ask for the input.  Default: 'Password: '\n  stream: A writable file object to display the prompt.  Defaults to\n          the tty.  If no tty is available defaults to sys.stderr.\nReturns:\n  The seKr3t input.\nRaises:\n  EOFError: If our input tty or stdin was closed.\n  GetPassWarning: When we were unable to turn echo off on the input.\n\nAlways restores terminal settings before returning.",
      "relationships": [
        {
          "target": "stdlib.getpass.ExitStack",
          "type": "calls"
        },
        {
          "target": "stdlib.getpass.write",
          "type": "calls"
        },
        {
          "target": "stdlib.getpass.open",
          "type": "calls"
        },
        {
          "target": "stdlib.getpass.FileIO",
          "type": "calls"
        },
        {
          "target": "stdlib.getpass.enter_context",
          "type": "calls"
        },
        {
          "target": "stdlib.getpass.TextIOWrapper",
          "type": "calls"
        },
        {
          "target": "stdlib.getpass.enter_context",
          "type": "calls"
        },
        {
          "target": "stdlib.getpass.close",
          "type": "calls"
        },
        {
          "target": "stdlib.getpass.tcgetattr",
          "type": "calls"
        },
        {
          "target": "stdlib.getpass.hasattr",
          "type": "calls"
        },
        {
          "target": "stdlib.getpass.fileno",
          "type": "calls"
        },
        {
          "target": "stdlib.getpass.tcsetattr",
          "type": "calls"
        },
        {
          "target": "stdlib.getpass._raw_input",
          "type": "calls"
        },
        {
          "target": "stdlib.getpass.tcsetattr",
          "type": "calls"
        },
        {
          "target": "stdlib.getpass.flush",
          "type": "calls"
        },
        {
          "target": "stdlib.getpass.fallback_getpass",
          "type": "calls"
        },
        {
          "target": "stdlib.getpass.fallback_getpass",
          "type": "calls"
        },
        {
          "target": "stdlib.getpass.close",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.getpass.win_getpass",
      "name": "win_getpass",
      "module": "getpass",
      "type": "function",
      "signature": "(prompt='Password: ', stream=None)",
      "description": "Prompt for password with echo off, using Windows getwch().",
      "relationships": [
        {
          "target": "stdlib.getpass.putwch",
          "type": "calls"
        },
        {
          "target": "stdlib.getpass.putwch",
          "type": "calls"
        },
        {
          "target": "stdlib.getpass.fallback_getpass",
          "type": "calls"
        },
        {
          "target": "stdlib.getpass.putwch",
          "type": "calls"
        },
        {
          "target": "stdlib.getpass.getwch",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.gettext.Catalog",
      "name": "Catalog",
      "module": "gettext",
      "type": "function",
      "signature": "(domain, localedir=None, languages=None, class_=None, fallback=False, codeset=['unspecified'])",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.gettext.find",
          "type": "calls"
        },
        {
          "target": "stdlib.gettext.FileNotFoundError",
          "type": "calls"
        },
        {
          "target": "stdlib.gettext.get",
          "type": "calls"
        },
        {
          "target": "stdlib.gettext.copy",
          "type": "calls"
        },
        {
          "target": "stdlib.gettext.NullTranslations",
          "type": "calls"
        },
        {
          "target": "stdlib.gettext.abspath",
          "type": "calls"
        },
        {
          "target": "stdlib.gettext.warn",
          "type": "calls"
        },
        {
          "target": "stdlib.gettext.add_fallback",
          "type": "calls"
        },
        {
          "target": "stdlib.gettext.open",
          "type": "calls"
        },
        {
          "target": "stdlib.gettext.setdefault",
          "type": "calls"
        },
        {
          "target": "stdlib.gettext.class_",
          "type": "calls"
        },
        {
          "target": "stdlib.gettext.catch_warnings",
          "type": "calls"
        },
        {
          "target": "stdlib.gettext.filterwarnings",
          "type": "calls"
        },
        {
          "target": "stdlib.gettext.set_output_charset",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.gettext.GNUTranslations",
      "name": "GNUTranslations",
      "module": "gettext",
      "type": "class",
      "signature": "(fp=None)",
      "description": "",
      "relationships": [
        {
          "target": "NullTranslations",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.gettext.NullTranslations",
      "name": "NullTranslations",
      "module": "gettext",
      "type": "class",
      "signature": "(fp=None)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.gettext.bind_textdomain_codeset",
      "name": "bind_textdomain_codeset",
      "module": "gettext",
      "type": "function",
      "signature": "(domain, codeset=None)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.gettext.warn",
          "type": "calls"
        },
        {
          "target": "stdlib.gettext.get",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.gettext.bindtextdomain",
      "name": "bindtextdomain",
      "module": "gettext",
      "type": "function",
      "signature": "(domain, localedir=None)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.gettext.get",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.gettext.c2py",
      "name": "c2py",
      "module": "gettext",
      "type": "function",
      "signature": "(plural)",
      "description": "Gets a C expression as used in PO files for plural forms and returns a\nPython function that implements an equivalent expression.",
      "relationships": [
        {
          "target": "stdlib.gettext.len",
          "type": "calls"
        },
        {
          "target": "stdlib.gettext.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.gettext._parse",
          "type": "calls"
        },
        {
          "target": "stdlib.gettext.exec",
          "type": "calls"
        },
        {
          "target": "stdlib.gettext._tokenize",
          "type": "calls"
        },
        {
          "target": "stdlib.gettext._error",
          "type": "calls"
        },
        {
          "target": "stdlib.gettext.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.gettext.ValueError",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.gettext.dgettext",
      "name": "dgettext",
      "module": "gettext",
      "type": "function",
      "signature": "(domain, message)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.gettext.gettext",
          "type": "calls"
        },
        {
          "target": "stdlib.gettext.translation",
          "type": "calls"
        },
        {
          "target": "stdlib.gettext.get",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.gettext.dngettext",
      "name": "dngettext",
      "module": "gettext",
      "type": "function",
      "signature": "(domain, msgid1, msgid2, n)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.gettext.ngettext",
          "type": "calls"
        },
        {
          "target": "stdlib.gettext.translation",
          "type": "calls"
        },
        {
          "target": "stdlib.gettext.get",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.gettext.dnpgettext",
      "name": "dnpgettext",
      "module": "gettext",
      "type": "function",
      "signature": "(domain, context, msgid1, msgid2, n)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.gettext.npgettext",
          "type": "calls"
        },
        {
          "target": "stdlib.gettext.translation",
          "type": "calls"
        },
        {
          "target": "stdlib.gettext.get",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.gettext.dpgettext",
      "name": "dpgettext",
      "module": "gettext",
      "type": "function",
      "signature": "(domain, context, message)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.gettext.pgettext",
          "type": "calls"
        },
        {
          "target": "stdlib.gettext.translation",
          "type": "calls"
        },
        {
          "target": "stdlib.gettext.get",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.gettext.find",
      "name": "find",
      "module": "gettext",
      "type": "function",
      "signature": "(domain, localedir=None, languages=None, all=False)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.gettext._expand_lang",
          "type": "calls"
        },
        {
          "target": "stdlib.gettext.join",
          "type": "calls"
        },
        {
          "target": "stdlib.gettext.exists",
          "type": "calls"
        },
        {
          "target": "stdlib.gettext.get",
          "type": "calls"
        },
        {
          "target": "stdlib.gettext.append",
          "type": "calls"
        },
        {
          "target": "stdlib.gettext.split",
          "type": "calls"
        },
        {
          "target": "stdlib.gettext.append",
          "type": "calls"
        },
        {
          "target": "stdlib.gettext.append",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.gettext.gettext",
      "name": "gettext",
      "module": "gettext",
      "type": "function",
      "signature": "(message)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.gettext.dgettext",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.gettext.install",
      "name": "install",
      "module": "gettext",
      "type": "function",
      "signature": "(domain, localedir=None, codeset=['unspecified'], names=None)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.gettext.translation",
          "type": "calls"
        },
        {
          "target": "stdlib.gettext.install",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.gettext.ldgettext",
      "name": "ldgettext",
      "module": "gettext",
      "type": "function",
      "signature": "(domain, message)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.gettext.warn",
          "type": "calls"
        },
        {
          "target": "stdlib.gettext.get",
          "type": "calls"
        },
        {
          "target": "stdlib.gettext.catch_warnings",
          "type": "calls"
        },
        {
          "target": "stdlib.gettext.filterwarnings",
          "type": "calls"
        },
        {
          "target": "stdlib.gettext.lgettext",
          "type": "calls"
        },
        {
          "target": "stdlib.gettext.catch_warnings",
          "type": "calls"
        },
        {
          "target": "stdlib.gettext.filterwarnings",
          "type": "calls"
        },
        {
          "target": "stdlib.gettext.translation",
          "type": "calls"
        },
        {
          "target": "stdlib.gettext.encode",
          "type": "calls"
        },
        {
          "target": "stdlib.gettext.get",
          "type": "calls"
        },
        {
          "target": "stdlib.gettext.getpreferredencoding",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.gettext.ldngettext",
      "name": "ldngettext",
      "module": "gettext",
      "type": "function",
      "signature": "(domain, msgid1, msgid2, n)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.gettext.warn",
          "type": "calls"
        },
        {
          "target": "stdlib.gettext.get",
          "type": "calls"
        },
        {
          "target": "stdlib.gettext.catch_warnings",
          "type": "calls"
        },
        {
          "target": "stdlib.gettext.filterwarnings",
          "type": "calls"
        },
        {
          "target": "stdlib.gettext.lngettext",
          "type": "calls"
        },
        {
          "target": "stdlib.gettext.catch_warnings",
          "type": "calls"
        },
        {
          "target": "stdlib.gettext.filterwarnings",
          "type": "calls"
        },
        {
          "target": "stdlib.gettext.translation",
          "type": "calls"
        },
        {
          "target": "stdlib.gettext.encode",
          "type": "calls"
        },
        {
          "target": "stdlib.gettext.get",
          "type": "calls"
        },
        {
          "target": "stdlib.gettext.getpreferredencoding",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.gettext.lgettext",
      "name": "lgettext",
      "module": "gettext",
      "type": "function",
      "signature": "(message)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.gettext.warn",
          "type": "calls"
        },
        {
          "target": "stdlib.gettext.catch_warnings",
          "type": "calls"
        },
        {
          "target": "stdlib.gettext.filterwarnings",
          "type": "calls"
        },
        {
          "target": "stdlib.gettext.ldgettext",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.gettext.lngettext",
      "name": "lngettext",
      "module": "gettext",
      "type": "function",
      "signature": "(msgid1, msgid2, n)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.gettext.warn",
          "type": "calls"
        },
        {
          "target": "stdlib.gettext.catch_warnings",
          "type": "calls"
        },
        {
          "target": "stdlib.gettext.filterwarnings",
          "type": "calls"
        },
        {
          "target": "stdlib.gettext.ldngettext",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.gettext.ngettext",
      "name": "ngettext",
      "module": "gettext",
      "type": "function",
      "signature": "(msgid1, msgid2, n)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.gettext.dngettext",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.gettext.npgettext",
      "name": "npgettext",
      "module": "gettext",
      "type": "function",
      "signature": "(context, msgid1, msgid2, n)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.gettext.dnpgettext",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.gettext.pgettext",
      "name": "pgettext",
      "module": "gettext",
      "type": "function",
      "signature": "(context, message)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.gettext.dpgettext",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.gettext.textdomain",
      "name": "textdomain",
      "module": "gettext",
      "type": "function",
      "signature": "(domain=None)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.gettext.translation",
      "name": "translation",
      "module": "gettext",
      "type": "function",
      "signature": "(domain, localedir=None, languages=None, class_=None, fallback=False, codeset=['unspecified'])",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.gettext.find",
          "type": "calls"
        },
        {
          "target": "stdlib.gettext.FileNotFoundError",
          "type": "calls"
        },
        {
          "target": "stdlib.gettext.get",
          "type": "calls"
        },
        {
          "target": "stdlib.gettext.copy",
          "type": "calls"
        },
        {
          "target": "stdlib.gettext.NullTranslations",
          "type": "calls"
        },
        {
          "target": "stdlib.gettext.abspath",
          "type": "calls"
        },
        {
          "target": "stdlib.gettext.warn",
          "type": "calls"
        },
        {
          "target": "stdlib.gettext.add_fallback",
          "type": "calls"
        },
        {
          "target": "stdlib.gettext.open",
          "type": "calls"
        },
        {
          "target": "stdlib.gettext.setdefault",
          "type": "calls"
        },
        {
          "target": "stdlib.gettext.class_",
          "type": "calls"
        },
        {
          "target": "stdlib.gettext.catch_warnings",
          "type": "calls"
        },
        {
          "target": "stdlib.gettext.filterwarnings",
          "type": "calls"
        },
        {
          "target": "stdlib.gettext.set_output_charset",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.glob.escape",
      "name": "escape",
      "module": "glob",
      "type": "function",
      "signature": "(pathname)",
      "description": "Escape all special characters.\n    ",
      "relationships": [
        {
          "target": "stdlib.glob.splitdrive",
          "type": "calls"
        },
        {
          "target": "stdlib.glob.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.glob.sub",
          "type": "calls"
        },
        {
          "target": "stdlib.glob.sub",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.glob.glob",
      "name": "glob",
      "module": "glob",
      "type": "function",
      "signature": "(pathname, *, recursive=False)",
      "description": "Return a list of paths matching a pathname pattern.\n\nThe pattern may contain simple shell-style wildcards a la\nfnmatch. However, unlike fnmatch, filenames starting with a\ndot are special cases that are not matched by '*' and '?'\npatterns.\n\nIf recursive is true, the pattern '**' will match any files and\nzero or more directories and subdirectories.",
      "relationships": [
        {
          "target": "stdlib.glob.list",
          "type": "calls"
        },
        {
          "target": "stdlib.glob.iglob",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.glob.glob0",
      "name": "glob0",
      "module": "glob",
      "type": "function",
      "signature": "(dirname, pattern)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.glob._glob0",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.glob.glob1",
      "name": "glob1",
      "module": "glob",
      "type": "function",
      "signature": "(dirname, pattern)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.glob._glob1",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.glob.has_magic",
      "name": "has_magic",
      "module": "glob",
      "type": "function",
      "signature": "(s)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.glob.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.glob.search",
          "type": "calls"
        },
        {
          "target": "stdlib.glob.search",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.glob.iglob",
      "name": "iglob",
      "module": "glob",
      "type": "function",
      "signature": "(pathname, *, recursive=False)",
      "description": "Return an iterator which yields the paths matching a pathname pattern.\n\nThe pattern may contain simple shell-style wildcards a la\nfnmatch. However, unlike fnmatch, filenames starting with a\ndot are special cases that are not matched by '*' and '?'\npatterns.\n\nIf recursive is true, the pattern '**' will match any files and\nzero or more directories and subdirectories.",
      "relationships": [
        {
          "target": "stdlib.glob.audit",
          "type": "calls"
        },
        {
          "target": "stdlib.glob._iglob",
          "type": "calls"
        },
        {
          "target": "stdlib.glob._isrecursive",
          "type": "calls"
        },
        {
          "target": "stdlib.glob.next",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.graphlib.TopologicalSorter",
      "name": "TopologicalSorter",
      "module": "graphlib",
      "type": "class",
      "signature": "(graph=None)",
      "description": "Provides functionality to topologically sort a graph of hashable nodes",
      "relationships": []
    },
    {
      "id": "stdlib.gzip.GzipFile",
      "name": "GzipFile",
      "module": "gzip",
      "type": "class",
      "signature": "(filename=None, mode=None, compresslevel=9, fileobj=None, mtime=None)",
      "description": "The GzipFile class simulates most of the methods of a file object with\nthe exception of the truncate() method.\n\nThis class only supports opening files in binary mode. If you need to open a\ncompressed file in text mode, use the gzip.open() function.",
      "relationships": [
        {
          "target": "BaseStream",
          "type": "base_class"
        },
        {
          "target": "BufferedIOBase",
          "type": "base_class"
        },
        {
          "target": "_BufferedIOBase",
          "type": "base_class"
        },
        {
          "target": "IOBase",
          "type": "base_class"
        },
        {
          "target": "_IOBase",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.gzip.compress",
      "name": "compress",
      "module": "gzip",
      "type": "function",
      "signature": "(data, compresslevel=9, *, mtime=None)",
      "description": "Compress data in one shot and return the compressed string.\nOptional argument is the compression level, in range of 0-9.",
      "relationships": [
        {
          "target": "stdlib.gzip.BytesIO",
          "type": "calls"
        },
        {
          "target": "stdlib.gzip.getvalue",
          "type": "calls"
        },
        {
          "target": "stdlib.gzip.GzipFile",
          "type": "calls"
        },
        {
          "target": "stdlib.gzip.write",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.gzip.decompress",
      "name": "decompress",
      "module": "gzip",
      "type": "function",
      "signature": "(data)",
      "description": "Decompress a gzip compressed string in one shot.\nReturn the decompressed string.",
      "relationships": [
        {
          "target": "stdlib.gzip.GzipFile",
          "type": "calls"
        },
        {
          "target": "stdlib.gzip.read",
          "type": "calls"
        },
        {
          "target": "stdlib.gzip.BytesIO",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.gzip.main",
      "name": "main",
      "module": "gzip",
      "type": "function",
      "signature": "()",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.gzip.ArgumentParser",
          "type": "calls"
        },
        {
          "target": "stdlib.gzip.add_mutually_exclusive_group",
          "type": "calls"
        },
        {
          "target": "stdlib.gzip.add_argument",
          "type": "calls"
        },
        {
          "target": "stdlib.gzip.add_argument",
          "type": "calls"
        },
        {
          "target": "stdlib.gzip.add_argument",
          "type": "calls"
        },
        {
          "target": "stdlib.gzip.add_argument",
          "type": "calls"
        },
        {
          "target": "stdlib.gzip.parse_args",
          "type": "calls"
        },
        {
          "target": "stdlib.gzip.read",
          "type": "calls"
        },
        {
          "target": "stdlib.gzip.write",
          "type": "calls"
        },
        {
          "target": "stdlib.gzip.close",
          "type": "calls"
        },
        {
          "target": "stdlib.gzip.close",
          "type": "calls"
        },
        {
          "target": "stdlib.gzip.GzipFile",
          "type": "calls"
        },
        {
          "target": "stdlib.gzip.open",
          "type": "calls"
        },
        {
          "target": "stdlib.gzip.open",
          "type": "calls"
        },
        {
          "target": "stdlib.gzip.GzipFile",
          "type": "calls"
        },
        {
          "target": "stdlib.gzip.open",
          "type": "calls"
        },
        {
          "target": "stdlib.gzip.open",
          "type": "calls"
        },
        {
          "target": "stdlib.gzip.exit",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.gzip.open",
      "name": "open",
      "module": "gzip",
      "type": "function",
      "signature": "(filename, mode='rb', compresslevel=9, encoding=None, errors=None, newline=None)",
      "description": "Open a gzip-compressed file in binary or text mode.\n\nThe filename argument can be an actual filename (a str or bytes object), or\nan existing file object to read from or write to.\n\nThe mode argument can be \"r\", \"rb\", \"w\", \"wb\", \"x\", \"xb\", \"a\" or \"ab\" for\nbinary mode, or \"rt\", \"wt\", \"xt\" or \"at\" for text mode. The default mode is\n\"rb\", and the default compresslevel is 9.\n\nFor binary mode, this function is equivalent to the GzipFile constructor:\nGzipFile(filename, mode, compresslevel). In this case, the encoding, errors\nand newline arguments must not be provided.\n\nFor text mode, a GzipFile object is created, and wrapped in an\nio.TextIOWrapper instance with the specified encoding, error handling\nbehavior, and line ending(s).",
      "relationships": [
        {
          "target": "stdlib.gzip.replace",
          "type": "calls"
        },
        {
          "target": "stdlib.gzip.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.gzip.GzipFile",
          "type": "calls"
        },
        {
          "target": "stdlib.gzip.TextIOWrapper",
          "type": "calls"
        },
        {
          "target": "stdlib.gzip.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.gzip.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.gzip.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.gzip.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.gzip.hasattr",
          "type": "calls"
        },
        {
          "target": "stdlib.gzip.hasattr",
          "type": "calls"
        },
        {
          "target": "stdlib.gzip.GzipFile",
          "type": "calls"
        },
        {
          "target": "stdlib.gzip.TypeError",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.gzip.write32u",
      "name": "write32u",
      "module": "gzip",
      "type": "function",
      "signature": "(output, value)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.gzip.write",
          "type": "calls"
        },
        {
          "target": "stdlib.gzip.pack",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.hashlib.blake2b",
      "name": "blake2b",
      "module": "hashlib",
      "type": "class",
      "signature": "(data=b'', /, *, digest_size=64, key=b'', salt=b'', person=b'', fanout=1, depth=1, leaf_size=0, node_offset=0, node_depth=0, inner_size=0, last_node=False, usedforsecurity=True)",
      "description": "Return a new BLAKE2b hash object.",
      "relationships": []
    },
    {
      "id": "stdlib.hashlib.blake2s",
      "name": "blake2s",
      "module": "hashlib",
      "type": "class",
      "signature": "(data=b'', /, *, digest_size=32, key=b'', salt=b'', person=b'', fanout=1, depth=1, leaf_size=0, node_offset=0, node_depth=0, inner_size=0, last_node=False, usedforsecurity=True)",
      "description": "Return a new BLAKE2s hash object.",
      "relationships": []
    },
    {
      "id": "stdlib.hashlib.new",
      "name": "new",
      "module": "hashlib",
      "type": "function",
      "signature": "(name, data=b'', **kwargs)",
      "description": "new(name, data=b'') - Return a new hashing object using the named algorithm;\noptionally initialized with data (which must be a bytes-like object).",
      "relationships": [
        {
          "target": "stdlib.hashlib.new",
          "type": "calls"
        },
        {
          "target": "stdlib.hashlib.__get_builtin_constructor",
          "type": "calls"
        },
        {
          "target": "stdlib.hashlib.__get_builtin_constructor",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.heapq.merge",
      "name": "merge",
      "module": "heapq",
      "type": "function",
      "signature": "(*iterables, key=None, reverse=False)",
      "description": "Merge multiple sorted inputs into a single sorted output.\n\nSimilar to sorted(itertools.chain(*iterables)) but returns a generator,\ndoes not pull the data into memory all at once, and assumes that each of\nthe input streams is already sorted (smallest to largest).\n\n>>> list(merge([1,3,5,7], [0,2,4,8], [5,10,15,20], [], [25]))\n[0, 1, 2, 3, 4, 5, 5, 7, 8, 10, 15, 20, 25]\n\nIf *key* is not None, applies a key function to each element to determine\nits sort order.\n\n>>> list(merge(['dog', 'horse'], ['cat', 'fish', 'kangaroo'], key=len))\n['dog', 'cat', 'fish', 'horse', 'kangaroo']",
      "relationships": [
        {
          "target": "stdlib.heapq.enumerate",
          "type": "calls"
        },
        {
          "target": "stdlib.heapq._heapify",
          "type": "calls"
        },
        {
          "target": "stdlib.heapq.enumerate",
          "type": "calls"
        },
        {
          "target": "stdlib.heapq._heapify",
          "type": "calls"
        },
        {
          "target": "stdlib.heapq.map",
          "type": "calls"
        },
        {
          "target": "stdlib.heapq.len",
          "type": "calls"
        },
        {
          "target": "stdlib.heapq.map",
          "type": "calls"
        },
        {
          "target": "stdlib.heapq.len",
          "type": "calls"
        },
        {
          "target": "stdlib.heapq.next",
          "type": "calls"
        },
        {
          "target": "stdlib.heapq.h_append",
          "type": "calls"
        },
        {
          "target": "stdlib.heapq.h_append",
          "type": "calls"
        },
        {
          "target": "stdlib.heapq.next",
          "type": "calls"
        },
        {
          "target": "stdlib.heapq.key",
          "type": "calls"
        },
        {
          "target": "stdlib.heapq._heapreplace",
          "type": "calls"
        },
        {
          "target": "stdlib.heapq._heappop",
          "type": "calls"
        },
        {
          "target": "stdlib.heapq.next",
          "type": "calls"
        },
        {
          "target": "stdlib.heapq._heapreplace",
          "type": "calls"
        },
        {
          "target": "stdlib.heapq._heappop",
          "type": "calls"
        },
        {
          "target": "stdlib.heapq.key",
          "type": "calls"
        },
        {
          "target": "stdlib.heapq.next",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.heapq.nlargest",
      "name": "nlargest",
      "module": "heapq",
      "type": "function",
      "signature": "(n, iterable, key=None)",
      "description": "Find the n largest elements in a dataset.\n\nEquivalent to:  sorted(iterable, key=key, reverse=True)[:n]",
      "relationships": [
        {
          "target": "stdlib.heapq.iter",
          "type": "calls"
        },
        {
          "target": "stdlib.heapq.heapify",
          "type": "calls"
        },
        {
          "target": "stdlib.heapq.sort",
          "type": "calls"
        },
        {
          "target": "stdlib.heapq.iter",
          "type": "calls"
        },
        {
          "target": "stdlib.heapq.object",
          "type": "calls"
        },
        {
          "target": "stdlib.heapq.max",
          "type": "calls"
        },
        {
          "target": "stdlib.heapq.len",
          "type": "calls"
        },
        {
          "target": "stdlib.heapq.iter",
          "type": "calls"
        },
        {
          "target": "stdlib.heapq.heapify",
          "type": "calls"
        },
        {
          "target": "stdlib.heapq.sort",
          "type": "calls"
        },
        {
          "target": "stdlib.heapq.key",
          "type": "calls"
        },
        {
          "target": "stdlib.heapq.key",
          "type": "calls"
        },
        {
          "target": "stdlib.heapq.zip",
          "type": "calls"
        },
        {
          "target": "stdlib.heapq._heapreplace",
          "type": "calls"
        },
        {
          "target": "stdlib.heapq.sorted",
          "type": "calls"
        },
        {
          "target": "stdlib.heapq.zip",
          "type": "calls"
        },
        {
          "target": "stdlib.heapq._heapreplace",
          "type": "calls"
        },
        {
          "target": "stdlib.heapq.range",
          "type": "calls"
        },
        {
          "target": "stdlib.heapq.range",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.heapq.nsmallest",
      "name": "nsmallest",
      "module": "heapq",
      "type": "function",
      "signature": "(n, iterable, key=None)",
      "description": "Find the n smallest elements in a dataset.\n\nEquivalent to:  sorted(iterable, key=key)[:n]",
      "relationships": [
        {
          "target": "stdlib.heapq.iter",
          "type": "calls"
        },
        {
          "target": "stdlib.heapq._heapify_max",
          "type": "calls"
        },
        {
          "target": "stdlib.heapq.sort",
          "type": "calls"
        },
        {
          "target": "stdlib.heapq.iter",
          "type": "calls"
        },
        {
          "target": "stdlib.heapq.object",
          "type": "calls"
        },
        {
          "target": "stdlib.heapq.min",
          "type": "calls"
        },
        {
          "target": "stdlib.heapq.len",
          "type": "calls"
        },
        {
          "target": "stdlib.heapq.iter",
          "type": "calls"
        },
        {
          "target": "stdlib.heapq._heapify_max",
          "type": "calls"
        },
        {
          "target": "stdlib.heapq.sort",
          "type": "calls"
        },
        {
          "target": "stdlib.heapq.key",
          "type": "calls"
        },
        {
          "target": "stdlib.heapq.key",
          "type": "calls"
        },
        {
          "target": "stdlib.heapq.zip",
          "type": "calls"
        },
        {
          "target": "stdlib.heapq._heapreplace",
          "type": "calls"
        },
        {
          "target": "stdlib.heapq.sorted",
          "type": "calls"
        },
        {
          "target": "stdlib.heapq.zip",
          "type": "calls"
        },
        {
          "target": "stdlib.heapq._heapreplace",
          "type": "calls"
        },
        {
          "target": "stdlib.heapq.range",
          "type": "calls"
        },
        {
          "target": "stdlib.heapq.range",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.hmac.HMAC",
      "name": "HMAC",
      "module": "hmac",
      "type": "class",
      "signature": "(key, msg=None, digestmod='')",
      "description": "RFC 2104 HMAC class.  Also complies with RFC 4231.\n\nThis supports the API for Cryptographic Hash Functions (PEP 247).",
      "relationships": []
    },
    {
      "id": "stdlib.hmac.digest",
      "name": "digest",
      "module": "hmac",
      "type": "function",
      "signature": "(key, msg, digest)",
      "description": "Fast inline implementation of HMAC.\n\nkey: bytes or buffer, The key for the keyed hash object.\nmsg: bytes or buffer, Input message.\ndigest: A hash name suitable for hashlib.new() for best performance. *OR*\n        A hashlib constructor returning a new hash object. *OR*\n        A module supporting PEP 247.",
      "relationships": [
        {
          "target": "stdlib.hmac.callable",
          "type": "calls"
        },
        {
          "target": "stdlib.hmac.digest_cons",
          "type": "calls"
        },
        {
          "target": "stdlib.hmac.digest_cons",
          "type": "calls"
        },
        {
          "target": "stdlib.hmac.getattr",
          "type": "calls"
        },
        {
          "target": "stdlib.hmac.update",
          "type": "calls"
        },
        {
          "target": "stdlib.hmac.update",
          "type": "calls"
        },
        {
          "target": "stdlib.hmac.update",
          "type": "calls"
        },
        {
          "target": "stdlib.hmac.update",
          "type": "calls"
        },
        {
          "target": "stdlib.hmac.digest",
          "type": "calls"
        },
        {
          "target": "stdlib.hmac.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.hmac.hmac_digest",
          "type": "calls"
        },
        {
          "target": "stdlib.hmac.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.hmac.len",
          "type": "calls"
        },
        {
          "target": "stdlib.hmac.digest",
          "type": "calls"
        },
        {
          "target": "stdlib.hmac.translate",
          "type": "calls"
        },
        {
          "target": "stdlib.hmac.translate",
          "type": "calls"
        },
        {
          "target": "stdlib.hmac.digest",
          "type": "calls"
        },
        {
          "target": "stdlib.hmac.new",
          "type": "calls"
        },
        {
          "target": "stdlib.hmac.new",
          "type": "calls"
        },
        {
          "target": "stdlib.hmac.digest_cons",
          "type": "calls"
        },
        {
          "target": "stdlib.hmac.len",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.hmac.new",
      "name": "new",
      "module": "hmac",
      "type": "function",
      "signature": "(key, msg=None, digestmod='')",
      "description": "Create a new hashing object and return it.\n\nkey: bytes or buffer, The starting key for the hash.\nmsg: bytes or buffer, Initial input for the hash, or None.\ndigestmod: A hash name suitable for hashlib.new(). *OR*\n           A hashlib constructor returning a new hash object. *OR*\n           A module supporting PEP 247.\n\n           Required as of 3.8, despite its position after the optional\n           msg argument.  Passing it as a keyword argument is\n           recommended, though not required for legacy API reasons.\n\nYou can now feed arbitrary bytes into the object using its update()\nmethod, and can ask for the hash value at any time by calling its digest()\nor hexdigest() methods.",
      "relationships": [
        {
          "target": "stdlib.hmac.HMAC",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.html.escape",
      "name": "escape",
      "module": "html",
      "type": "function",
      "signature": "(s, quote=True)",
      "description": "Replace special characters \"&\", \"<\" and \">\" to HTML-safe sequences.\nIf the optional flag quote is true (the default), the quotation mark\ncharacters, both double quote (\") and single quote (') characters are also\ntranslated.",
      "relationships": [
        {
          "target": "stdlib.html.replace",
          "type": "calls"
        },
        {
          "target": "stdlib.html.replace",
          "type": "calls"
        },
        {
          "target": "stdlib.html.replace",
          "type": "calls"
        },
        {
          "target": "stdlib.html.replace",
          "type": "calls"
        },
        {
          "target": "stdlib.html.replace",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.html.unescape",
      "name": "unescape",
      "module": "html",
      "type": "function",
      "signature": "(s)",
      "description": "Convert all named and numeric character references (e.g. &gt;, &#62;,\n&x3e;) in the string s to the corresponding unicode characters.\nThis function uses the rules defined by the HTML 5 standard\nfor both valid and invalid character references, and the list of\nHTML 5 named character references defined in html.entities.html5.",
      "relationships": [
        {
          "target": "stdlib.html.sub",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.http.HTTPStatus",
      "name": "HTTPStatus",
      "module": "http",
      "type": "class",
      "signature": "(value, names=None, *, module=None, qualname=None, type=None, start=1)",
      "description": "HTTP status codes and reason phrases\n\nStatus codes from the following RFCs are all observed:\n\n    * RFC 7231: Hypertext Transfer Protocol (HTTP/1.1), obsoletes 2616\n    * RFC 6585: Additional HTTP Status Codes\n    * RFC 3229: Delta encoding in HTTP\n    * RFC 4918: HTTP Extensions for WebDAV, obsoletes 2518\n    * RFC 5842: Binding Extensions to WebDAV\n    * RFC 7238: Permanent Redirect\n    * RFC 2295: Transparent Content Negotiation in HTTP\n    * RFC 2774: An HTTP Extension Framework\n    * RFC 7725: An HTTP Status Code to Report Legal Obstacles\n    * RFC 7540: Hypertext Transfer Protocol Version 2 (HTTP/2)\n    * RFC 2324: Hyper Text Coffee Pot Control Protocol (HTCPCP/1.0)\n    * RFC 8297: An HTTP Status Code for Indicating Hints\n    * RFC 8470: Using Early Data in HTTP",
      "relationships": [
        {
          "target": "IntEnum",
          "type": "base_class"
        },
        {
          "target": "int",
          "type": "base_class"
        },
        {
          "target": "Enum",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.http.IntEnum",
      "name": "IntEnum",
      "module": "http",
      "type": "class",
      "signature": "(value, names=None, *, module=None, qualname=None, type=None, start=1)",
      "description": "Enum where members are also (and must be) ints",
      "relationships": [
        {
          "target": "int",
          "type": "base_class"
        },
        {
          "target": "Enum",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.imaplib.IMAP4",
      "name": "IMAP4",
      "module": "imaplib",
      "type": "class",
      "signature": "(host='', port=143, timeout=None)",
      "description": "IMAP4 client class.\n\nInstantiate with: IMAP4([host[, port[, timeout=None]]])\n\n        host - host's name (default: localhost);\n        port - port number (default: standard IMAP4 port).\n        timeout - socket timeout (default: None)\n                  If timeout is not given or is None,\n                  the global default socket timeout is used\n\nAll IMAP4rev1 commands are supported by methods of the same\nname (in lower-case).\n\nAll arguments to commands are converted to strings, except for\nAUTHENTICATE, and the last argument to APPEND which is passed as\nan IMAP4 literal.  If necessary (the string contains any\nnon-printing characters or white-space and isn't enclosed with\neither parentheses or double quotes) each string is quoted.\nHowever, the 'password' argument to the LOGIN command is always\nquoted.  If you want to avoid having an argument string quoted\n(eg: the 'flags' argument to STORE) then enclose the string in\nparentheses (eg: \"(\\Deleted)\").\n\nEach command returns a tuple: (type, [data, ...]) where 'type'\nis usually 'OK' or 'NO', and 'data' is either the text from the\ntagged response, or untagged results from command. Each 'data'\nis either a string, or a tuple. If a tuple, then the first part\nis the header of the response, and the second part contains\nthe data (ie: 'literal' value).\n\nErrors raise the exception class <instance>.error(\"<reason>\").\nIMAP4 server errors raise <instance>.abort(\"<reason>\"),\nwhich is a sub-class of 'error'. Mailbox status changes\nfrom READ-WRITE to READ-ONLY raise the exception class\n<instance>.readonly(\"<reason>\"), which is a sub-class of 'abort'.\n\n\"error\" exceptions imply a program error.\n\"abort\" exceptions imply the connection should be reset, and\n        the command re-tried.\n\"readonly\" exceptions imply the command should be re-tried.\n\nNote: to use this module, you must read the RFCs pertaining to the\nIMAP4 protocol, as the semantics of the arguments to each IMAP4\ncommand are left to the invoker, not to mention the results. Also,\nmost IMAP servers implement a sub-set of the commands available here.",
      "relationships": []
    },
    {
      "id": "stdlib.imaplib.IMAP4_SSL",
      "name": "IMAP4_SSL",
      "module": "imaplib",
      "type": "class",
      "signature": "(host='', port=993, keyfile=None, certfile=None, ssl_context=None, timeout=None)",
      "description": "IMAP4 client class over SSL connection\n\nInstantiate with: IMAP4_SSL([host[, port[, keyfile[, certfile[, ssl_context[, timeout=None]]]]]])\n\n        host - host's name (default: localhost);\n        port - port number (default: standard IMAP4 SSL port);\n        keyfile - PEM formatted file that contains your private key (default: None);\n        certfile - PEM formatted certificate chain file (default: None);\n        ssl_context - a SSLContext object that contains your certificate chain\n                      and private key (default: None)\n        Note: if ssl_context is provided, then parameters keyfile or\n        certfile should not be set otherwise ValueError is raised.\n        timeout - socket timeout (default: None) If timeout is not given or is None,\n                  the global default socket timeout is used\n\nfor more documentation see the docstring of the parent class IMAP4.",
      "relationships": [
        {
          "target": "IMAP4",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.imaplib.IMAP4_stream",
      "name": "IMAP4_stream",
      "module": "imaplib",
      "type": "class",
      "signature": "(command)",
      "description": "IMAP4 client class over a stream\n\nInstantiate with: IMAP4_stream(command)\n\n        \"command\" - a string that can be passed to subprocess.Popen()\n\nfor more documentation see the docstring of the parent class IMAP4.",
      "relationships": [
        {
          "target": "IMAP4",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.imaplib.Int2AP",
      "name": "Int2AP",
      "module": "imaplib",
      "type": "function",
      "signature": "(num)",
      "description": "Convert integer to A-P string representation.",
      "relationships": [
        {
          "target": "stdlib.imaplib.int",
          "type": "calls"
        },
        {
          "target": "stdlib.imaplib.abs",
          "type": "calls"
        },
        {
          "target": "stdlib.imaplib.divmod",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.imaplib.Internaldate2tuple",
      "name": "Internaldate2tuple",
      "module": "imaplib",
      "type": "function",
      "signature": "(resp)",
      "description": "Parse an IMAP4 INTERNALDATE string.\n\nReturn corresponding local time.  The return value is a\ntime.struct_time tuple or None if the string has wrong format.",
      "relationships": [
        {
          "target": "stdlib.imaplib.match",
          "type": "calls"
        },
        {
          "target": "stdlib.imaplib.group",
          "type": "calls"
        },
        {
          "target": "stdlib.imaplib.int",
          "type": "calls"
        },
        {
          "target": "stdlib.imaplib.int",
          "type": "calls"
        },
        {
          "target": "stdlib.imaplib.int",
          "type": "calls"
        },
        {
          "target": "stdlib.imaplib.int",
          "type": "calls"
        },
        {
          "target": "stdlib.imaplib.int",
          "type": "calls"
        },
        {
          "target": "stdlib.imaplib.int",
          "type": "calls"
        },
        {
          "target": "stdlib.imaplib.int",
          "type": "calls"
        },
        {
          "target": "stdlib.imaplib.localtime",
          "type": "calls"
        },
        {
          "target": "stdlib.imaplib.group",
          "type": "calls"
        },
        {
          "target": "stdlib.imaplib.group",
          "type": "calls"
        },
        {
          "target": "stdlib.imaplib.group",
          "type": "calls"
        },
        {
          "target": "stdlib.imaplib.group",
          "type": "calls"
        },
        {
          "target": "stdlib.imaplib.group",
          "type": "calls"
        },
        {
          "target": "stdlib.imaplib.group",
          "type": "calls"
        },
        {
          "target": "stdlib.imaplib.group",
          "type": "calls"
        },
        {
          "target": "stdlib.imaplib.group",
          "type": "calls"
        },
        {
          "target": "stdlib.imaplib.timegm",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.imaplib.ParseFlags",
      "name": "ParseFlags",
      "module": "imaplib",
      "type": "function",
      "signature": "(resp)",
      "description": "Convert IMAP4 flags response to python tuple.",
      "relationships": [
        {
          "target": "stdlib.imaplib.match",
          "type": "calls"
        },
        {
          "target": "stdlib.imaplib.tuple",
          "type": "calls"
        },
        {
          "target": "stdlib.imaplib.split",
          "type": "calls"
        },
        {
          "target": "stdlib.imaplib.group",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.imaplib.Time2Internaldate",
      "name": "Time2Internaldate",
      "module": "imaplib",
      "type": "function",
      "signature": "(date_time)",
      "description": "Convert date_time to IMAP4 INTERNALDATE representation.\n\nReturn string in form: '\"DD-Mmm-YYYY HH:MM:SS +HHMM\"'.  The\ndate_time argument can be a number (int or float) representing\nseconds since epoch (as returned by time.time()), a 9-tuple\nrepresenting local time, an instance of time.struct_time (as\nreturned by time.localtime()), an aware datetime instance or a\ndouble-quoted string.  In the last case, it is assumed to already\nbe in the correct format.",
      "relationships": [
        {
          "target": "stdlib.imaplib.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.imaplib.format",
          "type": "calls"
        },
        {
          "target": "stdlib.imaplib.strftime",
          "type": "calls"
        },
        {
          "target": "stdlib.imaplib.astimezone",
          "type": "calls"
        },
        {
          "target": "stdlib.imaplib.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.imaplib.timedelta",
          "type": "calls"
        },
        {
          "target": "stdlib.imaplib.datetime",
          "type": "calls"
        },
        {
          "target": "stdlib.imaplib.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.imaplib.fromtimestamp",
          "type": "calls"
        },
        {
          "target": "stdlib.imaplib.timezone",
          "type": "calls"
        },
        {
          "target": "stdlib.imaplib.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.imaplib.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.imaplib.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.imaplib.localtime",
          "type": "calls"
        },
        {
          "target": "stdlib.imaplib.mktime",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.imghdr.PathLike",
      "name": "PathLike",
      "module": "imghdr",
      "type": "class",
      "signature": "()",
      "description": "Abstract base class for implementing the file system path protocol.",
      "relationships": [
        {
          "target": "ABC",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.imghdr.test",
      "name": "test",
      "module": "imghdr",
      "type": "function",
      "signature": "()",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.imghdr.testall",
          "type": "calls"
        },
        {
          "target": "stdlib.imghdr.testall",
          "type": "calls"
        },
        {
          "target": "stdlib.imghdr.write",
          "type": "calls"
        },
        {
          "target": "stdlib.imghdr.exit",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.imghdr.test_bmp",
      "name": "test_bmp",
      "module": "imghdr",
      "type": "function",
      "signature": "(h, f)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.imghdr.startswith",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.imghdr.test_exr",
      "name": "test_exr",
      "module": "imghdr",
      "type": "function",
      "signature": "(h, f)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.imghdr.startswith",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.imghdr.test_gif",
      "name": "test_gif",
      "module": "imghdr",
      "type": "function",
      "signature": "(h, f)",
      "description": "GIF ('87 and '89 variants)",
      "relationships": []
    },
    {
      "id": "stdlib.imghdr.test_jpeg",
      "name": "test_jpeg",
      "module": "imghdr",
      "type": "function",
      "signature": "(h, f)",
      "description": "JPEG data in JFIF or Exif format",
      "relationships": []
    },
    {
      "id": "stdlib.imghdr.test_pbm",
      "name": "test_pbm",
      "module": "imghdr",
      "type": "function",
      "signature": "(h, f)",
      "description": "PBM (portable bitmap)",
      "relationships": [
        {
          "target": "stdlib.imghdr.len",
          "type": "calls"
        },
        {
          "target": "stdlib.imghdr.ord",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.imghdr.test_pgm",
      "name": "test_pgm",
      "module": "imghdr",
      "type": "function",
      "signature": "(h, f)",
      "description": "PGM (portable graymap)",
      "relationships": [
        {
          "target": "stdlib.imghdr.len",
          "type": "calls"
        },
        {
          "target": "stdlib.imghdr.ord",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.imghdr.test_png",
      "name": "test_png",
      "module": "imghdr",
      "type": "function",
      "signature": "(h, f)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.imghdr.startswith",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.imghdr.test_ppm",
      "name": "test_ppm",
      "module": "imghdr",
      "type": "function",
      "signature": "(h, f)",
      "description": "PPM (portable pixmap)",
      "relationships": [
        {
          "target": "stdlib.imghdr.len",
          "type": "calls"
        },
        {
          "target": "stdlib.imghdr.ord",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.imghdr.test_rast",
      "name": "test_rast",
      "module": "imghdr",
      "type": "function",
      "signature": "(h, f)",
      "description": "Sun raster file",
      "relationships": [
        {
          "target": "stdlib.imghdr.startswith",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.imghdr.test_rgb",
      "name": "test_rgb",
      "module": "imghdr",
      "type": "function",
      "signature": "(h, f)",
      "description": "SGI image library",
      "relationships": [
        {
          "target": "stdlib.imghdr.startswith",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.imghdr.test_tiff",
      "name": "test_tiff",
      "module": "imghdr",
      "type": "function",
      "signature": "(h, f)",
      "description": "TIFF (can be in Motorola or Intel byte order)",
      "relationships": []
    },
    {
      "id": "stdlib.imghdr.test_webp",
      "name": "test_webp",
      "module": "imghdr",
      "type": "function",
      "signature": "(h, f)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.imghdr.startswith",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.imghdr.test_xbm",
      "name": "test_xbm",
      "module": "imghdr",
      "type": "function",
      "signature": "(h, f)",
      "description": "X bitmap (X10 or X11)",
      "relationships": [
        {
          "target": "stdlib.imghdr.startswith",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.imghdr.testall",
      "name": "testall",
      "module": "imghdr",
      "type": "function",
      "signature": "(list, recursive, toplevel)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.imghdr.isdir",
          "type": "calls"
        },
        {
          "target": "stdlib.imghdr.print",
          "type": "calls"
        },
        {
          "target": "stdlib.imghdr.print",
          "type": "calls"
        },
        {
          "target": "stdlib.imghdr.flush",
          "type": "calls"
        },
        {
          "target": "stdlib.imghdr.print",
          "type": "calls"
        },
        {
          "target": "stdlib.imghdr.glob",
          "type": "calls"
        },
        {
          "target": "stdlib.imghdr.testall",
          "type": "calls"
        },
        {
          "target": "stdlib.imghdr.print",
          "type": "calls"
        },
        {
          "target": "stdlib.imghdr.print",
          "type": "calls"
        },
        {
          "target": "stdlib.imghdr.join",
          "type": "calls"
        },
        {
          "target": "stdlib.imghdr.what",
          "type": "calls"
        },
        {
          "target": "stdlib.imghdr.print",
          "type": "calls"
        },
        {
          "target": "stdlib.imghdr.escape",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.imghdr.what",
      "name": "what",
      "module": "imghdr",
      "type": "function",
      "signature": "(file, h=None)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.imghdr.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.imghdr.tf",
          "type": "calls"
        },
        {
          "target": "stdlib.imghdr.close",
          "type": "calls"
        },
        {
          "target": "stdlib.imghdr.open",
          "type": "calls"
        },
        {
          "target": "stdlib.imghdr.read",
          "type": "calls"
        },
        {
          "target": "stdlib.imghdr.tell",
          "type": "calls"
        },
        {
          "target": "stdlib.imghdr.read",
          "type": "calls"
        },
        {
          "target": "stdlib.imghdr.seek",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.imp.NullImporter",
      "name": "NullImporter",
      "module": "imp",
      "type": "class",
      "signature": "(path)",
      "description": "**DEPRECATED**\n\nNull import object.",
      "relationships": []
    },
    {
      "id": "stdlib.imp.SourcelessFileLoader",
      "name": "SourcelessFileLoader",
      "module": "imp",
      "type": "class",
      "signature": "(fullname, path)",
      "description": "Loader which handles sourceless file imports.",
      "relationships": [
        {
          "target": "FileLoader",
          "type": "base_class"
        },
        {
          "target": "_LoaderBasics",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.imp.cache_from_source",
      "name": "cache_from_source",
      "module": "imp",
      "type": "function",
      "signature": "(path, debug_override=None)",
      "description": "**DEPRECATED**\n\nGiven the path to a .py file, return the path to its .pyc file.\n\nThe .py file does not need to exist; this simply returns the path to the\n.pyc file calculated as if the .py file were imported.\n\nIf debug_override is not None, then it must be a boolean and is used in\nplace of sys.flags.optimize.\n\nIf sys.implementation.cache_tag is None then NotImplementedError is raised.",
      "relationships": [
        {
          "target": "stdlib.imp.catch_warnings",
          "type": "calls"
        },
        {
          "target": "stdlib.imp.simplefilter",
          "type": "calls"
        },
        {
          "target": "stdlib.imp.cache_from_source",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.imp.find_module",
      "name": "find_module",
      "module": "imp",
      "type": "function",
      "signature": "(name, path=None)",
      "description": "**DEPRECATED**\n\nSearch for a module.\n\nIf path is omitted or None, search for a built-in, frozen or special\nmodule and continue search in sys.path. The module name cannot\ncontain '.'; to search for a submodule of a package, pass the\nsubmodule name and the package's __path__.",
      "relationships": [
        {
          "target": "stdlib.imp.open",
          "type": "calls"
        },
        {
          "target": "stdlib.imp.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.imp.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.imp.is_builtin",
          "type": "calls"
        },
        {
          "target": "stdlib.imp.join",
          "type": "calls"
        },
        {
          "target": "stdlib.imp.get_suffixes",
          "type": "calls"
        },
        {
          "target": "stdlib.imp.ImportError",
          "type": "calls"
        },
        {
          "target": "stdlib.imp.format",
          "type": "calls"
        },
        {
          "target": "stdlib.imp.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.imp.RuntimeError",
          "type": "calls"
        },
        {
          "target": "stdlib.imp.is_frozen",
          "type": "calls"
        },
        {
          "target": "stdlib.imp.join",
          "type": "calls"
        },
        {
          "target": "stdlib.imp.isfile",
          "type": "calls"
        },
        {
          "target": "stdlib.imp.join",
          "type": "calls"
        },
        {
          "target": "stdlib.imp.isfile",
          "type": "calls"
        },
        {
          "target": "stdlib.imp.format",
          "type": "calls"
        },
        {
          "target": "stdlib.imp.open",
          "type": "calls"
        },
        {
          "target": "stdlib.imp.type",
          "type": "calls"
        },
        {
          "target": "stdlib.imp.format",
          "type": "calls"
        },
        {
          "target": "stdlib.imp.detect_encoding",
          "type": "calls"
        },
        {
          "target": "stdlib.imp.type",
          "type": "calls"
        },
        {
          "target": "stdlib.imp.type",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.imp.get_magic",
      "name": "get_magic",
      "module": "imp",
      "type": "function",
      "signature": "()",
      "description": "**DEPRECATED**\n\nReturn the magic number for .pyc files.",
      "relationships": []
    },
    {
      "id": "stdlib.imp.get_suffixes",
      "name": "get_suffixes",
      "module": "imp",
      "type": "function",
      "signature": "()",
      "description": "**DEPRECATED**",
      "relationships": []
    },
    {
      "id": "stdlib.imp.get_tag",
      "name": "get_tag",
      "module": "imp",
      "type": "function",
      "signature": "()",
      "description": "Return the magic tag for .pyc files.",
      "relationships": []
    },
    {
      "id": "stdlib.imp.init_builtin",
      "name": "init_builtin",
      "module": "imp",
      "type": "function",
      "signature": "(name)",
      "description": "**DEPRECATED**\n\nLoad and return a built-in module by name, or None is such module doesn't\nexist",
      "relationships": [
        {
          "target": "stdlib.imp._builtin_from_name",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.imp.load_compiled",
      "name": "load_compiled",
      "module": "imp",
      "type": "function",
      "signature": "(name, pathname, file=None)",
      "description": "**DEPRECATED**",
      "relationships": [
        {
          "target": "stdlib.imp._LoadCompiledCompatibility",
          "type": "calls"
        },
        {
          "target": "stdlib.imp.spec_from_file_location",
          "type": "calls"
        },
        {
          "target": "stdlib.imp.SourcelessFileLoader",
          "type": "calls"
        },
        {
          "target": "stdlib.imp._exec",
          "type": "calls"
        },
        {
          "target": "stdlib.imp._load",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.imp.load_dynamic",
      "name": "load_dynamic",
      "module": "imp",
      "type": "function",
      "signature": "(name, path, file=None)",
      "description": "**DEPRECATED**\n\nLoad an extension module.",
      "relationships": [
        {
          "target": "stdlib.imp.ExtensionFileLoader",
          "type": "calls"
        },
        {
          "target": "stdlib.imp.ModuleSpec",
          "type": "calls"
        },
        {
          "target": "stdlib.imp._load",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.imp.load_module",
      "name": "load_module",
      "module": "imp",
      "type": "function",
      "signature": "(name, file, filename, details)",
      "description": "**DEPRECATED**\n\nLoad a module, given information returned by find_module().\n\nThe module name must include the full package name, if any.",
      "relationships": [
        {
          "target": "stdlib.imp.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.imp.format",
          "type": "calls"
        },
        {
          "target": "stdlib.imp.format",
          "type": "calls"
        },
        {
          "target": "stdlib.imp.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.imp.startswith",
          "type": "calls"
        },
        {
          "target": "stdlib.imp.load_source",
          "type": "calls"
        },
        {
          "target": "stdlib.imp.load_compiled",
          "type": "calls"
        },
        {
          "target": "stdlib.imp.load_dynamic",
          "type": "calls"
        },
        {
          "target": "stdlib.imp.load_package",
          "type": "calls"
        },
        {
          "target": "stdlib.imp.open",
          "type": "calls"
        },
        {
          "target": "stdlib.imp.load_dynamic",
          "type": "calls"
        },
        {
          "target": "stdlib.imp.init_builtin",
          "type": "calls"
        },
        {
          "target": "stdlib.imp.init_frozen",
          "type": "calls"
        },
        {
          "target": "stdlib.imp.format",
          "type": "calls"
        },
        {
          "target": "stdlib.imp.ImportError",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.imp.load_package",
      "name": "load_package",
      "module": "imp",
      "type": "function",
      "signature": "(name, path)",
      "description": "**DEPRECATED**",
      "relationships": [
        {
          "target": "stdlib.imp.isdir",
          "type": "calls"
        },
        {
          "target": "stdlib.imp.spec_from_file_location",
          "type": "calls"
        },
        {
          "target": "stdlib.imp._exec",
          "type": "calls"
        },
        {
          "target": "stdlib.imp._load",
          "type": "calls"
        },
        {
          "target": "stdlib.imp.join",
          "type": "calls"
        },
        {
          "target": "stdlib.imp.exists",
          "type": "calls"
        },
        {
          "target": "stdlib.imp.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.imp.format",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.imp.load_source",
      "name": "load_source",
      "module": "imp",
      "type": "function",
      "signature": "(name, pathname, file=None)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.imp._LoadSourceCompatibility",
          "type": "calls"
        },
        {
          "target": "stdlib.imp.spec_from_file_location",
          "type": "calls"
        },
        {
          "target": "stdlib.imp.SourceFileLoader",
          "type": "calls"
        },
        {
          "target": "stdlib.imp._exec",
          "type": "calls"
        },
        {
          "target": "stdlib.imp._load",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.imp.new_module",
      "name": "new_module",
      "module": "imp",
      "type": "function",
      "signature": "(name)",
      "description": "**DEPRECATED**\n\nCreate a new module.\n\nThe module is not entered into sys.modules.",
      "relationships": [
        {
          "target": "stdlib.imp.ModuleType",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.imp.reload",
      "name": "reload",
      "module": "imp",
      "type": "function",
      "signature": "(module)",
      "description": "**DEPRECATED**\n\nReload the module and return it.\n\nThe module must have been successfully imported before.",
      "relationships": [
        {
          "target": "stdlib.imp.reload",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.imp.source_from_cache",
      "name": "source_from_cache",
      "module": "imp",
      "type": "function",
      "signature": "(path)",
      "description": "**DEPRECATED**\n\nGiven the path to a .pyc. file, return the path to its .py file.\n\nThe .pyc file does not need to exist; this simply returns the path to\nthe .py file calculated to correspond to the .pyc file.  If path does\nnot conform to PEP 3147 format, ValueError will be raised. If\nsys.implementation.cache_tag is None then NotImplementedError is raised.",
      "relationships": [
        {
          "target": "stdlib.imp.source_from_cache",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.importlib.find_loader",
      "name": "find_loader",
      "module": "importlib",
      "type": "function",
      "signature": "(name, path=None)",
      "description": "Return the loader for the specified module.\n\nThis is a backward-compatible wrapper around find_spec().\n\nThis function is deprecated in favor of importlib.util.find_spec().",
      "relationships": [
        {
          "target": "stdlib.importlib.warn",
          "type": "calls"
        },
        {
          "target": "stdlib.importlib._find_spec",
          "type": "calls"
        },
        {
          "target": "stdlib.importlib.ImportError",
          "type": "calls"
        },
        {
          "target": "stdlib.importlib.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.importlib.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.importlib.ImportError",
          "type": "calls"
        },
        {
          "target": "stdlib.importlib.format",
          "type": "calls"
        },
        {
          "target": "stdlib.importlib.format",
          "type": "calls"
        },
        {
          "target": "stdlib.importlib.format",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.importlib.import_module",
      "name": "import_module",
      "module": "importlib",
      "type": "function",
      "signature": "(name, package=None)",
      "description": "Import a module.\n\nThe 'package' argument is required when performing a relative import. It\nspecifies the package to use as the anchor point from which to resolve the\nrelative import to an absolute import.",
      "relationships": [
        {
          "target": "stdlib.importlib.startswith",
          "type": "calls"
        },
        {
          "target": "stdlib.importlib._gcd_import",
          "type": "calls"
        },
        {
          "target": "stdlib.importlib.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.importlib.format",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.importlib.invalidate_caches",
      "name": "invalidate_caches",
      "module": "importlib",
      "type": "function",
      "signature": "()",
      "description": "Call the invalidate_caches() method on all meta path finders stored in\nsys.meta_path (where implemented).",
      "relationships": [
        {
          "target": "stdlib.importlib.hasattr",
          "type": "calls"
        },
        {
          "target": "stdlib.importlib.invalidate_caches",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.importlib.reload",
      "name": "reload",
      "module": "importlib",
      "type": "function",
      "signature": "(module)",
      "description": "Reload the module and return it.\n\nThe module must have been successfully imported before.",
      "relationships": [
        {
          "target": "stdlib.importlib.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.importlib.get",
          "type": "calls"
        },
        {
          "target": "stdlib.importlib.ImportError",
          "type": "calls"
        },
        {
          "target": "stdlib.importlib._find_spec",
          "type": "calls"
        },
        {
          "target": "stdlib.importlib._exec",
          "type": "calls"
        },
        {
          "target": "stdlib.importlib.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.importlib.format",
          "type": "calls"
        },
        {
          "target": "stdlib.importlib.rpartition",
          "type": "calls"
        },
        {
          "target": "stdlib.importlib.ModuleNotFoundError",
          "type": "calls"
        },
        {
          "target": "stdlib.importlib.ImportError",
          "type": "calls"
        },
        {
          "target": "stdlib.importlib.format",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.ArgInfo",
      "name": "ArgInfo",
      "module": "inspect",
      "type": "class",
      "signature": "(args, varargs, keywords, locals)",
      "description": "ArgInfo(args, varargs, keywords, locals)",
      "relationships": [
        {
          "target": "tuple",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.inspect.ArgSpec",
      "name": "ArgSpec",
      "module": "inspect",
      "type": "class",
      "signature": "(args, varargs, keywords, defaults)",
      "description": "ArgSpec(args, varargs, keywords, defaults)",
      "relationships": [
        {
          "target": "tuple",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.inspect.Arguments",
      "name": "Arguments",
      "module": "inspect",
      "type": "class",
      "signature": "(args, varargs, varkw)",
      "description": "Arguments(args, varargs, varkw)",
      "relationships": [
        {
          "target": "tuple",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.inspect.Attribute",
      "name": "Attribute",
      "module": "inspect",
      "type": "class",
      "signature": "(name, kind, defining_class, object)",
      "description": "Attribute(name, kind, defining_class, object)",
      "relationships": [
        {
          "target": "tuple",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.inspect.BlockFinder",
      "name": "BlockFinder",
      "module": "inspect",
      "type": "class",
      "signature": "()",
      "description": "Provide a tokeneater() method to detect the end of a code block.",
      "relationships": []
    },
    {
      "id": "stdlib.inspect.BoundArguments",
      "name": "BoundArguments",
      "module": "inspect",
      "type": "class",
      "signature": "(signature, arguments)",
      "description": "Result of `Signature.bind` call.  Holds the mapping of arguments\nto the function's parameters.\n\nHas the following public attributes:\n\n* arguments : dict\n    An ordered mutable mapping of parameters' names to arguments' values.\n    Does not contain arguments' default values.\n* signature : Signature\n    The Signature object that created this instance.\n* args : tuple\n    Tuple of positional arguments values.\n* kwargs : dict\n    Dict of keyword arguments values.",
      "relationships": []
    },
    {
      "id": "stdlib.inspect.ClosureVars",
      "name": "ClosureVars",
      "module": "inspect",
      "type": "class",
      "signature": "(nonlocals, globals, builtins, unbound)",
      "description": "ClosureVars(nonlocals, globals, builtins, unbound)",
      "relationships": [
        {
          "target": "tuple",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.inspect.FrameInfo",
      "name": "FrameInfo",
      "module": "inspect",
      "type": "class",
      "signature": "(frame, filename, lineno, function, code_context, index)",
      "description": "FrameInfo(frame, filename, lineno, function, code_context, index)",
      "relationships": [
        {
          "target": "tuple",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.inspect.FullArgSpec",
      "name": "FullArgSpec",
      "module": "inspect",
      "type": "class",
      "signature": "(args, varargs, varkw, defaults, kwonlyargs, kwonlydefaults, annotations)",
      "description": "FullArgSpec(args, varargs, varkw, defaults, kwonlyargs, kwonlydefaults, annotations)",
      "relationships": [
        {
          "target": "tuple",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.inspect.Parameter",
      "name": "Parameter",
      "module": "inspect",
      "type": "class",
      "signature": "(name, kind, *, default, annotation)",
      "description": "Represents a parameter in a function signature.\n\nHas the following public attributes:\n\n* name : str\n    The name of the parameter as a string.\n* default : object\n    The default value for the parameter if specified.  If the\n    parameter has no default value, this attribute is set to\n    `Parameter.empty`.\n* annotation\n    The annotation for the parameter if specified.  If the\n    parameter has no annotation, this attribute is set to\n    `Parameter.empty`.\n* kind : str\n    Describes how argument values are bound to the parameter.\n    Possible values: `Parameter.POSITIONAL_ONLY`,\n    `Parameter.POSITIONAL_OR_KEYWORD`, `Parameter.VAR_POSITIONAL`,\n    `Parameter.KEYWORD_ONLY`, `Parameter.VAR_KEYWORD`.",
      "relationships": []
    },
    {
      "id": "stdlib.inspect.Signature",
      "name": "Signature",
      "module": "inspect",
      "type": "class",
      "signature": "(parameters=None, *, return_annotation, __validate_parameters__=True)",
      "description": "A Signature object represents the overall signature of a function.\nIt stores a Parameter object for each parameter accepted by the\nfunction, as well as information specific to the function itself.\n\nA Signature object has the following public attributes and methods:\n\n* parameters : OrderedDict\n    An ordered mapping of parameters' names to the corresponding\n    Parameter objects (keyword-only arguments are in the same order\n    as listed in `code.co_varnames`).\n* return_annotation : object\n    The annotation for the return type of the function if specified.\n    If the function has no annotation for its return type, this\n    attribute is set to `Signature.empty`.\n* bind(*args, **kwargs) -> BoundArguments\n    Creates a mapping from positional and keyword arguments to\n    parameters.\n* bind_partial(*args, **kwargs) -> BoundArguments\n    Creates a partial mapping from positional and keyword arguments\n    to parameters (simulating 'functools.partial' behavior.)",
      "relationships": []
    },
    {
      "id": "stdlib.inspect.Traceback",
      "name": "Traceback",
      "module": "inspect",
      "type": "class",
      "signature": "(filename, lineno, function, code_context, index)",
      "description": "Traceback(filename, lineno, function, code_context, index)",
      "relationships": [
        {
          "target": "tuple",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.inspect.classify_class_attrs",
      "name": "classify_class_attrs",
      "module": "inspect",
      "type": "function",
      "signature": "(cls)",
      "description": "Return list of attribute-descriptor tuples.\n\nFor each name in dir(cls), the return list contains a 4-tuple\nwith these elements:\n\n    0. The name (a string).\n\n    1. The kind of attribute this is, one of these strings:\n           'class method'    created via classmethod()\n           'static method'   created via staticmethod()\n           'property'        created via property()\n           'method'          any other flavor of method or descriptor\n           'data'            not a method\n\n    2. The class which defined this attribute (a class).\n\n    3. The object as obtained by calling getattr; if this fails, or if the\n       resulting object does not live anywhere in the class' mro (including\n       metaclasses) then the object is looked up in the defining class's\n       dict (found by walking the mro).\n\nIf one of the items in dir(cls) is stored in the metaclass it will now\nbe discovered and not have None be listed as the class in which it was\ndefined.  Any items whose home class cannot be discovered are skipped.",
      "relationships": [
        {
          "target": "stdlib.inspect.getmro",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.getmro",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.tuple",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.dir",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.set",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.type",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.items",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.append",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.add",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.Attribute",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.append",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.getattr",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.getattr",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.Exception",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.isroutine",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.getattr",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.__getattr__",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.cleandoc",
      "name": "cleandoc",
      "module": "inspect",
      "type": "function",
      "signature": "(doc)",
      "description": "Clean up indentation from docstrings.\n\nAny whitespace that can be uniformly removed from the second line\nonwards is removed.",
      "relationships": [
        {
          "target": "stdlib.inspect.split",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.join",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.len",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.lstrip",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.range",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.pop",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.pop",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.expandtabs",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.lstrip",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.min",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.len",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.len",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.currentframe",
      "name": "currentframe",
      "module": "inspect",
      "type": "function",
      "signature": "()",
      "description": "Return the frame of the caller or None if this is not possible.",
      "relationships": [
        {
          "target": "stdlib.inspect.hasattr",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect._getframe",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.findsource",
      "name": "findsource",
      "module": "inspect",
      "type": "function",
      "signature": "(object)",
      "description": "Return the entire source file and starting line number for an object.\n\nThe argument may be a module, class, method, function, traceback, frame,\nor code object.  The source code is returned as a list of all the lines\nin the file and the line number indexes a line in that list.  An OSError\nis raised if the source code cannot be retrieved.",
      "relationships": [
        {
          "target": "stdlib.inspect.getsourcefile",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.getmodule",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.ismodule",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.isclass",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.ismethod",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.isfunction",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.istraceback",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.isframe",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.iscode",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.OSError",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.checkcache",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.getfile",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.getlines",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.getlines",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.OSError",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.join",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.parse",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect._ClassFinder",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.compile",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.OSError",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.visit",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.OSError",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.hasattr",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.OSError",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.match",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.startswith",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.endswith",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.OSError",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.formatannotation",
      "name": "formatannotation",
      "module": "inspect",
      "type": "function",
      "signature": "(annotation, base_module=None)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.inspect.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.repr",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.getattr",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.replace",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.repr",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.formatannotationrelativeto",
      "name": "formatannotationrelativeto",
      "module": "inspect",
      "type": "function",
      "signature": "(object)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.inspect.getattr",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.formatannotation",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.formatargspec",
      "name": "formatargspec",
      "module": "inspect",
      "type": "function",
      "signature": "(args, varargs=None, varkw=None, defaults=None, kwonlyargs=(), kwonlydefaults={}, annotations={}, formatarg=<class 'str'>, formatvarargs=<function <lambda> at 0x1037683a0>, formatvarkw=<function <lambda> at 0x103768430>, formatvalue=<function <lambda> at 0x1037684c0>, formatreturns=<function <lambda> at 0x103768550>, formatannotation=<function formatannotation at 0x103768280>)",
      "description": "Format an argument spec from the values returned by getfullargspec.\n\nThe first seven arguments are (args, varargs, varkw, defaults,\nkwonlyargs, kwonlydefaults, annotations).  The other five arguments\nare the corresponding optional formatting functions that are called to\nturn names and values into strings.  The last argument is an optional\nfunction to format the sequence of arguments.\n\nDeprecated since Python 3.5: use the `signature` function and `Signature`\nobjects.",
      "relationships": [
        {
          "target": "stdlib.inspect.warn",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.enumerate",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.formatarg",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.formatargandannotation",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.append",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.append",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.append",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.formatreturns",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.repr",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.len",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.len",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.formatvarargs",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.append",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.formatargandannotation",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.append",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.formatvarkw",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.join",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.formatannotation",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.formatannotation",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.formatvalue",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.formatargandannotation",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.formatvalue",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.formatargandannotation",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.formatargvalues",
      "name": "formatargvalues",
      "module": "inspect",
      "type": "function",
      "signature": "(args, varargs, varkw, locals, formatarg=<class 'str'>, formatvarargs=<function <lambda> at 0x103768700>, formatvarkw=<function <lambda> at 0x103768790>, formatvalue=<function <lambda> at 0x103768820>)",
      "description": "Format an argument spec from the 4 values returned by getargvalues.\n\nThe first four arguments are (args, varargs, varkw, locals).  The\nnext four arguments are the corresponding optional formatting functions\nthat are called to turn names and values into strings.  The ninth\nargument is an optional function to format the sequence of arguments.",
      "relationships": [
        {
          "target": "stdlib.inspect.range",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.len",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.append",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.append",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.append",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.repr",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.formatarg",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.formatvalue",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.convert",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.join",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.formatvarargs",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.formatvalue",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.formatvarkw",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.formatvalue",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.getabsfile",
      "name": "getabsfile",
      "module": "inspect",
      "type": "function",
      "signature": "(object, _filename=None)",
      "description": "Return an absolute path to the source or compiled file for an object.\n\nThe idea is for each object to have a unique origin, so this routine\nnormalizes the result as much as possible.",
      "relationships": [
        {
          "target": "stdlib.inspect.normcase",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.abspath",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.getsourcefile",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.getfile",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.getargs",
      "name": "getargs",
      "module": "inspect",
      "type": "function",
      "signature": "(co)",
      "description": "Get information about the arguments accepted by a code object.\n\nThree things are returned: (args, varargs, varkw), where\n'args' is the list of argument names. Keyword-only arguments are\nappended. 'varargs' and 'varkw' are the names of the * and **\narguments or None.",
      "relationships": [
        {
          "target": "stdlib.inspect.list",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.list",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.Arguments",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.iscode",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.format",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.getargspec",
      "name": "getargspec",
      "module": "inspect",
      "type": "function",
      "signature": "(func)",
      "description": "Get the names and default values of a function's parameters.\n\nA tuple of four things is returned: (args, varargs, keywords, defaults).\n'args' is a list of the argument names, including keyword-only argument names.\n'varargs' and 'keywords' are the names of the * and ** parameters or None.\n'defaults' is an n-tuple of the default values of the last n parameters.\n\nThis function is deprecated, as it does not support annotations or\nkeyword-only parameters and will raise ValueError if either is present\non the supplied callable.\n\nFor a more structured introspection API, use inspect.signature() instead.\n\nAlternatively, use getfullargspec() for an API with a similar namedtuple\nbased interface, but full support for annotations and keyword-only\nparameters.\n\nDeprecated since Python 3.5, use `inspect.getfullargspec()`.",
      "relationships": [
        {
          "target": "stdlib.inspect.warn",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.getfullargspec",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.ArgSpec",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.ValueError",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.getargvalues",
      "name": "getargvalues",
      "module": "inspect",
      "type": "function",
      "signature": "(frame)",
      "description": "Get information about arguments passed into a particular frame.\n\nA tuple of four things is returned: (args, varargs, varkw, locals).\n'args' is a list of the argument names.\n'varargs' and 'varkw' are the names of the * and ** arguments or None.\n'locals' is the locals dictionary of the given frame.",
      "relationships": [
        {
          "target": "stdlib.inspect.getargs",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.ArgInfo",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.getattr_static",
      "name": "getattr_static",
      "module": "inspect",
      "type": "function",
      "signature": "(obj, attr, default=<object object at 0x102f707a0>)",
      "description": "Retrieve attributes without triggering dynamic lookup via the\ndescriptor protocol,  __getattr__ or __getattribute__.\n\nNote: this function may not be able to retrieve all attributes\nthat getattr can fetch (like dynamically created attributes)\nand may find attributes that getattr can't (like descriptors\nthat raise AttributeError). It can also return descriptor objects\ninstead of instance members in some cases. See the\ndocumentation for details.",
      "relationships": [
        {
          "target": "stdlib.inspect._check_class",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.AttributeError",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect._is_type",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.type",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect._shadowed_dict",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect._static_getmro",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect._check_instance",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.type",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.type",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect._check_class",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect._check_class",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect._shadowed_dict",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.type",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.type",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.type",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.getblock",
      "name": "getblock",
      "module": "inspect",
      "type": "function",
      "signature": "(lines)",
      "description": "Extract the block of code at the top of the given list of lines.",
      "relationships": [
        {
          "target": "stdlib.inspect.BlockFinder",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.generate_tokens",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.tokeneater",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.iter",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.getcallargs",
      "name": "getcallargs",
      "module": "inspect",
      "type": "function",
      "signature": "(func, /, *positional, **named)",
      "description": "Get the mapping of arguments to values.\n\nA dict is returned, with keys the function argument names (including the\nnames of the * and ** arguments, if any), and values the respective bound\nvalues from 'positional' and 'named'.",
      "relationships": [
        {
          "target": "stdlib.inspect.getfullargspec",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.len",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.len",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.min",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.range",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.set",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.items",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.ismethod",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.len",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.tuple",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect._too_many",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.enumerate",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect._missing_arguments",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect._missing_arguments",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.getclasstree",
      "name": "getclasstree",
      "module": "inspect",
      "type": "function",
      "signature": "(classes, unique=False)",
      "description": "Arrange the given list of classes into a hierarchy of nested lists.\n\nWhere a nested list appears, it contains classes derived from the class\nwhose entry immediately precedes the list.  Each entry is a 2-tuple\ncontaining a class and a tuple of its base classes.  If the 'unique'\nargument is true, exactly one entry appears in the returned structure\nfor each class in the given list.  Otherwise, classes using multiple\ninheritance and their descendants will appear multiple times.",
      "relationships": [
        {
          "target": "stdlib.inspect.walktree",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.append",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.append",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.append",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.getclosurevars",
      "name": "getclosurevars",
      "module": "inspect",
      "type": "function",
      "signature": "(func)",
      "description": "Get the mapping of free variables to their current values.\n\nReturns a named tuple of dicts mapping the current nonlocal, global\nand builtin references as seen by the body of the function. A final\nset of unbound names that could not be resolved is also provided.",
      "relationships": [
        {
          "target": "stdlib.inspect.ismethod",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.get",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.ismodule",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.set",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.ClosureVars",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.isfunction",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.format",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.zip",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.add",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.getcomments",
      "name": "getcomments",
      "module": "inspect",
      "type": "function",
      "signature": "(object)",
      "description": "Get lines of comments immediately preceding an object's source code.\n\nReturns None when source can't be found.",
      "relationships": [
        {
          "target": "stdlib.inspect.ismodule",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.findsource",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.join",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.indentsize",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.len",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.strip",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.len",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.append",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.join",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.len",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.expandtabs",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.indentsize",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.lstrip",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.lstrip",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.lstrip",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.lstrip",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.strip",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.strip",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.expandtabs",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.expandtabs",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.indentsize",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.expandtabs",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.getcoroutinelocals",
      "name": "getcoroutinelocals",
      "module": "inspect",
      "type": "function",
      "signature": "(coroutine)",
      "description": "Get the mapping of coroutine local variables to their current values.\n\nA dict is returned, with the keys the local variable names and values the\nbound values.",
      "relationships": [
        {
          "target": "stdlib.inspect.getattr",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.getcoroutinestate",
      "name": "getcoroutinestate",
      "module": "inspect",
      "type": "function",
      "signature": "(coroutine)",
      "description": "Get current state of a coroutine object.\n\nPossible states are:\n  CORO_CREATED: Waiting to start execution.\n  CORO_RUNNING: Currently being executed by the interpreter.\n  CORO_SUSPENDED: Currently suspended at an await expression.\n  CORO_CLOSED: Execution has completed.",
      "relationships": []
    },
    {
      "id": "stdlib.inspect.getdoc",
      "name": "getdoc",
      "module": "inspect",
      "type": "function",
      "signature": "(object)",
      "description": "Get the documentation string for an object.\n\nAll tabs are expanded to spaces.  To clean up docstrings that are\nindented to line up with blocks of code, any whitespace than can be\nuniformly removed from the second line onwards is removed.",
      "relationships": [
        {
          "target": "stdlib.inspect.cleandoc",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect._finddoc",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.getfile",
      "name": "getfile",
      "module": "inspect",
      "type": "function",
      "signature": "(object)",
      "description": "Work out which source or compiled file an object was defined in.",
      "relationships": [
        {
          "target": "stdlib.inspect.ismodule",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.isclass",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.ismethod",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.isfunction",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.istraceback",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.isframe",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.iscode",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.getattr",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.hasattr",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.format",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.format",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.get",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.getattr",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.format",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.type",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.getframeinfo",
      "name": "getframeinfo",
      "module": "inspect",
      "type": "function",
      "signature": "(frame, context=1)",
      "description": "Get information about a frame or traceback object.\n\nA tuple of five things is returned: the filename, the line number of\nthe current line, the function name, a list of lines of context from\nthe source code, and the index of the current line within that list.\nThe optional second argument specifies the number of lines of context\nto return, which are centered around the current line.",
      "relationships": [
        {
          "target": "stdlib.inspect.istraceback",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.Traceback",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.isframe",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.getsourcefile",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.getfile",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.format",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.findsource",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.max",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.min",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.len",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.getfullargspec",
      "name": "getfullargspec",
      "module": "inspect",
      "type": "function",
      "signature": "(func)",
      "description": "Get the names and default values of a callable object's parameters.\n\nA tuple of seven things is returned:\n(args, varargs, varkw, defaults, kwonlyargs, kwonlydefaults, annotations).\n'args' is a list of the parameter names.\n'varargs' and 'varkw' are the names of the * and ** parameters or None.\n'defaults' is an n-tuple of the default values of the last n parameters.\n'kwonlyargs' is a list of keyword-only parameter names.\n'kwonlydefaults' is a dictionary mapping names from kwonlyargs to defaults.\n'annotations' is a dictionary mapping parameter names to annotations.\n\nNotable differences from inspect.signature():\n  - the \"self\" parameter is always reported, even for bound methods\n  - wrapper chains defined by __wrapped__ *not* unwrapped automatically",
      "relationships": [
        {
          "target": "stdlib.inspect.values",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.FullArgSpec",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect._signature_from_callable",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.append",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.append",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.append",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.getgeneratorlocals",
      "name": "getgeneratorlocals",
      "module": "inspect",
      "type": "function",
      "signature": "(generator)",
      "description": "Get the mapping of generator local variables to their current values.\n\nA dict is returned, with the keys the local variable names and values the\nbound values.",
      "relationships": [
        {
          "target": "stdlib.inspect.getattr",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.isgenerator",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.format",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.getgeneratorstate",
      "name": "getgeneratorstate",
      "module": "inspect",
      "type": "function",
      "signature": "(generator)",
      "description": "Get current state of a generator-iterator.\n\nPossible states are:\n  GEN_CREATED: Waiting to start execution.\n  GEN_RUNNING: Currently being executed by the interpreter.\n  GEN_SUSPENDED: Currently suspended at a yield expression.\n  GEN_CLOSED: Execution has completed.",
      "relationships": []
    },
    {
      "id": "stdlib.inspect.getinnerframes",
      "name": "getinnerframes",
      "module": "inspect",
      "type": "function",
      "signature": "(tb, context=1)",
      "description": "Get a list of records for a traceback's frame and all lower frames.\n\nEach record contains a frame object, filename, line number, function\nname, a list of lines of context, and index within the context.",
      "relationships": [
        {
          "target": "stdlib.inspect.append",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.getframeinfo",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.FrameInfo",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.getlineno",
      "name": "getlineno",
      "module": "inspect",
      "type": "function",
      "signature": "(frame)",
      "description": "Get the line number from a frame object, allowing for optimization.",
      "relationships": []
    },
    {
      "id": "stdlib.inspect.getmembers",
      "name": "getmembers",
      "module": "inspect",
      "type": "function",
      "signature": "(object, predicate=None)",
      "description": "Return all members of an object as (name, value) pairs sorted by name.\nOptionally, only return members that satisfy a given predicate.",
      "relationships": [
        {
          "target": "stdlib.inspect.isclass",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.set",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.dir",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.sort",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.add",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.getmro",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.items",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.getattr",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.predicate",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.append",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.append",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.getmodule",
      "name": "getmodule",
      "module": "inspect",
      "type": "function",
      "signature": "(object, _filename=None)",
      "description": "Return the module an object was defined in, or None if not found.",
      "relationships": [
        {
          "target": "stdlib.inspect.ismodule",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.hasattr",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.items",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.hasattr",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.hasattr",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.get",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.get",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.getabsfile",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.get",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.get",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.hasattr",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.getattr",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.getattr",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.copy",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.ismodule",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.hasattr",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.getabsfile",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.get",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.realpath",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.getmodulename",
      "name": "getmodulename",
      "module": "inspect",
      "type": "function",
      "signature": "(path)",
      "description": "Return the module name for a given file, or None.",
      "relationships": [
        {
          "target": "stdlib.inspect.basename",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.sort",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.endswith",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.all_suffixes",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.len",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.getmro",
      "name": "getmro",
      "module": "inspect",
      "type": "function",
      "signature": "(cls)",
      "description": "Return tuple of base classes (including cls) in method resolution order.",
      "relationships": []
    },
    {
      "id": "stdlib.inspect.getouterframes",
      "name": "getouterframes",
      "module": "inspect",
      "type": "function",
      "signature": "(frame, context=1)",
      "description": "Get a list of records for a frame and all higher (calling) frames.\n\nEach record contains a frame object, filename, line number, function\nname, a list of lines of context, and index within the context.",
      "relationships": [
        {
          "target": "stdlib.inspect.append",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.getframeinfo",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.FrameInfo",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.getsource",
      "name": "getsource",
      "module": "inspect",
      "type": "function",
      "signature": "(object)",
      "description": "Return the text of the source code for an object.\n\nThe argument may be a module, class, method, function, traceback, frame,\nor code object.  The source code is returned as a single string.  An\nOSError is raised if the source code cannot be retrieved.",
      "relationships": [
        {
          "target": "stdlib.inspect.getsourcelines",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.join",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.getsourcefile",
      "name": "getsourcefile",
      "module": "inspect",
      "type": "function",
      "signature": "(object)",
      "description": "Return the filename that can be used to locate an object's source.\nReturn None if no way can be identified to get the source.",
      "relationships": [
        {
          "target": "stdlib.inspect.getfile",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.any",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.exists",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.any",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.getattr",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.endswith",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.getmodule",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.splitext",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.endswith",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.getsourcelines",
      "name": "getsourcelines",
      "module": "inspect",
      "type": "function",
      "signature": "(object)",
      "description": "Return a list of source lines and starting line number for an object.\n\nThe argument may be a module, class, method, function, traceback, frame,\nor code object.  The source code is returned as a list of the lines\ncorresponding to the object and the line number indicates where in the\noriginal source file the first line of code was found.  An OSError is\nraised if the source code cannot be retrieved.",
      "relationships": [
        {
          "target": "stdlib.inspect.unwrap",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.findsource",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.istraceback",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.ismodule",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.isframe",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.getblock",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.indentsize",
      "name": "indentsize",
      "module": "inspect",
      "type": "function",
      "signature": "(line)",
      "description": "Return the indent size, in spaces, at the start of a line of text.",
      "relationships": [
        {
          "target": "stdlib.inspect.expandtabs",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.len",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.len",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.lstrip",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.isabstract",
      "name": "isabstract",
      "module": "inspect",
      "type": "function",
      "signature": "(object)",
      "description": "Return true if the object is an abstract base class (ABC).",
      "relationships": [
        {
          "target": "stdlib.inspect.hasattr",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.items",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.issubclass",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.getattr",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.getattr",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.type",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.getattr",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.getattr",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.isasyncgen",
      "name": "isasyncgen",
      "module": "inspect",
      "type": "function",
      "signature": "(object)",
      "description": "Return true if the object is an asynchronous generator.",
      "relationships": [
        {
          "target": "stdlib.inspect.isinstance",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.isasyncgenfunction",
      "name": "isasyncgenfunction",
      "module": "inspect",
      "type": "function",
      "signature": "(obj)",
      "description": "Return true if the object is an asynchronous generator function.\n\nAsynchronous generator functions are defined with \"async def\"\nsyntax and have \"yield\" expressions in their body.",
      "relationships": [
        {
          "target": "stdlib.inspect._has_code_flag",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.isawaitable",
      "name": "isawaitable",
      "module": "inspect",
      "type": "function",
      "signature": "(object)",
      "description": "Return true if object can be passed to an ``await`` expression.",
      "relationships": [
        {
          "target": "stdlib.inspect.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.bool",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.isbuiltin",
      "name": "isbuiltin",
      "module": "inspect",
      "type": "function",
      "signature": "(object)",
      "description": "Return true if the object is a built-in function or method.\n\nBuilt-in functions and methods provide these attributes:\n    __doc__         documentation string\n    __name__        original name of this function or method\n    __self__        instance to which a method is bound, or None",
      "relationships": [
        {
          "target": "stdlib.inspect.isinstance",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.isclass",
      "name": "isclass",
      "module": "inspect",
      "type": "function",
      "signature": "(object)",
      "description": "Return true if the object is a class.\n\nClass objects provide these attributes:\n    __doc__         documentation string\n    __module__      name of module in which this class was defined",
      "relationships": [
        {
          "target": "stdlib.inspect.isinstance",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.iscode",
      "name": "iscode",
      "module": "inspect",
      "type": "function",
      "signature": "(object)",
      "description": "Return true if the object is a code object.\n\nCode objects provide these attributes:\n    co_argcount         number of arguments (not including *, ** args\n                        or keyword only arguments)\n    co_code             string of raw compiled bytecode\n    co_cellvars         tuple of names of cell variables\n    co_consts           tuple of constants used in the bytecode\n    co_filename         name of file in which this code object was created\n    co_firstlineno      number of first line in Python source code\n    co_flags            bitmap: 1=optimized | 2=newlocals | 4=*arg | 8=**arg\n                        | 16=nested | 32=generator | 64=nofree | 128=coroutine\n                        | 256=iterable_coroutine | 512=async_generator\n    co_freevars         tuple of names of free variables\n    co_posonlyargcount  number of positional only arguments\n    co_kwonlyargcount   number of keyword only arguments (not including ** arg)\n    co_lnotab           encoded mapping of line numbers to bytecode indices\n    co_name             name with which this code object was defined\n    co_names            tuple of names of local variables\n    co_nlocals          number of local variables\n    co_stacksize        virtual machine stack space required\n    co_varnames         tuple of names of arguments and local variables",
      "relationships": [
        {
          "target": "stdlib.inspect.isinstance",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.iscoroutine",
      "name": "iscoroutine",
      "module": "inspect",
      "type": "function",
      "signature": "(object)",
      "description": "Return true if the object is a coroutine.",
      "relationships": [
        {
          "target": "stdlib.inspect.isinstance",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.iscoroutinefunction",
      "name": "iscoroutinefunction",
      "module": "inspect",
      "type": "function",
      "signature": "(obj)",
      "description": "Return true if the object is a coroutine function.\n\nCoroutine functions are defined with \"async def\" syntax.",
      "relationships": [
        {
          "target": "stdlib.inspect._has_code_flag",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.isdatadescriptor",
      "name": "isdatadescriptor",
      "module": "inspect",
      "type": "function",
      "signature": "(object)",
      "description": "Return true if the object is a data descriptor.\n\nData descriptors have a __set__ or a __delete__ attribute.  Examples are\nproperties (defined in Python) and getsets and members (defined in C).\nTypically, data descriptors will also have __name__ and __doc__ attributes\n(properties, getsets, and members have both of these attributes), but this\nis not guaranteed.",
      "relationships": [
        {
          "target": "stdlib.inspect.type",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.isclass",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.ismethod",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.isfunction",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.hasattr",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.hasattr",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.isframe",
      "name": "isframe",
      "module": "inspect",
      "type": "function",
      "signature": "(object)",
      "description": "Return true if the object is a frame object.\n\nFrame objects provide these attributes:\n    f_back          next outer frame object (this frame's caller)\n    f_builtins      built-in namespace seen by this frame\n    f_code          code object being executed in this frame\n    f_globals       global namespace seen by this frame\n    f_lasti         index of last attempted instruction in bytecode\n    f_lineno        current line number in Python source code\n    f_locals        local namespace seen by this frame\n    f_trace         tracing function for this frame, or None",
      "relationships": [
        {
          "target": "stdlib.inspect.isinstance",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.isfunction",
      "name": "isfunction",
      "module": "inspect",
      "type": "function",
      "signature": "(object)",
      "description": "Return true if the object is a user-defined function.\n\nFunction objects provide these attributes:\n    __doc__         documentation string\n    __name__        name with which this function was defined\n    __code__        code object containing compiled function bytecode\n    __defaults__    tuple of any default values for arguments\n    __globals__     global namespace in which this function was defined\n    __annotations__ dict of parameter annotations\n    __kwdefaults__  dict of keyword only parameters with defaults",
      "relationships": [
        {
          "target": "stdlib.inspect.isinstance",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.isgenerator",
      "name": "isgenerator",
      "module": "inspect",
      "type": "function",
      "signature": "(object)",
      "description": "Return true if the object is a generator.\n\nGenerator objects provide these attributes:\n    __iter__        defined to support iteration over container\n    close           raises a new GeneratorExit exception inside the\n                    generator to terminate the iteration\n    gi_code         code object\n    gi_frame        frame object or possibly None once the generator has\n                    been exhausted\n    gi_running      set to 1 when generator is executing, 0 otherwise\n    next            return the next item from the container\n    send            resumes the generator and \"sends\" a value that becomes\n                    the result of the current yield-expression\n    throw           used to raise an exception inside the generator",
      "relationships": [
        {
          "target": "stdlib.inspect.isinstance",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.isgeneratorfunction",
      "name": "isgeneratorfunction",
      "module": "inspect",
      "type": "function",
      "signature": "(obj)",
      "description": "Return true if the object is a user-defined generator function.\n\nGenerator function objects provide the same attributes as functions.\nSee help(isfunction) for a list of attributes.",
      "relationships": [
        {
          "target": "stdlib.inspect._has_code_flag",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.isgetsetdescriptor",
      "name": "isgetsetdescriptor",
      "module": "inspect",
      "type": "function",
      "signature": "(object)",
      "description": "Return true if the object is a getset descriptor.\n\ngetset descriptors are specialized descriptors defined in extension\nmodules.",
      "relationships": [
        {
          "target": "stdlib.inspect.isinstance",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.ismemberdescriptor",
      "name": "ismemberdescriptor",
      "module": "inspect",
      "type": "function",
      "signature": "(object)",
      "description": "Return true if the object is a member descriptor.\n\nMember descriptors are specialized descriptors defined in extension\nmodules.",
      "relationships": [
        {
          "target": "stdlib.inspect.isinstance",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.ismethod",
      "name": "ismethod",
      "module": "inspect",
      "type": "function",
      "signature": "(object)",
      "description": "Return true if the object is an instance method.\n\nInstance method objects provide these attributes:\n    __doc__         documentation string\n    __name__        name with which this method was defined\n    __func__        function object containing implementation of method\n    __self__        instance to which this method is bound",
      "relationships": [
        {
          "target": "stdlib.inspect.isinstance",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.ismethoddescriptor",
      "name": "ismethoddescriptor",
      "module": "inspect",
      "type": "function",
      "signature": "(object)",
      "description": "Return true if the object is a method descriptor.\n\nBut not if ismethod() or isclass() or isfunction() are true.\n\nThis is new in Python 2.2, and, for example, is true of int.__add__.\nAn object passing this test has a __get__ attribute but not a __set__\nattribute, but beyond that the set of attributes varies.  __name__ is\nusually sensible, and __doc__ often is.\n\nMethods implemented via descriptors that also pass one of the other\ntests return false from the ismethoddescriptor() test, simply because\nthe other tests promise more -- you can, e.g., count on having the\n__func__ attribute (etc) when an object passes ismethod().",
      "relationships": [
        {
          "target": "stdlib.inspect.type",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.isclass",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.ismethod",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.isfunction",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.hasattr",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.hasattr",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.ismodule",
      "name": "ismodule",
      "module": "inspect",
      "type": "function",
      "signature": "(object)",
      "description": "Return true if the object is a module.\n\nModule objects provide these attributes:\n    __cached__      pathname to byte compiled file\n    __doc__         documentation string\n    __file__        filename (missing for built-in modules)",
      "relationships": [
        {
          "target": "stdlib.inspect.isinstance",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.isroutine",
      "name": "isroutine",
      "module": "inspect",
      "type": "function",
      "signature": "(object)",
      "description": "Return true if the object is any kind of function or method.",
      "relationships": [
        {
          "target": "stdlib.inspect.isbuiltin",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.isfunction",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.ismethod",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.ismethoddescriptor",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.istraceback",
      "name": "istraceback",
      "module": "inspect",
      "type": "function",
      "signature": "(object)",
      "description": "Return true if the object is a traceback.\n\nTraceback objects provide these attributes:\n    tb_frame        frame object at this level\n    tb_lasti        index of last attempted instruction in bytecode\n    tb_lineno       current line number in Python source code\n    tb_next         next inner traceback object (called by this level)",
      "relationships": [
        {
          "target": "stdlib.inspect.isinstance",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.namedtuple",
      "name": "namedtuple",
      "module": "inspect",
      "type": "function",
      "signature": "(typename, field_names, *, rename=False, defaults=None, module=None)",
      "description": "Returns a new subclass of tuple with named fields.\n\n>>> Point = namedtuple('Point', ['x', 'y'])\n>>> Point.__doc__                   # docstring for the new class\n'Point(x, y)'\n>>> p = Point(11, y=22)             # instantiate with positional args or keywords\n>>> p[0] + p[1]                     # indexable like a plain tuple\n33\n>>> x, y = p                        # unpack like a regular tuple\n>>> x, y\n(11, 22)\n>>> p.x + p.y                       # fields also accessible by name\n33\n>>> d = p._asdict()                 # convert to a dictionary\n>>> d['x']\n11\n>>> Point(**d)                      # convert from a dictionary\nPoint(x=11, y=22)\n>>> p._replace(x=100)               # _replace() is like str.replace() but targets named fields\nPoint(x=100, y=22)",
      "relationships": [
        {
          "target": "stdlib.inspect.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.list",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.intern",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.set",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.tuple",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.len",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.join",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.eval",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.enumerate",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.type",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.split",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.map",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.str",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.set",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.enumerate",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect._iskeyword",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.add",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.tuple",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.dict",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.map",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.tuple_new",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect._make",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect._dict",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect._tuple",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.intern",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect._tuplegetter",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.add",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.type",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.isidentifier",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.startswith",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.len",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.len",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.reversed",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.join",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect._len",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect._map",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect._zip",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.get",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.replace",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect._iskeyword",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.startswith",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.list",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.isidentifier",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.zip",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.reversed",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.reversed",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.len",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.list",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect._getframe",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.signature",
      "name": "signature",
      "module": "inspect",
      "type": "function",
      "signature": "(obj, *, follow_wrapped=True)",
      "description": "Get a signature object for the passed callable.",
      "relationships": [
        {
          "target": "stdlib.inspect.from_callable",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.stack",
      "name": "stack",
      "module": "inspect",
      "type": "function",
      "signature": "(context=1)",
      "description": "Return a list of records for the stack above the caller's frame.",
      "relationships": [
        {
          "target": "stdlib.inspect.getouterframes",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect._getframe",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.trace",
      "name": "trace",
      "module": "inspect",
      "type": "function",
      "signature": "(context=1)",
      "description": "Return a list of records for the stack below the current exception.",
      "relationships": [
        {
          "target": "stdlib.inspect.getinnerframes",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.exc_info",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.unwrap",
      "name": "unwrap",
      "module": "inspect",
      "type": "function",
      "signature": "(func, *, stop=None)",
      "description": "Get the object wrapped by *func*.\n\nFollows the chain of :attr:`__wrapped__` attributes returning the last\nobject in the chain.\n\n*stop* is an optional callback accepting an object in the wrapper chain\nas its sole argument that allows the unwrapping to be terminated early if\nthe callback returns a true value. If the callback never returns a true\nvalue, the last object in the chain is returned as usual. For example,\n:func:`signature` uses this to stop unwrapping if any object in the\nchain has a ``__signature__`` attribute defined.\n\n:exc:`ValueError` is raised if a cycle is encountered.\n\n ",
      "relationships": [
        {
          "target": "stdlib.inspect.getrecursionlimit",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect._is_wrapper",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.id",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.id",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.hasattr",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.hasattr",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.len",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.format",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.stop",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.inspect.walktree",
      "name": "walktree",
      "module": "inspect",
      "type": "function",
      "signature": "(classes, children, parent)",
      "description": "Recursive helper function for getclasstree().",
      "relationships": [
        {
          "target": "stdlib.inspect.sort",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.append",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.attrgetter",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.append",
          "type": "calls"
        },
        {
          "target": "stdlib.inspect.walktree",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.io.BufferedRWPair",
      "name": "BufferedRWPair",
      "module": "io",
      "type": "class",
      "signature": "(reader, writer, buffer_size=8192, /)",
      "description": "A buffered reader and writer object together.\n\nA buffered reader object and buffered writer object put together to\nform a sequential IO object that can read and write. This is typically\nused with a socket or two-way pipe.\n\nreader and writer are RawIOBase objects that are readable and\nwriteable respectively. If the buffer_size is omitted it defaults to\nDEFAULT_BUFFER_SIZE.",
      "relationships": [
        {
          "target": "_BufferedIOBase",
          "type": "base_class"
        },
        {
          "target": "_IOBase",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.io.BufferedRandom",
      "name": "BufferedRandom",
      "module": "io",
      "type": "class",
      "signature": "(raw, buffer_size=8192)",
      "description": "A buffered interface to random access streams.\n\nThe constructor creates a reader and writer for a seekable stream,\nraw, given in the first argument. If the buffer_size is omitted it\ndefaults to DEFAULT_BUFFER_SIZE.",
      "relationships": [
        {
          "target": "_BufferedIOBase",
          "type": "base_class"
        },
        {
          "target": "_IOBase",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.io.BufferedReader",
      "name": "BufferedReader",
      "module": "io",
      "type": "class",
      "signature": "(raw, buffer_size=8192)",
      "description": "Create a new buffered reader using the given readable raw IO object.",
      "relationships": [
        {
          "target": "_BufferedIOBase",
          "type": "base_class"
        },
        {
          "target": "_IOBase",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.io.BufferedWriter",
      "name": "BufferedWriter",
      "module": "io",
      "type": "class",
      "signature": "(raw, buffer_size=8192)",
      "description": "A buffer for a writeable sequential RawIO object.\n\nThe constructor creates a BufferedWriter for the given writeable raw\nstream. If the buffer_size is not given, it defaults to\nDEFAULT_BUFFER_SIZE.",
      "relationships": [
        {
          "target": "_BufferedIOBase",
          "type": "base_class"
        },
        {
          "target": "_IOBase",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.io.BytesIO",
      "name": "BytesIO",
      "module": "io",
      "type": "class",
      "signature": "(initial_bytes=b'')",
      "description": "Buffered I/O implementation using an in-memory bytes buffer.",
      "relationships": [
        {
          "target": "_BufferedIOBase",
          "type": "base_class"
        },
        {
          "target": "_IOBase",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.io.FileIO",
      "name": "FileIO",
      "module": "io",
      "type": "class",
      "signature": "(file, mode='r', closefd=True, opener=None)",
      "description": "Open a file.\n\nThe mode can be 'r' (default), 'w', 'x' or 'a' for reading,\nwriting, exclusive creation or appending.  The file will be created if it\ndoesn't exist when opened for writing or appending; it will be truncated\nwhen opened for writing.  A FileExistsError will be raised if it already\nexists when opened for creating. Opening a file for creating implies\nwriting so this mode behaves in a similar way to 'w'.Add a '+' to the mode\nto allow simultaneous reading and writing. A custom opener can be used by\npassing a callable as *opener*. The underlying file descriptor for the file\nobject is then obtained by calling opener with (*name*, *flags*).\n*opener* must return an open file descriptor (passing os.open as *opener*\nresults in functionality similar to passing None).",
      "relationships": [
        {
          "target": "_RawIOBase",
          "type": "base_class"
        },
        {
          "target": "_IOBase",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.io.IncrementalNewlineDecoder",
      "name": "IncrementalNewlineDecoder",
      "module": "io",
      "type": "class",
      "signature": "(decoder, translate, errors='strict')",
      "description": "Codec used when reading a file in universal newlines mode.\n\nIt wraps another incremental decoder, translating \\r\\n and \\r into \\n.\nIt also records the types of newlines encountered.  When used with\ntranslate=False, it ensures that the newline sequence is returned in\none piece. When used with decoder=None, it expects unicode strings as\ndecode input and translates newlines without first invoking an external\ndecoder.",
      "relationships": []
    },
    {
      "id": "stdlib.io.StringIO",
      "name": "StringIO",
      "module": "io",
      "type": "class",
      "signature": "(initial_value='', newline='\\n')",
      "description": "Text I/O implementation using an in-memory buffer.\n\nThe initial_value argument sets the value of object.  The newline\nargument is like the one of TextIOWrapper's constructor.",
      "relationships": [
        {
          "target": "_TextIOBase",
          "type": "base_class"
        },
        {
          "target": "_IOBase",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.io.TextIOWrapper",
      "name": "TextIOWrapper",
      "module": "io",
      "type": "class",
      "signature": "(buffer, encoding=None, errors=None, newline=None, line_buffering=False, write_through=False)",
      "description": "Character and line based layer over a BufferedIOBase object, buffer.\n\nencoding gives the name of the encoding that the stream will be\ndecoded or encoded with. It defaults to locale.getpreferredencoding(False).\n\nerrors determines the strictness of encoding and decoding (see\nhelp(codecs.Codec) or the documentation for codecs.register) and\ndefaults to \"strict\".\n\nnewline controls how line endings are handled. It can be None, '',\n'\\n', '\\r', and '\\r\\n'.  It works as follows:\n\n* On input, if newline is None, universal newlines mode is\n  enabled. Lines in the input can end in '\\n', '\\r', or '\\r\\n', and\n  these are translated into '\\n' before being returned to the\n  caller. If it is '', universal newline mode is enabled, but line\n  endings are returned to the caller untranslated. If it has any of\n  the other legal values, input lines are only terminated by the given\n  string, and the line ending is returned to the caller untranslated.\n\n* On output, if newline is None, any '\\n' characters written are\n  translated to the system default line separator, os.linesep. If\n  newline is '' or '\\n', no translation takes place. If newline is any\n  of the other legal values, any '\\n' characters written are translated\n  to the given string.\n\nIf line_buffering is True, a call to flush is implied when a call to\nwrite contains a newline character.",
      "relationships": [
        {
          "target": "_TextIOBase",
          "type": "base_class"
        },
        {
          "target": "_IOBase",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.ipaddress.IPv4Address",
      "name": "IPv4Address",
      "module": "ipaddress",
      "type": "class",
      "signature": "(address)",
      "description": "Represent and manipulate single IPv4 Addresses.",
      "relationships": [
        {
          "target": "_BaseV4",
          "type": "base_class"
        },
        {
          "target": "_BaseAddress",
          "type": "base_class"
        },
        {
          "target": "_IPAddressBase",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.ipaddress.IPv4Interface",
      "name": "IPv4Interface",
      "module": "ipaddress",
      "type": "class",
      "signature": "(address)",
      "description": "Represent and manipulate single IPv4 Addresses.",
      "relationships": [
        {
          "target": "IPv4Address",
          "type": "base_class"
        },
        {
          "target": "_BaseV4",
          "type": "base_class"
        },
        {
          "target": "_BaseAddress",
          "type": "base_class"
        },
        {
          "target": "_IPAddressBase",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.ipaddress.IPv4Network",
      "name": "IPv4Network",
      "module": "ipaddress",
      "type": "class",
      "signature": "(address, strict=True)",
      "description": "This class represents and manipulates 32-bit IPv4 network + addresses..\n\nAttributes: [examples for IPv4Network('192.0.2.0/27')]\n    .network_address: IPv4Address('192.0.2.0')\n    .hostmask: IPv4Address('0.0.0.31')\n    .broadcast_address: IPv4Address('192.0.2.32')\n    .netmask: IPv4Address('255.255.255.224')\n    .prefixlen: 27",
      "relationships": [
        {
          "target": "_BaseV4",
          "type": "base_class"
        },
        {
          "target": "_BaseNetwork",
          "type": "base_class"
        },
        {
          "target": "_IPAddressBase",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.ipaddress.IPv6Address",
      "name": "IPv6Address",
      "module": "ipaddress",
      "type": "class",
      "signature": "(address)",
      "description": "Represent and manipulate single IPv6 Addresses.",
      "relationships": [
        {
          "target": "_BaseV6",
          "type": "base_class"
        },
        {
          "target": "_BaseAddress",
          "type": "base_class"
        },
        {
          "target": "_IPAddressBase",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.ipaddress.IPv6Interface",
      "name": "IPv6Interface",
      "module": "ipaddress",
      "type": "class",
      "signature": "(address)",
      "description": "Represent and manipulate single IPv6 Addresses.",
      "relationships": [
        {
          "target": "IPv6Address",
          "type": "base_class"
        },
        {
          "target": "_BaseV6",
          "type": "base_class"
        },
        {
          "target": "_BaseAddress",
          "type": "base_class"
        },
        {
          "target": "_IPAddressBase",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.ipaddress.IPv6Network",
      "name": "IPv6Network",
      "module": "ipaddress",
      "type": "class",
      "signature": "(address, strict=True)",
      "description": "This class represents and manipulates 128-bit IPv6 networks.\n\nAttributes: [examples for IPv6('2001:db8::1000/124')]\n    .network_address: IPv6Address('2001:db8::1000')\n    .hostmask: IPv6Address('::f')\n    .broadcast_address: IPv6Address('2001:db8::100f')\n    .netmask: IPv6Address('ffff:ffff:ffff:ffff:ffff:ffff:ffff:fff0')\n    .prefixlen: 124",
      "relationships": [
        {
          "target": "_BaseV6",
          "type": "base_class"
        },
        {
          "target": "_BaseNetwork",
          "type": "base_class"
        },
        {
          "target": "_IPAddressBase",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.ipaddress.collapse_addresses",
      "name": "collapse_addresses",
      "module": "ipaddress",
      "type": "function",
      "signature": "(addresses)",
      "description": "Collapse a list of IP objects.\n\nExample:\n    collapse_addresses([IPv4Network('192.0.2.0/25'),\n                        IPv4Network('192.0.2.128/25')]) ->\n                       [IPv4Network('192.0.2.0/24')]\n\nArgs:\n    addresses: An iterator of IPv4Network or IPv6Network objects.\n\nReturns:\n    An iterator of the collapsed IPv(4|6)Network objects.\n\nRaises:\n    TypeError: If passed a list of mixed version objects.",
      "relationships": [
        {
          "target": "stdlib.ipaddress.sorted",
          "type": "calls"
        },
        {
          "target": "stdlib.ipaddress._collapse_addresses_internal",
          "type": "calls"
        },
        {
          "target": "stdlib.ipaddress.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.ipaddress.set",
          "type": "calls"
        },
        {
          "target": "stdlib.ipaddress._find_address_range",
          "type": "calls"
        },
        {
          "target": "stdlib.ipaddress.append",
          "type": "calls"
        },
        {
          "target": "stdlib.ipaddress.extend",
          "type": "calls"
        },
        {
          "target": "stdlib.ipaddress.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.ipaddress.append",
          "type": "calls"
        },
        {
          "target": "stdlib.ipaddress.summarize_address_range",
          "type": "calls"
        },
        {
          "target": "stdlib.ipaddress.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.ipaddress.append",
          "type": "calls"
        },
        {
          "target": "stdlib.ipaddress.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.ipaddress.append",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ipaddress.get_mixed_type_key",
      "name": "get_mixed_type_key",
      "module": "ipaddress",
      "type": "function",
      "signature": "(obj)",
      "description": "Return a key suitable for sorting between networks and addresses.\n\nAddress and Network objects are not sortable by default; they're\nfundamentally different so the expression\n\n    IPv4Address('192.0.2.0') <= IPv4Network('192.0.2.0/24')\n\ndoesn't make any sense.  There are some times however, where you may wish\nto have ipaddress sort these for you anyway. If you need to do this, you\ncan use this function as the key= argument to sorted().\n\nArgs:\n  obj: either a Network or Address object.\nReturns:\n  appropriate key.",
      "relationships": [
        {
          "target": "stdlib.ipaddress.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.ipaddress._get_networks_key",
          "type": "calls"
        },
        {
          "target": "stdlib.ipaddress.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.ipaddress._get_address_key",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ipaddress.ip_address",
      "name": "ip_address",
      "module": "ipaddress",
      "type": "function",
      "signature": "(address)",
      "description": "Take an IP string/int and return an object of the correct type.\n\nArgs:\n    address: A string or integer, the IP address.  Either IPv4 or\n      IPv6 addresses may be supplied; integers less than 2**32 will\n      be considered to be IPv4 by default.\n\nReturns:\n    An IPv4Address or IPv6Address object.\n\nRaises:\n    ValueError: if the *address* passed isn't either a v4 or a v6\n      address",
      "relationships": [
        {
          "target": "stdlib.ipaddress.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.ipaddress.IPv4Address",
          "type": "calls"
        },
        {
          "target": "stdlib.ipaddress.IPv6Address",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ipaddress.ip_interface",
      "name": "ip_interface",
      "module": "ipaddress",
      "type": "function",
      "signature": "(address)",
      "description": "Take an IP string/int and return an object of the correct type.\n\nArgs:\n    address: A string or integer, the IP address.  Either IPv4 or\n      IPv6 addresses may be supplied; integers less than 2**32 will\n      be considered to be IPv4 by default.\n\nReturns:\n    An IPv4Interface or IPv6Interface object.\n\nRaises:\n    ValueError: if the string passed isn't either a v4 or a v6\n      address.\n\nNotes:\n    The IPv?Interface classes describe an Address on a particular\n    Network, so they're basically a combination of both the Address\n    and Network classes.",
      "relationships": [
        {
          "target": "stdlib.ipaddress.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.ipaddress.IPv4Interface",
          "type": "calls"
        },
        {
          "target": "stdlib.ipaddress.IPv6Interface",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ipaddress.ip_network",
      "name": "ip_network",
      "module": "ipaddress",
      "type": "function",
      "signature": "(address, strict=True)",
      "description": "Take an IP string/int and return an object of the correct type.\n\nArgs:\n    address: A string or integer, the IP network.  Either IPv4 or\n      IPv6 networks may be supplied; integers less than 2**32 will\n      be considered to be IPv4 by default.\n\nReturns:\n    An IPv4Network or IPv6Network object.\n\nRaises:\n    ValueError: if the string passed isn't either a v4 or a v6\n      address. Or if the network has host bits set.",
      "relationships": [
        {
          "target": "stdlib.ipaddress.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.ipaddress.IPv4Network",
          "type": "calls"
        },
        {
          "target": "stdlib.ipaddress.IPv6Network",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ipaddress.summarize_address_range",
      "name": "summarize_address_range",
      "module": "ipaddress",
      "type": "function",
      "signature": "(first, last)",
      "description": "Summarize a network range given the first and last IP addresses.\n\nExample:\n    >>> list(summarize_address_range(IPv4Address('192.0.2.0'),\n    ...                              IPv4Address('192.0.2.130')))\n    ...                                #doctest: +NORMALIZE_WHITESPACE\n    [IPv4Network('192.0.2.0/25'), IPv4Network('192.0.2.128/31'),\n     IPv4Network('192.0.2.130/32')]\n\nArgs:\n    first: the first IPv4Address or IPv6Address in the range.\n    last: the last IPv4Address or IPv6Address in the range.\n\nReturns:\n    An iterator of the summarized IPv(4|6) network objects.\n\nRaise:\n    TypeError:\n        If the first and last objects are not IP addresses.\n        If the first and last objects are not the same version.\n    ValueError:\n        If the last object is not greater than the first.\n        If the version of the first address is not 4 or 6.",
      "relationships": [
        {
          "target": "stdlib.ipaddress.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.ipaddress.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.ipaddress.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.ipaddress.min",
          "type": "calls"
        },
        {
          "target": "stdlib.ipaddress.ip",
          "type": "calls"
        },
        {
          "target": "stdlib.ipaddress.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.ipaddress.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.ipaddress.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.ipaddress._count_righthand_zero_bits",
          "type": "calls"
        },
        {
          "target": "stdlib.ipaddress.bit_length",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ipaddress.v4_int_to_packed",
      "name": "v4_int_to_packed",
      "module": "ipaddress",
      "type": "function",
      "signature": "(address)",
      "description": "Represent an address as 4 packed bytes in network (big-endian) order.\n\nArgs:\n    address: An integer representation of an IPv4 IP address.\n\nReturns:\n    The integer address packed as 4 bytes in network (big-endian) order.\n\nRaises:\n    ValueError: If the integer is negative or too large to be an\n      IPv4 IP address.",
      "relationships": [
        {
          "target": "stdlib.ipaddress.to_bytes",
          "type": "calls"
        },
        {
          "target": "stdlib.ipaddress.ValueError",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ipaddress.v6_int_to_packed",
      "name": "v6_int_to_packed",
      "module": "ipaddress",
      "type": "function",
      "signature": "(address)",
      "description": "Represent an address as 16 packed bytes in network (big-endian) order.\n\nArgs:\n    address: An integer representation of an IPv6 IP address.\n\nReturns:\n    The integer address packed as 16 bytes in network (big-endian) order.",
      "relationships": [
        {
          "target": "stdlib.ipaddress.to_bytes",
          "type": "calls"
        },
        {
          "target": "stdlib.ipaddress.ValueError",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.json.JSONDecodeError",
      "name": "JSONDecodeError",
      "module": "json",
      "type": "class",
      "signature": "(msg, doc, pos)",
      "description": "Subclass of ValueError with the following additional properties:\n\nmsg: The unformatted error message\ndoc: The JSON document being parsed\npos: The start index of doc where parsing failed\nlineno: The line corresponding to pos\ncolno: The column corresponding to pos",
      "relationships": [
        {
          "target": "ValueError",
          "type": "base_class"
        },
        {
          "target": "Exception",
          "type": "base_class"
        },
        {
          "target": "BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.json.JSONDecoder",
      "name": "JSONDecoder",
      "module": "json",
      "type": "class",
      "signature": "(*, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, strict=True, object_pairs_hook=None)",
      "description": "Simple JSON <http://json.org> decoder\n\nPerforms the following translations in decoding by default:\n\n+---------------+-------------------+\n| JSON          | Python            |\n+===============+===================+\n| object        | dict              |\n+---------------+-------------------+\n| array         | list              |\n+---------------+-------------------+\n| string        | str               |\n+---------------+-------------------+\n| number (int)  | int               |\n+---------------+-------------------+\n| number (real) | float             |\n+---------------+-------------------+\n| true          | True              |\n+---------------+-------------------+\n| false         | False             |\n+---------------+-------------------+\n| null          | None              |\n+---------------+-------------------+\n\nIt also understands ``NaN``, ``Infinity``, and ``-Infinity`` as\ntheir corresponding ``float`` values, which is outside the JSON spec.",
      "relationships": []
    },
    {
      "id": "stdlib.json.JSONEncoder",
      "name": "JSONEncoder",
      "module": "json",
      "type": "class",
      "signature": "(*, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, sort_keys=False, indent=None, separators=None, default=None)",
      "description": "Extensible JSON <http://json.org> encoder for Python data structures.\n\nSupports the following objects and types by default:\n\n+-------------------+---------------+\n| Python            | JSON          |\n+===================+===============+\n| dict              | object        |\n+-------------------+---------------+\n| list, tuple       | array         |\n+-------------------+---------------+\n| str               | string        |\n+-------------------+---------------+\n| int, float        | number        |\n+-------------------+---------------+\n| True              | true          |\n+-------------------+---------------+\n| False             | false         |\n+-------------------+---------------+\n| None              | null          |\n+-------------------+---------------+\n\nTo extend this to recognize other objects, subclass and implement a\n``.default()`` method with another method that returns a serializable\nobject for ``o`` if possible, otherwise it should call the superclass\nimplementation (to raise ``TypeError``).",
      "relationships": []
    },
    {
      "id": "stdlib.json.detect_encoding",
      "name": "detect_encoding",
      "module": "json",
      "type": "function",
      "signature": "(b)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.json.bstartswith",
          "type": "calls"
        },
        {
          "target": "stdlib.json.bstartswith",
          "type": "calls"
        },
        {
          "target": "stdlib.json.bstartswith",
          "type": "calls"
        },
        {
          "target": "stdlib.json.len",
          "type": "calls"
        },
        {
          "target": "stdlib.json.len",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.json.dump",
      "name": "dump",
      "module": "json",
      "type": "function",
      "signature": "(obj, fp, *, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, default=None, sort_keys=False, **kw)",
      "description": "Serialize ``obj`` as a JSON formatted stream to ``fp`` (a\n``.write()``-supporting file-like object).\n\nIf ``skipkeys`` is true then ``dict`` keys that are not basic types\n(``str``, ``int``, ``float``, ``bool``, ``None``) will be skipped\ninstead of raising a ``TypeError``.\n\nIf ``ensure_ascii`` is false, then the strings written to ``fp`` can\ncontain non-ASCII characters if they appear in strings contained in\n``obj``. Otherwise, all such characters are escaped in JSON strings.\n\nIf ``check_circular`` is false, then the circular reference check\nfor container types will be skipped and a circular reference will\nresult in an ``OverflowError`` (or worse).\n\nIf ``allow_nan`` is false, then it will be a ``ValueError`` to\nserialize out of range ``float`` values (``nan``, ``inf``, ``-inf``)\nin strict compliance of the JSON specification, instead of using the\nJavaScript equivalents (``NaN``, ``Infinity``, ``-Infinity``).\n\nIf ``indent`` is a non-negative integer, then JSON array elements and\nobject members will be pretty-printed with that indent level. An indent\nlevel of 0 will only insert newlines. ``None`` is the most compact\nrepresentation.\n\nIf specified, ``separators`` should be an ``(item_separator, key_separator)``\ntuple.  The default is ``(', ', ': ')`` if *indent* is ``None`` and\n``(',', ': ')`` otherwise.  To get the most compact JSON representation,\nyou should specify ``(',', ':')`` to eliminate whitespace.\n\n``default(obj)`` is a function that should return a serializable version\nof obj or raise TypeError. The default simply raises TypeError.\n\nIf *sort_keys* is true (default: ``False``), then the output of\ndictionaries will be sorted by key.\n\nTo use a custom ``JSONEncoder`` subclass (e.g. one that overrides the\n``.default()`` method to serialize additional types), specify it with\nthe ``cls`` kwarg; otherwise ``JSONEncoder`` is used.",
      "relationships": [
        {
          "target": "stdlib.json.iterencode",
          "type": "calls"
        },
        {
          "target": "stdlib.json.iterencode",
          "type": "calls"
        },
        {
          "target": "stdlib.json.write",
          "type": "calls"
        },
        {
          "target": "stdlib.json.cls",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.json.dumps",
      "name": "dumps",
      "module": "json",
      "type": "function",
      "signature": "(obj, *, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, default=None, sort_keys=False, **kw)",
      "description": "Serialize ``obj`` to a JSON formatted ``str``.\n\nIf ``skipkeys`` is true then ``dict`` keys that are not basic types\n(``str``, ``int``, ``float``, ``bool``, ``None``) will be skipped\ninstead of raising a ``TypeError``.\n\nIf ``ensure_ascii`` is false, then the return value can contain non-ASCII\ncharacters if they appear in strings contained in ``obj``. Otherwise, all\nsuch characters are escaped in JSON strings.\n\nIf ``check_circular`` is false, then the circular reference check\nfor container types will be skipped and a circular reference will\nresult in an ``OverflowError`` (or worse).\n\nIf ``allow_nan`` is false, then it will be a ``ValueError`` to\nserialize out of range ``float`` values (``nan``, ``inf``, ``-inf``) in\nstrict compliance of the JSON specification, instead of using the\nJavaScript equivalents (``NaN``, ``Infinity``, ``-Infinity``).\n\nIf ``indent`` is a non-negative integer, then JSON array elements and\nobject members will be pretty-printed with that indent level. An indent\nlevel of 0 will only insert newlines. ``None`` is the most compact\nrepresentation.\n\nIf specified, ``separators`` should be an ``(item_separator, key_separator)``\ntuple.  The default is ``(', ', ': ')`` if *indent* is ``None`` and\n``(',', ': ')`` otherwise.  To get the most compact JSON representation,\nyou should specify ``(',', ':')`` to eliminate whitespace.\n\n``default(obj)`` is a function that should return a serializable version\nof obj or raise TypeError. The default simply raises TypeError.\n\nIf *sort_keys* is true (default: ``False``), then the output of\ndictionaries will be sorted by key.\n\nTo use a custom ``JSONEncoder`` subclass (e.g. one that overrides the\n``.default()`` method to serialize additional types), specify it with\nthe ``cls`` kwarg; otherwise ``JSONEncoder`` is used.",
      "relationships": [
        {
          "target": "stdlib.json.encode",
          "type": "calls"
        },
        {
          "target": "stdlib.json.encode",
          "type": "calls"
        },
        {
          "target": "stdlib.json.cls",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.json.load",
      "name": "load",
      "module": "json",
      "type": "function",
      "signature": "(fp, *, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, object_pairs_hook=None, **kw)",
      "description": "Deserialize ``fp`` (a ``.read()``-supporting file-like object containing\na JSON document) to a Python object.\n\n``object_hook`` is an optional function that will be called with the\nresult of any object literal decode (a ``dict``). The return value of\n``object_hook`` will be used instead of the ``dict``. This feature\ncan be used to implement custom decoders (e.g. JSON-RPC class hinting).\n\n``object_pairs_hook`` is an optional function that will be called with the\nresult of any object literal decoded with an ordered list of pairs.  The\nreturn value of ``object_pairs_hook`` will be used instead of the ``dict``.\nThis feature can be used to implement custom decoders.  If ``object_hook``\nis also defined, the ``object_pairs_hook`` takes priority.\n\nTo use a custom ``JSONDecoder`` subclass, specify it with the ``cls``\nkwarg; otherwise ``JSONDecoder`` is used.",
      "relationships": [
        {
          "target": "stdlib.json.loads",
          "type": "calls"
        },
        {
          "target": "stdlib.json.read",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.json.loads",
      "name": "loads",
      "module": "json",
      "type": "function",
      "signature": "(s, *, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, object_pairs_hook=None, **kw)",
      "description": "Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance\ncontaining a JSON document) to a Python object.\n\n``object_hook`` is an optional function that will be called with the\nresult of any object literal decode (a ``dict``). The return value of\n``object_hook`` will be used instead of the ``dict``. This feature\ncan be used to implement custom decoders (e.g. JSON-RPC class hinting).\n\n``object_pairs_hook`` is an optional function that will be called with the\nresult of any object literal decoded with an ordered list of pairs.  The\nreturn value of ``object_pairs_hook`` will be used instead of the ``dict``.\nThis feature can be used to implement custom decoders.  If ``object_hook``\nis also defined, the ``object_pairs_hook`` takes priority.\n\n``parse_float``, if specified, will be called with the string\nof every JSON float to be decoded. By default this is equivalent to\nfloat(num_str). This can be used to use another datatype or parser\nfor JSON floats (e.g. decimal.Decimal).\n\n``parse_int``, if specified, will be called with the string\nof every JSON int to be decoded. By default this is equivalent to\nint(num_str). This can be used to use another datatype or parser\nfor JSON integers (e.g. float).\n\n``parse_constant``, if specified, will be called with one of the\nfollowing strings: -Infinity, Infinity, NaN.\nThis can be used to raise an exception if invalid JSON numbers\nare encountered.\n\nTo use a custom ``JSONDecoder`` subclass, specify it with the ``cls``\nkwarg; otherwise ``JSONDecoder`` is used.",
      "relationships": [
        {
          "target": "stdlib.json.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.json.decode",
          "type": "calls"
        },
        {
          "target": "stdlib.json.startswith",
          "type": "calls"
        },
        {
          "target": "stdlib.json.decode",
          "type": "calls"
        },
        {
          "target": "stdlib.json.decode",
          "type": "calls"
        },
        {
          "target": "stdlib.json.JSONDecodeError",
          "type": "calls"
        },
        {
          "target": "stdlib.json.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.json.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.json.detect_encoding",
          "type": "calls"
        },
        {
          "target": "stdlib.json.cls",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.linecache.checkcache",
      "name": "checkcache",
      "module": "linecache",
      "type": "function",
      "signature": "(filename=None)",
      "description": "Discard cache entries that are out of date.\n(This is not checked upon each call!)",
      "relationships": [
        {
          "target": "stdlib.linecache.list",
          "type": "calls"
        },
        {
          "target": "stdlib.linecache.keys",
          "type": "calls"
        },
        {
          "target": "stdlib.linecache.len",
          "type": "calls"
        },
        {
          "target": "stdlib.linecache.stat",
          "type": "calls"
        },
        {
          "target": "stdlib.linecache.pop",
          "type": "calls"
        },
        {
          "target": "stdlib.linecache.pop",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.linecache.clearcache",
      "name": "clearcache",
      "module": "linecache",
      "type": "function",
      "signature": "()",
      "description": "Clear the cache entirely.",
      "relationships": [
        {
          "target": "stdlib.linecache.clear",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.linecache.getline",
      "name": "getline",
      "module": "linecache",
      "type": "function",
      "signature": "(filename, lineno, module_globals=None)",
      "description": "Get a line for a Python source file from the cache.\nUpdate the cache if it doesn't contain an entry for this file already.",
      "relationships": [
        {
          "target": "stdlib.linecache.getlines",
          "type": "calls"
        },
        {
          "target": "stdlib.linecache.len",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.linecache.getlines",
      "name": "getlines",
      "module": "linecache",
      "type": "function",
      "signature": "(filename, module_globals=None)",
      "description": "Get the lines for a Python source file from the cache.\nUpdate the cache if it doesn't contain an entry for this file already.",
      "relationships": [
        {
          "target": "stdlib.linecache.updatecache",
          "type": "calls"
        },
        {
          "target": "stdlib.linecache.len",
          "type": "calls"
        },
        {
          "target": "stdlib.linecache.range",
          "type": "calls"
        },
        {
          "target": "stdlib.linecache.clearcache",
          "type": "calls"
        },
        {
          "target": "stdlib.linecache.list",
          "type": "calls"
        },
        {
          "target": "stdlib.linecache.values",
          "type": "calls"
        },
        {
          "target": "stdlib.linecache.getattr",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.linecache.lazycache",
      "name": "lazycache",
      "module": "linecache",
      "type": "function",
      "signature": "(filename, module_globals)",
      "description": "Seed the cache for filename with module_globals.\n\nThe module loader will be asked for the source only when getlines is\ncalled, not immediately.\n\nIf there is an entry in the cache already, it is not altered.\n\n:return: True if a lazy load is registered in the cache,\n    otherwise False. To register such a load a module loader with a\n    get_source method must be found, the filename must be a cachable\n    filename, and the filename must not be already cached.",
      "relationships": [
        {
          "target": "stdlib.linecache.get",
          "type": "calls"
        },
        {
          "target": "stdlib.linecache.getattr",
          "type": "calls"
        },
        {
          "target": "stdlib.linecache.len",
          "type": "calls"
        },
        {
          "target": "stdlib.linecache.startswith",
          "type": "calls"
        },
        {
          "target": "stdlib.linecache.endswith",
          "type": "calls"
        },
        {
          "target": "stdlib.linecache.get",
          "type": "calls"
        },
        {
          "target": "stdlib.linecache.partial",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.linecache.updatecache",
      "name": "updatecache",
      "module": "linecache",
      "type": "function",
      "signature": "(filename, module_globals=None)",
      "description": "Update a cache entry and return its list of lines.\nIf something's wrong, print a message, discard the cache entry,\nand return an empty list.",
      "relationships": [
        {
          "target": "stdlib.linecache.stat",
          "type": "calls"
        },
        {
          "target": "stdlib.linecache.len",
          "type": "calls"
        },
        {
          "target": "stdlib.linecache.pop",
          "type": "calls"
        },
        {
          "target": "stdlib.linecache.startswith",
          "type": "calls"
        },
        {
          "target": "stdlib.linecache.endswith",
          "type": "calls"
        },
        {
          "target": "stdlib.linecache.lazycache",
          "type": "calls"
        },
        {
          "target": "stdlib.linecache.isabs",
          "type": "calls"
        },
        {
          "target": "stdlib.linecache.open",
          "type": "calls"
        },
        {
          "target": "stdlib.linecache.readlines",
          "type": "calls"
        },
        {
          "target": "stdlib.linecache.endswith",
          "type": "calls"
        },
        {
          "target": "stdlib.linecache.join",
          "type": "calls"
        },
        {
          "target": "stdlib.linecache.stat",
          "type": "calls"
        },
        {
          "target": "stdlib.linecache.len",
          "type": "calls"
        },
        {
          "target": "stdlib.linecache.splitlines",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.locale.atof",
      "name": "atof",
      "module": "locale",
      "type": "function",
      "signature": "(string, func=<class 'float'>)",
      "description": "Parses a string as a float according to the locale settings.",
      "relationships": [
        {
          "target": "stdlib.locale.func",
          "type": "calls"
        },
        {
          "target": "stdlib.locale.delocalize",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.locale.atoi",
      "name": "atoi",
      "module": "locale",
      "type": "function",
      "signature": "(string)",
      "description": "Converts a string to an integer according to the locale settings.",
      "relationships": [
        {
          "target": "stdlib.locale.int",
          "type": "calls"
        },
        {
          "target": "stdlib.locale.delocalize",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.locale.currency",
      "name": "currency",
      "module": "locale",
      "type": "function",
      "signature": "(val, symbol=True, grouping=False, international=False)",
      "description": "Formats val according to the currency settings\nin the current locale.",
      "relationships": [
        {
          "target": "stdlib.locale.localeconv",
          "type": "calls"
        },
        {
          "target": "stdlib.locale._format",
          "type": "calls"
        },
        {
          "target": "stdlib.locale.replace",
          "type": "calls"
        },
        {
          "target": "stdlib.locale.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.locale.abs",
          "type": "calls"
        },
        {
          "target": "stdlib.locale.replace",
          "type": "calls"
        },
        {
          "target": "stdlib.locale.replace",
          "type": "calls"
        },
        {
          "target": "stdlib.locale.replace",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.locale.delocalize",
      "name": "delocalize",
      "module": "locale",
      "type": "function",
      "signature": "(string)",
      "description": "Parses a string as a normalized number according to the locale settings.",
      "relationships": [
        {
          "target": "stdlib.locale.localeconv",
          "type": "calls"
        },
        {
          "target": "stdlib.locale.replace",
          "type": "calls"
        },
        {
          "target": "stdlib.locale.replace",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.locale.format",
      "name": "format",
      "module": "locale",
      "type": "function",
      "signature": "(percent, value, grouping=False, monetary=False, *additional)",
      "description": "Deprecated, use format_string instead.",
      "relationships": [
        {
          "target": "stdlib.locale.warn",
          "type": "calls"
        },
        {
          "target": "stdlib.locale.match",
          "type": "calls"
        },
        {
          "target": "stdlib.locale._format",
          "type": "calls"
        },
        {
          "target": "stdlib.locale.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.locale.len",
          "type": "calls"
        },
        {
          "target": "stdlib.locale.len",
          "type": "calls"
        },
        {
          "target": "stdlib.locale.group",
          "type": "calls"
        },
        {
          "target": "stdlib.locale.repr",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.locale.format_string",
      "name": "format_string",
      "module": "locale",
      "type": "function",
      "signature": "(f, val, grouping=False, monetary=False)",
      "description": "Formats a string in the same way that the % formatting would use,\nbut takes the current locale into account.\n\nGrouping is applied if the third parameter is true.\nConversion uses monetary thousands separator and grouping strings if\nforth parameter monetary is true.",
      "relationships": [
        {
          "target": "stdlib.locale.list",
          "type": "calls"
        },
        {
          "target": "stdlib.locale.sub",
          "type": "calls"
        },
        {
          "target": "stdlib.locale.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.locale.tuple",
          "type": "calls"
        },
        {
          "target": "stdlib.locale.finditer",
          "type": "calls"
        },
        {
          "target": "stdlib.locale.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.locale.append",
          "type": "calls"
        },
        {
          "target": "stdlib.locale.append",
          "type": "calls"
        },
        {
          "target": "stdlib.locale.append",
          "type": "calls"
        },
        {
          "target": "stdlib.locale.count",
          "type": "calls"
        },
        {
          "target": "stdlib.locale.append",
          "type": "calls"
        },
        {
          "target": "stdlib.locale.group",
          "type": "calls"
        },
        {
          "target": "stdlib.locale._format",
          "type": "calls"
        },
        {
          "target": "stdlib.locale.group",
          "type": "calls"
        },
        {
          "target": "stdlib.locale._format",
          "type": "calls"
        },
        {
          "target": "stdlib.locale.group",
          "type": "calls"
        },
        {
          "target": "stdlib.locale.group",
          "type": "calls"
        },
        {
          "target": "stdlib.locale.group",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.locale.getdefaultlocale",
      "name": "getdefaultlocale",
      "module": "locale",
      "type": "function",
      "signature": "(envvars=('LC_ALL', 'LC_CTYPE', 'LANG', 'LANGUAGE'))",
      "description": "Tries to determine the default locale settings and returns\nthem as tuple (language code, encoding).\n\nAccording to POSIX, a program which has not called\nsetlocale(LC_ALL, \"\") runs using the portable 'C' locale.\nCalling setlocale(LC_ALL, \"\") lets it use the default locale as\ndefined by the LANG variable. Since we don't want to interfere\nwith the current locale setting we thus emulate the behavior\nin the way described above.\n\nTo maintain compatibility with other platforms, not only the\nLANG variable is tested, but a list of variables given as\nenvvars parameter. The first found to be defined will be\nused. envvars defaults to the search path used in GNU gettext;\nit must always contain the variable name 'LANG'.\n\nExcept for the code 'C', the language code corresponds to RFC\n1766.  code and encoding can be None in case the values cannot\nbe determined.",
      "relationships": [
        {
          "target": "stdlib.locale._parse_localename",
          "type": "calls"
        },
        {
          "target": "stdlib.locale._getdefaultlocale",
          "type": "calls"
        },
        {
          "target": "stdlib.locale.lookup",
          "type": "calls"
        },
        {
          "target": "stdlib.locale.get",
          "type": "calls"
        },
        {
          "target": "stdlib.locale.int",
          "type": "calls"
        },
        {
          "target": "stdlib.locale.split",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.locale.getlocale",
      "name": "getlocale",
      "module": "locale",
      "type": "function",
      "signature": "(category=2)",
      "description": "Returns the current setting for the given locale category as\ntuple (language code, encoding).\n\ncategory may be one of the LC_* value except LC_ALL. It\ndefaults to LC_CTYPE.\n\nExcept for the code 'C', the language code corresponds to RFC\n1766.  code and encoding can be None in case the values cannot\nbe determined.",
      "relationships": [
        {
          "target": "stdlib.locale._setlocale",
          "type": "calls"
        },
        {
          "target": "stdlib.locale._parse_localename",
          "type": "calls"
        },
        {
          "target": "stdlib.locale.TypeError",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.locale.getpreferredencoding",
      "name": "getpreferredencoding",
      "module": "locale",
      "type": "function",
      "signature": "(do_setlocale=True)",
      "description": "Return the charset that the user is likely using,\naccording to the system configuration.",
      "relationships": [
        {
          "target": "stdlib.locale.getpreferredencoding",
          "type": "calls"
        },
        {
          "target": "stdlib.locale.setlocale",
          "type": "calls"
        },
        {
          "target": "stdlib.locale.setlocale",
          "type": "calls"
        },
        {
          "target": "stdlib.locale.setlocale",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.locale.normalize",
      "name": "normalize",
      "module": "locale",
      "type": "function",
      "signature": "(localename)",
      "description": "Returns a normalized locale code for the given locale\nname.\n\nThe returned locale code is formatted for use with\nsetlocale().\n\nIf normalization fails, the original name is returned\nunchanged.\n\nIf the given encoding is not known, the function defaults to\nthe default encoding for the locale code just like setlocale()\ndoes.",
      "relationships": [
        {
          "target": "stdlib.locale.lower",
          "type": "calls"
        },
        {
          "target": "stdlib.locale.get",
          "type": "calls"
        },
        {
          "target": "stdlib.locale.replace",
          "type": "calls"
        },
        {
          "target": "stdlib.locale.split",
          "type": "calls"
        },
        {
          "target": "stdlib.locale.replace",
          "type": "calls"
        },
        {
          "target": "stdlib.locale.replace",
          "type": "calls"
        },
        {
          "target": "stdlib.locale.get",
          "type": "calls"
        },
        {
          "target": "stdlib.locale.get",
          "type": "calls"
        },
        {
          "target": "stdlib.locale.split",
          "type": "calls"
        },
        {
          "target": "stdlib.locale.split",
          "type": "calls"
        },
        {
          "target": "stdlib.locale.get",
          "type": "calls"
        },
        {
          "target": "stdlib.locale._append_modifier",
          "type": "calls"
        },
        {
          "target": "stdlib.locale.lower",
          "type": "calls"
        },
        {
          "target": "stdlib.locale._replace_encoding",
          "type": "calls"
        },
        {
          "target": "stdlib.locale.split",
          "type": "calls"
        },
        {
          "target": "stdlib.locale._replace_encoding",
          "type": "calls"
        },
        {
          "target": "stdlib.locale._replace_encoding",
          "type": "calls"
        },
        {
          "target": "stdlib.locale._append_modifier",
          "type": "calls"
        },
        {
          "target": "stdlib.locale.lower",
          "type": "calls"
        },
        {
          "target": "stdlib.locale.split",
          "type": "calls"
        },
        {
          "target": "stdlib.locale._replace_encoding",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.locale.resetlocale",
      "name": "resetlocale",
      "module": "locale",
      "type": "function",
      "signature": "(category=0)",
      "description": "Sets the locale for category to the default setting.\n\nThe default setting is determined by calling\ngetdefaultlocale(). category defaults to LC_ALL.",
      "relationships": [
        {
          "target": "stdlib.locale._setlocale",
          "type": "calls"
        },
        {
          "target": "stdlib.locale._build_localename",
          "type": "calls"
        },
        {
          "target": "stdlib.locale.getdefaultlocale",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.locale.setlocale",
      "name": "setlocale",
      "module": "locale",
      "type": "function",
      "signature": "(category, locale=None)",
      "description": "Set the locale for the given category.  The locale can be\na string, an iterable of two strings (language code and encoding),\nor None.\n\nIterables are converted to strings using the locale aliasing\nengine.  Locale strings are passed directly to the C lib.\n\ncategory may be given as one of the LC_* values.",
      "relationships": [
        {
          "target": "stdlib.locale._setlocale",
          "type": "calls"
        },
        {
          "target": "stdlib.locale.normalize",
          "type": "calls"
        },
        {
          "target": "stdlib.locale.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.locale._build_localename",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.locale.str",
      "name": "str",
      "module": "locale",
      "type": "function",
      "signature": "(val)",
      "description": "Convert float to string, taking the locale into account.",
      "relationships": [
        {
          "target": "stdlib.locale._format",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.logging.BufferingFormatter",
      "name": "BufferingFormatter",
      "module": "logging",
      "type": "class",
      "signature": "(linefmt=None)",
      "description": "A formatter suitable for formatting a number of records.",
      "relationships": []
    },
    {
      "id": "stdlib.logging.FileHandler",
      "name": "FileHandler",
      "module": "logging",
      "type": "class",
      "signature": "(filename, mode='a', encoding=None, delay=False, errors=None)",
      "description": "A handler class which writes formatted logging records to disk files.",
      "relationships": [
        {
          "target": "StreamHandler",
          "type": "base_class"
        },
        {
          "target": "Handler",
          "type": "base_class"
        },
        {
          "target": "Filterer",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.logging.Filter",
      "name": "Filter",
      "module": "logging",
      "type": "class",
      "signature": "(name='')",
      "description": "Filter instances are used to perform arbitrary filtering of LogRecords.\n\nLoggers and Handlers can optionally use Filter instances to filter\nrecords as desired. The base filter class only allows events which are\nbelow a certain point in the logger hierarchy. For example, a filter\ninitialized with \"A.B\" will allow events logged by loggers \"A.B\",\n\"A.B.C\", \"A.B.C.D\", \"A.B.D\" etc. but not \"A.BB\", \"B.A.B\" etc. If\ninitialized with the empty string, all events are passed.",
      "relationships": []
    },
    {
      "id": "stdlib.logging.Filterer",
      "name": "Filterer",
      "module": "logging",
      "type": "class",
      "signature": "()",
      "description": "A base class for loggers and handlers which allows them to share\ncommon code.",
      "relationships": []
    },
    {
      "id": "stdlib.logging.Formatter",
      "name": "Formatter",
      "module": "logging",
      "type": "class",
      "signature": "(fmt=None, datefmt=None, style='%', validate=True)",
      "description": "Formatter instances are used to convert a LogRecord to text.\n\nFormatters need to know how a LogRecord is constructed. They are\nresponsible for converting a LogRecord to (usually) a string which can\nbe interpreted by either a human or an external system. The base Formatter\nallows a formatting string to be specified. If none is supplied, the\nstyle-dependent default value, \"%(message)s\", \"{message}\", or\n\"${message}\", is used.\n\nThe Formatter can be initialized with a format string which makes use of\nknowledge of the LogRecord attributes - e.g. the default value mentioned\nabove makes use of the fact that the user's message and arguments are pre-\nformatted into a LogRecord's message attribute. Currently, the useful\nattributes in a LogRecord are described by:\n\n%(name)s            Name of the logger (logging channel)\n%(levelno)s         Numeric logging level for the message (DEBUG, INFO,\n                    WARNING, ERROR, CRITICAL)\n%(levelname)s       Text logging level for the message (\"DEBUG\", \"INFO\",\n                    \"WARNING\", \"ERROR\", \"CRITICAL\")\n%(pathname)s        Full pathname of the source file where the logging\n                    call was issued (if available)\n%(filename)s        Filename portion of pathname\n%(module)s          Module (name portion of filename)\n%(lineno)d          Source line number where the logging call was issued\n                    (if available)\n%(funcName)s        Function name\n%(created)f         Time when the LogRecord was created (time.time()\n                    return value)\n%(asctime)s         Textual time when the LogRecord was created\n%(msecs)d           Millisecond portion of the creation time\n%(relativeCreated)d Time in milliseconds when the LogRecord was created,\n                    relative to the time the logging module was loaded\n                    (typically at application startup time)\n%(thread)d          Thread ID (if available)\n%(threadName)s      Thread name (if available)\n%(process)d         Process ID (if available)\n%(message)s         The result of record.getMessage(), computed just as\n                    the record is emitted",
      "relationships": []
    },
    {
      "id": "stdlib.logging.Handler",
      "name": "Handler",
      "module": "logging",
      "type": "class",
      "signature": "(level=0)",
      "description": "Handler instances dispatch logging events to specific destinations.\n\nThe base handler class. Acts as a placeholder which defines the Handler\ninterface. Handlers can optionally use Formatter instances to format\nrecords as desired. By default, no formatter is specified; in this case,\nthe 'raw' message as determined by record.message is logged.",
      "relationships": [
        {
          "target": "Filterer",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.logging.LogRecord",
      "name": "LogRecord",
      "module": "logging",
      "type": "class",
      "signature": "(name, level, pathname, lineno, msg, args, exc_info, func=None, sinfo=None, **kwargs)",
      "description": "A LogRecord instance represents an event being logged.\n\nLogRecord instances are created every time something is logged. They\ncontain all the information pertinent to the event being logged. The\nmain information passed in is in msg and args, which are combined\nusing str(msg) % args to create the message field of the record. The\nrecord also includes information such as when the record was created,\nthe source line where the logging call was made, and any exception\ninformation to be logged.",
      "relationships": []
    },
    {
      "id": "stdlib.logging.Logger",
      "name": "Logger",
      "module": "logging",
      "type": "class",
      "signature": "(name, level=0)",
      "description": "Instances of the Logger class represent a single logging channel. A\n\"logging channel\" indicates an area of an application. Exactly how an\n\"area\" is defined is up to the application developer. Since an\napplication can have any number of areas, logging channels are identified\nby a unique string. Application areas can be nested (e.g. an area\nof \"input processing\" might include sub-areas \"read CSV files\", \"read\nXLS files\" and \"read Gnumeric files\"). To cater for this natural nesting,\nchannel names are organized into a namespace hierarchy where levels are\nseparated by periods, much like the Java or Python package namespace. So\nin the instance given above, channel names might be \"input\" for the upper\nlevel, and \"input.csv\", \"input.xls\" and \"input.gnu\" for the sub-levels.\nThere is no arbitrary limit to the depth of nesting.",
      "relationships": [
        {
          "target": "Filterer",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.logging.LoggerAdapter",
      "name": "LoggerAdapter",
      "module": "logging",
      "type": "class",
      "signature": "(logger, extra)",
      "description": "An adapter for loggers which makes it easier to specify contextual\ninformation in logging output.",
      "relationships": []
    },
    {
      "id": "stdlib.logging.Manager",
      "name": "Manager",
      "module": "logging",
      "type": "class",
      "signature": "(rootnode)",
      "description": "There is [under normal circumstances] just one Manager instance, which\nholds the hierarchy of loggers.",
      "relationships": []
    },
    {
      "id": "stdlib.logging.NullHandler",
      "name": "NullHandler",
      "module": "logging",
      "type": "class",
      "signature": "(level=0)",
      "description": "This handler does nothing. It's intended to be used to avoid the\n\"No handlers could be found for logger XXX\" one-off warning. This is\nimportant for library code, which may contain code to log events. If a user\nof the library does not configure logging, the one-off warning might be\nproduced; to avoid this, the library developer simply needs to instantiate\na NullHandler and add it to the top-level logger of the library module or\npackage.",
      "relationships": [
        {
          "target": "Handler",
          "type": "base_class"
        },
        {
          "target": "Filterer",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.logging.PercentStyle",
      "name": "PercentStyle",
      "module": "logging",
      "type": "class",
      "signature": "(fmt)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.logging.PlaceHolder",
      "name": "PlaceHolder",
      "module": "logging",
      "type": "class",
      "signature": "(alogger)",
      "description": "PlaceHolder instances are used in the Manager logger hierarchy to take\nthe place of nodes for which no loggers have been defined. This class is\nintended for internal use only and not as part of the public API.",
      "relationships": []
    },
    {
      "id": "stdlib.logging.RootLogger",
      "name": "RootLogger",
      "module": "logging",
      "type": "class",
      "signature": "(level)",
      "description": "A root logger is not that different to any other logger, except that\nit must have a logging level and there is only one instance of it in\nthe hierarchy.",
      "relationships": [
        {
          "target": "Logger",
          "type": "base_class"
        },
        {
          "target": "Filterer",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.logging.StrFormatStyle",
      "name": "StrFormatStyle",
      "module": "logging",
      "type": "class",
      "signature": "(fmt)",
      "description": "",
      "relationships": [
        {
          "target": "PercentStyle",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.logging.StreamHandler",
      "name": "StreamHandler",
      "module": "logging",
      "type": "class",
      "signature": "(stream=None)",
      "description": "A handler class which writes logging records, appropriately formatted,\nto a stream. Note that this class does not close the stream, as\nsys.stdout or sys.stderr may be used.",
      "relationships": [
        {
          "target": "Handler",
          "type": "base_class"
        },
        {
          "target": "Filterer",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.logging.StringTemplateStyle",
      "name": "StringTemplateStyle",
      "module": "logging",
      "type": "class",
      "signature": "(fmt)",
      "description": "",
      "relationships": [
        {
          "target": "PercentStyle",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.logging.Template",
      "name": "Template",
      "module": "logging",
      "type": "class",
      "signature": "(template)",
      "description": "A string class for supporting $-substitutions.",
      "relationships": []
    },
    {
      "id": "stdlib.logging.addLevelName",
      "name": "addLevelName",
      "module": "logging",
      "type": "function",
      "signature": "(level, levelName)",
      "description": "Associate 'levelName' with 'level'.\n\nThis is used when converting levels to text during message formatting.",
      "relationships": [
        {
          "target": "stdlib.logging._acquireLock",
          "type": "calls"
        },
        {
          "target": "stdlib.logging._releaseLock",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.logging.basicConfig",
      "name": "basicConfig",
      "module": "logging",
      "type": "function",
      "signature": "(**kwargs)",
      "description": "Do basic configuration for the logging system.\n\nThis function does nothing if the root logger already has handlers\nconfigured, unless the keyword argument *force* is set to ``True``.\nIt is a convenience method intended for use by simple scripts\nto do one-shot configuration of the logging package.\n\nThe default behaviour is to create a StreamHandler which writes to\nsys.stderr, set a formatter using the BASIC_FORMAT format string, and\nadd the handler to the root logger.\n\nA number of optional keyword arguments may be specified, which can alter\nthe default behaviour.\n\nfilename  Specifies that a FileHandler be created, using the specified\n          filename, rather than a StreamHandler.\nfilemode  Specifies the mode to open the file, if filename is specified\n          (if filemode is unspecified, it defaults to 'a').\nformat    Use the specified format string for the handler.\ndatefmt   Use the specified date/time format.\nstyle     If a format string is specified, use this to specify the\n          type of format string (possible values '%', '{', '$', for\n          %-formatting, :meth:`str.format` and :class:`string.Template`\n          - defaults to '%').\nlevel     Set the root logger level to the specified level.\nstream    Use the specified stream to initialize the StreamHandler. Note\n          that this argument is incompatible with 'filename' - if both\n          are present, 'stream' is ignored.\nhandlers  If specified, this should be an iterable of already created\n          handlers, which will be added to the root handler. Any handler\n          in the list which does not have a formatter assigned will be\n          assigned the formatter created in this function.\nforce     If this keyword  is specified as true, any existing handlers\n          attached to the root logger are removed and closed, before\n          carrying out the configuration as specified by the other\n          arguments.\nencoding  If specified together with a filename, this encoding is passed to\n          the created FileHandler, causing it to be used when the file is\n          opened.\nerrors    If specified together with a filename, this value is passed to the\n          created FileHandler, causing it to be used when the file is\n          opened in text mode. If not specified, the default value is\n          `backslashreplace`.\n\nNote that you could specify a stream created using open(filename, mode)\nrather than passing the filename and mode in. However, it should be\nremembered that StreamHandler does not close its stream (since it may be\nusing sys.stdout or sys.stderr), whereas FileHandler closes its stream\nwhen the handler is closed.\n\n.. versionchanged:: 3.2\n   Added the ``style`` parameter.\n\n.. versionchanged:: 3.3\n   Added the ``handlers`` parameter. A ``ValueError`` is now thrown for\n   incompatible arguments (e.g. ``handlers`` specified together with\n   ``filename``/``filemode``, or ``filename``/``filemode`` specified\n   together with ``stream``, or ``handlers`` specified together with\n   ``stream``.\n\n.. versionchanged:: 3.8\n   Added the ``force`` parameter.\n\n.. versionchanged:: 3.9\n   Added the ``encoding`` and ``errors`` parameters.",
      "relationships": [
        {
          "target": "stdlib.logging._acquireLock",
          "type": "calls"
        },
        {
          "target": "stdlib.logging.pop",
          "type": "calls"
        },
        {
          "target": "stdlib.logging.pop",
          "type": "calls"
        },
        {
          "target": "stdlib.logging.pop",
          "type": "calls"
        },
        {
          "target": "stdlib.logging._releaseLock",
          "type": "calls"
        },
        {
          "target": "stdlib.logging.len",
          "type": "calls"
        },
        {
          "target": "stdlib.logging.pop",
          "type": "calls"
        },
        {
          "target": "stdlib.logging.pop",
          "type": "calls"
        },
        {
          "target": "stdlib.logging.pop",
          "type": "calls"
        },
        {
          "target": "stdlib.logging.pop",
          "type": "calls"
        },
        {
          "target": "stdlib.logging.Formatter",
          "type": "calls"
        },
        {
          "target": "stdlib.logging.pop",
          "type": "calls"
        },
        {
          "target": "stdlib.logging.removeHandler",
          "type": "calls"
        },
        {
          "target": "stdlib.logging.close",
          "type": "calls"
        },
        {
          "target": "stdlib.logging.pop",
          "type": "calls"
        },
        {
          "target": "stdlib.logging.pop",
          "type": "calls"
        },
        {
          "target": "stdlib.logging.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.logging.addHandler",
          "type": "calls"
        },
        {
          "target": "stdlib.logging.setLevel",
          "type": "calls"
        },
        {
          "target": "stdlib.logging.join",
          "type": "calls"
        },
        {
          "target": "stdlib.logging.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.logging.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.logging.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.logging.FileHandler",
          "type": "calls"
        },
        {
          "target": "stdlib.logging.pop",
          "type": "calls"
        },
        {
          "target": "stdlib.logging.StreamHandler",
          "type": "calls"
        },
        {
          "target": "stdlib.logging.setFormatter",
          "type": "calls"
        },
        {
          "target": "stdlib.logging.keys",
          "type": "calls"
        },
        {
          "target": "stdlib.logging.join",
          "type": "calls"
        },
        {
          "target": "stdlib.logging.keys",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.logging.captureWarnings",
      "name": "captureWarnings",
      "module": "logging",
      "type": "function",
      "signature": "(capture)",
      "description": "If capture is true, redirect all warnings to the logging package.\nIf capture is False, ensure that warnings are not redirected to logging\nbut to their original destinations.",
      "relationships": []
    },
    {
      "id": "stdlib.logging.critical",
      "name": "critical",
      "module": "logging",
      "type": "function",
      "signature": "(msg, *args, **kwargs)",
      "description": "Log a message with severity 'CRITICAL' on the root logger. If the logger\nhas no handlers, call basicConfig() to add a console handler with a\npre-defined format.",
      "relationships": [
        {
          "target": "stdlib.logging.critical",
          "type": "calls"
        },
        {
          "target": "stdlib.logging.len",
          "type": "calls"
        },
        {
          "target": "stdlib.logging.basicConfig",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.logging.currentframe",
      "name": "currentframe",
      "module": "logging",
      "type": "function",
      "signature": "()",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.logging._getframe",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.logging.debug",
      "name": "debug",
      "module": "logging",
      "type": "function",
      "signature": "(msg, *args, **kwargs)",
      "description": "Log a message with severity 'DEBUG' on the root logger. If the logger has\nno handlers, call basicConfig() to add a console handler with a pre-defined\nformat.",
      "relationships": [
        {
          "target": "stdlib.logging.debug",
          "type": "calls"
        },
        {
          "target": "stdlib.logging.len",
          "type": "calls"
        },
        {
          "target": "stdlib.logging.basicConfig",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.logging.disable",
      "name": "disable",
      "module": "logging",
      "type": "function",
      "signature": "(level=50)",
      "description": "Disable all logging calls of severity 'level' and below.",
      "relationships": [
        {
          "target": "stdlib.logging._clear_cache",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.logging.error",
      "name": "error",
      "module": "logging",
      "type": "function",
      "signature": "(msg, *args, **kwargs)",
      "description": "Log a message with severity 'ERROR' on the root logger. If the logger has\nno handlers, call basicConfig() to add a console handler with a pre-defined\nformat.",
      "relationships": [
        {
          "target": "stdlib.logging.error",
          "type": "calls"
        },
        {
          "target": "stdlib.logging.len",
          "type": "calls"
        },
        {
          "target": "stdlib.logging.basicConfig",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.logging.exception",
      "name": "exception",
      "module": "logging",
      "type": "function",
      "signature": "(msg, *args, exc_info=True, **kwargs)",
      "description": "Log a message with severity 'ERROR' on the root logger, with exception\ninformation. If the logger has no handlers, basicConfig() is called to add\na console handler with a pre-defined format.",
      "relationships": [
        {
          "target": "stdlib.logging.error",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.logging.fatal",
      "name": "fatal",
      "module": "logging",
      "type": "function",
      "signature": "(msg, *args, **kwargs)",
      "description": "Log a message with severity 'CRITICAL' on the root logger. If the logger\nhas no handlers, call basicConfig() to add a console handler with a\npre-defined format.",
      "relationships": [
        {
          "target": "stdlib.logging.critical",
          "type": "calls"
        },
        {
          "target": "stdlib.logging.len",
          "type": "calls"
        },
        {
          "target": "stdlib.logging.basicConfig",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.logging.getLevelName",
      "name": "getLevelName",
      "module": "logging",
      "type": "function",
      "signature": "(level)",
      "description": "Return the textual or numeric representation of logging level 'level'.\n\nIf the level is one of the predefined levels (CRITICAL, ERROR, WARNING,\nINFO, DEBUG) then you get the corresponding string. If you have\nassociated levels with names using addLevelName then the name you have\nassociated with 'level' is returned.\n\nIf a numeric value corresponding to one of the defined levels is passed\nin, the corresponding string representation is returned.\n\nIf a string representation of the level is passed in, the corresponding\nnumeric value is returned.\n\nIf no matching numeric or string value is passed in, the string\n'Level %s' % level is returned.",
      "relationships": [
        {
          "target": "stdlib.logging.get",
          "type": "calls"
        },
        {
          "target": "stdlib.logging.get",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.logging.getLogRecordFactory",
      "name": "getLogRecordFactory",
      "module": "logging",
      "type": "function",
      "signature": "()",
      "description": "Return the factory to be used when instantiating a log record.",
      "relationships": []
    },
    {
      "id": "stdlib.logging.getLogger",
      "name": "getLogger",
      "module": "logging",
      "type": "function",
      "signature": "(name=None)",
      "description": "Return a logger with the specified name, creating it if necessary.\n\nIf no name is specified, return the root logger.",
      "relationships": [
        {
          "target": "stdlib.logging.getLogger",
          "type": "calls"
        },
        {
          "target": "stdlib.logging.isinstance",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.logging.getLoggerClass",
      "name": "getLoggerClass",
      "module": "logging",
      "type": "function",
      "signature": "()",
      "description": "Return the class to be used when instantiating a logger.",
      "relationships": []
    },
    {
      "id": "stdlib.logging.info",
      "name": "info",
      "module": "logging",
      "type": "function",
      "signature": "(msg, *args, **kwargs)",
      "description": "Log a message with severity 'INFO' on the root logger. If the logger has\nno handlers, call basicConfig() to add a console handler with a pre-defined\nformat.",
      "relationships": [
        {
          "target": "stdlib.logging.info",
          "type": "calls"
        },
        {
          "target": "stdlib.logging.len",
          "type": "calls"
        },
        {
          "target": "stdlib.logging.basicConfig",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.logging.log",
      "name": "log",
      "module": "logging",
      "type": "function",
      "signature": "(level, msg, *args, **kwargs)",
      "description": "Log 'msg % args' with the integer severity 'level' on the root logger. If\nthe logger has no handlers, call basicConfig() to add a console handler\nwith a pre-defined format.",
      "relationships": [
        {
          "target": "stdlib.logging.log",
          "type": "calls"
        },
        {
          "target": "stdlib.logging.len",
          "type": "calls"
        },
        {
          "target": "stdlib.logging.basicConfig",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.logging.makeLogRecord",
      "name": "makeLogRecord",
      "module": "logging",
      "type": "function",
      "signature": "(dict)",
      "description": "Make a LogRecord whose attributes are defined by the specified dictionary,\nThis function is useful for converting a logging event received over\na socket connection (which is sent as a dictionary) into a LogRecord\ninstance.",
      "relationships": [
        {
          "target": "stdlib.logging._logRecordFactory",
          "type": "calls"
        },
        {
          "target": "stdlib.logging.update",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.logging.setLogRecordFactory",
      "name": "setLogRecordFactory",
      "module": "logging",
      "type": "function",
      "signature": "(factory)",
      "description": "Set the factory to be used when instantiating a log record.\n\n:param factory: A callable which will be called to instantiate\na log record.",
      "relationships": []
    },
    {
      "id": "stdlib.logging.setLoggerClass",
      "name": "setLoggerClass",
      "module": "logging",
      "type": "function",
      "signature": "(klass)",
      "description": "Set the class to be used when instantiating a logger. The class should\ndefine __init__() such that only a name argument is required, and the\n__init__() should call Logger.__init__()",
      "relationships": [
        {
          "target": "stdlib.logging.issubclass",
          "type": "calls"
        },
        {
          "target": "stdlib.logging.TypeError",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.logging.shutdown",
      "name": "shutdown",
      "module": "logging",
      "type": "function",
      "signature": "(handlerList=[<weakref at 0x10836e0e0; to '_StderrHandler' at 0x10835ec40>])",
      "description": "Perform any cleanup actions in the logging system (e.g. flushing\nbuffers).\n\nShould be called at application exit.",
      "relationships": [
        {
          "target": "stdlib.logging.reversed",
          "type": "calls"
        },
        {
          "target": "stdlib.logging.wr",
          "type": "calls"
        },
        {
          "target": "stdlib.logging.acquire",
          "type": "calls"
        },
        {
          "target": "stdlib.logging.flush",
          "type": "calls"
        },
        {
          "target": "stdlib.logging.close",
          "type": "calls"
        },
        {
          "target": "stdlib.logging.release",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.logging.warn",
      "name": "warn",
      "module": "logging",
      "type": "function",
      "signature": "(msg, *args, **kwargs)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.logging.warn",
          "type": "calls"
        },
        {
          "target": "stdlib.logging.warning",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.logging.warning",
      "name": "warning",
      "module": "logging",
      "type": "function",
      "signature": "(msg, *args, **kwargs)",
      "description": "Log a message with severity 'WARNING' on the root logger. If the logger has\nno handlers, call basicConfig() to add a console handler with a pre-defined\nformat.",
      "relationships": [
        {
          "target": "stdlib.logging.warning",
          "type": "calls"
        },
        {
          "target": "stdlib.logging.len",
          "type": "calls"
        },
        {
          "target": "stdlib.logging.basicConfig",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.lzma.LZMADecompressor",
      "name": "LZMADecompressor",
      "module": "lzma",
      "type": "class",
      "signature": "(format=0, memlimit=None, filters=None)",
      "description": "Create a decompressor object for decompressing data incrementally.\n\n  format\n    Specifies the container format of the input stream.  If this is\n    FORMAT_AUTO (the default), the decompressor will automatically detect\n    whether the input is FORMAT_XZ or FORMAT_ALONE.  Streams created with\n    FORMAT_RAW cannot be autodetected.\n  memlimit\n    Limit the amount of memory used by the decompressor.  This will cause\n    decompression to fail if the input cannot be decompressed within the\n    given limit.\n  filters\n    A custom filter chain.  This argument is required for FORMAT_RAW, and\n    not accepted with any other format.  When provided, this should be a\n    sequence of dicts, each indicating the ID and options for a single\n    filter.\n\nFor one-shot decompression, use the decompress() function instead.",
      "relationships": []
    },
    {
      "id": "stdlib.lzma.LZMAFile",
      "name": "LZMAFile",
      "module": "lzma",
      "type": "class",
      "signature": "(filename=None, mode='r', *, format=None, check=-1, preset=None, filters=None)",
      "description": "A file object providing transparent LZMA (de)compression.\n\nAn LZMAFile can act as a wrapper for an existing file object, or\nrefer directly to a named file on disk.\n\nNote that LZMAFile provides a *binary* file interface - data read\nis returned as bytes, and data to be written must be given as bytes.",
      "relationships": [
        {
          "target": "BaseStream",
          "type": "base_class"
        },
        {
          "target": "BufferedIOBase",
          "type": "base_class"
        },
        {
          "target": "_BufferedIOBase",
          "type": "base_class"
        },
        {
          "target": "IOBase",
          "type": "base_class"
        },
        {
          "target": "_IOBase",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.lzma.compress",
      "name": "compress",
      "module": "lzma",
      "type": "function",
      "signature": "(data, format=1, check=-1, preset=None, filters=None)",
      "description": "Compress a block of data.\n\nRefer to LZMACompressor's docstring for a description of the\noptional arguments *format*, *check*, *preset* and *filters*.\n\nFor incremental compression, use an LZMACompressor instead.",
      "relationships": [
        {
          "target": "stdlib.lzma.LZMACompressor",
          "type": "calls"
        },
        {
          "target": "stdlib.lzma.compress",
          "type": "calls"
        },
        {
          "target": "stdlib.lzma.flush",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.lzma.decompress",
      "name": "decompress",
      "module": "lzma",
      "type": "function",
      "signature": "(data, format=0, memlimit=None, filters=None)",
      "description": "Decompress a block of data.\n\nRefer to LZMADecompressor's docstring for a description of the\noptional arguments *format*, *check* and *filters*.\n\nFor incremental decompression, use an LZMADecompressor instead.",
      "relationships": [
        {
          "target": "stdlib.lzma.join",
          "type": "calls"
        },
        {
          "target": "stdlib.lzma.LZMADecompressor",
          "type": "calls"
        },
        {
          "target": "stdlib.lzma.append",
          "type": "calls"
        },
        {
          "target": "stdlib.lzma.decompress",
          "type": "calls"
        },
        {
          "target": "stdlib.lzma.LZMAError",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.lzma.open",
      "name": "open",
      "module": "lzma",
      "type": "function",
      "signature": "(filename, mode='rb', *, format=None, check=-1, preset=None, filters=None, encoding=None, errors=None, newline=None)",
      "description": "Open an LZMA-compressed file in binary or text mode.\n\nfilename can be either an actual file name (given as a str, bytes,\nor PathLike object), in which case the named file is opened, or it\ncan be an existing file object to read from or write to.\n\nThe mode argument can be \"r\", \"rb\" (default), \"w\", \"wb\", \"x\", \"xb\",\n\"a\", or \"ab\" for binary mode, or \"rt\", \"wt\", \"xt\", or \"at\" for text\nmode.\n\nThe format, check, preset and filters arguments specify the\ncompression settings, as for LZMACompressor, LZMADecompressor and\nLZMAFile.\n\nFor binary mode, this function is equivalent to the LZMAFile\nconstructor: LZMAFile(filename, mode, ...). In this case, the\nencoding, errors and newline arguments must not be provided.\n\nFor text mode, an LZMAFile object is created, and wrapped in an\nio.TextIOWrapper instance with the specified encoding, error\nhandling behavior, and line ending(s).",
      "relationships": [
        {
          "target": "stdlib.lzma.replace",
          "type": "calls"
        },
        {
          "target": "stdlib.lzma.LZMAFile",
          "type": "calls"
        },
        {
          "target": "stdlib.lzma.TextIOWrapper",
          "type": "calls"
        },
        {
          "target": "stdlib.lzma.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.lzma.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.lzma.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.lzma.ValueError",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.mailbox.Babyl",
      "name": "Babyl",
      "module": "mailbox",
      "type": "class",
      "signature": "(path, factory=None, create=True)",
      "description": "An Rmail-style Babyl mailbox.",
      "relationships": [
        {
          "target": "_singlefileMailbox",
          "type": "base_class"
        },
        {
          "target": "Mailbox",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.mailbox.BabylMessage",
      "name": "BabylMessage",
      "module": "mailbox",
      "type": "class",
      "signature": "(message=None)",
      "description": "Message with Babyl-specific properties.",
      "relationships": [
        {
          "target": "Message",
          "type": "base_class"
        },
        {
          "target": "Message",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.mailbox.MH",
      "name": "MH",
      "module": "mailbox",
      "type": "class",
      "signature": "(path, factory=None, create=True)",
      "description": "An MH mailbox.",
      "relationships": [
        {
          "target": "Mailbox",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.mailbox.MHMessage",
      "name": "MHMessage",
      "module": "mailbox",
      "type": "class",
      "signature": "(message=None)",
      "description": "Message with MH-specific properties.",
      "relationships": [
        {
          "target": "Message",
          "type": "base_class"
        },
        {
          "target": "Message",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.mailbox.MMDF",
      "name": "MMDF",
      "module": "mailbox",
      "type": "class",
      "signature": "(path, factory=None, create=True)",
      "description": "An MMDF mailbox.",
      "relationships": [
        {
          "target": "_mboxMMDF",
          "type": "base_class"
        },
        {
          "target": "_singlefileMailbox",
          "type": "base_class"
        },
        {
          "target": "Mailbox",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.mailbox.MMDFMessage",
      "name": "MMDFMessage",
      "module": "mailbox",
      "type": "class",
      "signature": "(message=None)",
      "description": "Message with MMDF-specific properties.",
      "relationships": [
        {
          "target": "_mboxMMDFMessage",
          "type": "base_class"
        },
        {
          "target": "Message",
          "type": "base_class"
        },
        {
          "target": "Message",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.mailbox.Mailbox",
      "name": "Mailbox",
      "module": "mailbox",
      "type": "class",
      "signature": "(path, factory=None, create=True)",
      "description": "A group of messages in a particular place.",
      "relationships": []
    },
    {
      "id": "stdlib.mailbox.Maildir",
      "name": "Maildir",
      "module": "mailbox",
      "type": "class",
      "signature": "(dirname, factory=None, create=True)",
      "description": "A qmail-style Maildir mailbox.",
      "relationships": [
        {
          "target": "Mailbox",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.mailbox.MaildirMessage",
      "name": "MaildirMessage",
      "module": "mailbox",
      "type": "class",
      "signature": "(message=None)",
      "description": "Message with Maildir-specific properties.",
      "relationships": [
        {
          "target": "Message",
          "type": "base_class"
        },
        {
          "target": "Message",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.mailbox.Message",
      "name": "Message",
      "module": "mailbox",
      "type": "class",
      "signature": "(message=None)",
      "description": "Message with mailbox-format-specific properties.",
      "relationships": [
        {
          "target": "Message",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.mailbox.mbox",
      "name": "mbox",
      "module": "mailbox",
      "type": "class",
      "signature": "(path, factory=None, create=True)",
      "description": "A classic mbox mailbox.",
      "relationships": [
        {
          "target": "_mboxMMDF",
          "type": "base_class"
        },
        {
          "target": "_singlefileMailbox",
          "type": "base_class"
        },
        {
          "target": "Mailbox",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.mailbox.mboxMessage",
      "name": "mboxMessage",
      "module": "mailbox",
      "type": "class",
      "signature": "(message=None)",
      "description": "Message with mbox-specific properties.",
      "relationships": [
        {
          "target": "_mboxMMDFMessage",
          "type": "base_class"
        },
        {
          "target": "Message",
          "type": "base_class"
        },
        {
          "target": "Message",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.mailcap.findmatch",
      "name": "findmatch",
      "module": "mailcap",
      "type": "function",
      "signature": "(caps, MIMEtype, key='view', filename='/dev/null', plist=[])",
      "description": "Find a match for a mailcap entry.\n\nReturn a tuple containing the command line, and the mailcap entry\nused; (None, None) if no match is found.  This may invoke the\n'test' command of several matching entries before deciding which\nentry to use.",
      "relationships": [
        {
          "target": "stdlib.mailcap._find_unsafe",
          "type": "calls"
        },
        {
          "target": "stdlib.mailcap.lookup",
          "type": "calls"
        },
        {
          "target": "stdlib.mailcap.warn",
          "type": "calls"
        },
        {
          "target": "stdlib.mailcap.subst",
          "type": "calls"
        },
        {
          "target": "stdlib.mailcap.subst",
          "type": "calls"
        },
        {
          "target": "stdlib.mailcap.system",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.mailcap.findparam",
      "name": "findparam",
      "module": "mailcap",
      "type": "function",
      "signature": "(name, plist)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.mailcap.len",
          "type": "calls"
        },
        {
          "target": "stdlib.mailcap.lower",
          "type": "calls"
        },
        {
          "target": "stdlib.mailcap.lower",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.mailcap.getcaps",
      "name": "getcaps",
      "module": "mailcap",
      "type": "function",
      "signature": "()",
      "description": "Return a dictionary containing the mailcap database.\n\nThe dictionary maps a MIME type (in all lowercase, e.g. 'text/plain')\nto a list of dictionaries corresponding to mailcap entries.  The list\ncollects all the entries for that MIME type from all available mailcap\nfiles.  Each dictionary contains key-value pairs for that MIME type,\nwhere the viewing command is stored with the key \"view\".",
      "relationships": [
        {
          "target": "stdlib.mailcap.listmailcapfiles",
          "type": "calls"
        },
        {
          "target": "stdlib.mailcap.items",
          "type": "calls"
        },
        {
          "target": "stdlib.mailcap.open",
          "type": "calls"
        },
        {
          "target": "stdlib.mailcap._readmailcapfile",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.mailcap.lineno_sort_key",
      "name": "lineno_sort_key",
      "module": "mailcap",
      "type": "function",
      "signature": "(entry)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.mailcap.listmailcapfiles",
      "name": "listmailcapfiles",
      "module": "mailcap",
      "type": "function",
      "signature": "()",
      "description": "Return a list of all mailcap files found on the system.",
      "relationships": [
        {
          "target": "stdlib.mailcap.split",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.mailcap.lookup",
      "name": "lookup",
      "module": "mailcap",
      "type": "function",
      "signature": "(caps, MIMEtype, key=None)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.mailcap.split",
          "type": "calls"
        },
        {
          "target": "stdlib.mailcap.sorted",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.mailcap.parsefield",
      "name": "parsefield",
      "module": "mailcap",
      "type": "function",
      "signature": "(line, i, n)",
      "description": "Separate one key-value pair in a mailcap entry.",
      "relationships": [
        {
          "target": "stdlib.mailcap.strip",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.mailcap.parseline",
      "name": "parseline",
      "module": "mailcap",
      "type": "function",
      "signature": "(line)",
      "description": "Parse one entry in a mailcap file and return a dictionary.\n\nThe viewing command is stored as the value with the key \"view\",\nand the rest of the fields produce key-value pairs in the dict.",
      "relationships": [
        {
          "target": "stdlib.mailcap.len",
          "type": "calls"
        },
        {
          "target": "stdlib.mailcap.parsefield",
          "type": "calls"
        },
        {
          "target": "stdlib.mailcap.append",
          "type": "calls"
        },
        {
          "target": "stdlib.mailcap.len",
          "type": "calls"
        },
        {
          "target": "stdlib.mailcap.find",
          "type": "calls"
        },
        {
          "target": "stdlib.mailcap.strip",
          "type": "calls"
        },
        {
          "target": "stdlib.mailcap.strip",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.mailcap.readmailcapfile",
      "name": "readmailcapfile",
      "module": "mailcap",
      "type": "function",
      "signature": "(fp)",
      "description": "Read a mailcap file and return a dictionary keyed by MIME type.",
      "relationships": [
        {
          "target": "stdlib.mailcap.warn",
          "type": "calls"
        },
        {
          "target": "stdlib.mailcap._readmailcapfile",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.mailcap.show",
      "name": "show",
      "module": "mailcap",
      "type": "function",
      "signature": "(caps)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.mailcap.print",
          "type": "calls"
        },
        {
          "target": "stdlib.mailcap.listmailcapfiles",
          "type": "calls"
        },
        {
          "target": "stdlib.mailcap.print",
          "type": "calls"
        },
        {
          "target": "stdlib.mailcap.print",
          "type": "calls"
        },
        {
          "target": "stdlib.mailcap.print",
          "type": "calls"
        },
        {
          "target": "stdlib.mailcap.sorted",
          "type": "calls"
        },
        {
          "target": "stdlib.mailcap.print",
          "type": "calls"
        },
        {
          "target": "stdlib.mailcap.getcaps",
          "type": "calls"
        },
        {
          "target": "stdlib.mailcap.print",
          "type": "calls"
        },
        {
          "target": "stdlib.mailcap.sorted",
          "type": "calls"
        },
        {
          "target": "stdlib.mailcap.print",
          "type": "calls"
        },
        {
          "target": "stdlib.mailcap.print",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.mailcap.subst",
      "name": "subst",
      "module": "mailcap",
      "type": "function",
      "signature": "(field, MIMEtype, filename, plist=[])",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.mailcap.len",
          "type": "calls"
        },
        {
          "target": "stdlib.mailcap._find_unsafe",
          "type": "calls"
        },
        {
          "target": "stdlib.mailcap.warn",
          "type": "calls"
        },
        {
          "target": "stdlib.mailcap.findparam",
          "type": "calls"
        },
        {
          "target": "stdlib.mailcap._find_unsafe",
          "type": "calls"
        },
        {
          "target": "stdlib.mailcap.warn",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.mailcap.test",
      "name": "test",
      "module": "mailcap",
      "type": "function",
      "signature": "()",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.mailcap.getcaps",
          "type": "calls"
        },
        {
          "target": "stdlib.mailcap.range",
          "type": "calls"
        },
        {
          "target": "stdlib.mailcap.show",
          "type": "calls"
        },
        {
          "target": "stdlib.mailcap.len",
          "type": "calls"
        },
        {
          "target": "stdlib.mailcap.findmatch",
          "type": "calls"
        },
        {
          "target": "stdlib.mailcap.len",
          "type": "calls"
        },
        {
          "target": "stdlib.mailcap.print",
          "type": "calls"
        },
        {
          "target": "stdlib.mailcap.print",
          "type": "calls"
        },
        {
          "target": "stdlib.mailcap.print",
          "type": "calls"
        },
        {
          "target": "stdlib.mailcap.system",
          "type": "calls"
        },
        {
          "target": "stdlib.mailcap.waitstatus_to_exitcode",
          "type": "calls"
        },
        {
          "target": "stdlib.mailcap.print",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.mimetypes.MimeTypes",
      "name": "MimeTypes",
      "module": "mimetypes",
      "type": "class",
      "signature": "(filenames=(), strict=True)",
      "description": "MIME-types datastore.\n\nThis datastore can handle information from mime.types-style files\nand supports basic determination of MIME type from a filename or\nURL, and can guess a reasonable extension given a MIME type.",
      "relationships": []
    },
    {
      "id": "stdlib.mimetypes.add_type",
      "name": "add_type",
      "module": "mimetypes",
      "type": "function",
      "signature": "(type, ext, strict=True)",
      "description": "Add a mapping between a type and an extension.\n\nWhen the extension is already known, the new\ntype will replace the old one. When the type\nis already known the extension will be added\nto the list of known extensions.\n\nIf strict is true, information will be added to\nlist of standard types, else to the list of non-standard\ntypes.",
      "relationships": [
        {
          "target": "stdlib.mimetypes.add_type",
          "type": "calls"
        },
        {
          "target": "stdlib.mimetypes.init",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.mimetypes.guess_all_extensions",
      "name": "guess_all_extensions",
      "module": "mimetypes",
      "type": "function",
      "signature": "(type, strict=True)",
      "description": "Guess the extensions for a file based on its MIME type.\n\nReturn value is a list of strings giving the possible filename\nextensions, including the leading dot ('.').  The extension is not\nguaranteed to have been associated with any particular data\nstream, but would be mapped to the MIME type `type' by\nguess_type().  If no extension can be guessed for `type', None\nis returned.\n\nOptional `strict' argument when false adds a bunch of commonly found,\nbut non-standard types.",
      "relationships": [
        {
          "target": "stdlib.mimetypes.guess_all_extensions",
          "type": "calls"
        },
        {
          "target": "stdlib.mimetypes.init",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.mimetypes.guess_extension",
      "name": "guess_extension",
      "module": "mimetypes",
      "type": "function",
      "signature": "(type, strict=True)",
      "description": "Guess the extension for a file based on its MIME type.\n\nReturn value is a string giving a filename extension, including the\nleading dot ('.').  The extension is not guaranteed to have been\nassociated with any particular data stream, but would be mapped to the\nMIME type `type' by guess_type().  If no extension can be guessed for\n`type', None is returned.\n\nOptional `strict' argument when false adds a bunch of commonly found,\nbut non-standard types.",
      "relationships": [
        {
          "target": "stdlib.mimetypes.guess_extension",
          "type": "calls"
        },
        {
          "target": "stdlib.mimetypes.init",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.mimetypes.guess_type",
      "name": "guess_type",
      "module": "mimetypes",
      "type": "function",
      "signature": "(url, strict=True)",
      "description": "Guess the type of a file based on its URL.\n\nReturn value is a tuple (type, encoding) where type is None if the\ntype can't be guessed (no or unknown suffix) or a string of the\nform type/subtype, usable for a MIME Content-type header; and\nencoding is None for no encoding or the name of the program used\nto encode (e.g. compress or gzip).  The mappings are table\ndriven.  Encoding suffixes are case sensitive; type suffixes are\nfirst tried case sensitive, then case insensitive.\n\nThe suffixes .tgz, .taz and .tz (case sensitive!) are all mapped\nto \".tar.gz\".  (This is table-driven too, using the dictionary\nsuffix_map).\n\nOptional `strict' argument when false adds a bunch of commonly found, but\nnon-standard types.",
      "relationships": [
        {
          "target": "stdlib.mimetypes.guess_type",
          "type": "calls"
        },
        {
          "target": "stdlib.mimetypes.init",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.mimetypes.init",
      "name": "init",
      "module": "mimetypes",
      "type": "function",
      "signature": "(files=None)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.mimetypes.MimeTypes",
          "type": "calls"
        },
        {
          "target": "stdlib.mimetypes.isfile",
          "type": "calls"
        },
        {
          "target": "stdlib.mimetypes.read_windows_registry",
          "type": "calls"
        },
        {
          "target": "stdlib.mimetypes.read",
          "type": "calls"
        },
        {
          "target": "stdlib.mimetypes.list",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.mimetypes.read_mime_types",
      "name": "read_mime_types",
      "module": "mimetypes",
      "type": "function",
      "signature": "(file)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.mimetypes.open",
          "type": "calls"
        },
        {
          "target": "stdlib.mimetypes.MimeTypes",
          "type": "calls"
        },
        {
          "target": "stdlib.mimetypes.readfp",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.modulefinder.AddPackagePath",
      "name": "AddPackagePath",
      "module": "modulefinder",
      "type": "function",
      "signature": "(packagename, path)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.modulefinder.append",
          "type": "calls"
        },
        {
          "target": "stdlib.modulefinder.setdefault",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.modulefinder.Module",
      "name": "Module",
      "module": "modulefinder",
      "type": "class",
      "signature": "(name, file=None, path=None)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.modulefinder.ModuleFinder",
      "name": "ModuleFinder",
      "module": "modulefinder",
      "type": "class",
      "signature": "(path=None, debug=0, excludes=None, replace_paths=None)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.modulefinder.ReplacePackage",
      "name": "ReplacePackage",
      "module": "modulefinder",
      "type": "function",
      "signature": "(oldname, newname)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.modulefinder.test",
      "name": "test",
      "module": "modulefinder",
      "type": "function",
      "signature": "()",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.modulefinder.dirname",
          "type": "calls"
        },
        {
          "target": "stdlib.modulefinder.ModuleFinder",
          "type": "calls"
        },
        {
          "target": "stdlib.modulefinder.run_script",
          "type": "calls"
        },
        {
          "target": "stdlib.modulefinder.report",
          "type": "calls"
        },
        {
          "target": "stdlib.modulefinder.getopt",
          "type": "calls"
        },
        {
          "target": "stdlib.modulefinder.print",
          "type": "calls"
        },
        {
          "target": "stdlib.modulefinder.print",
          "type": "calls"
        },
        {
          "target": "stdlib.modulefinder.append",
          "type": "calls"
        },
        {
          "target": "stdlib.modulefinder.print",
          "type": "calls"
        },
        {
          "target": "stdlib.modulefinder.load_file",
          "type": "calls"
        },
        {
          "target": "stdlib.modulefinder.split",
          "type": "calls"
        },
        {
          "target": "stdlib.modulefinder.repr",
          "type": "calls"
        },
        {
          "target": "stdlib.modulefinder.import_hook",
          "type": "calls"
        },
        {
          "target": "stdlib.modulefinder.import_hook",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.multiprocessing.Process",
      "name": "Process",
      "module": "multiprocessing",
      "type": "class",
      "signature": "(group=None, target=None, name=None, args=(), kwargs={}, *, daemon=None)",
      "description": "Process objects represent activity that is run in a separate process\n\nThe class is analogous to `threading.Thread`",
      "relationships": [
        {
          "target": "BaseProcess",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.multiprocessing.active_children",
      "name": "active_children",
      "module": "multiprocessing",
      "type": "function",
      "signature": "()",
      "description": "Return list of process objects corresponding to live child processes",
      "relationships": [
        {
          "target": "stdlib.multiprocessing._cleanup",
          "type": "calls"
        },
        {
          "target": "stdlib.multiprocessing.list",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.multiprocessing.current_process",
      "name": "current_process",
      "module": "multiprocessing",
      "type": "function",
      "signature": "()",
      "description": "Return process object representing the current process",
      "relationships": []
    },
    {
      "id": "stdlib.multiprocessing.parent_process",
      "name": "parent_process",
      "module": "multiprocessing",
      "type": "function",
      "signature": "()",
      "description": "Return process object representing the parent process",
      "relationships": []
    },
    {
      "id": "stdlib.netrc.NetrcParseError",
      "name": "NetrcParseError",
      "module": "netrc",
      "type": "class",
      "signature": "(msg, filename=None, lineno=None)",
      "description": "Exception raised on syntax errors in the .netrc file.",
      "relationships": [
        {
          "target": "Exception",
          "type": "base_class"
        },
        {
          "target": "BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.netrc.netrc",
      "name": "netrc",
      "module": "netrc",
      "type": "class",
      "signature": "(file=None)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.nntplib.ArticleInfo",
      "name": "ArticleInfo",
      "module": "nntplib",
      "type": "class",
      "signature": "(number, message_id, lines)",
      "description": "ArticleInfo(number, message_id, lines)",
      "relationships": [
        {
          "target": "tuple",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.nntplib.GroupInfo",
      "name": "GroupInfo",
      "module": "nntplib",
      "type": "class",
      "signature": "(group, last, first, flag)",
      "description": "GroupInfo(group, last, first, flag)",
      "relationships": [
        {
          "target": "tuple",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.nntplib.NNTP",
      "name": "NNTP",
      "module": "nntplib",
      "type": "class",
      "signature": "(host, port=119, user=None, password=None, readermode=None, usenetrc=False, timeout=<object object at 0x102f70e60>)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.nntplib.NNTPDataError",
      "name": "NNTPDataError",
      "module": "nntplib",
      "type": "class",
      "signature": "(*args)",
      "description": "Error in response data",
      "relationships": [
        {
          "target": "NNTPError",
          "type": "base_class"
        },
        {
          "target": "Exception",
          "type": "base_class"
        },
        {
          "target": "BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.nntplib.NNTPError",
      "name": "NNTPError",
      "module": "nntplib",
      "type": "class",
      "signature": "(*args)",
      "description": "Base class for all nntplib exceptions",
      "relationships": [
        {
          "target": "Exception",
          "type": "base_class"
        },
        {
          "target": "BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.nntplib.NNTPPermanentError",
      "name": "NNTPPermanentError",
      "module": "nntplib",
      "type": "class",
      "signature": "(*args)",
      "description": "5xx errors",
      "relationships": [
        {
          "target": "NNTPError",
          "type": "base_class"
        },
        {
          "target": "Exception",
          "type": "base_class"
        },
        {
          "target": "BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.nntplib.NNTPProtocolError",
      "name": "NNTPProtocolError",
      "module": "nntplib",
      "type": "class",
      "signature": "(*args)",
      "description": "Response does not begin with [1-5]",
      "relationships": [
        {
          "target": "NNTPError",
          "type": "base_class"
        },
        {
          "target": "Exception",
          "type": "base_class"
        },
        {
          "target": "BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.nntplib.NNTPReplyError",
      "name": "NNTPReplyError",
      "module": "nntplib",
      "type": "class",
      "signature": "(*args)",
      "description": "Unexpected [123]xx reply",
      "relationships": [
        {
          "target": "NNTPError",
          "type": "base_class"
        },
        {
          "target": "Exception",
          "type": "base_class"
        },
        {
          "target": "BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.nntplib.NNTPTemporaryError",
      "name": "NNTPTemporaryError",
      "module": "nntplib",
      "type": "class",
      "signature": "(*args)",
      "description": "4xx errors",
      "relationships": [
        {
          "target": "NNTPError",
          "type": "base_class"
        },
        {
          "target": "Exception",
          "type": "base_class"
        },
        {
          "target": "BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.nntplib.NNTP_SSL",
      "name": "NNTP_SSL",
      "module": "nntplib",
      "type": "class",
      "signature": "(host, port=563, user=None, password=None, ssl_context=None, readermode=None, usenetrc=False, timeout=<object object at 0x102f70e60>)",
      "description": "",
      "relationships": [
        {
          "target": "NNTP",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.nntplib.decode_header",
      "name": "decode_header",
      "module": "nntplib",
      "type": "function",
      "signature": "(header_str)",
      "description": "Takes a unicode string representing a munged header value\nand decodes it as a (possibly non-ASCII) readable value.",
      "relationships": [
        {
          "target": "stdlib.nntplib._email_decode_header",
          "type": "calls"
        },
        {
          "target": "stdlib.nntplib.join",
          "type": "calls"
        },
        {
          "target": "stdlib.nntplib.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.nntplib.append",
          "type": "calls"
        },
        {
          "target": "stdlib.nntplib.append",
          "type": "calls"
        },
        {
          "target": "stdlib.nntplib.decode",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ntpath.abspath",
      "name": "abspath",
      "module": "ntpath",
      "type": "function",
      "signature": "(path)",
      "description": "Return the absolute version of a path as a fallback function in case\n`nt._getfullpathname` is not available or raises OSError. See bpo-31047 for\nmore.",
      "relationships": [
        {
          "target": "stdlib.ntpath.fspath",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.normpath",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.isabs",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.join",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.getcwdb",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.getcwd",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ntpath.basename",
      "name": "basename",
      "module": "ntpath",
      "type": "function",
      "signature": "(p)",
      "description": "Returns the final component of a pathname",
      "relationships": [
        {
          "target": "stdlib.ntpath.split",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ntpath.commonpath",
      "name": "commonpath",
      "module": "ntpath",
      "type": "function",
      "signature": "(paths)",
      "description": "Given a sequence of path names, returns the longest common sub-path.",
      "relationships": [
        {
          "target": "stdlib.ntpath.tuple",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.map",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.splitdrive",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.split",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.min",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.max",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.enumerate",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.splitdrive",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.split",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.set",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.len",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.replace",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.join",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath._check_arg_types",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.lower",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.set",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.len",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.replace",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ntpath.commonprefix",
      "name": "commonprefix",
      "module": "ntpath",
      "type": "function",
      "signature": "(m)",
      "description": "Given a list of pathnames, returns the longest common leading component",
      "relationships": [
        {
          "target": "stdlib.ntpath.min",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.max",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.enumerate",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.tuple",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.map",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ntpath.dirname",
      "name": "dirname",
      "module": "ntpath",
      "type": "function",
      "signature": "(p)",
      "description": "Returns the directory component of a pathname",
      "relationships": [
        {
          "target": "stdlib.ntpath.split",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ntpath.exists",
      "name": "exists",
      "module": "ntpath",
      "type": "function",
      "signature": "(path)",
      "description": "Test whether a path exists.  Returns False for broken symbolic links",
      "relationships": [
        {
          "target": "stdlib.ntpath.stat",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ntpath.expanduser",
      "name": "expanduser",
      "module": "ntpath",
      "type": "function",
      "signature": "(path)",
      "description": "Expand ~ and ~user constructs.\n\nIf user or $HOME is unknown, do nothing.",
      "relationships": [
        {
          "target": "stdlib.ntpath.fspath",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.startswith",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.len",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.fsencode",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.join",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath._get_bothseps",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.join",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.dirname",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ntpath.expandvars",
      "name": "expandvars",
      "module": "ntpath",
      "type": "function",
      "signature": "(path)",
      "description": "Expand shell variables of the forms $var, ${var} and %var%.\n\nUnknown variables are left unchanged.",
      "relationships": [
        {
          "target": "stdlib.ntpath.fspath",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.len",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.bytes",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.getattr",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.len",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.index",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.len",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.index",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.len",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.fsencode",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.index",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.fsencode",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.fsdecode",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.fsencode",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.fsdecode",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.fsdecode",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ntpath.getatime",
      "name": "getatime",
      "module": "ntpath",
      "type": "function",
      "signature": "(filename)",
      "description": "Return the last access time of a file, reported by os.stat().",
      "relationships": [
        {
          "target": "stdlib.ntpath.stat",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ntpath.getctime",
      "name": "getctime",
      "module": "ntpath",
      "type": "function",
      "signature": "(filename)",
      "description": "Return the metadata change time of a file, reported by os.stat().",
      "relationships": [
        {
          "target": "stdlib.ntpath.stat",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ntpath.getmtime",
      "name": "getmtime",
      "module": "ntpath",
      "type": "function",
      "signature": "(filename)",
      "description": "Return the last modification time of a file, reported by os.stat().",
      "relationships": [
        {
          "target": "stdlib.ntpath.stat",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ntpath.getsize",
      "name": "getsize",
      "module": "ntpath",
      "type": "function",
      "signature": "(filename)",
      "description": "Return the size of a file, reported by os.stat().",
      "relationships": [
        {
          "target": "stdlib.ntpath.stat",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ntpath.isabs",
      "name": "isabs",
      "module": "ntpath",
      "type": "function",
      "signature": "(s)",
      "description": "Test whether a path is absolute",
      "relationships": [
        {
          "target": "stdlib.ntpath.fspath",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.startswith",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.startswith",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.splitdrive",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.len",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath._get_bothseps",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.replace",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.replace",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ntpath.isdir",
      "name": "isdir",
      "module": "ntpath",
      "type": "function",
      "signature": "(s)",
      "description": "Return true if the pathname refers to an existing directory.",
      "relationships": [
        {
          "target": "stdlib.ntpath.S_ISDIR",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.stat",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ntpath.isfile",
      "name": "isfile",
      "module": "ntpath",
      "type": "function",
      "signature": "(path)",
      "description": "Test whether a path is a regular file",
      "relationships": [
        {
          "target": "stdlib.ntpath.S_ISREG",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.stat",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ntpath.islink",
      "name": "islink",
      "module": "ntpath",
      "type": "function",
      "signature": "(path)",
      "description": "Test whether a path is a symbolic link.\nThis will always return false for Windows prior to 6.0.",
      "relationships": [
        {
          "target": "stdlib.ntpath.S_ISLNK",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.lstat",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ntpath.ismount",
      "name": "ismount",
      "module": "ntpath",
      "type": "function",
      "signature": "(path)",
      "description": "Test whether a path is a mount point (a drive root, the root of a\nshare, or a mounted volume)",
      "relationships": [
        {
          "target": "stdlib.ntpath.fspath",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath._get_bothseps",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.abspath",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.splitdrive",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.rstrip",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.rstrip",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath._getvolumepathname",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ntpath.join",
      "name": "join",
      "module": "ntpath",
      "type": "function",
      "signature": "(path, *paths)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.ntpath.fspath",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.splitdrive",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.map",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.splitdrive",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath._check_arg_types",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.lower",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.lower",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ntpath.lexists",
      "name": "lexists",
      "module": "ntpath",
      "type": "function",
      "signature": "(path)",
      "description": "Test whether a path exists.  Returns True for broken symbolic links",
      "relationships": [
        {
          "target": "stdlib.ntpath.lstat",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ntpath.normcase",
      "name": "normcase",
      "module": "ntpath",
      "type": "function",
      "signature": "(s)",
      "description": "Normalize case of pathname.\n\nMakes all characters lowercase and all slashes into backslashes.",
      "relationships": [
        {
          "target": "stdlib.ntpath.fspath",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.lower",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.lower",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.replace",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.replace",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ntpath.normpath",
      "name": "normpath",
      "module": "ntpath",
      "type": "function",
      "signature": "(path)",
      "description": "Normalize path, eliminating double slashes, etc.",
      "relationships": [
        {
          "target": "stdlib.ntpath.fspath",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.startswith",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.replace",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.splitdrive",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.startswith",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.split",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.lstrip",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.len",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.append",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.join",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.endswith",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ntpath.realpath",
      "name": "realpath",
      "module": "ntpath",
      "type": "function",
      "signature": "(path)",
      "description": "Return the absolute version of a path as a fallback function in case\n`nt._getfullpathname` is not available or raises OSError. See bpo-31047 for\nmore.",
      "relationships": [
        {
          "target": "stdlib.ntpath.fspath",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.normpath",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.isabs",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.join",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.getcwdb",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.getcwd",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ntpath.relpath",
      "name": "relpath",
      "module": "ntpath",
      "type": "function",
      "signature": "(path, start=None)",
      "description": "Return a relative version of a path",
      "relationships": [
        {
          "target": "stdlib.ntpath.fspath",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.fspath",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.abspath",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.abspath",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.splitdrive",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.splitdrive",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.zip",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.join",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.normpath",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.normpath",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.normcase",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.normcase",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath._check_arg_types",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.split",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.split",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.normcase",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.normcase",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.len",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ntpath.samefile",
      "name": "samefile",
      "module": "ntpath",
      "type": "function",
      "signature": "(f1, f2)",
      "description": "Test whether two pathnames reference the same actual file or directory\n\nThis is determined by the device number and i-node number and\nraises an exception if an os.stat() call on either pathname fails.",
      "relationships": [
        {
          "target": "stdlib.ntpath.stat",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.stat",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.samestat",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ntpath.sameopenfile",
      "name": "sameopenfile",
      "module": "ntpath",
      "type": "function",
      "signature": "(fp1, fp2)",
      "description": "Test whether two open file objects reference the same file",
      "relationships": [
        {
          "target": "stdlib.ntpath.fstat",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.fstat",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.samestat",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ntpath.samestat",
      "name": "samestat",
      "module": "ntpath",
      "type": "function",
      "signature": "(s1, s2)",
      "description": "Test whether two stat buffers reference the same file",
      "relationships": []
    },
    {
      "id": "stdlib.ntpath.split",
      "name": "split",
      "module": "ntpath",
      "type": "function",
      "signature": "(p)",
      "description": "Split a pathname.\n\nReturn tuple (head, tail) where tail is everything after the final slash.\nEither part may be empty.",
      "relationships": [
        {
          "target": "stdlib.ntpath.fspath",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath._get_bothseps",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.splitdrive",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.len",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.rstrip",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ntpath.splitdrive",
      "name": "splitdrive",
      "module": "ntpath",
      "type": "function",
      "signature": "(p)",
      "description": "Split a pathname into drive/UNC sharepoint and relative path specifiers.\nReturns a 2-tuple (drive_or_unc, path); either part may be empty.\n\nIf you assign\n    result = splitdrive(p)\nIt is always true that:\n    result[0] + result[1] == p\n\nIf the path contained a drive letter, drive_or_unc will contain everything\nup to and including the colon.  e.g. splitdrive(\"c:/dir\") returns (\"c:\", \"/dir\")\n\nIf the path contained a UNC path, the drive_or_unc will contain the host name\nand share up to but not including the fourth directory separator character.\ne.g. splitdrive(\"//host/computer/dir\") returns (\"//host/computer\", \"/dir\")\n\nPaths cannot contain both a drive letter and a UNC path.",
      "relationships": [
        {
          "target": "stdlib.ntpath.fspath",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.len",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.replace",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.find",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.find",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.len",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ntpath.splitext",
      "name": "splitext",
      "module": "ntpath",
      "type": "function",
      "signature": "(p)",
      "description": "Split the extension from a pathname.\n\nExtension is everything from the last dot to the end, ignoring\nleading dots.  Returns \"(root, ext)\"; ext may be empty.",
      "relationships": [
        {
          "target": "stdlib.ntpath.fspath",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath._splitext",
          "type": "calls"
        },
        {
          "target": "stdlib.ntpath._splitext",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.nturl2path.pathname2url",
      "name": "pathname2url",
      "module": "nturl2path",
      "type": "function",
      "signature": "(p)",
      "description": "OS-specific conversion from a file system path to a relative URL\nof the 'file' scheme; not recommended for general use.",
      "relationships": [
        {
          "target": "stdlib.nturl2path.split",
          "type": "calls"
        },
        {
          "target": "stdlib.nturl2path.quote",
          "type": "calls"
        },
        {
          "target": "stdlib.nturl2path.split",
          "type": "calls"
        },
        {
          "target": "stdlib.nturl2path.split",
          "type": "calls"
        },
        {
          "target": "stdlib.nturl2path.quote",
          "type": "calls"
        },
        {
          "target": "stdlib.nturl2path.OSError",
          "type": "calls"
        },
        {
          "target": "stdlib.nturl2path.upper",
          "type": "calls"
        },
        {
          "target": "stdlib.nturl2path.upper",
          "type": "calls"
        },
        {
          "target": "stdlib.nturl2path.join",
          "type": "calls"
        },
        {
          "target": "stdlib.nturl2path.len",
          "type": "calls"
        },
        {
          "target": "stdlib.nturl2path.len",
          "type": "calls"
        },
        {
          "target": "stdlib.nturl2path.OSError",
          "type": "calls"
        },
        {
          "target": "stdlib.nturl2path.quote",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.nturl2path.url2pathname",
      "name": "url2pathname",
      "module": "nturl2path",
      "type": "function",
      "signature": "(url)",
      "description": "OS-specific conversion from a relative URL of the 'file' scheme\nto a file system path; not recommended for general use.",
      "relationships": [
        {
          "target": "stdlib.nturl2path.replace",
          "type": "calls"
        },
        {
          "target": "stdlib.nturl2path.split",
          "type": "calls"
        },
        {
          "target": "stdlib.nturl2path.upper",
          "type": "calls"
        },
        {
          "target": "stdlib.nturl2path.split",
          "type": "calls"
        },
        {
          "target": "stdlib.nturl2path.split",
          "type": "calls"
        },
        {
          "target": "stdlib.nturl2path.unquote",
          "type": "calls"
        },
        {
          "target": "stdlib.nturl2path.OSError",
          "type": "calls"
        },
        {
          "target": "stdlib.nturl2path.endswith",
          "type": "calls"
        },
        {
          "target": "stdlib.nturl2path.endswith",
          "type": "calls"
        },
        {
          "target": "stdlib.nturl2path.join",
          "type": "calls"
        },
        {
          "target": "stdlib.nturl2path.len",
          "type": "calls"
        },
        {
          "target": "stdlib.nturl2path.unquote",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.numbers.ABCMeta",
      "name": "ABCMeta",
      "module": "numbers",
      "type": "class",
      "signature": "(name, bases, namespace, **kwargs)",
      "description": "Metaclass for defining Abstract Base Classes (ABCs).\n\nUse this metaclass to create an ABC.  An ABC can be subclassed\ndirectly, and then acts as a mix-in class.  You can also register\nunrelated concrete classes (even built-in classes) and unrelated\nABCs as 'virtual subclasses' -- these and their descendants will\nbe considered subclasses of the registering ABC by the built-in\nissubclass() function, but the registering ABC won't show up in\ntheir MRO (Method Resolution Order) nor will method\nimplementations defined by the registering ABC be callable (not\neven via super()).",
      "relationships": [
        {
          "target": "type",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.numbers.Complex",
      "name": "Complex",
      "module": "numbers",
      "type": "class",
      "signature": "()",
      "description": "Complex defines the operations that work on the builtin complex type.\n\nIn short, those are: a conversion to complex, .real, .imag, +, -,\n*, /, **, abs(), .conjugate, ==, and !=.\n\nIf it is given heterogeneous arguments, and doesn't have special\nknowledge about them, it should fall back to the builtin complex\ntype as described below.",
      "relationships": [
        {
          "target": "Number",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.numbers.Integral",
      "name": "Integral",
      "module": "numbers",
      "type": "class",
      "signature": "()",
      "description": "Integral adds methods that work on integral numbers.\n\nIn short, these are conversion to int, pow with modulus, and the\nbit-string operations.",
      "relationships": [
        {
          "target": "Rational",
          "type": "base_class"
        },
        {
          "target": "Real",
          "type": "base_class"
        },
        {
          "target": "Complex",
          "type": "base_class"
        },
        {
          "target": "Number",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.numbers.Number",
      "name": "Number",
      "module": "numbers",
      "type": "class",
      "signature": "()",
      "description": "All numbers inherit from this class.\n\nIf you just want to check if an argument x is a number, without\ncaring what kind, use isinstance(x, Number).",
      "relationships": []
    },
    {
      "id": "stdlib.numbers.Rational",
      "name": "Rational",
      "module": "numbers",
      "type": "class",
      "signature": "()",
      "description": ".numerator and .denominator should be in lowest terms.",
      "relationships": [
        {
          "target": "Real",
          "type": "base_class"
        },
        {
          "target": "Complex",
          "type": "base_class"
        },
        {
          "target": "Number",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.numbers.Real",
      "name": "Real",
      "module": "numbers",
      "type": "class",
      "signature": "()",
      "description": "To Complex, Real adds the operations that work on real numbers.\n\nIn short, those are: a conversion to float, trunc(), divmod,\n%, <, <=, >, and >=.\n\nReal also provides defaults for the derived operations.",
      "relationships": [
        {
          "target": "Complex",
          "type": "base_class"
        },
        {
          "target": "Number",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.numbers.abstractmethod",
      "name": "abstractmethod",
      "module": "numbers",
      "type": "function",
      "signature": "(funcobj)",
      "description": "A decorator indicating abstract methods.\n\nRequires that the metaclass is ABCMeta or derived from it.  A\nclass that has a metaclass derived from ABCMeta cannot be\ninstantiated unless all of its abstract methods are overridden.\nThe abstract methods can be called using any of the normal\n'super' call mechanisms.  abstractmethod() may be used to declare\nabstract methods for properties and descriptors.\n\nUsage:\n\n    class C(metaclass=ABCMeta):\n        @abstractmethod\n        def my_abstract_method(self, ...):\n            ...",
      "relationships": []
    },
    {
      "id": "stdlib.optparse.AmbiguousOptionError",
      "name": "AmbiguousOptionError",
      "module": "optparse",
      "type": "class",
      "signature": "(opt_str, possibilities)",
      "description": "Raised if an ambiguous option is seen on the command line.",
      "relationships": [
        {
          "target": "BadOptionError",
          "type": "base_class"
        },
        {
          "target": "OptParseError",
          "type": "base_class"
        },
        {
          "target": "Exception",
          "type": "base_class"
        },
        {
          "target": "BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.optparse.BadOptionError",
      "name": "BadOptionError",
      "module": "optparse",
      "type": "class",
      "signature": "(opt_str)",
      "description": "Raised if an invalid option is seen on the command line.",
      "relationships": [
        {
          "target": "OptParseError",
          "type": "base_class"
        },
        {
          "target": "Exception",
          "type": "base_class"
        },
        {
          "target": "BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.optparse.HelpFormatter",
      "name": "HelpFormatter",
      "module": "optparse",
      "type": "class",
      "signature": "(indent_increment, max_help_position, width, short_first)",
      "description": "Abstract base class for formatting option help.  OptionParser\ninstances should use one of the HelpFormatter subclasses for\nformatting help; by default IndentedHelpFormatter is used.\n\nInstance attributes:\n  parser : OptionParser\n    the controlling OptionParser instance\n  indent_increment : int\n    the number of columns to indent per nesting level\n  max_help_position : int\n    the maximum starting column for option help text\n  help_position : int\n    the calculated starting column for option help text;\n    initially the same as the maximum\n  width : int\n    total number of columns for output (pass None to constructor for\n    this value to be taken from the $COLUMNS environment variable)\n  level : int\n    current indentation level\n  current_indent : int\n    current indentation level (in columns)\n  help_width : int\n    number of columns available for option help text (calculated)\n  default_tag : str\n    text to replace with each option's default value, \"%default\"\n    by default.  Set to false value to disable default value expansion.\n  option_strings : { Option : str }\n    maps Option instances to the snippet of help text explaining\n    the syntax of that option, e.g. \"-h, --help\" or\n    \"-fFILE, --file=FILE\"\n  _short_opt_fmt : str\n    format string controlling how short options with values are\n    printed in help text.  Must be either \"%s%s\" (\"-fFILE\") or\n    \"%s %s\" (\"-f FILE\"), because those are the two syntaxes that\n    Optik supports.\n  _long_opt_fmt : str\n    similar but for long options; must be either \"%s %s\" (\"--file FILE\")\n    or \"%s=%s\" (\"--file=FILE\").",
      "relationships": []
    },
    {
      "id": "stdlib.optparse.IndentedHelpFormatter",
      "name": "IndentedHelpFormatter",
      "module": "optparse",
      "type": "class",
      "signature": "(indent_increment=2, max_help_position=24, width=None, short_first=1)",
      "description": "Format help with indented section bodies.\n    ",
      "relationships": [
        {
          "target": "HelpFormatter",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.optparse.OptParseError",
      "name": "OptParseError",
      "module": "optparse",
      "type": "class",
      "signature": "(msg)",
      "description": "Common base class for all non-exit exceptions.",
      "relationships": [
        {
          "target": "Exception",
          "type": "base_class"
        },
        {
          "target": "BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.optparse.Option",
      "name": "Option",
      "module": "optparse",
      "type": "class",
      "signature": "(*opts, **attrs)",
      "description": "Instance attributes:\n  _short_opts : [string]\n  _long_opts : [string]\n\n  action : string\n  type : string\n  dest : string\n  default : any\n  nargs : int\n  const : any\n  choices : [string]\n  callback : function\n  callback_args : (any*)\n  callback_kwargs : { string : any }\n  help : string\n  metavar : string",
      "relationships": []
    },
    {
      "id": "stdlib.optparse.OptionConflictError",
      "name": "OptionConflictError",
      "module": "optparse",
      "type": "class",
      "signature": "(msg, option)",
      "description": "Raised if conflicting options are added to an OptionParser.",
      "relationships": [
        {
          "target": "OptionError",
          "type": "base_class"
        },
        {
          "target": "OptParseError",
          "type": "base_class"
        },
        {
          "target": "Exception",
          "type": "base_class"
        },
        {
          "target": "BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.optparse.OptionContainer",
      "name": "OptionContainer",
      "module": "optparse",
      "type": "class",
      "signature": "(option_class, conflict_handler, description)",
      "description": "Abstract base class.\n\nClass attributes:\n  standard_option_list : [Option]\n    list of standard options that will be accepted by all instances\n    of this parser class (intended to be overridden by subclasses).\n\nInstance attributes:\n  option_list : [Option]\n    the list of Option objects contained by this OptionContainer\n  _short_opt : { string : Option }\n    dictionary mapping short option strings, eg. \"-f\" or \"-X\",\n    to the Option instances that implement them.  If an Option\n    has multiple short option strings, it will appear in this\n    dictionary multiple times. [1]\n  _long_opt : { string : Option }\n    dictionary mapping long option strings, eg. \"--file\" or\n    \"--exclude\", to the Option instances that implement them.\n    Again, a given Option can occur multiple times in this\n    dictionary. [1]\n  defaults : { string : any }\n    dictionary mapping option destination names to default\n    values for each destination [1]\n\n[1] These mappings are common to (shared by) all components of the\n    controlling OptionParser, where they are initially created.",
      "relationships": []
    },
    {
      "id": "stdlib.optparse.OptionError",
      "name": "OptionError",
      "module": "optparse",
      "type": "class",
      "signature": "(msg, option)",
      "description": "Raised if an Option instance is created with invalid or\ninconsistent arguments.",
      "relationships": [
        {
          "target": "OptParseError",
          "type": "base_class"
        },
        {
          "target": "Exception",
          "type": "base_class"
        },
        {
          "target": "BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.optparse.OptionGroup",
      "name": "OptionGroup",
      "module": "optparse",
      "type": "class",
      "signature": "(parser, title, description=None)",
      "description": "Abstract base class.\n\nClass attributes:\n  standard_option_list : [Option]\n    list of standard options that will be accepted by all instances\n    of this parser class (intended to be overridden by subclasses).\n\nInstance attributes:\n  option_list : [Option]\n    the list of Option objects contained by this OptionContainer\n  _short_opt : { string : Option }\n    dictionary mapping short option strings, eg. \"-f\" or \"-X\",\n    to the Option instances that implement them.  If an Option\n    has multiple short option strings, it will appear in this\n    dictionary multiple times. [1]\n  _long_opt : { string : Option }\n    dictionary mapping long option strings, eg. \"--file\" or\n    \"--exclude\", to the Option instances that implement them.\n    Again, a given Option can occur multiple times in this\n    dictionary. [1]\n  defaults : { string : any }\n    dictionary mapping option destination names to default\n    values for each destination [1]\n\n[1] These mappings are common to (shared by) all components of the\n    controlling OptionParser, where they are initially created.",
      "relationships": [
        {
          "target": "OptionContainer",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.optparse.OptionParser",
      "name": "OptionParser",
      "module": "optparse",
      "type": "class",
      "signature": "(usage=None, option_list=None, option_class=<class 'optparse.Option'>, version=None, conflict_handler='error', description=None, formatter=None, add_help_option=True, prog=None, epilog=None)",
      "description": "Class attributes:\n  standard_option_list : [Option]\n    list of standard options that will be accepted by all instances\n    of this parser class (intended to be overridden by subclasses).\n\nInstance attributes:\n  usage : string\n    a usage string for your program.  Before it is displayed\n    to the user, \"%prog\" will be expanded to the name of\n    your program (self.prog or os.path.basename(sys.argv[0])).\n  prog : string\n    the name of the current program (to override\n    os.path.basename(sys.argv[0])).\n  description : string\n    A paragraph of text giving a brief overview of your program.\n    optparse reformats this paragraph to fit the current terminal\n    width and prints it when the user requests help (after usage,\n    but before the list of options).\n  epilog : string\n    paragraph of help text to print after option help\n\n  option_groups : [OptionGroup]\n    list of option groups in this parser (option groups are\n    irrelevant for parsing the command-line, but very useful\n    for generating help)\n\n  allow_interspersed_args : bool = true\n    if true, positional arguments may be interspersed with options.\n    Assuming -a and -b each take a single argument, the command-line\n      -ablah foo bar -bboo baz\n    will be interpreted the same as\n      -ablah -bboo -- foo bar baz\n    If this flag were false, that command line would be interpreted as\n      -ablah -- foo bar -bboo baz\n    -- ie. we stop processing options as soon as we see the first\n    non-option argument.  (This is the tradition followed by\n    Python's getopt module, Perl's Getopt::Std, and other argument-\n    parsing libraries, but it is generally annoying to users.)\n\n  process_default_values : bool = true\n    if true, option default values are processed similarly to option\n    values from the command line: that is, they are passed to the\n    type-checking function for the option's type (as long as the\n    default value is a string).  (This really only matters if you\n    have defined custom types; see SF bug #955889.)  Set it to false\n    to restore the behaviour of Optik 1.4.1 and earlier.\n\n  rargs : [string]\n    the argument list currently being parsed.  Only set when\n    parse_args() is active, and continually trimmed down as\n    we consume arguments.  Mainly there for the benefit of\n    callback options.\n  largs : [string]\n    the list of leftover arguments that we have skipped while\n    parsing options.  If allow_interspersed_args is false, this\n    list is always empty.\n  values : Values\n    the set of option values currently being accumulated.  Only\n    set when parse_args() is active.  Also mainly for callbacks.\n\nBecause of the 'rargs', 'largs', and 'values' attributes,\nOptionParser is not thread-safe.  If, for some perverse reason, you\nneed to parse command-line arguments simultaneously in different\nthreads, use different OptionParser instances.",
      "relationships": [
        {
          "target": "OptionContainer",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.optparse.OptionValueError",
      "name": "OptionValueError",
      "module": "optparse",
      "type": "class",
      "signature": "(msg)",
      "description": "Raised if an invalid option value is encountered on the command\nline.",
      "relationships": [
        {
          "target": "OptParseError",
          "type": "base_class"
        },
        {
          "target": "Exception",
          "type": "base_class"
        },
        {
          "target": "BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.optparse.TitledHelpFormatter",
      "name": "TitledHelpFormatter",
      "module": "optparse",
      "type": "class",
      "signature": "(indent_increment=0, max_help_position=24, width=None, short_first=0)",
      "description": "Format help with underlined section headers.\n    ",
      "relationships": [
        {
          "target": "HelpFormatter",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.optparse.Values",
      "name": "Values",
      "module": "optparse",
      "type": "class",
      "signature": "(defaults=None)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.optparse.check_builtin",
      "name": "check_builtin",
      "module": "optparse",
      "type": "function",
      "signature": "(option, opt, value)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.optparse.cvt",
          "type": "calls"
        },
        {
          "target": "stdlib.optparse.OptionValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.optparse._",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.optparse.check_choice",
      "name": "check_choice",
      "module": "optparse",
      "type": "function",
      "signature": "(option, opt, value)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.optparse.join",
          "type": "calls"
        },
        {
          "target": "stdlib.optparse.OptionValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.optparse.map",
          "type": "calls"
        },
        {
          "target": "stdlib.optparse._",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.optparse.gettext",
      "name": "gettext",
      "module": "optparse",
      "type": "function",
      "signature": "(message)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.optparse.dgettext",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.optparse.make_option",
      "name": "make_option",
      "module": "optparse",
      "type": "class",
      "signature": "(*opts, **attrs)",
      "description": "Instance attributes:\n  _short_opts : [string]\n  _long_opts : [string]\n\n  action : string\n  type : string\n  dest : string\n  default : any\n  nargs : int\n  const : any\n  choices : [string]\n  callback : function\n  callback_args : (any*)\n  callback_kwargs : { string : any }\n  help : string\n  metavar : string",
      "relationships": []
    },
    {
      "id": "stdlib.optparse.ngettext",
      "name": "ngettext",
      "module": "optparse",
      "type": "function",
      "signature": "(msgid1, msgid2, n)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.optparse.dngettext",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.os.Mapping",
      "name": "Mapping",
      "module": "os",
      "type": "class",
      "signature": "()",
      "description": "",
      "relationships": [
        {
          "target": "Collection",
          "type": "base_class"
        },
        {
          "target": "Sized",
          "type": "base_class"
        },
        {
          "target": "Iterable",
          "type": "base_class"
        },
        {
          "target": "Container",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.os.MutableMapping",
      "name": "MutableMapping",
      "module": "os",
      "type": "class",
      "signature": "()",
      "description": "",
      "relationships": [
        {
          "target": "Mapping",
          "type": "base_class"
        },
        {
          "target": "Collection",
          "type": "base_class"
        },
        {
          "target": "Sized",
          "type": "base_class"
        },
        {
          "target": "Iterable",
          "type": "base_class"
        },
        {
          "target": "Container",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.os.PathLike",
      "name": "PathLike",
      "module": "os",
      "type": "class",
      "signature": "()",
      "description": "Abstract base class for implementing the file system path protocol.",
      "relationships": [
        {
          "target": "ABC",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.os.execl",
      "name": "execl",
      "module": "os",
      "type": "function",
      "signature": "(file, *args)",
      "description": "execl(file, *args)\n\nExecute the executable file with argument list args, replacing the\ncurrent process. ",
      "relationships": [
        {
          "target": "stdlib.os.execv",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.os.execle",
      "name": "execle",
      "module": "os",
      "type": "function",
      "signature": "(file, *args)",
      "description": "execle(file, *args, env)\n\nExecute the executable file with argument list args and\nenvironment env, replacing the current process. ",
      "relationships": [
        {
          "target": "stdlib.os.execve",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.os.execlp",
      "name": "execlp",
      "module": "os",
      "type": "function",
      "signature": "(file, *args)",
      "description": "execlp(file, *args)\n\nExecute the executable file (which is searched for along $PATH)\nwith argument list args, replacing the current process. ",
      "relationships": [
        {
          "target": "stdlib.os.execvp",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.os.execlpe",
      "name": "execlpe",
      "module": "os",
      "type": "function",
      "signature": "(file, *args)",
      "description": "execlpe(file, *args, env)\n\nExecute the executable file (which is searched for along $PATH)\nwith argument list args and environment env, replacing the current\nprocess. ",
      "relationships": [
        {
          "target": "stdlib.os.execvpe",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.os.execvp",
      "name": "execvp",
      "module": "os",
      "type": "function",
      "signature": "(file, args)",
      "description": "execvp(file, args)\n\nExecute the executable file (which is searched for along $PATH)\nwith argument list args, replacing the current process.\nargs may be a list or tuple of strings. ",
      "relationships": [
        {
          "target": "stdlib.os._execvpe",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.os.execvpe",
      "name": "execvpe",
      "module": "os",
      "type": "function",
      "signature": "(file, args, env)",
      "description": "execvpe(file, args, env)\n\nExecute the executable file (which is searched for along $PATH)\nwith argument list args and environment env, replacing the\ncurrent process.\nargs may be a list or tuple of strings. ",
      "relationships": [
        {
          "target": "stdlib.os._execvpe",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.os.fdopen",
      "name": "fdopen",
      "module": "os",
      "type": "function",
      "signature": "(fd, *args, **kwargs)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.os.open",
          "type": "calls"
        },
        {
          "target": "stdlib.os.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.os.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.os.type",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.os.fsdecode",
      "name": "fsdecode",
      "module": "os",
      "type": "function",
      "signature": "(filename)",
      "description": "Decode filename (an os.PathLike, bytes, or str) from the filesystem\nencoding with 'surrogateescape' error handler, return str unchanged. On\nWindows, use 'strict' error handler if the file system encoding is\n'mbcs' (which is the default encoding).",
      "relationships": [
        {
          "target": "stdlib.os.fspath",
          "type": "calls"
        },
        {
          "target": "stdlib.os.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.os.decode",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.os.fsencode",
      "name": "fsencode",
      "module": "os",
      "type": "function",
      "signature": "(filename)",
      "description": "Encode filename (an os.PathLike, bytes, or str) to the filesystem\nencoding with 'surrogateescape' error handler, return bytes unchanged.\nOn Windows, use 'strict' error handler if the file system encoding is\n'mbcs' (which is the default encoding).",
      "relationships": [
        {
          "target": "stdlib.os.fspath",
          "type": "calls"
        },
        {
          "target": "stdlib.os.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.os.encode",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.os.fwalk",
      "name": "fwalk",
      "module": "os",
      "type": "function",
      "signature": "(top='.', topdown=True, onerror=None, *, follow_symlinks=False, dir_fd=None)",
      "description": "Directory tree generator.\n\nThis behaves exactly like walk(), except that it yields a 4-tuple\n\n    dirpath, dirnames, filenames, dirfd\n\n`dirpath`, `dirnames` and `filenames` are identical to walk() output,\nand `dirfd` is a file descriptor referring to the directory `dirpath`.\n\nThe advantage of fwalk() over walk() is that it's safe against symlink\nraces (when follow_symlinks is False).\n\nIf dir_fd is not None, it should be a file descriptor open to a directory,\n  and top should be relative; top will then be relative to that directory.\n  (dir_fd is always supported for fwalk.)\n\nCaution:\nSince fwalk() yields file descriptors, those are only valid until the\nnext iteration step, so you should dup() them if you want to keep them\nfor a longer period.\n\nExample:\n\nimport os\nfor root, dirs, files, rootfd in os.fwalk('python/Lib/email'):\n    print(root, \"consumes\", end=\"\")\n    print(sum(os.stat(name, dir_fd=rootfd).st_size for name in files),\n          end=\"\")\n    print(\"bytes in\", len(files), \"non-directory files\")\n    if 'CVS' in dirs:\n        dirs.remove('CVS')  # don't visit CVS directories",
      "relationships": [
        {
          "target": "stdlib.os.audit",
          "type": "calls"
        },
        {
          "target": "stdlib.os.open",
          "type": "calls"
        },
        {
          "target": "stdlib.os.fspath",
          "type": "calls"
        },
        {
          "target": "stdlib.os.stat",
          "type": "calls"
        },
        {
          "target": "stdlib.os.close",
          "type": "calls"
        },
        {
          "target": "stdlib.os.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.os.hasattr",
          "type": "calls"
        },
        {
          "target": "stdlib.os.S_ISDIR",
          "type": "calls"
        },
        {
          "target": "stdlib.os.samestat",
          "type": "calls"
        },
        {
          "target": "stdlib.os._fwalk",
          "type": "calls"
        },
        {
          "target": "stdlib.os.stat",
          "type": "calls"
        },
        {
          "target": "stdlib.os.isinstance",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.os.get_exec_path",
      "name": "get_exec_path",
      "module": "os",
      "type": "function",
      "signature": "(env=None)",
      "description": "Returns the sequence of directories that will be searched for the\nnamed executable (similar to a shell) when launching a process.\n\n*env* must be an environment variable dict or None.  If *env* is None,\nos.environ will be used.",
      "relationships": [
        {
          "target": "stdlib.os.split",
          "type": "calls"
        },
        {
          "target": "stdlib.os.catch_warnings",
          "type": "calls"
        },
        {
          "target": "stdlib.os.simplefilter",
          "type": "calls"
        },
        {
          "target": "stdlib.os.get",
          "type": "calls"
        },
        {
          "target": "stdlib.os.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.os.fsdecode",
          "type": "calls"
        },
        {
          "target": "stdlib.os.ValueError",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.os.getenv",
      "name": "getenv",
      "module": "os",
      "type": "function",
      "signature": "(key, default=None)",
      "description": "Get an environment variable, return None if it doesn't exist.\nThe optional second argument can specify an alternate default.\nkey, default and the result are str.",
      "relationships": [
        {
          "target": "stdlib.os.get",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.os.getenvb",
      "name": "getenvb",
      "module": "os",
      "type": "function",
      "signature": "(key, default=None)",
      "description": "Get an environment variable, return None if it doesn't exist.\nThe optional second argument can specify an alternate default.\nkey, default and the result are bytes.",
      "relationships": [
        {
          "target": "stdlib.os.get",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.os.makedirs",
      "name": "makedirs",
      "module": "os",
      "type": "function",
      "signature": "(name, mode=511, exist_ok=False)",
      "description": "makedirs(name [, mode=0o777][, exist_ok=False])\n\nSuper-mkdir; create a leaf directory and all intermediate ones.  Works like\nmkdir, except that any intermediate path segment (not just the rightmost)\nwill be created if it does not exist. If the target directory already\nexists, raise an OSError if exist_ok is False. Otherwise no exception is\nraised.  This is recursive.",
      "relationships": [
        {
          "target": "stdlib.os.split",
          "type": "calls"
        },
        {
          "target": "stdlib.os.split",
          "type": "calls"
        },
        {
          "target": "stdlib.os.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.os.mkdir",
          "type": "calls"
        },
        {
          "target": "stdlib.os.exists",
          "type": "calls"
        },
        {
          "target": "stdlib.os.makedirs",
          "type": "calls"
        },
        {
          "target": "stdlib.os.bytes",
          "type": "calls"
        },
        {
          "target": "stdlib.os.isdir",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.os.popen",
      "name": "popen",
      "module": "os",
      "type": "function",
      "signature": "(cmd, mode='r', buffering=-1)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.os.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.os.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.os.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.os.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.os.Popen",
          "type": "calls"
        },
        {
          "target": "stdlib.os._wrap_close",
          "type": "calls"
        },
        {
          "target": "stdlib.os.Popen",
          "type": "calls"
        },
        {
          "target": "stdlib.os._wrap_close",
          "type": "calls"
        },
        {
          "target": "stdlib.os.TextIOWrapper",
          "type": "calls"
        },
        {
          "target": "stdlib.os.TextIOWrapper",
          "type": "calls"
        },
        {
          "target": "stdlib.os.type",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.os.removedirs",
      "name": "removedirs",
      "module": "os",
      "type": "function",
      "signature": "(name)",
      "description": "removedirs(name)\n\nSuper-rmdir; remove a leaf directory and all empty intermediate\nones.  Works like rmdir except that, if the leaf directory is\nsuccessfully removed, directories corresponding to rightmost path\nsegments will be pruned away until either the whole path is\nconsumed or an error occurs.  Errors during this latter phase are\nignored -- they generally mean that a directory was not empty.",
      "relationships": [
        {
          "target": "stdlib.os.rmdir",
          "type": "calls"
        },
        {
          "target": "stdlib.os.split",
          "type": "calls"
        },
        {
          "target": "stdlib.os.split",
          "type": "calls"
        },
        {
          "target": "stdlib.os.split",
          "type": "calls"
        },
        {
          "target": "stdlib.os.rmdir",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.os.renames",
      "name": "renames",
      "module": "os",
      "type": "function",
      "signature": "(old, new)",
      "description": "renames(old, new)\n\nSuper-rename; create directories as necessary and delete any left\nempty.  Works like rename, except creation of any intermediate\ndirectories needed to make the new pathname good is attempted\nfirst.  After the rename, directories corresponding to rightmost\npath segments of the old name will be pruned until either the\nwhole path is consumed or a nonempty directory is found.\n\nNote: this function can fail with the new directory structure made\nif you lack permissions needed to unlink the leaf directory or\nfile.",
      "relationships": [
        {
          "target": "stdlib.os.split",
          "type": "calls"
        },
        {
          "target": "stdlib.os.rename",
          "type": "calls"
        },
        {
          "target": "stdlib.os.split",
          "type": "calls"
        },
        {
          "target": "stdlib.os.makedirs",
          "type": "calls"
        },
        {
          "target": "stdlib.os.exists",
          "type": "calls"
        },
        {
          "target": "stdlib.os.removedirs",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.os.spawnl",
      "name": "spawnl",
      "module": "os",
      "type": "function",
      "signature": "(mode, file, *args)",
      "description": "spawnl(mode, file, *args) -> integer\n\nExecute file with arguments from args in a subprocess.\nIf mode == P_NOWAIT return the pid of the process.\nIf mode == P_WAIT return the process's exit code if it exits normally;\notherwise return -SIG, where SIG is the signal that killed it. ",
      "relationships": []
    },
    {
      "id": "stdlib.os.spawnle",
      "name": "spawnle",
      "module": "os",
      "type": "function",
      "signature": "(mode, file, *args)",
      "description": "spawnle(mode, file, *args, env) -> integer\n\nExecute file with arguments from args in a subprocess with the\nsupplied environment.\nIf mode == P_NOWAIT return the pid of the process.\nIf mode == P_WAIT return the process's exit code if it exits normally;\notherwise return -SIG, where SIG is the signal that killed it. ",
      "relationships": []
    },
    {
      "id": "stdlib.os.spawnlp",
      "name": "spawnlp",
      "module": "os",
      "type": "function",
      "signature": "(mode, file, *args)",
      "description": "spawnlp(mode, file, *args) -> integer\n\nExecute file (which is looked for along $PATH) with arguments from\nargs in a subprocess with the supplied environment.\nIf mode == P_NOWAIT return the pid of the process.\nIf mode == P_WAIT return the process's exit code if it exits normally;\notherwise return -SIG, where SIG is the signal that killed it. ",
      "relationships": []
    },
    {
      "id": "stdlib.os.spawnlpe",
      "name": "spawnlpe",
      "module": "os",
      "type": "function",
      "signature": "(mode, file, *args)",
      "description": "spawnlpe(mode, file, *args, env) -> integer\n\nExecute file (which is looked for along $PATH) with arguments from\nargs in a subprocess with the supplied environment.\nIf mode == P_NOWAIT return the pid of the process.\nIf mode == P_WAIT return the process's exit code if it exits normally;\notherwise return -SIG, where SIG is the signal that killed it. ",
      "relationships": []
    },
    {
      "id": "stdlib.os.spawnv",
      "name": "spawnv",
      "module": "os",
      "type": "function",
      "signature": "(mode, file, args)",
      "description": "spawnv(mode, file, args) -> integer\n\nExecute file with arguments from args in a subprocess.\nIf mode == P_NOWAIT return the pid of the process.\nIf mode == P_WAIT return the process's exit code if it exits normally;\notherwise return -SIG, where SIG is the signal that killed it. ",
      "relationships": []
    },
    {
      "id": "stdlib.os.spawnve",
      "name": "spawnve",
      "module": "os",
      "type": "function",
      "signature": "(mode, file, args, env)",
      "description": "spawnve(mode, file, args, env) -> integer\n\nExecute file with arguments from args in a subprocess with the\nspecified environment.\nIf mode == P_NOWAIT return the pid of the process.\nIf mode == P_WAIT return the process's exit code if it exits normally;\notherwise return -SIG, where SIG is the signal that killed it. ",
      "relationships": []
    },
    {
      "id": "stdlib.os.spawnvp",
      "name": "spawnvp",
      "module": "os",
      "type": "function",
      "signature": "(mode, file, args)",
      "description": "spawnvp(mode, file, args) -> integer\n\nExecute file (which is looked for along $PATH) with arguments from\nargs in a subprocess.\nIf mode == P_NOWAIT return the pid of the process.\nIf mode == P_WAIT return the process's exit code if it exits normally;\notherwise return -SIG, where SIG is the signal that killed it. ",
      "relationships": []
    },
    {
      "id": "stdlib.os.spawnvpe",
      "name": "spawnvpe",
      "module": "os",
      "type": "function",
      "signature": "(mode, file, args, env)",
      "description": "spawnvpe(mode, file, args, env) -> integer\n\nExecute file (which is looked for along $PATH) with arguments from\nargs in a subprocess with the supplied environment.\nIf mode == P_NOWAIT return the pid of the process.\nIf mode == P_WAIT return the process's exit code if it exits normally;\notherwise return -SIG, where SIG is the signal that killed it. ",
      "relationships": []
    },
    {
      "id": "stdlib.os.stat_result",
      "name": "stat_result",
      "module": "os",
      "type": "class",
      "signature": "(iterable=(), /)",
      "description": "stat_result: Result from stat, fstat, or lstat.\n\nThis object may be accessed either as a tuple of\n  (mode, ino, dev, nlink, uid, gid, size, atime, mtime, ctime)\nor via the attributes st_mode, st_ino, st_dev, st_nlink, st_uid, and so on.\n\nPosix/windows: If your platform supports st_blksize, st_blocks, st_rdev,\nor st_flags, they are available as attributes only.\n\nSee os.stat for more information.",
      "relationships": [
        {
          "target": "tuple",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.os.statvfs_result",
      "name": "statvfs_result",
      "module": "os",
      "type": "class",
      "signature": "(iterable=(), /)",
      "description": "statvfs_result: Result from statvfs or fstatvfs.\n\nThis object may be accessed either as a tuple of\n  (bsize, frsize, blocks, bfree, bavail, files, ffree, favail, flag, namemax),\nor via the attributes f_bsize, f_frsize, f_blocks, f_bfree, and so on.\n\nSee os.statvfs for more information.",
      "relationships": [
        {
          "target": "tuple",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.os.system",
      "name": "system",
      "module": "os",
      "type": "function",
      "signature": "(cmd)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.os._system",
          "type": "calls"
        },
        {
          "target": "stdlib.os.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.os.run",
          "type": "calls"
        },
        {
          "target": "stdlib.os.getattr",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.os.terminal_size",
      "name": "terminal_size",
      "module": "os",
      "type": "class",
      "signature": "(iterable=(), /)",
      "description": "A tuple of (columns, lines) for holding terminal window size",
      "relationships": [
        {
          "target": "tuple",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.os.times_result",
      "name": "times_result",
      "module": "os",
      "type": "class",
      "signature": "(iterable=(), /)",
      "description": "times_result: Result from os.times().\n\nThis object may be accessed either as a tuple of\n  (user, system, children_user, children_system, elapsed),\nor via the attributes user, system, children_user, children_system,\nand elapsed.\n\nSee os.times for more information.",
      "relationships": [
        {
          "target": "tuple",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.os.uname_result",
      "name": "uname_result",
      "module": "os",
      "type": "class",
      "signature": "(iterable=(), /)",
      "description": "uname_result: Result from os.uname().\n\nThis object may be accessed either as a tuple of\n  (sysname, nodename, release, version, machine),\nor via the attributes sysname, nodename, release, version, and machine.\n\nSee os.uname for more information.",
      "relationships": [
        {
          "target": "tuple",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.os.walk",
      "name": "walk",
      "module": "os",
      "type": "function",
      "signature": "(top, topdown=True, onerror=None, followlinks=False)",
      "description": "Directory tree generator.\n\nFor each directory in the directory tree rooted at top (including top\nitself, but excluding '.' and '..'), yields a 3-tuple\n\n    dirpath, dirnames, filenames\n\ndirpath is a string, the path to the directory.  dirnames is a list of\nthe names of the subdirectories in dirpath (excluding '.' and '..').\nfilenames is a list of the names of the non-directory files in dirpath.\nNote that the names in the lists are just names, with no path components.\nTo get a full path (which begins with top) to a file or directory in\ndirpath, do os.path.join(dirpath, name).\n\nIf optional arg 'topdown' is true or not specified, the triple for a\ndirectory is generated before the triples for any of its subdirectories\n(directories are generated top down).  If topdown is false, the triple\nfor a directory is generated after the triples for all of its\nsubdirectories (directories are generated bottom up).\n\nWhen topdown is true, the caller can modify the dirnames list in-place\n(e.g., via del or slice assignment), and walk will only recurse into the\nsubdirectories whose names remain in dirnames; this can be used to prune the\nsearch, or to impose a specific order of visiting.  Modifying dirnames when\ntopdown is false has no effect on the behavior of os.walk(), since the\ndirectories in dirnames have already been generated by the time dirnames\nitself is generated. No matter the value of topdown, the list of\nsubdirectories is retrieved before the tuples for the directory and its\nsubdirectories are generated.\n\nBy default errors from the os.scandir() call are ignored.  If\noptional arg 'onerror' is specified, it should be a function; it\nwill be called with one argument, an OSError instance.  It can\nreport the error to continue with the walk, or raise the exception\nto abort the walk.  Note that the filename is available as the\nfilename attribute of the exception object.\n\nBy default, os.walk does not follow symbolic links to subdirectories on\nsystems that support them.  In order to get this functionality, set the\noptional argument 'followlinks' to true.\n\nCaution:  if you pass a relative pathname for top, don't change the\ncurrent working directory between resumptions of walk.  walk never\nchanges the current directory, and assumes that the client doesn't\neither.\n\nExample:\n\nimport os\nfrom os.path import join, getsize\nfor root, dirs, files in os.walk('python/Lib/email'):\n    print(root, \"consumes\", end=\"\")\n    print(sum(getsize(join(root, name)) for name in files), end=\"\")\n    print(\"bytes in\", len(files), \"non-directory files\")\n    if 'CVS' in dirs:\n        dirs.remove('CVS')  # don't visit CVS directories",
      "relationships": [
        {
          "target": "stdlib.os.audit",
          "type": "calls"
        },
        {
          "target": "stdlib.os._walk",
          "type": "calls"
        },
        {
          "target": "stdlib.os.fspath",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pathlib.Path",
      "name": "Path",
      "module": "pathlib",
      "type": "class",
      "signature": "(*args, **kwargs)",
      "description": "PurePath subclass that can make system calls.\n\nPath represents a filesystem path but unlike PurePath, also offers\nmethods to do system calls on path objects. Depending on your system,\ninstantiating a Path will return either a PosixPath or a WindowsPath\nobject. You can also instantiate a PosixPath or WindowsPath directly,\nbut cannot instantiate a WindowsPath on a POSIX system or vice versa.",
      "relationships": [
        {
          "target": "PurePath",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.pathlib.PosixPath",
      "name": "PosixPath",
      "module": "pathlib",
      "type": "class",
      "signature": "(*args, **kwargs)",
      "description": "Path subclass for non-Windows systems.\n\nOn a POSIX system, instantiating a Path should return this object.",
      "relationships": [
        {
          "target": "Path",
          "type": "base_class"
        },
        {
          "target": "PurePosixPath",
          "type": "base_class"
        },
        {
          "target": "PurePath",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.pathlib.PurePath",
      "name": "PurePath",
      "module": "pathlib",
      "type": "class",
      "signature": "(*args)",
      "description": "Base class for manipulating paths without I/O.\n\nPurePath represents a filesystem path and offers operations which\ndon't imply any actual filesystem I/O.  Depending on your system,\ninstantiating a PurePath will return either a PurePosixPath or a\nPureWindowsPath object.  You can also instantiate either of these classes\ndirectly, regardless of your system.",
      "relationships": []
    },
    {
      "id": "stdlib.pathlib.PurePosixPath",
      "name": "PurePosixPath",
      "module": "pathlib",
      "type": "class",
      "signature": "(*args)",
      "description": "PurePath subclass for non-Windows systems.\n\nOn a POSIX system, instantiating a PurePath should return this object.\nHowever, you can also instantiate it directly on any system.",
      "relationships": [
        {
          "target": "PurePath",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.pathlib.PureWindowsPath",
      "name": "PureWindowsPath",
      "module": "pathlib",
      "type": "class",
      "signature": "(*args)",
      "description": "PurePath subclass for Windows systems.\n\nOn a Windows system, instantiating a PurePath should return this object.\nHowever, you can also instantiate it directly on any system.",
      "relationships": [
        {
          "target": "PurePath",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.pathlib.Sequence",
      "name": "Sequence",
      "module": "pathlib",
      "type": "class",
      "signature": "()",
      "description": "All the operations on a read-only sequence.\n\nConcrete subclasses must override __new__ or __init__,\n__getitem__, and __len__.",
      "relationships": [
        {
          "target": "Reversible",
          "type": "base_class"
        },
        {
          "target": "Collection",
          "type": "base_class"
        },
        {
          "target": "Sized",
          "type": "base_class"
        },
        {
          "target": "Iterable",
          "type": "base_class"
        },
        {
          "target": "Container",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.pathlib.WindowsPath",
      "name": "WindowsPath",
      "module": "pathlib",
      "type": "class",
      "signature": "(*args, **kwargs)",
      "description": "Path subclass for Windows systems.\n\nOn a Windows system, instantiating a Path should return this object.",
      "relationships": [
        {
          "target": "Path",
          "type": "base_class"
        },
        {
          "target": "PureWindowsPath",
          "type": "base_class"
        },
        {
          "target": "PurePath",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.pathlib.urlquote_from_bytes",
      "name": "urlquote_from_bytes",
      "module": "pathlib",
      "type": "function",
      "signature": "(bs, safe='/')",
      "description": "Like quote(), but accepts a bytes object rather than a str, and does\nnot perform string-to-bytes encoding.  It always returns an ASCII string.\nquote_from_bytes(b'abc def?') -> 'abc%20def%3f'",
      "relationships": [
        {
          "target": "stdlib.pathlib.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.pathlib.join",
          "type": "calls"
        },
        {
          "target": "stdlib.pathlib.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.pathlib.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.pathlib.encode",
          "type": "calls"
        },
        {
          "target": "stdlib.pathlib.bytes",
          "type": "calls"
        },
        {
          "target": "stdlib.pathlib.rstrip",
          "type": "calls"
        },
        {
          "target": "stdlib.pathlib.decode",
          "type": "calls"
        },
        {
          "target": "stdlib.pathlib.quoter",
          "type": "calls"
        },
        {
          "target": "stdlib.pathlib.Quoter",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pdb.Pdb",
      "name": "Pdb",
      "module": "pdb",
      "type": "class",
      "signature": "(completekey='tab', stdin=None, stdout=None, skip=None, nosigint=False, readrc=True)",
      "description": "Generic Python debugger base class.\n\nThis class takes care of details of the trace facility;\na derived class should implement user interaction.\nThe standard debugger class (pdb.Pdb) is an example.\n\nThe optional skip argument must be an iterable of glob-style\nmodule name patterns.  The debugger will not step into frames\nthat originate in a module that matches one of these patterns.\nWhether a frame is considered to originate in a certain module\nis determined by the __name__ in the frame globals.",
      "relationships": [
        {
          "target": "Bdb",
          "type": "base_class"
        },
        {
          "target": "Cmd",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.pdb.find_function",
      "name": "find_function",
      "module": "pdb",
      "type": "function",
      "signature": "(funcname, filename)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.pdb.compile",
          "type": "calls"
        },
        {
          "target": "stdlib.pdb.open",
          "type": "calls"
        },
        {
          "target": "stdlib.pdb.enumerate",
          "type": "calls"
        },
        {
          "target": "stdlib.pdb.escape",
          "type": "calls"
        },
        {
          "target": "stdlib.pdb.match",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pdb.getsourcelines",
      "name": "getsourcelines",
      "module": "pdb",
      "type": "function",
      "signature": "(obj)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.pdb.findsource",
          "type": "calls"
        },
        {
          "target": "stdlib.pdb.isframe",
          "type": "calls"
        },
        {
          "target": "stdlib.pdb.ismodule",
          "type": "calls"
        },
        {
          "target": "stdlib.pdb.getblock",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pdb.help",
      "name": "help",
      "module": "pdb",
      "type": "function",
      "signature": "()",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.pdb.pager",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pdb.lasti2lineno",
      "name": "lasti2lineno",
      "module": "pdb",
      "type": "function",
      "signature": "(code, lasti)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.pdb.list",
          "type": "calls"
        },
        {
          "target": "stdlib.pdb.reverse",
          "type": "calls"
        },
        {
          "target": "stdlib.pdb.findlinestarts",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pdb.main",
      "name": "main",
      "module": "pdb",
      "type": "function",
      "signature": "()",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.pdb.getopt",
          "type": "calls"
        },
        {
          "target": "stdlib.pdb.Pdb",
          "type": "calls"
        },
        {
          "target": "stdlib.pdb.extend",
          "type": "calls"
        },
        {
          "target": "stdlib.pdb.print",
          "type": "calls"
        },
        {
          "target": "stdlib.pdb.exit",
          "type": "calls"
        },
        {
          "target": "stdlib.pdb.print",
          "type": "calls"
        },
        {
          "target": "stdlib.pdb.exit",
          "type": "calls"
        },
        {
          "target": "stdlib.pdb.realpath",
          "type": "calls"
        },
        {
          "target": "stdlib.pdb.dirname",
          "type": "calls"
        },
        {
          "target": "stdlib.pdb.print",
          "type": "calls"
        },
        {
          "target": "stdlib.pdb.exit",
          "type": "calls"
        },
        {
          "target": "stdlib.pdb.exists",
          "type": "calls"
        },
        {
          "target": "stdlib.pdb.print",
          "type": "calls"
        },
        {
          "target": "stdlib.pdb.append",
          "type": "calls"
        },
        {
          "target": "stdlib.pdb._runmodule",
          "type": "calls"
        },
        {
          "target": "stdlib.pdb._runscript",
          "type": "calls"
        },
        {
          "target": "stdlib.pdb.print",
          "type": "calls"
        },
        {
          "target": "stdlib.pdb.print",
          "type": "calls"
        },
        {
          "target": "stdlib.pdb.print",
          "type": "calls"
        },
        {
          "target": "stdlib.pdb.print",
          "type": "calls"
        },
        {
          "target": "stdlib.pdb.print_exc",
          "type": "calls"
        },
        {
          "target": "stdlib.pdb.exit",
          "type": "calls"
        },
        {
          "target": "stdlib.pdb.print_exc",
          "type": "calls"
        },
        {
          "target": "stdlib.pdb.print",
          "type": "calls"
        },
        {
          "target": "stdlib.pdb.print",
          "type": "calls"
        },
        {
          "target": "stdlib.pdb.interaction",
          "type": "calls"
        },
        {
          "target": "stdlib.pdb.print",
          "type": "calls"
        },
        {
          "target": "stdlib.pdb.exc_info",
          "type": "calls"
        },
        {
          "target": "stdlib.pdb.join",
          "type": "calls"
        },
        {
          "target": "stdlib.pdb.exc_info",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pdb.pm",
      "name": "pm",
      "module": "pdb",
      "type": "function",
      "signature": "()",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.pdb.post_mortem",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pdb.post_mortem",
      "name": "post_mortem",
      "module": "pdb",
      "type": "function",
      "signature": "(t=None)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.pdb.Pdb",
          "type": "calls"
        },
        {
          "target": "stdlib.pdb.reset",
          "type": "calls"
        },
        {
          "target": "stdlib.pdb.interaction",
          "type": "calls"
        },
        {
          "target": "stdlib.pdb.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.pdb.exc_info",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pdb.run",
      "name": "run",
      "module": "pdb",
      "type": "function",
      "signature": "(statement, globals=None, locals=None)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.pdb.run",
          "type": "calls"
        },
        {
          "target": "stdlib.pdb.Pdb",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pdb.runcall",
      "name": "runcall",
      "module": "pdb",
      "type": "function",
      "signature": "(*args, **kwds)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.pdb.runcall",
          "type": "calls"
        },
        {
          "target": "stdlib.pdb.Pdb",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pdb.runctx",
      "name": "runctx",
      "module": "pdb",
      "type": "function",
      "signature": "(statement, globals, locals)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.pdb.run",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pdb.runeval",
      "name": "runeval",
      "module": "pdb",
      "type": "function",
      "signature": "(expression, globals=None, locals=None)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.pdb.runeval",
          "type": "calls"
        },
        {
          "target": "stdlib.pdb.Pdb",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pdb.set_trace",
      "name": "set_trace",
      "module": "pdb",
      "type": "function",
      "signature": "(*, header=None)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.pdb.Pdb",
          "type": "calls"
        },
        {
          "target": "stdlib.pdb.set_trace",
          "type": "calls"
        },
        {
          "target": "stdlib.pdb.message",
          "type": "calls"
        },
        {
          "target": "stdlib.pdb._getframe",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pdb.test",
      "name": "test",
      "module": "pdb",
      "type": "function",
      "signature": "()",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.pdb.run",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pickle.FunctionType",
      "name": "FunctionType",
      "module": "pickle",
      "type": "class",
      "signature": "(code, globals, name=None, argdefs=None, closure=None)",
      "description": "Create a function object.\n\ncode\n  a code object\nglobals\n  the globals dictionary\nname\n  a string that overrides the name from the code object\nargdefs\n  a tuple that specifies the default argument values\nclosure\n  a tuple that supplies the bindings for free variables",
      "relationships": []
    },
    {
      "id": "stdlib.pickle.Pickler",
      "name": "Pickler",
      "module": "pickle",
      "type": "class",
      "signature": "(file, protocol=None, fix_imports=True, buffer_callback=None)",
      "description": "This takes a binary file for writing a pickle data stream.\n\nThe optional *protocol* argument tells the pickler to use the given\nprotocol; supported protocols are 0, 1, 2, 3, 4 and 5.  The default\nprotocol is 4. It was introduced in Python 3.4, and is incompatible\nwith previous versions.\n\nSpecifying a negative protocol version selects the highest protocol\nversion supported.  The higher the protocol used, the more recent the\nversion of Python needed to read the pickle produced.\n\nThe *file* argument must have a write() method that accepts a single\nbytes argument. It can thus be a file object opened for binary\nwriting, an io.BytesIO instance, or any other custom object that meets\nthis interface.\n\nIf *fix_imports* is True and protocol is less than 3, pickle will try\nto map the new Python 3 names to the old module names used in Python\n2, so that the pickle data stream is readable with Python 2.\n\nIf *buffer_callback* is None (the default), buffer views are\nserialized into *file* as part of the pickle stream.\n\nIf *buffer_callback* is not None, then it can be called any number\nof times with a buffer view.  If the callback returns a false value\n(such as None), the given buffer is out-of-band; otherwise the\nbuffer is serialized in-band, i.e. inside the pickle stream.\n\nIt is an error if *buffer_callback* is not None and *protocol*\nis None or smaller than 5.",
      "relationships": []
    },
    {
      "id": "stdlib.pickle.Unpickler",
      "name": "Unpickler",
      "module": "pickle",
      "type": "class",
      "signature": "(file, *, fix_imports=True, encoding='ASCII', errors='strict', buffers=())",
      "description": "This takes a binary file for reading a pickle data stream.\n\nThe protocol version of the pickle is detected automatically, so no\nprotocol argument is needed.  Bytes past the pickled object's\nrepresentation are ignored.\n\nThe argument *file* must have two methods, a read() method that takes\nan integer argument, and a readline() method that requires no\narguments.  Both methods should return bytes.  Thus *file* can be a\nbinary file object opened for reading, an io.BytesIO object, or any\nother custom object that meets this interface.\n\nOptional keyword arguments are *fix_imports*, *encoding* and *errors*,\nwhich are used to control compatibility support for pickle stream\ngenerated by Python 2.  If *fix_imports* is True, pickle will try to\nmap the old Python 2 names to the new names used in Python 3.  The\n*encoding* and *errors* tell pickle how to decode 8-bit string\ninstances pickled by Python 2; these default to 'ASCII' and 'strict',\nrespectively.  The *encoding* can be 'bytes' to read these 8-bit\nstring instances as bytes objects.",
      "relationships": []
    },
    {
      "id": "stdlib.pickle.decode_long",
      "name": "decode_long",
      "module": "pickle",
      "type": "function",
      "signature": "(data)",
      "description": "Decode a long from a two's complement little-endian binary string.\n\n>>> decode_long(b'')\n0\n>>> decode_long(b\"\\xff\\x00\")\n255\n>>> decode_long(b\"\\xff\\x7f\")\n32767\n>>> decode_long(b\"\\x00\\xff\")\n-256\n>>> decode_long(b\"\\x00\\x80\")\n-32768\n>>> decode_long(b\"\\x80\")\n-128\n>>> decode_long(b\"\\x7f\")\n127",
      "relationships": [
        {
          "target": "stdlib.pickle.from_bytes",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pickle.encode_long",
      "name": "encode_long",
      "module": "pickle",
      "type": "function",
      "signature": "(x)",
      "description": "Encode a long to a two's complement little-endian binary string.\nNote that 0 is a special case, returning an empty string, to save a\nbyte in the LONG1 pickling context.\n\n>>> encode_long(0)\nb''\n>>> encode_long(255)\nb'\\xff\\x00'\n>>> encode_long(32767)\nb'\\xff\\x7f'\n>>> encode_long(-256)\nb'\\x00\\xff'\n>>> encode_long(-32768)\nb'\\x00\\x80'\n>>> encode_long(-128)\nb'\\x80'\n>>> encode_long(127)\nb'\\x7f'\n>>>",
      "relationships": [
        {
          "target": "stdlib.pickle.to_bytes",
          "type": "calls"
        },
        {
          "target": "stdlib.pickle.bit_length",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pickle.whichmodule",
      "name": "whichmodule",
      "module": "pickle",
      "type": "function",
      "signature": "(obj, name)",
      "description": "Find the module an object belong to.",
      "relationships": [
        {
          "target": "stdlib.pickle.getattr",
          "type": "calls"
        },
        {
          "target": "stdlib.pickle.items",
          "type": "calls"
        },
        {
          "target": "stdlib.pickle.copy",
          "type": "calls"
        },
        {
          "target": "stdlib.pickle._getattribute",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pickletools.ArgumentDescriptor",
      "name": "ArgumentDescriptor",
      "module": "pickletools",
      "type": "class",
      "signature": "(name, n, reader, doc)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.pickletools.OpcodeInfo",
      "name": "OpcodeInfo",
      "module": "pickletools",
      "type": "class",
      "signature": "(name, code, arg, stack_before, stack_after, proto, doc)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.pickletools.StackObject",
      "name": "StackObject",
      "module": "pickletools",
      "type": "class",
      "signature": "(name, obtype, doc)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.pickletools.decode_long",
      "name": "decode_long",
      "module": "pickletools",
      "type": "function",
      "signature": "(data)",
      "description": "Decode a long from a two's complement little-endian binary string.\n\n>>> decode_long(b'')\n0\n>>> decode_long(b\"\\xff\\x00\")\n255\n>>> decode_long(b\"\\xff\\x7f\")\n32767\n>>> decode_long(b\"\\x00\\xff\")\n-256\n>>> decode_long(b\"\\x00\\x80\")\n-32768\n>>> decode_long(b\"\\x80\")\n-128\n>>> decode_long(b\"\\x7f\")\n127",
      "relationships": [
        {
          "target": "stdlib.pickletools.from_bytes",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pickletools.dis",
      "name": "dis",
      "module": "pickletools",
      "type": "function",
      "signature": "(pickle, out=None, memo=None, indentlevel=4, annotate=0)",
      "description": "Produce a symbolic disassembly of a pickle.\n\n'pickle' is a file-like object, or string, containing a (at least one)\npickle.  The pickle is disassembled from the current position, through\nthe first STOP opcode encountered.\n\nOptional arg 'out' is a file-like object to which the disassembly is\nprinted.  It defaults to sys.stdout.\n\nOptional arg 'memo' is a Python dict, used as the pickle's memo.  It\nmay be mutated by dis(), if the pickle contains PUT or BINPUT opcodes.\nPassing the same memo object to another dis() call then allows disassembly\nto proceed across multiple pickles that were all created by the same\npickler with the same memo.  Ordinarily you don't need to worry about this.\n\nOptional arg 'indentlevel' is the number of blanks by which to indent\na new MARK level.  It defaults to 4.\n\nOptional arg 'annotate' if nonzero instructs dis() to add short\ndescription of the opcode on each line of disassembled output.\nThe value given to 'annotate' must be an integer and is used as a\nhint for the column where annotation should start.  The default\nvalue is 0, meaning no annotations.\n\nIn addition to printing the disassembly, some sanity checks are made:\n\n+ All embedded opcode arguments \"make sense\".\n\n+ Explicit and implicit pop operations have enough items on the stack.\n\n+ When an opcode implicitly refers to a markobject, a markobject is\n  actually on the stack.\n\n+ A memo entry isn't referenced before it's defined.\n\n+ The markobject isn't stored in the memo.\n\n+ A memo entry isn't redefined.",
      "relationships": [
        {
          "target": "stdlib.pickletools.genops",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.print",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.max",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.len",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.print",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.extend",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.print",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.len",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.len",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.append",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.pop",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.pop",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.len",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.repr",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.len",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.pop",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.index",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.len",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.repr",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.len",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.split",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.len",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.len",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pickletools.genops",
      "name": "genops",
      "module": "pickletools",
      "type": "function",
      "signature": "(pickle)",
      "description": "Generate all the opcodes in a pickle.\n\n'pickle' is a file-like object, or string, containing the pickle.\n\nEach opcode in the pickle is generated, from the current pickle position,\nstopping after a STOP opcode is delivered.  A triple is generated for\neach opcode:\n\n    opcode, arg, pos\n\nopcode is an OpcodeInfo record, describing the current opcode.\n\nIf the opcode has an argument embedded in the pickle, arg is its decoded\nvalue, as a Python object.  If the opcode doesn't have an argument, arg\nis None.\n\nIf the pickle has a tell() method, pos was the value of pickle.tell()\nbefore reading the current opcode.  If the pickle is a bytes object,\nit's wrapped in a BytesIO object, and the latter's tell() result is\nused.  Else (the pickle doesn't have a tell(), and it's not obvious how\nto query its current position) pos is None.",
      "relationships": [
        {
          "target": "stdlib.pickletools._genops",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pickletools.optimize",
      "name": "optimize",
      "module": "pickletools",
      "type": "function",
      "signature": "(p)",
      "description": "Optimize a pickle string by removing unused PUT opcodes",
      "relationships": [
        {
          "target": "stdlib.pickletools.set",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools._genops",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.BytesIO",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.write",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools._Pickler",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.end_framing",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.getvalue",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.start_framing",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.commit_frame",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.add",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.append",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.put",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.file_write",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.write",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.len",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.add",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.append",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.get",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.len",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.append",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.append",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.append",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pickletools.read_bytearray8",
      "name": "read_bytearray8",
      "module": "pickletools",
      "type": "function",
      "signature": "(f)",
      "description": ">>> import io, struct, sys\n>>> read_bytearray8(io.BytesIO(b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00abc\"))\nbytearray(b'')\n>>> read_bytearray8(io.BytesIO(b\"\\x03\\x00\\x00\\x00\\x00\\x00\\x00\\x00abcdef\"))\nbytearray(b'abc')\n>>> bigsize8 = struct.pack(\"<Q\", sys.maxsize//3)\n>>> read_bytearray8(io.BytesIO(bigsize8 + b\"abcdef\"))  #doctest: +ELLIPSIS\nTraceback (most recent call last):\n...\nValueError: expected ... bytes in a bytearray8, but only 6 remain",
      "relationships": [
        {
          "target": "stdlib.pickletools.read_uint8",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.read",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.len",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.bytearray",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.len",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pickletools.read_bytes1",
      "name": "read_bytes1",
      "module": "pickletools",
      "type": "function",
      "signature": "(f)",
      "description": ">>> import io\n>>> read_bytes1(io.BytesIO(b\"\\x00\"))\nb''\n>>> read_bytes1(io.BytesIO(b\"\\x03abcdef\"))\nb'abc'",
      "relationships": [
        {
          "target": "stdlib.pickletools.read_uint1",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.read",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.len",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.len",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pickletools.read_bytes4",
      "name": "read_bytes4",
      "module": "pickletools",
      "type": "function",
      "signature": "(f)",
      "description": ">>> import io\n>>> read_bytes4(io.BytesIO(b\"\\x00\\x00\\x00\\x00abc\"))\nb''\n>>> read_bytes4(io.BytesIO(b\"\\x03\\x00\\x00\\x00abcdef\"))\nb'abc'\n>>> read_bytes4(io.BytesIO(b\"\\x00\\x00\\x00\\x03abcdef\"))\nTraceback (most recent call last):\n...\nValueError: expected 50331648 bytes in a bytes4, but only 6 remain",
      "relationships": [
        {
          "target": "stdlib.pickletools.read_uint4",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.read",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.len",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.len",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pickletools.read_bytes8",
      "name": "read_bytes8",
      "module": "pickletools",
      "type": "function",
      "signature": "(f)",
      "description": ">>> import io, struct, sys\n>>> read_bytes8(io.BytesIO(b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00abc\"))\nb''\n>>> read_bytes8(io.BytesIO(b\"\\x03\\x00\\x00\\x00\\x00\\x00\\x00\\x00abcdef\"))\nb'abc'\n>>> bigsize8 = struct.pack(\"<Q\", sys.maxsize//3)\n>>> read_bytes8(io.BytesIO(bigsize8 + b\"abcdef\"))  #doctest: +ELLIPSIS\nTraceback (most recent call last):\n...\nValueError: expected ... bytes in a bytes8, but only 6 remain",
      "relationships": [
        {
          "target": "stdlib.pickletools.read_uint8",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.read",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.len",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.len",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pickletools.read_decimalnl_long",
      "name": "read_decimalnl_long",
      "module": "pickletools",
      "type": "function",
      "signature": "(f)",
      "description": ">>> import io\n\n>>> read_decimalnl_long(io.BytesIO(b\"1234L\\n56\"))\n1234\n\n>>> read_decimalnl_long(io.BytesIO(b\"123456789012345678901234L\\n6\"))\n123456789012345678901234",
      "relationships": [
        {
          "target": "stdlib.pickletools.read_stringnl",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.int",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pickletools.read_decimalnl_short",
      "name": "read_decimalnl_short",
      "module": "pickletools",
      "type": "function",
      "signature": "(f)",
      "description": ">>> import io\n>>> read_decimalnl_short(io.BytesIO(b\"1234\\n56\"))\n1234\n\n>>> read_decimalnl_short(io.BytesIO(b\"1234L\\n56\"))\nTraceback (most recent call last):\n...\nValueError: invalid literal for int() with base 10: b'1234L'",
      "relationships": [
        {
          "target": "stdlib.pickletools.read_stringnl",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.int",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pickletools.read_float8",
      "name": "read_float8",
      "module": "pickletools",
      "type": "function",
      "signature": "(f)",
      "description": ">>> import io, struct\n>>> raw = struct.pack(\">d\", -1.25)\n>>> raw\nb'\\xbf\\xf4\\x00\\x00\\x00\\x00\\x00\\x00'\n>>> read_float8(io.BytesIO(raw + b\"\\n\"))\n-1.25",
      "relationships": [
        {
          "target": "stdlib.pickletools.read",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.len",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools._unpack",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pickletools.read_floatnl",
      "name": "read_floatnl",
      "module": "pickletools",
      "type": "function",
      "signature": "(f)",
      "description": ">>> import io\n>>> read_floatnl(io.BytesIO(b\"-1.25\\n6\"))\n-1.25",
      "relationships": [
        {
          "target": "stdlib.pickletools.read_stringnl",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.float",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pickletools.read_int4",
      "name": "read_int4",
      "module": "pickletools",
      "type": "function",
      "signature": "(f)",
      "description": ">>> import io\n>>> read_int4(io.BytesIO(b'\\xff\\x00\\x00\\x00'))\n255\n>>> read_int4(io.BytesIO(b'\\x00\\x00\\x00\\x80')) == -(2**31)\nTrue",
      "relationships": [
        {
          "target": "stdlib.pickletools.read",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.len",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools._unpack",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pickletools.read_long1",
      "name": "read_long1",
      "module": "pickletools",
      "type": "function",
      "signature": "(f)",
      "description": ">>> import io\n>>> read_long1(io.BytesIO(b\"\\x00\"))\n0\n>>> read_long1(io.BytesIO(b\"\\x02\\xff\\x00\"))\n255\n>>> read_long1(io.BytesIO(b\"\\x02\\xff\\x7f\"))\n32767\n>>> read_long1(io.BytesIO(b\"\\x02\\x00\\xff\"))\n-256\n>>> read_long1(io.BytesIO(b\"\\x02\\x00\\x80\"))\n-32768",
      "relationships": [
        {
          "target": "stdlib.pickletools.read_uint1",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.read",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.decode_long",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.len",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.ValueError",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pickletools.read_long4",
      "name": "read_long4",
      "module": "pickletools",
      "type": "function",
      "signature": "(f)",
      "description": ">>> import io\n>>> read_long4(io.BytesIO(b\"\\x02\\x00\\x00\\x00\\xff\\x00\"))\n255\n>>> read_long4(io.BytesIO(b\"\\x02\\x00\\x00\\x00\\xff\\x7f\"))\n32767\n>>> read_long4(io.BytesIO(b\"\\x02\\x00\\x00\\x00\\x00\\xff\"))\n-256\n>>> read_long4(io.BytesIO(b\"\\x02\\x00\\x00\\x00\\x00\\x80\"))\n-32768\n>>> read_long1(io.BytesIO(b\"\\x00\\x00\\x00\\x00\"))\n0",
      "relationships": [
        {
          "target": "stdlib.pickletools.read_int4",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.read",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.decode_long",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.len",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.ValueError",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pickletools.read_string1",
      "name": "read_string1",
      "module": "pickletools",
      "type": "function",
      "signature": "(f)",
      "description": ">>> import io\n>>> read_string1(io.BytesIO(b\"\\x00\"))\n''\n>>> read_string1(io.BytesIO(b\"\\x03abcdef\"))\n'abc'",
      "relationships": [
        {
          "target": "stdlib.pickletools.read_uint1",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.read",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.len",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.decode",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.len",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pickletools.read_string4",
      "name": "read_string4",
      "module": "pickletools",
      "type": "function",
      "signature": "(f)",
      "description": ">>> import io\n>>> read_string4(io.BytesIO(b\"\\x00\\x00\\x00\\x00abc\"))\n''\n>>> read_string4(io.BytesIO(b\"\\x03\\x00\\x00\\x00abcdef\"))\n'abc'\n>>> read_string4(io.BytesIO(b\"\\x00\\x00\\x00\\x03abcdef\"))\nTraceback (most recent call last):\n...\nValueError: expected 50331648 bytes in a string4, but only 6 remain",
      "relationships": [
        {
          "target": "stdlib.pickletools.read_int4",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.read",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.len",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.decode",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.len",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pickletools.read_stringnl",
      "name": "read_stringnl",
      "module": "pickletools",
      "type": "function",
      "signature": "(f, decode=True, stripquotes=True)",
      "description": ">>> import io\n>>> read_stringnl(io.BytesIO(b\"'abcd'\\nefg\\n\"))\n'abcd'\n\n>>> read_stringnl(io.BytesIO(b\"\\n\"))\nTraceback (most recent call last):\n...\nValueError: no string quotes around b''\n\n>>> read_stringnl(io.BytesIO(b\"\\n\"), stripquotes=False)\n''\n\n>>> read_stringnl(io.BytesIO(b\"''\\n\"))\n''\n\n>>> read_stringnl(io.BytesIO(b'\"abcd\"'))\nTraceback (most recent call last):\n...\nValueError: no newline found when trying to read stringnl\n\nEmbedded escapes are undone in the result.\n>>> read_stringnl(io.BytesIO(br\"'a\\n\\\\b\\x00c\\td'\" + b\"\\n'e'\"))\n'a\\n\\\\b\\x00c\\td'",
      "relationships": [
        {
          "target": "stdlib.pickletools.readline",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.endswith",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.decode",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.startswith",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.endswith",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.escape_decode",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pickletools.read_stringnl_noescape",
      "name": "read_stringnl_noescape",
      "module": "pickletools",
      "type": "function",
      "signature": "(f)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.pickletools.read_stringnl",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pickletools.read_stringnl_noescape_pair",
      "name": "read_stringnl_noescape_pair",
      "module": "pickletools",
      "type": "function",
      "signature": "(f)",
      "description": ">>> import io\n>>> read_stringnl_noescape_pair(io.BytesIO(b\"Queue\\nEmpty\\njunk\"))\n'Queue Empty'",
      "relationships": [
        {
          "target": "stdlib.pickletools.read_stringnl_noescape",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.read_stringnl_noescape",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pickletools.read_uint1",
      "name": "read_uint1",
      "module": "pickletools",
      "type": "function",
      "signature": "(f)",
      "description": ">>> import io\n>>> read_uint1(io.BytesIO(b'\\xff'))\n255",
      "relationships": [
        {
          "target": "stdlib.pickletools.read",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.ValueError",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pickletools.read_uint2",
      "name": "read_uint2",
      "module": "pickletools",
      "type": "function",
      "signature": "(f)",
      "description": ">>> import io\n>>> read_uint2(io.BytesIO(b'\\xff\\x00'))\n255\n>>> read_uint2(io.BytesIO(b'\\xff\\xff'))\n65535",
      "relationships": [
        {
          "target": "stdlib.pickletools.read",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.len",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools._unpack",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pickletools.read_uint4",
      "name": "read_uint4",
      "module": "pickletools",
      "type": "function",
      "signature": "(f)",
      "description": ">>> import io\n>>> read_uint4(io.BytesIO(b'\\xff\\x00\\x00\\x00'))\n255\n>>> read_uint4(io.BytesIO(b'\\x00\\x00\\x00\\x80')) == 2**31\nTrue",
      "relationships": [
        {
          "target": "stdlib.pickletools.read",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.len",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools._unpack",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pickletools.read_uint8",
      "name": "read_uint8",
      "module": "pickletools",
      "type": "function",
      "signature": "(f)",
      "description": ">>> import io\n>>> read_uint8(io.BytesIO(b'\\xff\\x00\\x00\\x00\\x00\\x00\\x00\\x00'))\n255\n>>> read_uint8(io.BytesIO(b'\\xff' * 8)) == 2**64-1\nTrue",
      "relationships": [
        {
          "target": "stdlib.pickletools.read",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.len",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools._unpack",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pickletools.read_unicodestring1",
      "name": "read_unicodestring1",
      "module": "pickletools",
      "type": "function",
      "signature": "(f)",
      "description": ">>> import io\n>>> s = 'abcd\\uabcd'\n>>> enc = s.encode('utf-8')\n>>> enc\nb'abcd\\xea\\xaf\\x8d'\n>>> n = bytes([len(enc)])  # little-endian 1-byte length\n>>> t = read_unicodestring1(io.BytesIO(n + enc + b'junk'))\n>>> s == t\nTrue\n\n>>> read_unicodestring1(io.BytesIO(n + enc[:-1]))\nTraceback (most recent call last):\n...\nValueError: expected 7 bytes in a unicodestring1, but only 6 remain",
      "relationships": [
        {
          "target": "stdlib.pickletools.read_uint1",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.read",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.len",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.str",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.len",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pickletools.read_unicodestring4",
      "name": "read_unicodestring4",
      "module": "pickletools",
      "type": "function",
      "signature": "(f)",
      "description": ">>> import io\n>>> s = 'abcd\\uabcd'\n>>> enc = s.encode('utf-8')\n>>> enc\nb'abcd\\xea\\xaf\\x8d'\n>>> n = bytes([len(enc), 0, 0, 0])  # little-endian 4-byte length\n>>> t = read_unicodestring4(io.BytesIO(n + enc + b'junk'))\n>>> s == t\nTrue\n\n>>> read_unicodestring4(io.BytesIO(n + enc[:-1]))\nTraceback (most recent call last):\n...\nValueError: expected 7 bytes in a unicodestring4, but only 6 remain",
      "relationships": [
        {
          "target": "stdlib.pickletools.read_uint4",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.read",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.len",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.str",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.len",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pickletools.read_unicodestring8",
      "name": "read_unicodestring8",
      "module": "pickletools",
      "type": "function",
      "signature": "(f)",
      "description": ">>> import io\n>>> s = 'abcd\\uabcd'\n>>> enc = s.encode('utf-8')\n>>> enc\nb'abcd\\xea\\xaf\\x8d'\n>>> n = bytes([len(enc)]) + b'\\0' * 7  # little-endian 8-byte length\n>>> t = read_unicodestring8(io.BytesIO(n + enc + b'junk'))\n>>> s == t\nTrue\n\n>>> read_unicodestring8(io.BytesIO(n + enc[:-1]))\nTraceback (most recent call last):\n...\nValueError: expected 7 bytes in a unicodestring8, but only 6 remain",
      "relationships": [
        {
          "target": "stdlib.pickletools.read_uint8",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.read",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.len",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.str",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.len",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pickletools.read_unicodestringnl",
      "name": "read_unicodestringnl",
      "module": "pickletools",
      "type": "function",
      "signature": "(f)",
      "description": ">>> import io\n>>> read_unicodestringnl(io.BytesIO(b\"abc\\\\uabcd\\njunk\")) == 'abc\\uabcd'\nTrue",
      "relationships": [
        {
          "target": "stdlib.pickletools.readline",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.str",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.endswith",
          "type": "calls"
        },
        {
          "target": "stdlib.pickletools.ValueError",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pipes.Template",
      "name": "Template",
      "module": "pipes",
      "type": "class",
      "signature": "()",
      "description": "Class representing a pipeline template.",
      "relationships": []
    },
    {
      "id": "stdlib.pipes.makepipeline",
      "name": "makepipeline",
      "module": "pipes",
      "type": "function",
      "signature": "(infile, steps, outfile)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.pipes.range",
          "type": "calls"
        },
        {
          "target": "stdlib.pipes.append",
          "type": "calls"
        },
        {
          "target": "stdlib.pipes.append",
          "type": "calls"
        },
        {
          "target": "stdlib.pipes.insert",
          "type": "calls"
        },
        {
          "target": "stdlib.pipes.append",
          "type": "calls"
        },
        {
          "target": "stdlib.pipes.len",
          "type": "calls"
        },
        {
          "target": "stdlib.pipes.mkstemp",
          "type": "calls"
        },
        {
          "target": "stdlib.pipes.close",
          "type": "calls"
        },
        {
          "target": "stdlib.pipes.append",
          "type": "calls"
        },
        {
          "target": "stdlib.pipes.quote",
          "type": "calls"
        },
        {
          "target": "stdlib.pipes.quote",
          "type": "calls"
        },
        {
          "target": "stdlib.pipes.quote",
          "type": "calls"
        },
        {
          "target": "stdlib.pipes.quote",
          "type": "calls"
        },
        {
          "target": "stdlib.pipes.quote",
          "type": "calls"
        },
        {
          "target": "stdlib.pipes.quote",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pipes.quote",
      "name": "quote",
      "module": "pipes",
      "type": "function",
      "signature": "(s)",
      "description": "Return a shell-escaped version of the string *s*.",
      "relationships": [
        {
          "target": "stdlib.pipes._find_unsafe",
          "type": "calls"
        },
        {
          "target": "stdlib.pipes.replace",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pkgutil.ImpImporter",
      "name": "ImpImporter",
      "module": "pkgutil",
      "type": "class",
      "signature": "(path=None)",
      "description": "PEP 302 Finder that wraps Python's \"classic\" import algorithm\n\nImpImporter(dirname) produces a PEP 302 finder that searches that\ndirectory.  ImpImporter(None) produces a PEP 302 finder that searches\nthe current sys.path, plus any modules that are frozen or built-in.\n\nNote that ImpImporter does not currently support being used by placement\non sys.meta_path.",
      "relationships": []
    },
    {
      "id": "stdlib.pkgutil.ImpLoader",
      "name": "ImpLoader",
      "module": "pkgutil",
      "type": "class",
      "signature": "(fullname, file, filename, etc)",
      "description": "PEP 302 Loader that wraps Python's \"classic\" import algorithm\n    ",
      "relationships": []
    },
    {
      "id": "stdlib.pkgutil.ModuleInfo",
      "name": "ModuleInfo",
      "module": "pkgutil",
      "type": "class",
      "signature": "(module_finder, name, ispkg)",
      "description": "A namedtuple with minimal info about a module.",
      "relationships": [
        {
          "target": "tuple",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.pkgutil.ModuleType",
      "name": "ModuleType",
      "module": "pkgutil",
      "type": "class",
      "signature": "(name, doc=None)",
      "description": "Create a module object.\n\nThe name must be a string; the optional doc argument can have any type.",
      "relationships": []
    },
    {
      "id": "stdlib.pkgutil.extend_path",
      "name": "extend_path",
      "module": "pkgutil",
      "type": "function",
      "signature": "(path, name)",
      "description": "Extend a package's path.\n\nIntended use is to place the following code in a package's __init__.py:\n\n    from pkgutil import extend_path\n    __path__ = extend_path(__path__, __name__)\n\nThis will add to the package's __path__ all subdirectories of\ndirectories on sys.path named after the package.  This is useful\nif one wants to distribute different parts of a single logical\npackage as multiple directories.\n\nIt also looks for *.pkg files beginning where * matches the name\nargument.  This feature is similar to *.pth files (see site.py),\nexcept that it doesn't special-case lines starting with 'import'.\nA *.pkg file is trusted at face value: apart from checking for\nduplicates, all entries found in a *.pkg file are added to the\npath, regardless of whether they are exist the filesystem.  (This\nis a feature.)\n\nIf the input path is not a list (as is the case for frozen\npackages) it is returned unchanged.  The input path is not\nmodified; an extended copy is returned.  Items are only appended\nto the copy at the end.\n\nIt is assumed that sys.path is a sequence.  Items of sys.path that\nare not (unicode or 8-bit) strings referring to existing\ndirectories are ignored.  Unicode items of sys.path that cause\nerrors when used as filenames may cause this function to raise an\nexception (in line with os.path.isdir() behavior).",
      "relationships": [
        {
          "target": "stdlib.pkgutil.rpartition",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.get_importer",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.join",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.isfile",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.hasattr",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.find_spec",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.hasattr",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.open",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.find_loader",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.append",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.write",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.rstrip",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.append",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.startswith",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pkgutil.find_loader",
      "name": "find_loader",
      "module": "pkgutil",
      "type": "function",
      "signature": "(fullname)",
      "description": "Find a \"loader\" object for fullname\n\nThis is a backwards compatibility wrapper around\nimportlib.util.find_spec that converts most failures to ImportError\nand only returns the loader rather than the full spec",
      "relationships": [
        {
          "target": "stdlib.pkgutil.startswith",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.format",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.ImportError",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.find_spec",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.ImportError",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.format",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.type",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pkgutil.get_data",
      "name": "get_data",
      "module": "pkgutil",
      "type": "function",
      "signature": "(package, resource)",
      "description": "Get a resource from a package.\n\nThis is a wrapper round the PEP 302 loader get_data API. The package\nargument should be the name of a package, in standard module format\n(foo.bar). The resource argument should be in the form of a relative\nfilename, using '/' as the path separator. The parent directory name '..'\nis not allowed, and nor is a rooted name (starting with a '/').\n\nThe function returns a binary string, which is the contents of the\nspecified resource.\n\nFor packages located in the filesystem, which have already been imported,\nthis is the rough equivalent of\n\n    d = os.path.dirname(sys.modules[package].__file__)\n    data = open(os.path.join(d, resource), 'rb').read()\n\nIf the package cannot be located or loaded, or it uses a PEP 302 loader\nwhich does not support get_data(), then None is returned.",
      "relationships": [
        {
          "target": "stdlib.pkgutil.find_spec",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.split",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.insert",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.join",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.get_data",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.get",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil._load",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.dirname",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.hasattr",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.hasattr",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pkgutil.get_importer",
      "name": "get_importer",
      "module": "pkgutil",
      "type": "function",
      "signature": "(path_item)",
      "description": "Retrieve a finder for the given path item\n\nThe returned finder is cached in sys.path_importer_cache\nif it was newly created by a path hook.\n\nThe cache (or part of it) can be cleared manually if a\nrescan of sys.path_hooks is necessary.",
      "relationships": [
        {
          "target": "stdlib.pkgutil.fsdecode",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.path_hook",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.setdefault",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pkgutil.get_loader",
      "name": "get_loader",
      "module": "pkgutil",
      "type": "function",
      "signature": "(module_or_name)",
      "description": "Get a \"loader\" object for module_or_name\n\nReturns None if the module cannot be found or imported.\nIf the named module is not already imported, its containing package\n(if any) is imported, in order to establish the package __path__.",
      "relationships": [
        {
          "target": "stdlib.pkgutil.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.find_loader",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.getattr",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.getattr",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pkgutil.iter_importer_modules",
      "name": "iter_importer_modules",
      "module": "pkgutil",
      "type": "function",
      "signature": "(importer, prefix='')",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.pkgutil.iter_modules",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.hasattr",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pkgutil.iter_importers",
      "name": "iter_importers",
      "module": "pkgutil",
      "type": "function",
      "signature": "(fullname='')",
      "description": "Yield finders for the given module name\n\nIf fullname contains a '.', the finders will be for the package\ncontaining fullname, otherwise they will be all registered top level\nfinders (i.e. those on both sys.meta_path and sys.path_hooks).\n\nIf the named module is in a package, that package is imported as a side\neffect of invoking this function.\n\nIf no module name is specified, all top level finders are produced.",
      "relationships": [
        {
          "target": "stdlib.pkgutil.startswith",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.format",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.ImportError",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.import_module",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.getattr",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.rpartition",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.get_importer",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pkgutil.iter_modules",
      "name": "iter_modules",
      "module": "pkgutil",
      "type": "function",
      "signature": "(path=None, prefix='')",
      "description": "Yields ModuleInfo for all submodules on path,\nor, if path is None, all top-level modules on sys.path.\n\n'path' should be either None or a list of paths to look for\nmodules in.\n\n'prefix' is a string to output on the front of every module name\non output.",
      "relationships": [
        {
          "target": "stdlib.pkgutil.iter_importers",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.iter_importer_modules",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.map",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.ModuleInfo",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pkgutil.iter_zipimport_modules",
      "name": "iter_zipimport_modules",
      "module": "pkgutil",
      "type": "function",
      "signature": "(importer, prefix='')",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.pkgutil.sorted",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.len",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.split",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.getmodulename",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.startswith",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.startswith",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.len",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.len",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pkgutil.namedtuple",
      "name": "namedtuple",
      "module": "pkgutil",
      "type": "function",
      "signature": "(typename, field_names, *, rename=False, defaults=None, module=None)",
      "description": "Returns a new subclass of tuple with named fields.\n\n>>> Point = namedtuple('Point', ['x', 'y'])\n>>> Point.__doc__                   # docstring for the new class\n'Point(x, y)'\n>>> p = Point(11, y=22)             # instantiate with positional args or keywords\n>>> p[0] + p[1]                     # indexable like a plain tuple\n33\n>>> x, y = p                        # unpack like a regular tuple\n>>> x, y\n(11, 22)\n>>> p.x + p.y                       # fields also accessible by name\n33\n>>> d = p._asdict()                 # convert to a dictionary\n>>> d['x']\n11\n>>> Point(**d)                      # convert from a dictionary\nPoint(x=11, y=22)\n>>> p._replace(x=100)               # _replace() is like str.replace() but targets named fields\nPoint(x=100, y=22)",
      "relationships": [
        {
          "target": "stdlib.pkgutil.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.list",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.intern",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.set",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.tuple",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.len",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.join",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.eval",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.enumerate",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.type",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.split",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.map",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.str",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.set",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.enumerate",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil._iskeyword",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.add",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.tuple",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.dict",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.map",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.tuple_new",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil._make",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil._dict",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil._tuple",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.intern",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil._tuplegetter",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.add",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.type",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.isidentifier",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.startswith",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.len",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.len",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.reversed",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.join",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil._len",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil._map",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil._zip",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.get",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.replace",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil._iskeyword",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.startswith",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.list",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.isidentifier",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.zip",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.reversed",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.reversed",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.len",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.list",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil._getframe",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pkgutil.read_code",
      "name": "read_code",
      "module": "pkgutil",
      "type": "function",
      "signature": "(stream)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.pkgutil.read",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.read",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.load",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pkgutil.resolve_name",
      "name": "resolve_name",
      "module": "pkgutil",
      "type": "function",
      "signature": "(name)",
      "description": "Resolve a name to an object.\n\nIt is expected that `name` will be a string in one of the following\nformats, where W is shorthand for a valid Python identifier and dot stands\nfor a literal period in these pseudo-regexes:\n\nW(.W)*\nW(.W)*:(W(.W)*)?\n\nThe first form is intended for backward compatibility only. It assumes that\nsome part of the dotted name is a package, and the rest is an object\nsomewhere within that package, possibly nested inside other objects.\nBecause the place where the package stops and the object hierarchy starts\ncan't be inferred by inspection, repeated attempts to import must be done\nwith this form.\n\nIn the second form, the caller makes the division point clear through the\nprovision of a single colon: the dotted name to the left of the colon is a\npackage to be imported, and the dotted name to the right is the object\nhierarchy within that package. Only one import is needed in this form. If\nit ends with the colon, then a module object is returned.\n\nThe function will return an object (which might be a module), or raise one\nof the following exceptions:\n\nValueError - if `name` isn't in a recognised format\nImportError - if an import failed when it shouldn't have\nAttributeError - if a failure occurred when traversing the object hierarchy\n                 within the imported package to get to the desired object)",
      "relationships": [
        {
          "target": "stdlib.pkgutil.match",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.groupdict",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.get",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.import_module",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.get",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.split",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.pop",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.import_module",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.getattr",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.split",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.import_module",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.pop",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pkgutil.simplegeneric",
      "name": "simplegeneric",
      "module": "pkgutil",
      "type": "function",
      "signature": "(func)",
      "description": "Single-dispatch generic function decorator.\n\nTransforms a function into a generic function, which can have different\nbehaviours depending upon the type of its first argument. The decorated\nfunction acts as the default implementation, and additional\nimplementations can be registered using the register() attribute of the\ngeneric function.",
      "relationships": [
        {
          "target": "stdlib.pkgutil.WeakKeyDictionary",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.getattr",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.MappingProxyType",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.update_wrapper",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.clear",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.get_cache_token",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.getattr",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.next",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.hasattr",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.get_cache_token",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.dispatch",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.clear",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.iter",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.register",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.items",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil._find_impl",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.get_type_hints",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pkgutil.walk_packages",
      "name": "walk_packages",
      "module": "pkgutil",
      "type": "function",
      "signature": "(path=None, prefix='', onerror=None)",
      "description": "Yields ModuleInfo for all modules recursively\non path, or, if path is None, all accessible modules.\n\n'path' should be either None or a list of paths to look for\nmodules in.\n\n'prefix' is a string to output on the front of every module name\non output.\n\nNote that this function must import all *packages* (NOT all\nmodules!) on the given path, in order to access the __path__\nattribute to find submodules.\n\n'onerror' is a function which gets called with one argument (the\nname of the package which was being imported) if any exception\noccurs while trying to import a package.  If no onerror function is\nsupplied, ImportErrors are caught and ignored, while all other\nexceptions are propagated, terminating the search.\n\nExamples:\n\n# list all modules python can access\nwalk_packages()\n\n# list all submodules of ctypes\nwalk_packages(ctypes.__path__, ctypes.__name__+'.')",
      "relationships": [
        {
          "target": "stdlib.pkgutil.iter_modules",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.__import__",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.getattr",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.walk_packages",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.onerror",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.onerror",
          "type": "calls"
        },
        {
          "target": "stdlib.pkgutil.seen",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pkgutil.zipimporter",
      "name": "zipimporter",
      "module": "pkgutil",
      "type": "class",
      "signature": "(path)",
      "description": "zipimporter(archivepath) -> zipimporter object\n\nCreate a new zipimporter instance. 'archivepath' must be a path to\na zipfile, or to a specific path inside a zipfile. For example, it can be\n'/tmp/myimport.zip', or '/tmp/myimport.zip/mydirectory', if mydirectory is a\nvalid directory inside the archive.\n\n'ZipImportError is raised if 'archivepath' doesn't point to a valid Zip\narchive.\n\nThe 'archive' attribute of zipimporter objects contains the name of the\nzipfile targeted.",
      "relationships": []
    },
    {
      "id": "stdlib.platform.architecture",
      "name": "architecture",
      "module": "platform",
      "type": "function",
      "signature": "(executable='/Users/anthonycardillo/Documents/personal/polyester/.venv/bin/python', bits='', linkage='')",
      "description": "Queries the given executable (defaults to the Python interpreter\nbinary) for various architecture information.\n\nReturns a tuple (bits, linkage) which contains information about\nthe bit architecture and the linkage format used for the\nexecutable. Both values are returned as strings.\n\nValues that cannot be determined are returned as given by the\nparameter presets. If bits is given as '', the sizeof(pointer)\n(or sizeof(long) on Python version < 1.5.2) is used as\nindicator for the supported pointer size.\n\nThe function relies on the system's \"file\" command to do the\nactual work. This is available on most if not all Unix\nplatforms. On some non-Unix platforms where the \"file\" command\ndoes not exist and the executable is set to the Python interpreter\nbinary defaults from _default_architecture are used.",
      "relationships": [
        {
          "target": "stdlib.platform.calcsize",
          "type": "calls"
        },
        {
          "target": "stdlib.platform._syscmd_file",
          "type": "calls"
        },
        {
          "target": "stdlib.platform.str",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.platform.java_ver",
      "name": "java_ver",
      "module": "platform",
      "type": "function",
      "signature": "(release='', vendor='', vminfo=('', '', ''), osinfo=('', '', ''))",
      "description": "Version interface for Jython.\n\nReturns a tuple (release, vendor, vminfo, osinfo) with vminfo being\na tuple (vm_name, vm_release, vm_vendor) and osinfo being a\ntuple (os_name, os_version, os_arch).\n\nValues which cannot be determined are set to the defaults\ngiven as parameters (which all default to '').",
      "relationships": [
        {
          "target": "stdlib.platform._java_getprop",
          "type": "calls"
        },
        {
          "target": "stdlib.platform._java_getprop",
          "type": "calls"
        },
        {
          "target": "stdlib.platform._java_getprop",
          "type": "calls"
        },
        {
          "target": "stdlib.platform._java_getprop",
          "type": "calls"
        },
        {
          "target": "stdlib.platform._java_getprop",
          "type": "calls"
        },
        {
          "target": "stdlib.platform._java_getprop",
          "type": "calls"
        },
        {
          "target": "stdlib.platform._java_getprop",
          "type": "calls"
        },
        {
          "target": "stdlib.platform._java_getprop",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.platform.libc_ver",
      "name": "libc_ver",
      "module": "platform",
      "type": "function",
      "signature": "(executable=None, lib='', version='', chunksize=16384)",
      "description": "Tries to determine the libc version that the file executable\n(which defaults to the Python interpreter) is linked against.\n\nReturns a tuple of strings (lib,version) which default to the\ngiven parameters in case the lookup fails.\n\nNote that the function has intimate knowledge of how different\nlibc versions add symbols to the executable and thus is probably\nonly useable for executables compiled using gcc.\n\nThe file is read and scanned in chunks of chunksize bytes.",
      "relationships": [
        {
          "target": "stdlib.platform.hasattr",
          "type": "calls"
        },
        {
          "target": "stdlib.platform.realpath",
          "type": "calls"
        },
        {
          "target": "stdlib.platform.open",
          "type": "calls"
        },
        {
          "target": "stdlib.platform.read",
          "type": "calls"
        },
        {
          "target": "stdlib.platform.confstr",
          "type": "calls"
        },
        {
          "target": "stdlib.platform.split",
          "type": "calls"
        },
        {
          "target": "stdlib.platform.len",
          "type": "calls"
        },
        {
          "target": "stdlib.platform.end",
          "type": "calls"
        },
        {
          "target": "stdlib.platform.len",
          "type": "calls"
        },
        {
          "target": "stdlib.platform.tuple",
          "type": "calls"
        },
        {
          "target": "stdlib.platform.search",
          "type": "calls"
        },
        {
          "target": "stdlib.platform.read",
          "type": "calls"
        },
        {
          "target": "stdlib.platform.end",
          "type": "calls"
        },
        {
          "target": "stdlib.platform.len",
          "type": "calls"
        },
        {
          "target": "stdlib.platform.decode",
          "type": "calls"
        },
        {
          "target": "stdlib.platform.groups",
          "type": "calls"
        },
        {
          "target": "stdlib.platform.V",
          "type": "calls"
        },
        {
          "target": "stdlib.platform.V",
          "type": "calls"
        },
        {
          "target": "stdlib.platform.max",
          "type": "calls"
        },
        {
          "target": "stdlib.platform.len",
          "type": "calls"
        },
        {
          "target": "stdlib.platform.V",
          "type": "calls"
        },
        {
          "target": "stdlib.platform.V",
          "type": "calls"
        },
        {
          "target": "stdlib.platform.len",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.platform.mac_ver",
      "name": "mac_ver",
      "module": "platform",
      "type": "function",
      "signature": "(release='', versioninfo=('', '', ''), machine='')",
      "description": "Get macOS version information and return it as tuple (release,\nversioninfo, machine) with versioninfo being a tuple (version,\ndev_stage, non_release_version).\n\nEntries which cannot be determined are set to the parameter values\nwhich default to ''. All tuple entries are strings.",
      "relationships": [
        {
          "target": "stdlib.platform._mac_ver_xml",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.platform.machine",
      "name": "machine",
      "module": "platform",
      "type": "function",
      "signature": "()",
      "description": "Returns the machine type, e.g. 'i386'\n\nAn empty string is returned if the value cannot be determined.",
      "relationships": [
        {
          "target": "stdlib.platform.uname",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.platform.node",
      "name": "node",
      "module": "platform",
      "type": "function",
      "signature": "()",
      "description": "Returns the computer's network name (which may not be fully\nqualified)\n\nAn empty string is returned if the value cannot be determined.",
      "relationships": [
        {
          "target": "stdlib.platform.uname",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.platform.platform",
      "name": "platform",
      "module": "platform",
      "type": "function",
      "signature": "(aliased=0, terse=0)",
      "description": "Returns a single string identifying the underlying platform\nwith as much useful information as possible (but no more :).\n\nThe output is intended to be human readable rather than\nmachine parseable. It may look different on different\nplatforms and this is intended.\n\nIf \"aliased\" is true, the function will use aliases for\nvarious platforms that report system names which differ from\ntheir common names, e.g. SunOS will be reported as\nSolaris. The system_alias() function is used to implement\nthis.\n\nSetting terse to true causes the function to return only the\nabsolute minimum information needed to identify the platform.",
      "relationships": [
        {
          "target": "stdlib.platform.get",
          "type": "calls"
        },
        {
          "target": "stdlib.platform.uname",
          "type": "calls"
        },
        {
          "target": "stdlib.platform.system_alias",
          "type": "calls"
        },
        {
          "target": "stdlib.platform.win32_ver",
          "type": "calls"
        },
        {
          "target": "stdlib.platform.mac_ver",
          "type": "calls"
        },
        {
          "target": "stdlib.platform._platform",
          "type": "calls"
        },
        {
          "target": "stdlib.platform._platform",
          "type": "calls"
        },
        {
          "target": "stdlib.platform.libc_ver",
          "type": "calls"
        },
        {
          "target": "stdlib.platform._platform",
          "type": "calls"
        },
        {
          "target": "stdlib.platform.java_ver",
          "type": "calls"
        },
        {
          "target": "stdlib.platform._platform",
          "type": "calls"
        },
        {
          "target": "stdlib.platform._platform",
          "type": "calls"
        },
        {
          "target": "stdlib.platform._platform",
          "type": "calls"
        },
        {
          "target": "stdlib.platform.architecture",
          "type": "calls"
        },
        {
          "target": "stdlib.platform._platform",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.platform.processor",
      "name": "processor",
      "module": "platform",
      "type": "function",
      "signature": "()",
      "description": "Returns the (true) processor name, e.g. 'amdk6'\n\nAn empty string is returned if the value cannot be\ndetermined. Note that many platforms do not provide this\ninformation or simply return the same value as for machine(),\ne.g.  NetBSD does this.",
      "relationships": [
        {
          "target": "stdlib.platform.uname",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.platform.python_branch",
      "name": "python_branch",
      "module": "platform",
      "type": "function",
      "signature": "()",
      "description": "Returns a string identifying the Python implementation\nbranch.\n\nFor CPython this is the SCM branch from which the\nPython binary was built.\n\nIf not available, an empty string is returned.",
      "relationships": [
        {
          "target": "stdlib.platform._sys_version",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.platform.python_build",
      "name": "python_build",
      "module": "platform",
      "type": "function",
      "signature": "()",
      "description": "Returns a tuple (buildno, builddate) stating the Python\nbuild number and date as strings.",
      "relationships": [
        {
          "target": "stdlib.platform._sys_version",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.platform.python_compiler",
      "name": "python_compiler",
      "module": "platform",
      "type": "function",
      "signature": "()",
      "description": "Returns a string identifying the compiler used for compiling\nPython.",
      "relationships": [
        {
          "target": "stdlib.platform._sys_version",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.platform.python_implementation",
      "name": "python_implementation",
      "module": "platform",
      "type": "function",
      "signature": "()",
      "description": "Returns a string identifying the Python implementation.\n\nCurrently, the following implementations are identified:\n  'CPython' (C implementation of Python),\n  'IronPython' (.NET implementation of Python),\n  'Jython' (Java implementation of Python),\n  'PyPy' (Python implementation of Python).",
      "relationships": [
        {
          "target": "stdlib.platform._sys_version",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.platform.python_revision",
      "name": "python_revision",
      "module": "platform",
      "type": "function",
      "signature": "()",
      "description": "Returns a string identifying the Python implementation\nrevision.\n\nFor CPython this is the SCM revision from which the\nPython binary was built.\n\nIf not available, an empty string is returned.",
      "relationships": [
        {
          "target": "stdlib.platform._sys_version",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.platform.python_version",
      "name": "python_version",
      "module": "platform",
      "type": "function",
      "signature": "()",
      "description": "Returns the Python version as string 'major.minor.patchlevel'\n\nNote that unlike the Python sys.version, the returned value\nwill always include the patchlevel (it defaults to 0).",
      "relationships": [
        {
          "target": "stdlib.platform._sys_version",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.platform.python_version_tuple",
      "name": "python_version_tuple",
      "module": "platform",
      "type": "function",
      "signature": "()",
      "description": "Returns the Python version as tuple (major, minor, patchlevel)\nof strings.\n\nNote that unlike the Python sys.version, the returned value\nwill always include the patchlevel (it defaults to 0).",
      "relationships": [
        {
          "target": "stdlib.platform.tuple",
          "type": "calls"
        },
        {
          "target": "stdlib.platform.split",
          "type": "calls"
        },
        {
          "target": "stdlib.platform._sys_version",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.platform.release",
      "name": "release",
      "module": "platform",
      "type": "function",
      "signature": "()",
      "description": "Returns the system's release, e.g. '2.2.0' or 'NT'\n\nAn empty string is returned if the value cannot be determined.",
      "relationships": [
        {
          "target": "stdlib.platform.uname",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.platform.system",
      "name": "system",
      "module": "platform",
      "type": "function",
      "signature": "()",
      "description": "Returns the system/OS name, e.g. 'Linux', 'Windows' or 'Java'.\n\nAn empty string is returned if the value cannot be determined.",
      "relationships": [
        {
          "target": "stdlib.platform.uname",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.platform.system_alias",
      "name": "system_alias",
      "module": "platform",
      "type": "function",
      "signature": "(system, release, version)",
      "description": "Returns (system, release, version) aliased to common\nmarketing names used for some systems.\n\nIt also does some reordering of the information in some cases\nwhere it would otherwise cause confusion.",
      "relationships": [
        {
          "target": "stdlib.platform.split",
          "type": "calls"
        },
        {
          "target": "stdlib.platform.int",
          "type": "calls"
        },
        {
          "target": "stdlib.platform.str",
          "type": "calls"
        },
        {
          "target": "stdlib.platform.join",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.platform.uname",
      "name": "uname",
      "module": "platform",
      "type": "function",
      "signature": "()",
      "description": "Fairly portable uname interface. Returns a tuple\nof strings (system, node, release, version, machine, processor)\nidentifying the underlying platform.\n\nNote that unlike the os.uname function this also returns\npossible processor information as an additional tuple entry.\n\nEntries which cannot be determined are set to ''.",
      "relationships": [
        {
          "target": "stdlib.platform.uname_result",
          "type": "calls"
        },
        {
          "target": "stdlib.platform.uname",
          "type": "calls"
        },
        {
          "target": "stdlib.platform.any",
          "type": "calls"
        },
        {
          "target": "stdlib.platform._node",
          "type": "calls"
        },
        {
          "target": "stdlib.platform.win32_ver",
          "type": "calls"
        },
        {
          "target": "stdlib.platform._syscmd_ver",
          "type": "calls"
        },
        {
          "target": "stdlib.platform.map",
          "type": "calls"
        },
        {
          "target": "stdlib.platform._get_machine_win32",
          "type": "calls"
        },
        {
          "target": "stdlib.platform.java_ver",
          "type": "calls"
        },
        {
          "target": "stdlib.platform.join",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.platform.uname_result",
      "name": "uname_result",
      "module": "platform",
      "type": "class",
      "signature": "(system, node, release, version, machine)",
      "description": "A uname_result that's largely compatible with a\nsimple namedtuple except that 'processor' is\nresolved late and cached to avoid calling \"uname\"\nexcept when needed.",
      "relationships": [
        {
          "target": "uname_result_base",
          "type": "base_class"
        },
        {
          "target": "tuple",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.platform.version",
      "name": "version",
      "module": "platform",
      "type": "function",
      "signature": "()",
      "description": "Returns the system's release version, e.g. '#3 on degas'\n\nAn empty string is returned if the value cannot be determined.",
      "relationships": [
        {
          "target": "stdlib.platform.uname",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.platform.win32_edition",
      "name": "win32_edition",
      "module": "platform",
      "type": "function",
      "signature": "()",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.platform.OpenKeyEx",
          "type": "calls"
        },
        {
          "target": "stdlib.platform.QueryValueEx",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.platform.win32_is_iot",
      "name": "win32_is_iot",
      "module": "platform",
      "type": "function",
      "signature": "()",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.platform.win32_edition",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.platform.win32_ver",
      "name": "win32_ver",
      "module": "platform",
      "type": "function",
      "signature": "(release='', version='', csd='', ptype='')",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.platform.getwindowsversion",
          "type": "calls"
        },
        {
          "target": "stdlib.platform.format",
          "type": "calls"
        },
        {
          "target": "stdlib.platform.map",
          "type": "calls"
        },
        {
          "target": "stdlib.platform.get",
          "type": "calls"
        },
        {
          "target": "stdlib.platform.get",
          "type": "calls"
        },
        {
          "target": "stdlib.platform.getattr",
          "type": "calls"
        },
        {
          "target": "stdlib.platform.split",
          "type": "calls"
        },
        {
          "target": "stdlib.platform.format",
          "type": "calls"
        },
        {
          "target": "stdlib.platform.get",
          "type": "calls"
        },
        {
          "target": "stdlib.platform.get",
          "type": "calls"
        },
        {
          "target": "stdlib.platform.OpenKeyEx",
          "type": "calls"
        },
        {
          "target": "stdlib.platform.QueryValueEx",
          "type": "calls"
        },
        {
          "target": "stdlib.platform._syscmd_ver",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.plistlib.BytesIO",
      "name": "BytesIO",
      "module": "plistlib",
      "type": "class",
      "signature": "(initial_bytes=b'')",
      "description": "Buffered I/O implementation using an in-memory bytes buffer.",
      "relationships": [
        {
          "target": "_BufferedIOBase",
          "type": "base_class"
        },
        {
          "target": "_IOBase",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.plistlib.InvalidFileException",
      "name": "InvalidFileException",
      "module": "plistlib",
      "type": "class",
      "signature": "(message='Invalid file')",
      "description": "Inappropriate argument value (of correct type).",
      "relationships": [
        {
          "target": "ValueError",
          "type": "base_class"
        },
        {
          "target": "Exception",
          "type": "base_class"
        },
        {
          "target": "BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.plistlib.PlistFormat",
      "name": "PlistFormat",
      "module": "plistlib",
      "type": "class",
      "signature": "(value, names=None, *, module=None, qualname=None, type=None, start=1)",
      "description": "An enumeration.",
      "relationships": [
        {
          "target": "Enum",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.plistlib.UID",
      "name": "UID",
      "module": "plistlib",
      "type": "class",
      "signature": "(data)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.plistlib.dump",
      "name": "dump",
      "module": "plistlib",
      "type": "function",
      "signature": "(value, fp, *, fmt=<PlistFormat.FMT_XML: 1>, sort_keys=True, skipkeys=False)",
      "description": "Write 'value' to a .plist file. 'fp' should be a writable,\nbinary file object.",
      "relationships": [
        {
          "target": "stdlib.plistlib.write",
          "type": "calls"
        },
        {
          "target": "stdlib.plistlib.ValueError",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.plistlib.dumps",
      "name": "dumps",
      "module": "plistlib",
      "type": "function",
      "signature": "(value, *, fmt=<PlistFormat.FMT_XML: 1>, skipkeys=False, sort_keys=True)",
      "description": "Return a bytes object with the contents for a .plist file.\n    ",
      "relationships": [
        {
          "target": "stdlib.plistlib.BytesIO",
          "type": "calls"
        },
        {
          "target": "stdlib.plistlib.dump",
          "type": "calls"
        },
        {
          "target": "stdlib.plistlib.getvalue",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.plistlib.load",
      "name": "load",
      "module": "plistlib",
      "type": "function",
      "signature": "(fp, *, fmt=None, dict_type=<class 'dict'>)",
      "description": "Read a .plist file. 'fp' should be a readable and binary file object.\nReturn the unpacked root object (which usually is a dictionary).",
      "relationships": [
        {
          "target": "stdlib.plistlib.P",
          "type": "calls"
        },
        {
          "target": "stdlib.plistlib.parse",
          "type": "calls"
        },
        {
          "target": "stdlib.plistlib.read",
          "type": "calls"
        },
        {
          "target": "stdlib.plistlib.seek",
          "type": "calls"
        },
        {
          "target": "stdlib.plistlib.values",
          "type": "calls"
        },
        {
          "target": "stdlib.plistlib.InvalidFileException",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.plistlib.loads",
      "name": "loads",
      "module": "plistlib",
      "type": "function",
      "signature": "(value, *, fmt=None, dict_type=<class 'dict'>)",
      "description": "Read a .plist file from a bytes object.\nReturn the unpacked root object (which usually is a dictionary).",
      "relationships": [
        {
          "target": "stdlib.plistlib.BytesIO",
          "type": "calls"
        },
        {
          "target": "stdlib.plistlib.load",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.poplib.POP3",
      "name": "POP3",
      "module": "poplib",
      "type": "class",
      "signature": "(host, port=110, timeout=<object object at 0x102f70e60>)",
      "description": "This class supports both the minimal and optional command sets.\nArguments can be strings or integers (where appropriate)\n(e.g.: retr(1) and retr('1') both work equally well.\n\nMinimal Command Set:\n        USER name               user(name)\n        PASS string             pass_(string)\n        STAT                    stat()\n        LIST [msg]              list(msg = None)\n        RETR msg                retr(msg)\n        DELE msg                dele(msg)\n        NOOP                    noop()\n        RSET                    rset()\n        QUIT                    quit()\n\nOptional Commands (some servers support these):\n        RPOP name               rpop(name)\n        APOP name digest        apop(name, digest)\n        TOP msg n               top(msg, n)\n        UIDL [msg]              uidl(msg = None)\n        CAPA                    capa()\n        STLS                    stls()\n        UTF8                    utf8()\n\nRaises one exception: 'error_proto'.\n\nInstantiate with:\n        POP3(hostname, port=110)\n\nNB:     the POP protocol locks the mailbox from user\n        authorization until QUIT, so be sure to get in, suck\n        the messages, and quit, each time you access the\n        mailbox.\n\n        POP is a line-based protocol, which means large mail\n        messages consume lots of python cycles reading them\n        line-by-line.\n\n        If it's available on your mail server, use IMAP4\n        instead, it doesn't suffer from the two problems\n        above.",
      "relationships": []
    },
    {
      "id": "stdlib.poplib.POP3_SSL",
      "name": "POP3_SSL",
      "module": "poplib",
      "type": "class",
      "signature": "(host, port=995, keyfile=None, certfile=None, timeout=<object object at 0x102f70e60>, context=None)",
      "description": "POP3 client class over SSL connection\n\nInstantiate with: POP3_SSL(hostname, port=995, keyfile=None, certfile=None,\n                           context=None)\n\n       hostname - the hostname of the pop3 over ssl server\n       port - port number\n       keyfile - PEM formatted file that contains your private key\n       certfile - PEM formatted certificate chain file\n       context - a ssl.SSLContext\n\nSee the methods of the parent class POP3 for more documentation.",
      "relationships": [
        {
          "target": "POP3",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.posixpath.abspath",
      "name": "abspath",
      "module": "posixpath",
      "type": "function",
      "signature": "(path)",
      "description": "Return an absolute path.",
      "relationships": [
        {
          "target": "stdlib.posixpath.fspath",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.normpath",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.isabs",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.join",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.getcwdb",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.getcwd",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.posixpath.basename",
      "name": "basename",
      "module": "posixpath",
      "type": "function",
      "signature": "(p)",
      "description": "Returns the final component of a pathname",
      "relationships": [
        {
          "target": "stdlib.posixpath.fspath",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath._get_sep",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.rfind",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.posixpath.commonpath",
      "name": "commonpath",
      "module": "posixpath",
      "type": "function",
      "signature": "(paths)",
      "description": "Given a sequence of path names, returns the longest common sub-path.",
      "relationships": [
        {
          "target": "stdlib.posixpath.tuple",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.map",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.min",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.max",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.enumerate",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.split",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.set",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.join",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath._check_arg_types",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.ValueError",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.posixpath.commonprefix",
      "name": "commonprefix",
      "module": "posixpath",
      "type": "function",
      "signature": "(m)",
      "description": "Given a list of pathnames, returns the longest common leading component",
      "relationships": [
        {
          "target": "stdlib.posixpath.min",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.max",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.enumerate",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.tuple",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.map",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.posixpath.dirname",
      "name": "dirname",
      "module": "posixpath",
      "type": "function",
      "signature": "(p)",
      "description": "Returns the directory component of a pathname",
      "relationships": [
        {
          "target": "stdlib.posixpath.fspath",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath._get_sep",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.rfind",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.rstrip",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.len",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.posixpath.exists",
      "name": "exists",
      "module": "posixpath",
      "type": "function",
      "signature": "(path)",
      "description": "Test whether a path exists.  Returns False for broken symbolic links",
      "relationships": [
        {
          "target": "stdlib.posixpath.stat",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.posixpath.expanduser",
      "name": "expanduser",
      "module": "posixpath",
      "type": "function",
      "signature": "(path)",
      "description": "Expand ~ and ~user constructions.  If user or $HOME is unknown,\ndo nothing.",
      "relationships": [
        {
          "target": "stdlib.posixpath.fspath",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath._get_sep",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.find",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.rstrip",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.startswith",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.len",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.fsencode",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.str",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.getpwnam",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.getpwuid",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.getuid",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.posixpath.expandvars",
      "name": "expandvars",
      "module": "posixpath",
      "type": "function",
      "signature": "(path)",
      "description": "Expand shell variables of form $var and ${var}.  Unknown variables\nare left unchanged.",
      "relationships": [
        {
          "target": "stdlib.posixpath.fspath",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.getattr",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.search",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.span",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.group",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.compile",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.compile",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.startswith",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.endswith",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.len",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.fsencode",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.fsdecode",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.posixpath.getatime",
      "name": "getatime",
      "module": "posixpath",
      "type": "function",
      "signature": "(filename)",
      "description": "Return the last access time of a file, reported by os.stat().",
      "relationships": [
        {
          "target": "stdlib.posixpath.stat",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.posixpath.getctime",
      "name": "getctime",
      "module": "posixpath",
      "type": "function",
      "signature": "(filename)",
      "description": "Return the metadata change time of a file, reported by os.stat().",
      "relationships": [
        {
          "target": "stdlib.posixpath.stat",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.posixpath.getmtime",
      "name": "getmtime",
      "module": "posixpath",
      "type": "function",
      "signature": "(filename)",
      "description": "Return the last modification time of a file, reported by os.stat().",
      "relationships": [
        {
          "target": "stdlib.posixpath.stat",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.posixpath.getsize",
      "name": "getsize",
      "module": "posixpath",
      "type": "function",
      "signature": "(filename)",
      "description": "Return the size of a file, reported by os.stat().",
      "relationships": [
        {
          "target": "stdlib.posixpath.stat",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.posixpath.isabs",
      "name": "isabs",
      "module": "posixpath",
      "type": "function",
      "signature": "(s)",
      "description": "Test whether a path is absolute",
      "relationships": [
        {
          "target": "stdlib.posixpath.fspath",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath._get_sep",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.startswith",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.posixpath.isdir",
      "name": "isdir",
      "module": "posixpath",
      "type": "function",
      "signature": "(s)",
      "description": "Return true if the pathname refers to an existing directory.",
      "relationships": [
        {
          "target": "stdlib.posixpath.S_ISDIR",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.stat",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.posixpath.isfile",
      "name": "isfile",
      "module": "posixpath",
      "type": "function",
      "signature": "(path)",
      "description": "Test whether a path is a regular file",
      "relationships": [
        {
          "target": "stdlib.posixpath.S_ISREG",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.stat",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.posixpath.islink",
      "name": "islink",
      "module": "posixpath",
      "type": "function",
      "signature": "(path)",
      "description": "Test whether a path is a symbolic link",
      "relationships": [
        {
          "target": "stdlib.posixpath.S_ISLNK",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.lstat",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.posixpath.ismount",
      "name": "ismount",
      "module": "posixpath",
      "type": "function",
      "signature": "(path)",
      "description": "Test whether a path is a mount point",
      "relationships": [
        {
          "target": "stdlib.posixpath.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.realpath",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.lstat",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.S_ISLNK",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.join",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.join",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.lstat",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.posixpath.join",
      "name": "join",
      "module": "posixpath",
      "type": "function",
      "signature": "(a, *p)",
      "description": "Join two or more pathname components, inserting '/' as needed.\nIf any component is an absolute path, all previous path components\nwill be discarded.  An empty last part will result in a path that\nends with a separator.",
      "relationships": [
        {
          "target": "stdlib.posixpath.fspath",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath._get_sep",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.map",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.startswith",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath._check_arg_types",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.endswith",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.posixpath.lexists",
      "name": "lexists",
      "module": "posixpath",
      "type": "function",
      "signature": "(path)",
      "description": "Test whether a path exists.  Returns True for broken symbolic links",
      "relationships": [
        {
          "target": "stdlib.posixpath.lstat",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.posixpath.normcase",
      "name": "normcase",
      "module": "posixpath",
      "type": "function",
      "signature": "(s)",
      "description": "Normalize case of pathname.  Has no effect under Posix",
      "relationships": [
        {
          "target": "stdlib.posixpath.fspath",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.posixpath.normpath",
      "name": "normpath",
      "module": "posixpath",
      "type": "function",
      "signature": "(path)",
      "description": "Normalize path, eliminating double slashes, etc.",
      "relationships": [
        {
          "target": "stdlib.posixpath.fspath",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.startswith",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.split",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.join",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.startswith",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.startswith",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.append",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.pop",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.posixpath.realpath",
      "name": "realpath",
      "module": "posixpath",
      "type": "function",
      "signature": "(filename)",
      "description": "Return the canonical path of the specified filename, eliminating any\nsymbolic links encountered in the path.",
      "relationships": [
        {
          "target": "stdlib.posixpath.fspath",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath._joinrealpath",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.abspath",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.posixpath.relpath",
      "name": "relpath",
      "module": "posixpath",
      "type": "function",
      "signature": "(path, start=None)",
      "description": "Return a relative version of a path",
      "relationships": [
        {
          "target": "stdlib.posixpath.fspath",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.fspath",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.len",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.join",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.commonprefix",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath._check_arg_types",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.split",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.split",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.len",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.abspath",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.abspath",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.posixpath.samefile",
      "name": "samefile",
      "module": "posixpath",
      "type": "function",
      "signature": "(f1, f2)",
      "description": "Test whether two pathnames reference the same actual file or directory\n\nThis is determined by the device number and i-node number and\nraises an exception if an os.stat() call on either pathname fails.",
      "relationships": [
        {
          "target": "stdlib.posixpath.stat",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.stat",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.samestat",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.posixpath.sameopenfile",
      "name": "sameopenfile",
      "module": "posixpath",
      "type": "function",
      "signature": "(fp1, fp2)",
      "description": "Test whether two open file objects reference the same file",
      "relationships": [
        {
          "target": "stdlib.posixpath.fstat",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.fstat",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.samestat",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.posixpath.samestat",
      "name": "samestat",
      "module": "posixpath",
      "type": "function",
      "signature": "(s1, s2)",
      "description": "Test whether two stat buffers reference the same file",
      "relationships": []
    },
    {
      "id": "stdlib.posixpath.split",
      "name": "split",
      "module": "posixpath",
      "type": "function",
      "signature": "(p)",
      "description": "Split a pathname.  Returns tuple \"(head, tail)\" where \"tail\" is\neverything after the final slash.  Either part may be empty.",
      "relationships": [
        {
          "target": "stdlib.posixpath.fspath",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath._get_sep",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.rfind",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.rstrip",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.len",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.posixpath.splitdrive",
      "name": "splitdrive",
      "module": "posixpath",
      "type": "function",
      "signature": "(p)",
      "description": "Split a pathname into drive and path. On Posix, drive is always\nempty.",
      "relationships": [
        {
          "target": "stdlib.posixpath.fspath",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.posixpath.splitext",
      "name": "splitext",
      "module": "posixpath",
      "type": "function",
      "signature": "(p)",
      "description": "Split the extension from a pathname.\n\nExtension is everything from the last dot to the end, ignoring\nleading dots.  Returns \"(root, ext)\"; ext may be empty.",
      "relationships": [
        {
          "target": "stdlib.posixpath.fspath",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.posixpath._splitext",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pprint.PrettyPrinter",
      "name": "PrettyPrinter",
      "module": "pprint",
      "type": "class",
      "signature": "(indent=1, width=80, depth=None, stream=None, *, compact=False, sort_dicts=True)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.pprint.isreadable",
      "name": "isreadable",
      "module": "pprint",
      "type": "function",
      "signature": "(object)",
      "description": "Determine if saferepr(object) is readable by eval().",
      "relationships": [
        {
          "target": "stdlib.pprint._safe_repr",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pprint.isrecursive",
      "name": "isrecursive",
      "module": "pprint",
      "type": "function",
      "signature": "(object)",
      "description": "Determine if object requires a recursive representation.",
      "relationships": [
        {
          "target": "stdlib.pprint._safe_repr",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pprint.pformat",
      "name": "pformat",
      "module": "pprint",
      "type": "function",
      "signature": "(object, indent=1, width=80, depth=None, *, compact=False, sort_dicts=True)",
      "description": "Format a Python object into a pretty-printed representation.",
      "relationships": [
        {
          "target": "stdlib.pprint.pformat",
          "type": "calls"
        },
        {
          "target": "stdlib.pprint.PrettyPrinter",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pprint.pp",
      "name": "pp",
      "module": "pprint",
      "type": "function",
      "signature": "(object, *args, sort_dicts=False, **kwargs)",
      "description": "Pretty-print a Python object",
      "relationships": [
        {
          "target": "stdlib.pprint.pprint",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pprint.pprint",
      "name": "pprint",
      "module": "pprint",
      "type": "function",
      "signature": "(object, stream=None, indent=1, width=80, depth=None, *, compact=False, sort_dicts=True)",
      "description": "Pretty-print a Python object to a stream [default is sys.stdout].",
      "relationships": [
        {
          "target": "stdlib.pprint.PrettyPrinter",
          "type": "calls"
        },
        {
          "target": "stdlib.pprint.pprint",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pprint.saferepr",
      "name": "saferepr",
      "module": "pprint",
      "type": "function",
      "signature": "(object)",
      "description": "Version of repr() which can handle recursive data structures.",
      "relationships": [
        {
          "target": "stdlib.pprint._safe_repr",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.profile.Profile",
      "name": "Profile",
      "module": "profile",
      "type": "class",
      "signature": "(timer=None, bias=None)",
      "description": "Profiler class.\n\nself.cur is always a tuple.  Each such tuple corresponds to a stack\nframe that is currently active (self.cur[-2]).  The following are the\ndefinitions of its members.  We use this external \"parallel stack\" to\navoid contaminating the program that we are profiling. (old profiler\nused to write into the frames local dictionary!!) Derived classes\ncan change the definition of some entries, as long as they leave\n[-2:] intact (frame and previous tuple).  In case an internal error is\ndetected, the -3 element is used as the function name.\n\n[ 0] = Time that needs to be charged to the parent frame's function.\n       It is used so that a function call will not have to access the\n       timing data for the parent frame.\n[ 1] = Total time spent in this frame's function, excluding time in\n       subfunctions (this latter is tallied in cur[2]).\n[ 2] = Total time spent in subfunctions, excluding time executing the\n       frame's function (this latter is tallied in cur[1]).\n[-3] = Name of the function that corresponds to this frame.\n[-2] = Actual frame that we correspond to (used to sync exception handling).\n[-1] = Our parent 6-tuple (corresponds to frame.f_back).\n\nTiming data for each function is stored as a 5-tuple in the dictionary\nself.timings[].  The index is always the name stored in self.cur[-3].\nThe following are the definitions of the members:\n\n[0] = The number of times this function was called, not counting direct\n      or indirect recursion,\n[1] = Number of times this function appears on the stack, minus one\n[2] = Total time spent internal to this function\n[3] = Cumulative time that this function was present on the stack.  In\n      non-recursive functions, this is the total execution time from start\n      to finish of each invocation of a function, including time spent in\n      all subfunctions.\n[4] = A dictionary indicating for each function name, the number of times\n      it was called by us.",
      "relationships": []
    },
    {
      "id": "stdlib.profile.main",
      "name": "main",
      "module": "profile",
      "type": "function",
      "signature": "()",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.profile.OptionParser",
          "type": "calls"
        },
        {
          "target": "stdlib.profile.add_option",
          "type": "calls"
        },
        {
          "target": "stdlib.profile.add_option",
          "type": "calls"
        },
        {
          "target": "stdlib.profile.add_option",
          "type": "calls"
        },
        {
          "target": "stdlib.profile.parse_args",
          "type": "calls"
        },
        {
          "target": "stdlib.profile.print_usage",
          "type": "calls"
        },
        {
          "target": "stdlib.profile.exit",
          "type": "calls"
        },
        {
          "target": "stdlib.profile.abspath",
          "type": "calls"
        },
        {
          "target": "stdlib.profile.len",
          "type": "calls"
        },
        {
          "target": "stdlib.profile.print_usage",
          "type": "calls"
        },
        {
          "target": "stdlib.profile.insert",
          "type": "calls"
        },
        {
          "target": "stdlib.profile.runctx",
          "type": "calls"
        },
        {
          "target": "stdlib.profile.dirname",
          "type": "calls"
        },
        {
          "target": "stdlib.profile.open",
          "type": "calls"
        },
        {
          "target": "stdlib.profile.compile",
          "type": "calls"
        },
        {
          "target": "stdlib.profile.exit",
          "type": "calls"
        },
        {
          "target": "stdlib.profile.read",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.profile.run",
      "name": "run",
      "module": "profile",
      "type": "function",
      "signature": "(statement, filename=None, sort=-1)",
      "description": "Run statement under profiler optionally saving results in filename\n\nThis function takes a single argument that can be passed to the\n\"exec\" statement, and an optional file name.  In all cases this\nroutine attempts to \"exec\" its first argument and gather profiling\nstatistics from the execution. If no file name is present, then this\nfunction automatically prints a simple profiling report, sorted by the\nstandard name string (file/line/function-name) that is presented in\neach line.",
      "relationships": [
        {
          "target": "stdlib.profile.run",
          "type": "calls"
        },
        {
          "target": "stdlib.profile._Utils",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.profile.runctx",
      "name": "runctx",
      "module": "profile",
      "type": "function",
      "signature": "(statement, globals, locals, filename=None, sort=-1)",
      "description": "Run statement under profiler, supplying your own globals and locals,\noptionally saving results in filename.\n\nstatement and filename have the same semantics as profile.run",
      "relationships": [
        {
          "target": "stdlib.profile.runctx",
          "type": "calls"
        },
        {
          "target": "stdlib.profile._Utils",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pstats.Enum",
      "name": "Enum",
      "module": "pstats",
      "type": "class",
      "signature": "(value, names=None, *, module=None, qualname=None, type=None, start=1)",
      "description": "Generic enumeration.\n\nDerive from this class to define new enumerations.",
      "relationships": []
    },
    {
      "id": "stdlib.pstats.FunctionProfile",
      "name": "FunctionProfile",
      "module": "pstats",
      "type": "class",
      "signature": "(ncalls: int, tottime: float, percall_tottime: float, cumtime: float, percall_cumtime: float, file_name: str, line_number: int) -> None",
      "description": "FunctionProfile(ncalls: int, tottime: float, percall_tottime: float, cumtime: float, percall_cumtime: float, file_name: str, line_number: int)",
      "relationships": []
    },
    {
      "id": "stdlib.pstats.SortKey",
      "name": "SortKey",
      "module": "pstats",
      "type": "class",
      "signature": "(value, names=None, *, module=None, qualname=None, type=None, start=1)",
      "description": "An enumeration.",
      "relationships": [
        {
          "target": "str",
          "type": "base_class"
        },
        {
          "target": "Enum",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.pstats.Stats",
      "name": "Stats",
      "module": "pstats",
      "type": "class",
      "signature": "(*args, stream=None)",
      "description": "This class is used for creating reports from data generated by the\nProfile class.  It is a \"friend\" of that class, and imports data either\nby direct access to members of Profile class, or by reading in a dictionary\nthat was emitted (via marshal) from the Profile class.\n\nThe big change from the previous Profiler (in terms of raw functionality)\nis that an \"add()\" method has been provided to combine Stats from\nseveral distinct profile runs.  Both the constructor and the add()\nmethod now take arbitrarily many file names as arguments.\n\nAll the print methods now take an argument that indicates how many lines\nto print.  If the arg is a floating point number between 0 and 1.0, then\nit is taken as a decimal percentage of the available lines to be printed\n(e.g., .1 means print 10% of all available lines).  If it is an integer,\nit is taken to mean the number of lines of data that you wish to have\nprinted.\n\nThe sort_stats() method now processes some additional options (i.e., in\naddition to the old -1, 0, 1, or 2 that are respectively interpreted as\n'stdname', 'calls', 'time', and 'cumulative').  It takes either an\narbitrary number of quoted strings or SortKey enum to select the sort\norder.\n\nFor example sort_stats('time', 'name') or sort_stats(SortKey.TIME,\nSortKey.NAME) sorts on the major key of 'internal function time', and on\nthe minor key of 'the name of the function'.  Look at the two tables in\nsort_stats() and get_sort_arg_defs(self) for more examples.\n\nAll methods return self, so you can string together commands like:\n    Stats('foo', 'goo').strip_dirs().sort_stats('calls').                            print_stats(5).print_callers(5)",
      "relationships": []
    },
    {
      "id": "stdlib.pstats.StatsProfile",
      "name": "StatsProfile",
      "module": "pstats",
      "type": "class",
      "signature": "(total_tt: float, func_profiles: Dict[str, pstats.FunctionProfile]) -> None",
      "description": "Class for keeping track of an item in inventory.",
      "relationships": []
    },
    {
      "id": "stdlib.pstats.TupleComp",
      "name": "TupleComp",
      "module": "pstats",
      "type": "class",
      "signature": "(comp_select_list)",
      "description": "This class provides a generic function for comparing any two tuples.\nEach instance records a list of tuple-indices (from most significant\nto least significant), and sort direction (ascending or decending) for\neach tuple-index.  The compare functions can then be used as the function\nargument to the system sort() function when a list of tuples need to be\nsorted in the instances order.",
      "relationships": []
    },
    {
      "id": "stdlib.pstats.add_callers",
      "name": "add_callers",
      "module": "pstats",
      "type": "function",
      "signature": "(target, source)",
      "description": "Combine two caller lists in a single list.",
      "relationships": [
        {
          "target": "stdlib.pstats.items",
          "type": "calls"
        },
        {
          "target": "stdlib.pstats.items",
          "type": "calls"
        },
        {
          "target": "stdlib.pstats.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.pstats.tuple",
          "type": "calls"
        },
        {
          "target": "stdlib.pstats.zip",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pstats.add_func_stats",
      "name": "add_func_stats",
      "module": "pstats",
      "type": "function",
      "signature": "(target, source)",
      "description": "Add together all the stats for two profile entries.",
      "relationships": [
        {
          "target": "stdlib.pstats.add_callers",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pstats.count_calls",
      "name": "count_calls",
      "module": "pstats",
      "type": "function",
      "signature": "(callers)",
      "description": "Sum the caller statistics to get total number of calls received.",
      "relationships": [
        {
          "target": "stdlib.pstats.values",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pstats.dataclass",
      "name": "dataclass",
      "module": "pstats",
      "type": "function",
      "signature": "(cls=None, /, *, init=True, repr=True, eq=True, order=False, unsafe_hash=False, frozen=False)",
      "description": "Returns the same class as was passed in, with dunder methods\nadded based on the fields defined in the class.\n\nExamines PEP 526 __annotations__ to determine fields.\n\nIf init is true, an __init__() method is added to the class. If\nrepr is true, a __repr__() method is added. If order is true, rich\ncomparison dunder methods are added. If unsafe_hash is true, a\n__hash__() method function is added. If frozen is true, fields may\nnot be assigned to after instance creation.",
      "relationships": [
        {
          "target": "stdlib.pstats.wrap",
          "type": "calls"
        },
        {
          "target": "stdlib.pstats._process_class",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pstats.f8",
      "name": "f8",
      "module": "pstats",
      "type": "function",
      "signature": "(x)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.pstats.func_get_function_name",
      "name": "func_get_function_name",
      "module": "pstats",
      "type": "function",
      "signature": "(func)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.pstats.func_std_string",
      "name": "func_std_string",
      "module": "pstats",
      "type": "function",
      "signature": "(func_name)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.pstats.startswith",
          "type": "calls"
        },
        {
          "target": "stdlib.pstats.endswith",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pstats.func_strip_path",
      "name": "func_strip_path",
      "module": "pstats",
      "type": "function",
      "signature": "(func_name)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.pstats.basename",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pty.fork",
      "name": "fork",
      "module": "pty",
      "type": "function",
      "signature": "()",
      "description": "fork() -> (pid, master_fd)\nFork and make the child a session leader with a controlling terminal.",
      "relationships": [
        {
          "target": "stdlib.pty.openpty",
          "type": "calls"
        },
        {
          "target": "stdlib.pty.fork",
          "type": "calls"
        },
        {
          "target": "stdlib.pty.forkpty",
          "type": "calls"
        },
        {
          "target": "stdlib.pty.setsid",
          "type": "calls"
        },
        {
          "target": "stdlib.pty.close",
          "type": "calls"
        },
        {
          "target": "stdlib.pty.dup2",
          "type": "calls"
        },
        {
          "target": "stdlib.pty.dup2",
          "type": "calls"
        },
        {
          "target": "stdlib.pty.dup2",
          "type": "calls"
        },
        {
          "target": "stdlib.pty.open",
          "type": "calls"
        },
        {
          "target": "stdlib.pty.close",
          "type": "calls"
        },
        {
          "target": "stdlib.pty.close",
          "type": "calls"
        },
        {
          "target": "stdlib.pty.close",
          "type": "calls"
        },
        {
          "target": "stdlib.pty.ttyname",
          "type": "calls"
        },
        {
          "target": "stdlib.pty.setsid",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pty.master_open",
      "name": "master_open",
      "module": "pty",
      "type": "function",
      "signature": "()",
      "description": "master_open() -> (master_fd, slave_name)\nOpen a pty master and return the fd, and the filename of the slave end.\nDeprecated, use openpty() instead.",
      "relationships": [
        {
          "target": "stdlib.pty._open_terminal",
          "type": "calls"
        },
        {
          "target": "stdlib.pty.openpty",
          "type": "calls"
        },
        {
          "target": "stdlib.pty.ttyname",
          "type": "calls"
        },
        {
          "target": "stdlib.pty.close",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pty.openpty",
      "name": "openpty",
      "module": "pty",
      "type": "function",
      "signature": "()",
      "description": "openpty() -> (master_fd, slave_fd)\nOpen a pty master/slave pair, using os.openpty() if possible.",
      "relationships": [
        {
          "target": "stdlib.pty._open_terminal",
          "type": "calls"
        },
        {
          "target": "stdlib.pty.slave_open",
          "type": "calls"
        },
        {
          "target": "stdlib.pty.openpty",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pty.slave_open",
      "name": "slave_open",
      "module": "pty",
      "type": "function",
      "signature": "(tty_name)",
      "description": "slave_open(tty_name) -> slave_fd\nOpen the pty slave and acquire the controlling terminal, returning\nopened filedescriptor.\nDeprecated, use openpty() instead.",
      "relationships": [
        {
          "target": "stdlib.pty.open",
          "type": "calls"
        },
        {
          "target": "stdlib.pty.ioctl",
          "type": "calls"
        },
        {
          "target": "stdlib.pty.ioctl",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pty.spawn",
      "name": "spawn",
      "module": "pty",
      "type": "function",
      "signature": "(argv, master_read=<function _read at 0x1093491f0>, stdin_read=<function _read at 0x1093491f0>)",
      "description": "Create a spawned process.",
      "relationships": [
        {
          "target": "stdlib.pty.audit",
          "type": "calls"
        },
        {
          "target": "stdlib.pty.fork",
          "type": "calls"
        },
        {
          "target": "stdlib.pty.close",
          "type": "calls"
        },
        {
          "target": "stdlib.pty.type",
          "type": "calls"
        },
        {
          "target": "stdlib.pty.type",
          "type": "calls"
        },
        {
          "target": "stdlib.pty.execlp",
          "type": "calls"
        },
        {
          "target": "stdlib.pty.tcgetattr",
          "type": "calls"
        },
        {
          "target": "stdlib.pty.setraw",
          "type": "calls"
        },
        {
          "target": "stdlib.pty._copy",
          "type": "calls"
        },
        {
          "target": "stdlib.pty.waitpid",
          "type": "calls"
        },
        {
          "target": "stdlib.pty.tcsetattr",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.py_compile.PyCompileError",
      "name": "PyCompileError",
      "module": "py_compile",
      "type": "class",
      "signature": "(exc_type, exc_value, file, msg='')",
      "description": "Exception raised when an error occurs while attempting to\ncompile the file.\n\nTo raise this exception, use\n\n    raise PyCompileError(exc_type,exc_value,file[,msg])\n\nwhere\n\n    exc_type:   exception type to be used in error message\n                type name can be accesses as class variable\n                'exc_type_name'\n\n    exc_value:  exception value to be used in error message\n                can be accesses as class variable 'exc_value'\n\n    file:       name of file being compiled to be used in error message\n                can be accesses as class variable 'file'\n\n    msg:        string message to be written as error message\n                If no value is given, a default exception message will be\n                given, consistent with 'standard' py_compile output.\n                message (or default) can be accesses as class variable\n                'msg'",
      "relationships": [
        {
          "target": "Exception",
          "type": "base_class"
        },
        {
          "target": "BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.py_compile.PycInvalidationMode",
      "name": "PycInvalidationMode",
      "module": "py_compile",
      "type": "class",
      "signature": "(value, names=None, *, module=None, qualname=None, type=None, start=1)",
      "description": "An enumeration.",
      "relationships": [
        {
          "target": "Enum",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.py_compile.compile",
      "name": "compile",
      "module": "py_compile",
      "type": "function",
      "signature": "(file, cfile=None, dfile=None, doraise=False, optimize=-1, invalidation_mode=None, quiet=0)",
      "description": "Byte-compile one Python source file to Python bytecode.\n\n:param file: The source file name.\n:param cfile: The target byte compiled file name.  When not given, this\n    defaults to the PEP 3147/PEP 488 location.\n:param dfile: Purported file name, i.e. the file name that shows up in\n    error messages.  Defaults to the source file name.\n:param doraise: Flag indicating whether or not an exception should be\n    raised when a compile error is found.  If an exception occurs and this\n    flag is set to False, a string indicating the nature of the exception\n    will be printed, and the function will return to the caller. If an\n    exception occurs and this flag is set to True, a PyCompileError\n    exception will be raised.\n:param optimize: The optimization level for the compiler.  Valid values\n    are -1, 0, 1 and 2.  A value of -1 means to use the optimization\n    level of the current interpreter, as given by -O command line options.\n:param invalidation_mode:\n:param quiet: Return full output with False or 0, errors only with 1,\n    and no output with 2.\n\n:return: Path to the resulting byte compiled file.\n\nNote that it isn't necessary to byte-compile Python modules for\nexecution efficiency -- Python itself byte-compiles a module when\nit is loaded, and if it can, writes out the bytecode to the\ncorresponding .pyc file.\n\nHowever, if a Python installation is shared between users, it is a\ngood idea to byte-compile all modules upon installation, since\nother users may not be able to write in the source directories,\nand thus they won't be able to write the .pyc file, and then\nthey would be byte-compiling every module each time it is loaded.\nThis can slow down program start-up considerably.\n\nSee compileall.py for a script/module that uses this module to\nbyte-compile all installed files (or all files in selected\ndirectories).\n\nDo note that FileExistsError is raised if cfile ends up pointing at a\nnon-regular file or symlink. Because the compilation uses a file renaming,\nthe resulting file would be regular and thus not the same type of file as\nit was previously.",
      "relationships": [
        {
          "target": "stdlib.py_compile.islink",
          "type": "calls"
        },
        {
          "target": "stdlib.py_compile.SourceFileLoader",
          "type": "calls"
        },
        {
          "target": "stdlib.py_compile.get_data",
          "type": "calls"
        },
        {
          "target": "stdlib.py_compile._calc_mode",
          "type": "calls"
        },
        {
          "target": "stdlib.py_compile._write_atomic",
          "type": "calls"
        },
        {
          "target": "stdlib.py_compile._get_default_invalidation_mode",
          "type": "calls"
        },
        {
          "target": "stdlib.py_compile.FileExistsError",
          "type": "calls"
        },
        {
          "target": "stdlib.py_compile.source_to_code",
          "type": "calls"
        },
        {
          "target": "stdlib.py_compile.dirname",
          "type": "calls"
        },
        {
          "target": "stdlib.py_compile.path_stats",
          "type": "calls"
        },
        {
          "target": "stdlib.py_compile._code_to_timestamp_pyc",
          "type": "calls"
        },
        {
          "target": "stdlib.py_compile.source_hash",
          "type": "calls"
        },
        {
          "target": "stdlib.py_compile._code_to_hash_pyc",
          "type": "calls"
        },
        {
          "target": "stdlib.py_compile.cache_from_source",
          "type": "calls"
        },
        {
          "target": "stdlib.py_compile.cache_from_source",
          "type": "calls"
        },
        {
          "target": "stdlib.py_compile.format",
          "type": "calls"
        },
        {
          "target": "stdlib.py_compile.exists",
          "type": "calls"
        },
        {
          "target": "stdlib.py_compile.FileExistsError",
          "type": "calls"
        },
        {
          "target": "stdlib.py_compile.PyCompileError",
          "type": "calls"
        },
        {
          "target": "stdlib.py_compile.makedirs",
          "type": "calls"
        },
        {
          "target": "stdlib.py_compile.isfile",
          "type": "calls"
        },
        {
          "target": "stdlib.py_compile.format",
          "type": "calls"
        },
        {
          "target": "stdlib.py_compile.write",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.py_compile.main",
      "name": "main",
      "module": "py_compile",
      "type": "function",
      "signature": "(args=None)",
      "description": "Compile several source files.\n\nThe files named in 'args' (or on the command line, if 'args' is\nnot specified) are compiled and the resulting bytecode is cached\nin the normal manner.  This function does not search a directory\nstructure to locate source files; it only compiles files named\nexplicitly.  If '-' is the only parameter in args, the list of\nfiles is taken from standard input.",
      "relationships": [
        {
          "target": "stdlib.py_compile.readline",
          "type": "calls"
        },
        {
          "target": "stdlib.py_compile.rstrip",
          "type": "calls"
        },
        {
          "target": "stdlib.py_compile.compile",
          "type": "calls"
        },
        {
          "target": "stdlib.py_compile.compile",
          "type": "calls"
        },
        {
          "target": "stdlib.py_compile.write",
          "type": "calls"
        },
        {
          "target": "stdlib.py_compile.write",
          "type": "calls"
        },
        {
          "target": "stdlib.py_compile.write",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pyclbr.Class",
      "name": "Class",
      "module": "pyclbr",
      "type": "class",
      "signature": "(module, name, super, file, lineno, parent=None)",
      "description": "Information about a Python class.",
      "relationships": [
        {
          "target": "_Object",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.pyclbr.Function",
      "name": "Function",
      "module": "pyclbr",
      "type": "class",
      "signature": "(module, name, file, lineno, parent=None)",
      "description": "Information about a Python function, including methods.",
      "relationships": [
        {
          "target": "_Object",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.pyclbr.readmodule",
      "name": "readmodule",
      "module": "pyclbr",
      "type": "function",
      "signature": "(module, path=None)",
      "description": "Return Class objects for the top-level classes in module.\n\nThis is the original interface, before Functions were added.",
      "relationships": [
        {
          "target": "stdlib.pyclbr.items",
          "type": "calls"
        },
        {
          "target": "stdlib.pyclbr.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.pyclbr._readmodule",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pyclbr.readmodule_ex",
      "name": "readmodule_ex",
      "module": "pyclbr",
      "type": "function",
      "signature": "(module, path=None)",
      "description": "Return a dictionary with all functions and classes in module.\n\nSearch for module in PATH + sys.path.\nIf possible, include imported superclasses.\nDo this by reading source, without importing (and executing) it.",
      "relationships": [
        {
          "target": "stdlib.pyclbr._readmodule",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pydoc.Doc",
      "name": "Doc",
      "module": "pydoc",
      "type": "class",
      "signature": "()",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.pydoc.ErrorDuringImport",
      "name": "ErrorDuringImport",
      "module": "pydoc",
      "type": "class",
      "signature": "(filename, exc_info)",
      "description": "Errors that occurred while trying to import something to document it.",
      "relationships": [
        {
          "target": "Exception",
          "type": "base_class"
        },
        {
          "target": "BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.pydoc.HTMLDoc",
      "name": "HTMLDoc",
      "module": "pydoc",
      "type": "class",
      "signature": "()",
      "description": "Formatter class for HTML documentation.",
      "relationships": [
        {
          "target": "Doc",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.pydoc.HTMLRepr",
      "name": "HTMLRepr",
      "module": "pydoc",
      "type": "class",
      "signature": "()",
      "description": "Class for safely making an HTML representation of a Python object.",
      "relationships": [
        {
          "target": "Repr",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.pydoc.Helper",
      "name": "Helper",
      "module": "pydoc",
      "type": "class",
      "signature": "(input=None, output=None)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.pydoc.ModuleScanner",
      "name": "ModuleScanner",
      "module": "pydoc",
      "type": "class",
      "signature": "()",
      "description": "An interruptible scanner that searches module synopses.",
      "relationships": []
    },
    {
      "id": "stdlib.pydoc.Repr",
      "name": "Repr",
      "module": "pydoc",
      "type": "class",
      "signature": "()",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.pydoc.TextDoc",
      "name": "TextDoc",
      "module": "pydoc",
      "type": "class",
      "signature": "()",
      "description": "Formatter class for text documentation.",
      "relationships": [
        {
          "target": "Doc",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.pydoc.TextRepr",
      "name": "TextRepr",
      "module": "pydoc",
      "type": "class",
      "signature": "()",
      "description": "Class for safely making a text representation of a Python object.",
      "relationships": [
        {
          "target": "Repr",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.pydoc.allmethods",
      "name": "allmethods",
      "module": "pydoc",
      "type": "function",
      "signature": "(cl)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.pydoc.getmembers",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.keys",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.update",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.getattr",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.allmethods",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pydoc.apropos",
      "name": "apropos",
      "module": "pydoc",
      "type": "function",
      "signature": "(key)",
      "description": "Print all the one-line module summaries that contain a substring.",
      "relationships": [
        {
          "target": "stdlib.pydoc.print",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.catch_warnings",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.filterwarnings",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.run",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.ModuleScanner",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pydoc.browse",
      "name": "browse",
      "module": "pydoc",
      "type": "function",
      "signature": "(port=0, *, open_browser=True, hostname='localhost')",
      "description": "Start the enhanced pydoc Web server and open a Web browser.\n\nUse port '0' to start the server on an arbitrary port.\nSet open_browser to False to suppress opening a browser.",
      "relationships": [
        {
          "target": "stdlib.pydoc._start_server",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.print",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.open",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.print",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.print",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.input",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.lower",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.print",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.stop",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.print",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.open",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.print",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pydoc.classify_class_attrs",
      "name": "classify_class_attrs",
      "module": "pydoc",
      "type": "function",
      "signature": "(object)",
      "description": "Wrap inspect.classify_class_attrs, with fixup for data descriptors.",
      "relationships": [
        {
          "target": "stdlib.pydoc.classify_class_attrs",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.isdatadescriptor",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.append",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.isinstance",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pydoc.classname",
      "name": "classname",
      "module": "pydoc",
      "type": "function",
      "signature": "(object, modname)",
      "description": "Get a class name and qualify it with a module name if necessary.",
      "relationships": []
    },
    {
      "id": "stdlib.pydoc.cli",
      "name": "cli",
      "module": "pydoc",
      "type": "function",
      "signature": "()",
      "description": "Command-line interface (looks at sys.argv to decide what to do).",
      "relationships": [
        {
          "target": "stdlib.pydoc._adjust_cli_sys_path",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.getopt",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.browse",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.print",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.apropos",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.ispath",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.print",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.splitext",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.format",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.exists",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.ispath",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.isfile",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.importfile",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.help",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.print",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.basename",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.ispath",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.isdir",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.writedocs",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.writedoc",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pydoc.cram",
      "name": "cram",
      "module": "pydoc",
      "type": "function",
      "signature": "(text, maxlen)",
      "description": "Omit part of a string if needed to make it fit in a maximum length.",
      "relationships": [
        {
          "target": "stdlib.pydoc.len",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.max",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.max",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.len",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pydoc.describe",
      "name": "describe",
      "module": "pydoc",
      "type": "function",
      "signature": "(thing)",
      "description": "Produce a short description of the given thing.",
      "relationships": [
        {
          "target": "stdlib.pydoc.ismodule",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.isbuiltin",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.isgetsetdescriptor",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.ismemberdescriptor",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.isclass",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.isfunction",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.ismethod",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.hasattr",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.type",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pydoc.doc",
      "name": "doc",
      "module": "pydoc",
      "type": "function",
      "signature": "(thing, title='Python Library Documentation: %s', forceload=0, output=None)",
      "description": "Display text documentation, given an object or a path to an object.",
      "relationships": [
        {
          "target": "stdlib.pydoc.pager",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.write",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.print",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.render_doc",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.render_doc",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pydoc.format_exception_only",
      "name": "format_exception_only",
      "module": "pydoc",
      "type": "function",
      "signature": "(etype, value)",
      "description": "Format the exception part of a traceback.\n\nThe arguments are the exception type and value such as given by\nsys.last_type and sys.last_value. The return value is a list of\nstrings, each ending in a newline.\n\nNormally, the list contains a single string; however, for\nSyntaxError exceptions, it contains several lines that (when\nprinted) display detailed information about where the syntax\nerror occurred.\n\nThe message indicating which exception occurred is always the last\nstring in the list.",
      "relationships": [
        {
          "target": "stdlib.pydoc.list",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.format_exception_only",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.TracebackException",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pydoc.getdoc",
      "name": "getdoc",
      "module": "pydoc",
      "type": "function",
      "signature": "(object)",
      "description": "Get the doc string or comments for an object.",
      "relationships": [
        {
          "target": "stdlib.pydoc._getdoc",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.getcomments",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.sub",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.rstrip",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pydoc.getpager",
      "name": "getpager",
      "module": "pydoc",
      "type": "function",
      "signature": "()",
      "description": "Decide what method to use for paging through text.",
      "relationships": [
        {
          "target": "stdlib.pydoc.mkstemp",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.close",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.hasattr",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.hasattr",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.get",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.get",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.get",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.hasattr",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.unlink",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.isatty",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.isatty",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.tempfilepager",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.system",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.pipepager",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.hasattr",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.tempfilepager",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.get",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.plain",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.system",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.pipepager",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.plain",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.pipepager",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.pipepager",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.plain",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pydoc.importfile",
      "name": "importfile",
      "module": "pydoc",
      "type": "function",
      "signature": "(path)",
      "description": "Import a Python source file or compiled file given its path.",
      "relationships": [
        {
          "target": "stdlib.pydoc.basename",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.splitext",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.spec_from_file_location",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.open",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.SourcelessFileLoader",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.SourceFileLoader",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc._load",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.read",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.ErrorDuringImport",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.len",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.exc_info",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pydoc.isdata",
      "name": "isdata",
      "module": "pydoc",
      "type": "function",
      "signature": "(object)",
      "description": "Check if an object is of a type that probably means it's data.",
      "relationships": [
        {
          "target": "stdlib.pydoc.ismodule",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.isclass",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.isroutine",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.isframe",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.istraceback",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.iscode",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pydoc.ispackage",
      "name": "ispackage",
      "module": "pydoc",
      "type": "function",
      "signature": "(path)",
      "description": "Guess whether a path refers to a package directory.",
      "relationships": [
        {
          "target": "stdlib.pydoc.isdir",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.isfile",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.join",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pydoc.ispath",
      "name": "ispath",
      "module": "pydoc",
      "type": "function",
      "signature": "(x)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.pydoc.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.find",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pydoc.locate",
      "name": "locate",
      "module": "pydoc",
      "type": "function",
      "signature": "(path, forceload=0)",
      "description": "Locate an object by name or dotted path, importing as necessary.",
      "relationships": [
        {
          "target": "stdlib.pydoc.len",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.safeimport",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.split",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.join",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.getattr",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pydoc.pager",
      "name": "pager",
      "module": "pydoc",
      "type": "function",
      "signature": "(text)",
      "description": "The first time this is called, determine what kind of pager to use.",
      "relationships": [
        {
          "target": "stdlib.pydoc.getpager",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.pager",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pydoc.pathdirs",
      "name": "pathdirs",
      "module": "pydoc",
      "type": "function",
      "signature": "()",
      "description": "Convert sys.path into a list of absolute, existing, unique paths.",
      "relationships": [
        {
          "target": "stdlib.pydoc.abspath",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.normcase",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.isdir",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.append",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.append",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pydoc.pipepager",
      "name": "pipepager",
      "module": "pydoc",
      "type": "function",
      "signature": "(text, cmd)",
      "description": "Page through text by feeding it to another program.",
      "relationships": [
        {
          "target": "stdlib.pydoc.Popen",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.TextIOWrapper",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.wait",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.write",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pydoc.plain",
      "name": "plain",
      "module": "pydoc",
      "type": "function",
      "signature": "(text)",
      "description": "Remove boldface formatting from text.",
      "relationships": [
        {
          "target": "stdlib.pydoc.sub",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pydoc.plainpager",
      "name": "plainpager",
      "module": "pydoc",
      "type": "function",
      "signature": "(text)",
      "description": "Simply print unformatted text.  This is the ultimate fallback.",
      "relationships": [
        {
          "target": "stdlib.pydoc.write",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.plain",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc._escape_stdout",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pydoc.render_doc",
      "name": "render_doc",
      "module": "pydoc",
      "type": "function",
      "signature": "(thing, title='Python Library Documentation: %s', forceload=0, renderer=None)",
      "description": "Render text documentation, given an object or a path to an object.",
      "relationships": [
        {
          "target": "stdlib.pydoc.resolve",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.describe",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.getmodule",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.hasattr",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.document",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.ismodule",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.isclass",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.isroutine",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.isdatadescriptor",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc._getdoc",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.type",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.rfind",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pydoc.replace",
      "name": "replace",
      "module": "pydoc",
      "type": "function",
      "signature": "(text, *pairs)",
      "description": "Do a series of global replacements on a string.",
      "relationships": [
        {
          "target": "stdlib.pydoc.join",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.split",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pydoc.resolve",
      "name": "resolve",
      "module": "pydoc",
      "type": "function",
      "signature": "(thing, forceload=0)",
      "description": "Given an object or a path to an object, get the object and its name.",
      "relationships": [
        {
          "target": "stdlib.pydoc.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.locate",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.getattr",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.ImportError",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.isinstance",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pydoc.safeimport",
      "name": "safeimport",
      "module": "pydoc",
      "type": "function",
      "signature": "(path, forceload=0, cache={})",
      "description": "Import a module; handle errors; return None if the module isn't found.\n\nIf the module *is* found but an exception occurs, it's wrapped in an\nErrorDuringImport exception and reraised.  Unlike __import__, if a\npackage path is specified, the module at the end of the path is returned,\nnot the package at the beginning.  If the optional 'forceload' argument\nis 1, we reload the module from disk (unless it's a dynamic extension).",
      "relationships": [
        {
          "target": "stdlib.pydoc.__import__",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.split",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.exc_info",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.getattr",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.ErrorDuringImport",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.ErrorDuringImport",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.startswith",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.issubclass",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.ErrorDuringImport",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.exc_info",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pydoc.sort_attributes",
      "name": "sort_attributes",
      "module": "pydoc",
      "type": "function",
      "signature": "(attrs, object)",
      "description": "Sort the attrs list in-place by _fields and then alphabetically by name",
      "relationships": [
        {
          "target": "stdlib.pydoc.getattr",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.sort",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.get",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.len",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.enumerate",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pydoc.source_synopsis",
      "name": "source_synopsis",
      "module": "pydoc",
      "type": "function",
      "signature": "(file)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.pydoc.readline",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.strip",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.readline",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.strip",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.strip",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.strip",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.readline",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.split",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pydoc.splitdoc",
      "name": "splitdoc",
      "module": "pydoc",
      "type": "function",
      "signature": "(doc)",
      "description": "Split a doc string into a synopsis line (if any) and the rest.",
      "relationships": [
        {
          "target": "stdlib.pydoc.split",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.len",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.join",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.strip",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.len",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.rstrip",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.join",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pydoc.stripid",
      "name": "stripid",
      "module": "pydoc",
      "type": "function",
      "signature": "(text)",
      "description": "Remove the hexadecimal id from a Python object representation.",
      "relationships": [
        {
          "target": "stdlib.pydoc.sub",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pydoc.synopsis",
      "name": "synopsis",
      "module": "pydoc",
      "type": "function",
      "signature": "(filename, cache={})",
      "description": "Get the one-line summary out of a module file.",
      "relationships": [
        {
          "target": "stdlib.pydoc.get",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.stat",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.endswith",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.tuple",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.endswith",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.loader_cls",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.spec_from_file_location",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.tuple",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.open",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.source_synopsis",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc._load",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.splitlines",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pydoc.tempfilepager",
      "name": "tempfilepager",
      "module": "pydoc",
      "type": "function",
      "signature": "(text, cmd)",
      "description": "Page through text by invoking a program on a temporary file.",
      "relationships": [
        {
          "target": "stdlib.pydoc.mktemp",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.open",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.write",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.system",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.unlink",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pydoc.ttypager",
      "name": "ttypager",
      "module": "pydoc",
      "type": "function",
      "signature": "(text)",
      "description": "Page through text on a text terminal.",
      "relationships": [
        {
          "target": "stdlib.pydoc.split",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.fileno",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.tcgetattr",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.setcbreak",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.write",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.plain",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.read",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.int",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.write",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.flush",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.getchar",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.write",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.tcsetattr",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc._escape_stdout",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.get",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.join",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.write",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.write",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.readline",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.join",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pydoc.visiblename",
      "name": "visiblename",
      "module": "pydoc",
      "type": "function",
      "signature": "(name, all=None, obj=None)",
      "description": "Decide whether to show documentation on a variable.",
      "relationships": [
        {
          "target": "stdlib.pydoc.startswith",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.endswith",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.startswith",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.hasattr",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.startswith",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pydoc.writedoc",
      "name": "writedoc",
      "module": "pydoc",
      "type": "function",
      "signature": "(thing, forceload=0)",
      "description": "Write HTML documentation to a file in the current directory.",
      "relationships": [
        {
          "target": "stdlib.pydoc.resolve",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.page",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.print",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.describe",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.document",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.open",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.write",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.print",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.pydoc.writedocs",
      "name": "writedocs",
      "module": "pydoc",
      "type": "function",
      "signature": "(dir, pkgpath='', done=None)",
      "description": "Write out HTML documentation for all modules in a directory tree.",
      "relationships": [
        {
          "target": "stdlib.pydoc.walk_packages",
          "type": "calls"
        },
        {
          "target": "stdlib.pydoc.writedoc",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.queue.LifoQueue",
      "name": "LifoQueue",
      "module": "queue",
      "type": "class",
      "signature": "(maxsize=0)",
      "description": "Variant of Queue that retrieves most recently added entries first.",
      "relationships": [
        {
          "target": "Queue",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.queue.PriorityQueue",
      "name": "PriorityQueue",
      "module": "queue",
      "type": "class",
      "signature": "(maxsize=0)",
      "description": "Variant of Queue that retrieves open entries in priority order (lowest first).\n\nEntries are typically tuples of the form:  (priority number, data).",
      "relationships": [
        {
          "target": "Queue",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.queue.Queue",
      "name": "Queue",
      "module": "queue",
      "type": "class",
      "signature": "(maxsize=0)",
      "description": "Create a queue object with a given maximum size.\n\nIf maxsize is <= 0, the queue size is infinite.",
      "relationships": []
    },
    {
      "id": "stdlib.queue.SimpleQueue",
      "name": "SimpleQueue",
      "module": "queue",
      "type": "class",
      "signature": "()",
      "description": "Simple, unbounded, reentrant FIFO queue.",
      "relationships": []
    },
    {
      "id": "stdlib.quopri.decode",
      "name": "decode",
      "module": "quopri",
      "type": "function",
      "signature": "(input, output, header=False)",
      "description": "Read 'input', apply quoted-printable decoding, and write to 'output'.\n'input' and 'output' are binary file objects.\nIf 'header' is true, decode underscore as space (per RFC 1522).",
      "relationships": [
        {
          "target": "stdlib.quopri.read",
          "type": "calls"
        },
        {
          "target": "stdlib.quopri.a2b_qp",
          "type": "calls"
        },
        {
          "target": "stdlib.quopri.write",
          "type": "calls"
        },
        {
          "target": "stdlib.quopri.readline",
          "type": "calls"
        },
        {
          "target": "stdlib.quopri.write",
          "type": "calls"
        },
        {
          "target": "stdlib.quopri.len",
          "type": "calls"
        },
        {
          "target": "stdlib.quopri.write",
          "type": "calls"
        },
        {
          "target": "stdlib.quopri.ishex",
          "type": "calls"
        },
        {
          "target": "stdlib.quopri.ishex",
          "type": "calls"
        },
        {
          "target": "stdlib.quopri.bytes",
          "type": "calls"
        },
        {
          "target": "stdlib.quopri.unhex",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.quopri.decodestring",
      "name": "decodestring",
      "module": "quopri",
      "type": "function",
      "signature": "(s, header=False)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.quopri.BytesIO",
          "type": "calls"
        },
        {
          "target": "stdlib.quopri.BytesIO",
          "type": "calls"
        },
        {
          "target": "stdlib.quopri.decode",
          "type": "calls"
        },
        {
          "target": "stdlib.quopri.getvalue",
          "type": "calls"
        },
        {
          "target": "stdlib.quopri.a2b_qp",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.quopri.encode",
      "name": "encode",
      "module": "quopri",
      "type": "function",
      "signature": "(input, output, quotetabs, header=False)",
      "description": "Read 'input', apply quoted-printable encoding, and write to 'output'.\n\n'input' and 'output' are binary file objects. The 'quotetabs' flag\nindicates whether embedded tabs and spaces should be quoted. Note that\nline-ending tabs and spaces are always encoded, as per RFC 1521.\nThe 'header' flag indicates whether we are encoding spaces as _ as per RFC\n1522.",
      "relationships": [
        {
          "target": "stdlib.quopri.read",
          "type": "calls"
        },
        {
          "target": "stdlib.quopri.b2a_qp",
          "type": "calls"
        },
        {
          "target": "stdlib.quopri.write",
          "type": "calls"
        },
        {
          "target": "stdlib.quopri.readline",
          "type": "calls"
        },
        {
          "target": "stdlib.quopri.join",
          "type": "calls"
        },
        {
          "target": "stdlib.quopri.write",
          "type": "calls"
        },
        {
          "target": "stdlib.quopri.write",
          "type": "calls"
        },
        {
          "target": "stdlib.quopri.bytes",
          "type": "calls"
        },
        {
          "target": "stdlib.quopri.needsquoting",
          "type": "calls"
        },
        {
          "target": "stdlib.quopri.write",
          "type": "calls"
        },
        {
          "target": "stdlib.quopri.len",
          "type": "calls"
        },
        {
          "target": "stdlib.quopri.write",
          "type": "calls"
        },
        {
          "target": "stdlib.quopri.write",
          "type": "calls"
        },
        {
          "target": "stdlib.quopri.write",
          "type": "calls"
        },
        {
          "target": "stdlib.quopri.quote",
          "type": "calls"
        },
        {
          "target": "stdlib.quopri.append",
          "type": "calls"
        },
        {
          "target": "stdlib.quopri.append",
          "type": "calls"
        },
        {
          "target": "stdlib.quopri.quote",
          "type": "calls"
        },
        {
          "target": "stdlib.quopri.quote",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.quopri.encodestring",
      "name": "encodestring",
      "module": "quopri",
      "type": "function",
      "signature": "(s, quotetabs=False, header=False)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.quopri.BytesIO",
          "type": "calls"
        },
        {
          "target": "stdlib.quopri.BytesIO",
          "type": "calls"
        },
        {
          "target": "stdlib.quopri.encode",
          "type": "calls"
        },
        {
          "target": "stdlib.quopri.getvalue",
          "type": "calls"
        },
        {
          "target": "stdlib.quopri.b2a_qp",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.quopri.ishex",
      "name": "ishex",
      "module": "quopri",
      "type": "function",
      "signature": "(c)",
      "description": "Return true if the byte ordinal 'c' is a hexadecimal digit in ASCII.",
      "relationships": [
        {
          "target": "stdlib.quopri.isinstance",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.quopri.main",
      "name": "main",
      "module": "quopri",
      "type": "function",
      "signature": "()",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.quopri.getopt",
          "type": "calls"
        },
        {
          "target": "stdlib.quopri.print",
          "type": "calls"
        },
        {
          "target": "stdlib.quopri.exit",
          "type": "calls"
        },
        {
          "target": "stdlib.quopri.exit",
          "type": "calls"
        },
        {
          "target": "stdlib.quopri.print",
          "type": "calls"
        },
        {
          "target": "stdlib.quopri.print",
          "type": "calls"
        },
        {
          "target": "stdlib.quopri.print",
          "type": "calls"
        },
        {
          "target": "stdlib.quopri.print",
          "type": "calls"
        },
        {
          "target": "stdlib.quopri.exit",
          "type": "calls"
        },
        {
          "target": "stdlib.quopri.open",
          "type": "calls"
        },
        {
          "target": "stdlib.quopri.decode",
          "type": "calls"
        },
        {
          "target": "stdlib.quopri.encode",
          "type": "calls"
        },
        {
          "target": "stdlib.quopri.close",
          "type": "calls"
        },
        {
          "target": "stdlib.quopri.write",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.quopri.needsquoting",
      "name": "needsquoting",
      "module": "quopri",
      "type": "function",
      "signature": "(c, quotetabs, header)",
      "description": "Decide whether a particular byte ordinal needs to be quoted.\n\nThe 'quotetabs' flag indicates whether embedded tabs and spaces should be\nquoted.  Note that line-ending tabs and spaces are always encoded, as per\nRFC 1521.",
      "relationships": [
        {
          "target": "stdlib.quopri.isinstance",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.quopri.quote",
      "name": "quote",
      "module": "quopri",
      "type": "function",
      "signature": "(c)",
      "description": "Quote a single character.",
      "relationships": [
        {
          "target": "stdlib.quopri.ord",
          "type": "calls"
        },
        {
          "target": "stdlib.quopri.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.quopri.bytes",
          "type": "calls"
        },
        {
          "target": "stdlib.quopri.len",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.quopri.unhex",
      "name": "unhex",
      "module": "quopri",
      "type": "function",
      "signature": "(s)",
      "description": "Get the integer value of a hexadecimal number.",
      "relationships": [
        {
          "target": "stdlib.quopri.bytes",
          "type": "calls"
        },
        {
          "target": "stdlib.quopri.ord",
          "type": "calls"
        },
        {
          "target": "stdlib.quopri.ord",
          "type": "calls"
        },
        {
          "target": "stdlib.quopri.ord",
          "type": "calls"
        },
        {
          "target": "stdlib.quopri.ord",
          "type": "calls"
        },
        {
          "target": "stdlib.quopri.repr",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.random.Random",
      "name": "Random",
      "module": "random",
      "type": "class",
      "signature": "(x=None)",
      "description": "Random number generator base class used by bound module functions.\n\nUsed to instantiate instances of Random to get generators that don't\nshare state.\n\nClass Random can also be subclassed if you want to use a different basic\ngenerator of your own devising: in that case, override the following\nmethods:  random(), seed(), getstate(), and setstate().\nOptionally, implement a getrandbits() method so that randrange()\ncan cover arbitrarily large ranges.",
      "relationships": [
        {
          "target": "Random",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.random.SystemRandom",
      "name": "SystemRandom",
      "module": "random",
      "type": "class",
      "signature": "(x=None)",
      "description": "Alternate random number generator using sources provided\nby the operating system (such as /dev/urandom on Unix or\nCryptGenRandom on Windows).\n\n Not available on all systems (see os.urandom() for details).",
      "relationships": [
        {
          "target": "Random",
          "type": "base_class"
        },
        {
          "target": "Random",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.re.Match",
      "name": "Match",
      "module": "re",
      "type": "class",
      "signature": "()",
      "description": "The result of re.match() and re.search().\nMatch objects always have a boolean value of True.",
      "relationships": []
    },
    {
      "id": "stdlib.re.Pattern",
      "name": "Pattern",
      "module": "re",
      "type": "class",
      "signature": "()",
      "description": "Compiled regular expression object.",
      "relationships": []
    },
    {
      "id": "stdlib.re.RegexFlag",
      "name": "RegexFlag",
      "module": "re",
      "type": "class",
      "signature": "(value, names=None, *, module=None, qualname=None, type=None, start=1)",
      "description": "An enumeration.",
      "relationships": [
        {
          "target": "IntFlag",
          "type": "base_class"
        },
        {
          "target": "int",
          "type": "base_class"
        },
        {
          "target": "Flag",
          "type": "base_class"
        },
        {
          "target": "Enum",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.re.Scanner",
      "name": "Scanner",
      "module": "re",
      "type": "class",
      "signature": "(lexicon, flags=0)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.re.compile",
      "name": "compile",
      "module": "re",
      "type": "function",
      "signature": "(pattern, flags=0)",
      "description": "Compile a regular expression pattern, returning a Pattern object.",
      "relationships": [
        {
          "target": "stdlib.re._compile",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.re.error",
      "name": "error",
      "module": "re",
      "type": "class",
      "signature": "(msg, pattern=None, pos=None)",
      "description": "Exception raised for invalid regular expressions.\n\nAttributes:\n\n    msg: The unformatted error message\n    pattern: The regular expression pattern\n    pos: The index in the pattern where compilation failed (may be None)\n    lineno: The line corresponding to pos (may be None)\n    colno: The column corresponding to pos (may be None)",
      "relationships": [
        {
          "target": "Exception",
          "type": "base_class"
        },
        {
          "target": "BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.re.escape",
      "name": "escape",
      "module": "re",
      "type": "function",
      "signature": "(pattern)",
      "description": "Escape special characters in a string.",
      "relationships": [
        {
          "target": "stdlib.re.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.re.translate",
          "type": "calls"
        },
        {
          "target": "stdlib.re.str",
          "type": "calls"
        },
        {
          "target": "stdlib.re.encode",
          "type": "calls"
        },
        {
          "target": "stdlib.re.translate",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.re.findall",
      "name": "findall",
      "module": "re",
      "type": "function",
      "signature": "(pattern, string, flags=0)",
      "description": "Return a list of all non-overlapping matches in the string.\n\nIf one or more capturing groups are present in the pattern, return\na list of groups; this will be a list of tuples if the pattern\nhas more than one group.\n\nEmpty matches are included in the result.",
      "relationships": [
        {
          "target": "stdlib.re.findall",
          "type": "calls"
        },
        {
          "target": "stdlib.re._compile",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.re.finditer",
      "name": "finditer",
      "module": "re",
      "type": "function",
      "signature": "(pattern, string, flags=0)",
      "description": "Return an iterator over all non-overlapping matches in the\nstring.  For each match, the iterator returns a Match object.\n\nEmpty matches are included in the result.",
      "relationships": [
        {
          "target": "stdlib.re.finditer",
          "type": "calls"
        },
        {
          "target": "stdlib.re._compile",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.re.fullmatch",
      "name": "fullmatch",
      "module": "re",
      "type": "function",
      "signature": "(pattern, string, flags=0)",
      "description": "Try to apply the pattern to all of the string, returning\na Match object, or None if no match was found.",
      "relationships": [
        {
          "target": "stdlib.re.fullmatch",
          "type": "calls"
        },
        {
          "target": "stdlib.re._compile",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.re.match",
      "name": "match",
      "module": "re",
      "type": "function",
      "signature": "(pattern, string, flags=0)",
      "description": "Try to apply the pattern at the start of the string, returning\na Match object, or None if no match was found.",
      "relationships": [
        {
          "target": "stdlib.re.match",
          "type": "calls"
        },
        {
          "target": "stdlib.re._compile",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.re.purge",
      "name": "purge",
      "module": "re",
      "type": "function",
      "signature": "()",
      "description": "Clear the regular expression caches",
      "relationships": [
        {
          "target": "stdlib.re.clear",
          "type": "calls"
        },
        {
          "target": "stdlib.re.cache_clear",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.re.search",
      "name": "search",
      "module": "re",
      "type": "function",
      "signature": "(pattern, string, flags=0)",
      "description": "Scan through string looking for a match to the pattern, returning\na Match object, or None if no match was found.",
      "relationships": [
        {
          "target": "stdlib.re.search",
          "type": "calls"
        },
        {
          "target": "stdlib.re._compile",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.re.split",
      "name": "split",
      "module": "re",
      "type": "function",
      "signature": "(pattern, string, maxsplit=0, flags=0)",
      "description": "Split the source string by the occurrences of the pattern,\nreturning a list containing the resulting substrings.  If\ncapturing parentheses are used in pattern, then the text of all\ngroups in the pattern are also returned as part of the resulting\nlist.  If maxsplit is nonzero, at most maxsplit splits occur,\nand the remainder of the string is returned as the final element\nof the list.",
      "relationships": [
        {
          "target": "stdlib.re.split",
          "type": "calls"
        },
        {
          "target": "stdlib.re._compile",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.re.sub",
      "name": "sub",
      "module": "re",
      "type": "function",
      "signature": "(pattern, repl, string, count=0, flags=0)",
      "description": "Return the string obtained by replacing the leftmost\nnon-overlapping occurrences of the pattern in string by the\nreplacement repl.  repl can be either a string or a callable;\nif a string, backslash escapes in it are processed.  If it is\na callable, it's passed the Match object and must return\na replacement string to be used.",
      "relationships": [
        {
          "target": "stdlib.re.sub",
          "type": "calls"
        },
        {
          "target": "stdlib.re._compile",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.re.subn",
      "name": "subn",
      "module": "re",
      "type": "function",
      "signature": "(pattern, repl, string, count=0, flags=0)",
      "description": "Return a 2-tuple containing (new_string, number).\nnew_string is the string obtained by replacing the leftmost\nnon-overlapping occurrences of the pattern in the source\nstring by the replacement repl.  number is the number of\nsubstitutions that were made. repl can be either a string or a\ncallable; if a string, backslash escapes in it are processed.\nIf it is a callable, it's passed the Match object and must\nreturn a replacement string to be used.",
      "relationships": [
        {
          "target": "stdlib.re.subn",
          "type": "calls"
        },
        {
          "target": "stdlib.re._compile",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.re.template",
      "name": "template",
      "module": "re",
      "type": "function",
      "signature": "(pattern, flags=0)",
      "description": "Compile a template pattern, returning a Pattern object",
      "relationships": [
        {
          "target": "stdlib.re._compile",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.reprlib.Repr",
      "name": "Repr",
      "module": "reprlib",
      "type": "class",
      "signature": "()",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.reprlib.recursive_repr",
      "name": "recursive_repr",
      "module": "reprlib",
      "type": "function",
      "signature": "(fillvalue='...')",
      "description": "Decorator to make a repr function return fillvalue for a recursive call",
      "relationships": [
        {
          "target": "stdlib.reprlib.set",
          "type": "calls"
        },
        {
          "target": "stdlib.reprlib.getattr",
          "type": "calls"
        },
        {
          "target": "stdlib.reprlib.getattr",
          "type": "calls"
        },
        {
          "target": "stdlib.reprlib.getattr",
          "type": "calls"
        },
        {
          "target": "stdlib.reprlib.getattr",
          "type": "calls"
        },
        {
          "target": "stdlib.reprlib.getattr",
          "type": "calls"
        },
        {
          "target": "stdlib.reprlib.add",
          "type": "calls"
        },
        {
          "target": "stdlib.reprlib.id",
          "type": "calls"
        },
        {
          "target": "stdlib.reprlib.get_ident",
          "type": "calls"
        },
        {
          "target": "stdlib.reprlib.user_function",
          "type": "calls"
        },
        {
          "target": "stdlib.reprlib.discard",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.rlcompleter.Completer",
      "name": "Completer",
      "module": "rlcompleter",
      "type": "class",
      "signature": "(namespace=None)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.rlcompleter.get_class_members",
      "name": "get_class_members",
      "module": "rlcompleter",
      "type": "function",
      "signature": "(klass)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.rlcompleter.dir",
          "type": "calls"
        },
        {
          "target": "stdlib.rlcompleter.hasattr",
          "type": "calls"
        },
        {
          "target": "stdlib.rlcompleter.get_class_members",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.runpy.get_importer",
      "name": "get_importer",
      "module": "runpy",
      "type": "function",
      "signature": "(path_item)",
      "description": "Retrieve a finder for the given path item\n\nThe returned finder is cached in sys.path_importer_cache\nif it was newly created by a path hook.\n\nThe cache (or part of it) can be cleared manually if a\nrescan of sys.path_hooks is necessary.",
      "relationships": [
        {
          "target": "stdlib.runpy.fsdecode",
          "type": "calls"
        },
        {
          "target": "stdlib.runpy.path_hook",
          "type": "calls"
        },
        {
          "target": "stdlib.runpy.setdefault",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.runpy.read_code",
      "name": "read_code",
      "module": "runpy",
      "type": "function",
      "signature": "(stream)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.runpy.read",
          "type": "calls"
        },
        {
          "target": "stdlib.runpy.read",
          "type": "calls"
        },
        {
          "target": "stdlib.runpy.load",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.runpy.run_module",
      "name": "run_module",
      "module": "runpy",
      "type": "function",
      "signature": "(mod_name, init_globals=None, run_name=None, alter_sys=False)",
      "description": "Execute a module's code without importing it\n\nReturns the resulting top level namespace dictionary",
      "relationships": [
        {
          "target": "stdlib.runpy._get_module_details",
          "type": "calls"
        },
        {
          "target": "stdlib.runpy._run_module_code",
          "type": "calls"
        },
        {
          "target": "stdlib.runpy._run_code",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.runpy.run_path",
      "name": "run_path",
      "module": "runpy",
      "type": "function",
      "signature": "(path_name, init_globals=None, run_name=None)",
      "description": "Execute code located at the specified filesystem location\n\nReturns the resulting top level namespace dictionary\n\nThe file path may refer directly to a Python script (i.e.\none that could be directly executed with execfile) or else\nit may refer to a zipfile or directory containing a top\nlevel __main__.py script.",
      "relationships": [
        {
          "target": "stdlib.runpy.get_importer",
          "type": "calls"
        },
        {
          "target": "stdlib.runpy.rpartition",
          "type": "calls"
        },
        {
          "target": "stdlib.runpy.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.runpy._get_code_from_file",
          "type": "calls"
        },
        {
          "target": "stdlib.runpy._run_module_code",
          "type": "calls"
        },
        {
          "target": "stdlib.runpy.insert",
          "type": "calls"
        },
        {
          "target": "stdlib.runpy.type",
          "type": "calls"
        },
        {
          "target": "stdlib.runpy.type",
          "type": "calls"
        },
        {
          "target": "stdlib.runpy._get_main_module_details",
          "type": "calls"
        },
        {
          "target": "stdlib.runpy.type",
          "type": "calls"
        },
        {
          "target": "stdlib.runpy._TempModule",
          "type": "calls"
        },
        {
          "target": "stdlib.runpy._ModifiedArgv0",
          "type": "calls"
        },
        {
          "target": "stdlib.runpy.copy",
          "type": "calls"
        },
        {
          "target": "stdlib.runpy.remove",
          "type": "calls"
        },
        {
          "target": "stdlib.runpy._run_code",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.sched.Event",
      "name": "Event",
      "module": "sched",
      "type": "class",
      "signature": "(time, priority, action, argument, kwargs)",
      "description": "Event(time, priority, action, argument, kwargs)",
      "relationships": [
        {
          "target": "Event",
          "type": "base_class"
        },
        {
          "target": "tuple",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.sched.namedtuple",
      "name": "namedtuple",
      "module": "sched",
      "type": "function",
      "signature": "(typename, field_names, *, rename=False, defaults=None, module=None)",
      "description": "Returns a new subclass of tuple with named fields.\n\n>>> Point = namedtuple('Point', ['x', 'y'])\n>>> Point.__doc__                   # docstring for the new class\n'Point(x, y)'\n>>> p = Point(11, y=22)             # instantiate with positional args or keywords\n>>> p[0] + p[1]                     # indexable like a plain tuple\n33\n>>> x, y = p                        # unpack like a regular tuple\n>>> x, y\n(11, 22)\n>>> p.x + p.y                       # fields also accessible by name\n33\n>>> d = p._asdict()                 # convert to a dictionary\n>>> d['x']\n11\n>>> Point(**d)                      # convert from a dictionary\nPoint(x=11, y=22)\n>>> p._replace(x=100)               # _replace() is like str.replace() but targets named fields\nPoint(x=100, y=22)",
      "relationships": [
        {
          "target": "stdlib.sched.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.sched.list",
          "type": "calls"
        },
        {
          "target": "stdlib.sched.intern",
          "type": "calls"
        },
        {
          "target": "stdlib.sched.set",
          "type": "calls"
        },
        {
          "target": "stdlib.sched.tuple",
          "type": "calls"
        },
        {
          "target": "stdlib.sched.len",
          "type": "calls"
        },
        {
          "target": "stdlib.sched.join",
          "type": "calls"
        },
        {
          "target": "stdlib.sched.eval",
          "type": "calls"
        },
        {
          "target": "stdlib.sched.enumerate",
          "type": "calls"
        },
        {
          "target": "stdlib.sched.type",
          "type": "calls"
        },
        {
          "target": "stdlib.sched.split",
          "type": "calls"
        },
        {
          "target": "stdlib.sched.map",
          "type": "calls"
        },
        {
          "target": "stdlib.sched.str",
          "type": "calls"
        },
        {
          "target": "stdlib.sched.set",
          "type": "calls"
        },
        {
          "target": "stdlib.sched.enumerate",
          "type": "calls"
        },
        {
          "target": "stdlib.sched._iskeyword",
          "type": "calls"
        },
        {
          "target": "stdlib.sched.add",
          "type": "calls"
        },
        {
          "target": "stdlib.sched.tuple",
          "type": "calls"
        },
        {
          "target": "stdlib.sched.dict",
          "type": "calls"
        },
        {
          "target": "stdlib.sched.map",
          "type": "calls"
        },
        {
          "target": "stdlib.sched.tuple_new",
          "type": "calls"
        },
        {
          "target": "stdlib.sched._make",
          "type": "calls"
        },
        {
          "target": "stdlib.sched._dict",
          "type": "calls"
        },
        {
          "target": "stdlib.sched._tuple",
          "type": "calls"
        },
        {
          "target": "stdlib.sched.intern",
          "type": "calls"
        },
        {
          "target": "stdlib.sched._tuplegetter",
          "type": "calls"
        },
        {
          "target": "stdlib.sched.add",
          "type": "calls"
        },
        {
          "target": "stdlib.sched.type",
          "type": "calls"
        },
        {
          "target": "stdlib.sched.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.sched.isidentifier",
          "type": "calls"
        },
        {
          "target": "stdlib.sched.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.sched.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.sched.startswith",
          "type": "calls"
        },
        {
          "target": "stdlib.sched.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.sched.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.sched.len",
          "type": "calls"
        },
        {
          "target": "stdlib.sched.len",
          "type": "calls"
        },
        {
          "target": "stdlib.sched.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.sched.reversed",
          "type": "calls"
        },
        {
          "target": "stdlib.sched.join",
          "type": "calls"
        },
        {
          "target": "stdlib.sched._len",
          "type": "calls"
        },
        {
          "target": "stdlib.sched.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.sched._map",
          "type": "calls"
        },
        {
          "target": "stdlib.sched.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.sched._zip",
          "type": "calls"
        },
        {
          "target": "stdlib.sched.get",
          "type": "calls"
        },
        {
          "target": "stdlib.sched.replace",
          "type": "calls"
        },
        {
          "target": "stdlib.sched._iskeyword",
          "type": "calls"
        },
        {
          "target": "stdlib.sched.startswith",
          "type": "calls"
        },
        {
          "target": "stdlib.sched.list",
          "type": "calls"
        },
        {
          "target": "stdlib.sched.isidentifier",
          "type": "calls"
        },
        {
          "target": "stdlib.sched.zip",
          "type": "calls"
        },
        {
          "target": "stdlib.sched.reversed",
          "type": "calls"
        },
        {
          "target": "stdlib.sched.reversed",
          "type": "calls"
        },
        {
          "target": "stdlib.sched.len",
          "type": "calls"
        },
        {
          "target": "stdlib.sched.list",
          "type": "calls"
        },
        {
          "target": "stdlib.sched._getframe",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.sched.scheduler",
      "name": "scheduler",
      "module": "sched",
      "type": "class",
      "signature": "(timefunc=<built-in function monotonic>, delayfunc=<built-in function sleep>)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.secrets.SystemRandom",
      "name": "SystemRandom",
      "module": "secrets",
      "type": "class",
      "signature": "(x=None)",
      "description": "Alternate random number generator using sources provided\nby the operating system (such as /dev/urandom on Unix or\nCryptGenRandom on Windows).\n\n Not available on all systems (see os.urandom() for details).",
      "relationships": [
        {
          "target": "Random",
          "type": "base_class"
        },
        {
          "target": "Random",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.secrets.randbelow",
      "name": "randbelow",
      "module": "secrets",
      "type": "function",
      "signature": "(exclusive_upper_bound)",
      "description": "Return a random int in the range [0, n).",
      "relationships": [
        {
          "target": "stdlib.secrets._randbelow",
          "type": "calls"
        },
        {
          "target": "stdlib.secrets.ValueError",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.secrets.token_bytes",
      "name": "token_bytes",
      "module": "secrets",
      "type": "function",
      "signature": "(nbytes=None)",
      "description": "Return a random byte string containing *nbytes* bytes.\n\nIf *nbytes* is ``None`` or not supplied, a reasonable\ndefault is used.\n\n>>> token_bytes(16)  #doctest:+SKIP\nb'\\xebr\\x17D*t\\xae\\xd4\\xe3S\\xb6\\xe2\\xebP1\\x8b'",
      "relationships": [
        {
          "target": "stdlib.secrets.randbytes",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.secrets.token_hex",
      "name": "token_hex",
      "module": "secrets",
      "type": "function",
      "signature": "(nbytes=None)",
      "description": "Return a random text string, in hexadecimal.\n\nThe string has *nbytes* random bytes, each byte converted to two\nhex digits.  If *nbytes* is ``None`` or not supplied, a reasonable\ndefault is used.\n\n>>> token_hex(16)  #doctest:+SKIP\n'f9bf78b9a18ce6d46a0cd2b0b86df9da'",
      "relationships": [
        {
          "target": "stdlib.secrets.decode",
          "type": "calls"
        },
        {
          "target": "stdlib.secrets.hexlify",
          "type": "calls"
        },
        {
          "target": "stdlib.secrets.token_bytes",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.secrets.token_urlsafe",
      "name": "token_urlsafe",
      "module": "secrets",
      "type": "function",
      "signature": "(nbytes=None)",
      "description": "Return a random URL-safe text string, in Base64 encoding.\n\nThe string has *nbytes* random bytes.  If *nbytes* is ``None``\nor not supplied, a reasonable default is used.\n\n>>> token_urlsafe(16)  #doctest:+SKIP\n'Drmhze6EPcv0fN_81Bj-nA'",
      "relationships": [
        {
          "target": "stdlib.secrets.token_bytes",
          "type": "calls"
        },
        {
          "target": "stdlib.secrets.decode",
          "type": "calls"
        },
        {
          "target": "stdlib.secrets.rstrip",
          "type": "calls"
        },
        {
          "target": "stdlib.secrets.urlsafe_b64encode",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.selectors.ABCMeta",
      "name": "ABCMeta",
      "module": "selectors",
      "type": "class",
      "signature": "(name, bases, namespace, **kwargs)",
      "description": "Metaclass for defining Abstract Base Classes (ABCs).\n\nUse this metaclass to create an ABC.  An ABC can be subclassed\ndirectly, and then acts as a mix-in class.  You can also register\nunrelated concrete classes (even built-in classes) and unrelated\nABCs as 'virtual subclasses' -- these and their descendants will\nbe considered subclasses of the registering ABC by the built-in\nissubclass() function, but the registering ABC won't show up in\ntheir MRO (Method Resolution Order) nor will method\nimplementations defined by the registering ABC be callable (not\neven via super()).",
      "relationships": [
        {
          "target": "type",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.selectors.BaseSelector",
      "name": "BaseSelector",
      "module": "selectors",
      "type": "class",
      "signature": "()",
      "description": "Selector abstract base class.\n\nA selector supports registering file objects to be monitored for specific\nI/O events.\n\nA file object is a file descriptor or any object with a `fileno()` method.\nAn arbitrary object can be attached to the file object, which can be used\nfor example to store context information, a callback, etc.\n\nA selector can use various implementations (select(), poll(), epoll()...)\ndepending on the platform. The default `Selector` class uses the most\nefficient implementation on the current platform.",
      "relationships": []
    },
    {
      "id": "stdlib.selectors.DefaultSelector",
      "name": "DefaultSelector",
      "module": "selectors",
      "type": "class",
      "signature": "()",
      "description": "Kqueue-based selector.",
      "relationships": [
        {
          "target": "_BaseSelectorImpl",
          "type": "base_class"
        },
        {
          "target": "BaseSelector",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.selectors.KqueueSelector",
      "name": "KqueueSelector",
      "module": "selectors",
      "type": "class",
      "signature": "()",
      "description": "Kqueue-based selector.",
      "relationships": [
        {
          "target": "_BaseSelectorImpl",
          "type": "base_class"
        },
        {
          "target": "BaseSelector",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.selectors.Mapping",
      "name": "Mapping",
      "module": "selectors",
      "type": "class",
      "signature": "()",
      "description": "",
      "relationships": [
        {
          "target": "Collection",
          "type": "base_class"
        },
        {
          "target": "Sized",
          "type": "base_class"
        },
        {
          "target": "Iterable",
          "type": "base_class"
        },
        {
          "target": "Container",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.selectors.PollSelector",
      "name": "PollSelector",
      "module": "selectors",
      "type": "class",
      "signature": "()",
      "description": "Poll-based selector.",
      "relationships": [
        {
          "target": "_PollLikeSelector",
          "type": "base_class"
        },
        {
          "target": "_BaseSelectorImpl",
          "type": "base_class"
        },
        {
          "target": "BaseSelector",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.selectors.SelectSelector",
      "name": "SelectSelector",
      "module": "selectors",
      "type": "class",
      "signature": "()",
      "description": "Select-based selector.",
      "relationships": [
        {
          "target": "_BaseSelectorImpl",
          "type": "base_class"
        },
        {
          "target": "BaseSelector",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.selectors.SelectorKey",
      "name": "SelectorKey",
      "module": "selectors",
      "type": "class",
      "signature": "(fileobj, fd, events, data)",
      "description": "SelectorKey(fileobj, fd, events, data)\n\nObject used to associate a file object to its backing\nfile descriptor, selected event mask, and attached data.",
      "relationships": [
        {
          "target": "tuple",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.selectors.abstractmethod",
      "name": "abstractmethod",
      "module": "selectors",
      "type": "function",
      "signature": "(funcobj)",
      "description": "A decorator indicating abstract methods.\n\nRequires that the metaclass is ABCMeta or derived from it.  A\nclass that has a metaclass derived from ABCMeta cannot be\ninstantiated unless all of its abstract methods are overridden.\nThe abstract methods can be called using any of the normal\n'super' call mechanisms.  abstractmethod() may be used to declare\nabstract methods for properties and descriptors.\n\nUsage:\n\n    class C(metaclass=ABCMeta):\n        @abstractmethod\n        def my_abstract_method(self, ...):\n            ...",
      "relationships": []
    },
    {
      "id": "stdlib.selectors.namedtuple",
      "name": "namedtuple",
      "module": "selectors",
      "type": "function",
      "signature": "(typename, field_names, *, rename=False, defaults=None, module=None)",
      "description": "Returns a new subclass of tuple with named fields.\n\n>>> Point = namedtuple('Point', ['x', 'y'])\n>>> Point.__doc__                   # docstring for the new class\n'Point(x, y)'\n>>> p = Point(11, y=22)             # instantiate with positional args or keywords\n>>> p[0] + p[1]                     # indexable like a plain tuple\n33\n>>> x, y = p                        # unpack like a regular tuple\n>>> x, y\n(11, 22)\n>>> p.x + p.y                       # fields also accessible by name\n33\n>>> d = p._asdict()                 # convert to a dictionary\n>>> d['x']\n11\n>>> Point(**d)                      # convert from a dictionary\nPoint(x=11, y=22)\n>>> p._replace(x=100)               # _replace() is like str.replace() but targets named fields\nPoint(x=100, y=22)",
      "relationships": [
        {
          "target": "stdlib.selectors.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.selectors.list",
          "type": "calls"
        },
        {
          "target": "stdlib.selectors.intern",
          "type": "calls"
        },
        {
          "target": "stdlib.selectors.set",
          "type": "calls"
        },
        {
          "target": "stdlib.selectors.tuple",
          "type": "calls"
        },
        {
          "target": "stdlib.selectors.len",
          "type": "calls"
        },
        {
          "target": "stdlib.selectors.join",
          "type": "calls"
        },
        {
          "target": "stdlib.selectors.eval",
          "type": "calls"
        },
        {
          "target": "stdlib.selectors.enumerate",
          "type": "calls"
        },
        {
          "target": "stdlib.selectors.type",
          "type": "calls"
        },
        {
          "target": "stdlib.selectors.split",
          "type": "calls"
        },
        {
          "target": "stdlib.selectors.map",
          "type": "calls"
        },
        {
          "target": "stdlib.selectors.str",
          "type": "calls"
        },
        {
          "target": "stdlib.selectors.set",
          "type": "calls"
        },
        {
          "target": "stdlib.selectors.enumerate",
          "type": "calls"
        },
        {
          "target": "stdlib.selectors._iskeyword",
          "type": "calls"
        },
        {
          "target": "stdlib.selectors.add",
          "type": "calls"
        },
        {
          "target": "stdlib.selectors.tuple",
          "type": "calls"
        },
        {
          "target": "stdlib.selectors.dict",
          "type": "calls"
        },
        {
          "target": "stdlib.selectors.map",
          "type": "calls"
        },
        {
          "target": "stdlib.selectors.tuple_new",
          "type": "calls"
        },
        {
          "target": "stdlib.selectors._make",
          "type": "calls"
        },
        {
          "target": "stdlib.selectors._dict",
          "type": "calls"
        },
        {
          "target": "stdlib.selectors._tuple",
          "type": "calls"
        },
        {
          "target": "stdlib.selectors.intern",
          "type": "calls"
        },
        {
          "target": "stdlib.selectors._tuplegetter",
          "type": "calls"
        },
        {
          "target": "stdlib.selectors.add",
          "type": "calls"
        },
        {
          "target": "stdlib.selectors.type",
          "type": "calls"
        },
        {
          "target": "stdlib.selectors.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.selectors.isidentifier",
          "type": "calls"
        },
        {
          "target": "stdlib.selectors.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.selectors.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.selectors.startswith",
          "type": "calls"
        },
        {
          "target": "stdlib.selectors.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.selectors.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.selectors.len",
          "type": "calls"
        },
        {
          "target": "stdlib.selectors.len",
          "type": "calls"
        },
        {
          "target": "stdlib.selectors.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.selectors.reversed",
          "type": "calls"
        },
        {
          "target": "stdlib.selectors.join",
          "type": "calls"
        },
        {
          "target": "stdlib.selectors._len",
          "type": "calls"
        },
        {
          "target": "stdlib.selectors.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.selectors._map",
          "type": "calls"
        },
        {
          "target": "stdlib.selectors.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.selectors._zip",
          "type": "calls"
        },
        {
          "target": "stdlib.selectors.get",
          "type": "calls"
        },
        {
          "target": "stdlib.selectors.replace",
          "type": "calls"
        },
        {
          "target": "stdlib.selectors._iskeyword",
          "type": "calls"
        },
        {
          "target": "stdlib.selectors.startswith",
          "type": "calls"
        },
        {
          "target": "stdlib.selectors.list",
          "type": "calls"
        },
        {
          "target": "stdlib.selectors.isidentifier",
          "type": "calls"
        },
        {
          "target": "stdlib.selectors.zip",
          "type": "calls"
        },
        {
          "target": "stdlib.selectors.reversed",
          "type": "calls"
        },
        {
          "target": "stdlib.selectors.reversed",
          "type": "calls"
        },
        {
          "target": "stdlib.selectors.len",
          "type": "calls"
        },
        {
          "target": "stdlib.selectors.list",
          "type": "calls"
        },
        {
          "target": "stdlib.selectors._getframe",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.shelve.BsdDbShelf",
      "name": "BsdDbShelf",
      "module": "shelve",
      "type": "class",
      "signature": "(dict, protocol=None, writeback=False, keyencoding='utf-8')",
      "description": "Shelf implementation using the \"BSD\" db interface.\n\nThis adds methods first(), next(), previous(), last() and\nset_location() that have no counterpart in [g]dbm databases.\n\nThe actual database must be opened using one of the \"bsddb\"\nmodules \"open\" routines (i.e. bsddb.hashopen, bsddb.btopen or\nbsddb.rnopen) and passed to the constructor.\n\nSee the module's __doc__ string for an overview of the interface.",
      "relationships": [
        {
          "target": "Shelf",
          "type": "base_class"
        },
        {
          "target": "MutableMapping",
          "type": "base_class"
        },
        {
          "target": "Mapping",
          "type": "base_class"
        },
        {
          "target": "Collection",
          "type": "base_class"
        },
        {
          "target": "Sized",
          "type": "base_class"
        },
        {
          "target": "Iterable",
          "type": "base_class"
        },
        {
          "target": "Container",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.shelve.BytesIO",
      "name": "BytesIO",
      "module": "shelve",
      "type": "class",
      "signature": "(initial_bytes=b'')",
      "description": "Buffered I/O implementation using an in-memory bytes buffer.",
      "relationships": [
        {
          "target": "_BufferedIOBase",
          "type": "base_class"
        },
        {
          "target": "_IOBase",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.shelve.DbfilenameShelf",
      "name": "DbfilenameShelf",
      "module": "shelve",
      "type": "class",
      "signature": "(filename, flag='c', protocol=None, writeback=False)",
      "description": "Shelf implementation using the \"dbm\" generic dbm interface.\n\nThis is initialized with the filename for the dbm database.\nSee the module's __doc__ string for an overview of the interface.",
      "relationships": [
        {
          "target": "Shelf",
          "type": "base_class"
        },
        {
          "target": "MutableMapping",
          "type": "base_class"
        },
        {
          "target": "Mapping",
          "type": "base_class"
        },
        {
          "target": "Collection",
          "type": "base_class"
        },
        {
          "target": "Sized",
          "type": "base_class"
        },
        {
          "target": "Iterable",
          "type": "base_class"
        },
        {
          "target": "Container",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.shelve.Pickler",
      "name": "Pickler",
      "module": "shelve",
      "type": "class",
      "signature": "(file, protocol=None, fix_imports=True, buffer_callback=None)",
      "description": "This takes a binary file for writing a pickle data stream.\n\nThe optional *protocol* argument tells the pickler to use the given\nprotocol; supported protocols are 0, 1, 2, 3, 4 and 5.  The default\nprotocol is 4. It was introduced in Python 3.4, and is incompatible\nwith previous versions.\n\nSpecifying a negative protocol version selects the highest protocol\nversion supported.  The higher the protocol used, the more recent the\nversion of Python needed to read the pickle produced.\n\nThe *file* argument must have a write() method that accepts a single\nbytes argument. It can thus be a file object opened for binary\nwriting, an io.BytesIO instance, or any other custom object that meets\nthis interface.\n\nIf *fix_imports* is True and protocol is less than 3, pickle will try\nto map the new Python 3 names to the old module names used in Python\n2, so that the pickle data stream is readable with Python 2.\n\nIf *buffer_callback* is None (the default), buffer views are\nserialized into *file* as part of the pickle stream.\n\nIf *buffer_callback* is not None, then it can be called any number\nof times with a buffer view.  If the callback returns a false value\n(such as None), the given buffer is out-of-band; otherwise the\nbuffer is serialized in-band, i.e. inside the pickle stream.\n\nIt is an error if *buffer_callback* is not None and *protocol*\nis None or smaller than 5.",
      "relationships": []
    },
    {
      "id": "stdlib.shelve.Shelf",
      "name": "Shelf",
      "module": "shelve",
      "type": "class",
      "signature": "(dict, protocol=None, writeback=False, keyencoding='utf-8')",
      "description": "Base class for shelf implementations.\n\nThis is initialized with a dictionary-like object.\nSee the module's __doc__ string for an overview of the interface.",
      "relationships": [
        {
          "target": "MutableMapping",
          "type": "base_class"
        },
        {
          "target": "Mapping",
          "type": "base_class"
        },
        {
          "target": "Collection",
          "type": "base_class"
        },
        {
          "target": "Sized",
          "type": "base_class"
        },
        {
          "target": "Iterable",
          "type": "base_class"
        },
        {
          "target": "Container",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.shelve.Unpickler",
      "name": "Unpickler",
      "module": "shelve",
      "type": "class",
      "signature": "(file, *, fix_imports=True, encoding='ASCII', errors='strict', buffers=())",
      "description": "This takes a binary file for reading a pickle data stream.\n\nThe protocol version of the pickle is detected automatically, so no\nprotocol argument is needed.  Bytes past the pickled object's\nrepresentation are ignored.\n\nThe argument *file* must have two methods, a read() method that takes\nan integer argument, and a readline() method that requires no\narguments.  Both methods should return bytes.  Thus *file* can be a\nbinary file object opened for reading, an io.BytesIO object, or any\nother custom object that meets this interface.\n\nOptional keyword arguments are *fix_imports*, *encoding* and *errors*,\nwhich are used to control compatibility support for pickle stream\ngenerated by Python 2.  If *fix_imports* is True, pickle will try to\nmap the old Python 2 names to the new names used in Python 3.  The\n*encoding* and *errors* tell pickle how to decode 8-bit string\ninstances pickled by Python 2; these default to 'ASCII' and 'strict',\nrespectively.  The *encoding* can be 'bytes' to read these 8-bit\nstring instances as bytes objects.",
      "relationships": []
    },
    {
      "id": "stdlib.shelve.open",
      "name": "open",
      "module": "shelve",
      "type": "function",
      "signature": "(filename, flag='c', protocol=None, writeback=False)",
      "description": "Open a persistent dictionary for reading and writing.\n\nThe filename parameter is the base filename for the underlying\ndatabase.  As a side-effect, an extension may be added to the\nfilename and more than one file may be created.  The optional flag\nparameter has the same interpretation as the flag parameter of\ndbm.open(). The optional protocol parameter specifies the\nversion of the pickle protocol.\n\nSee the module's __doc__ string for an overview of the interface.",
      "relationships": [
        {
          "target": "stdlib.shelve.DbfilenameShelf",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.shlex.StringIO",
      "name": "StringIO",
      "module": "shlex",
      "type": "class",
      "signature": "(initial_value='', newline='\\n')",
      "description": "Text I/O implementation using an in-memory buffer.\n\nThe initial_value argument sets the value of object.  The newline\nargument is like the one of TextIOWrapper's constructor.",
      "relationships": [
        {
          "target": "_TextIOBase",
          "type": "base_class"
        },
        {
          "target": "_IOBase",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.shlex.join",
      "name": "join",
      "module": "shlex",
      "type": "function",
      "signature": "(split_command)",
      "description": "Return a shell-escaped string from *split_command*.",
      "relationships": [
        {
          "target": "stdlib.shlex.join",
          "type": "calls"
        },
        {
          "target": "stdlib.shlex.quote",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.shlex.quote",
      "name": "quote",
      "module": "shlex",
      "type": "function",
      "signature": "(s)",
      "description": "Return a shell-escaped version of the string *s*.",
      "relationships": [
        {
          "target": "stdlib.shlex._find_unsafe",
          "type": "calls"
        },
        {
          "target": "stdlib.shlex.replace",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.shlex.shlex",
      "name": "shlex",
      "module": "shlex",
      "type": "class",
      "signature": "(instream=None, infile=None, posix=False, punctuation_chars=False)",
      "description": "A lexical analyzer class for simple shell-like syntaxes.",
      "relationships": []
    },
    {
      "id": "stdlib.shlex.split",
      "name": "split",
      "module": "shlex",
      "type": "function",
      "signature": "(s, comments=False, posix=True)",
      "description": "Split the string *s* using shell-like syntax.",
      "relationships": [
        {
          "target": "stdlib.shlex.shlex",
          "type": "calls"
        },
        {
          "target": "stdlib.shlex.list",
          "type": "calls"
        },
        {
          "target": "stdlib.shlex.warn",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.shutil.chown",
      "name": "chown",
      "module": "shutil",
      "type": "function",
      "signature": "(path, user=None, group=None)",
      "description": "Change owner user and group of the given path.\n\nuser and group can be the uid/gid or the user/group names, and in that case,\nthey are converted to their respective uid/gid.",
      "relationships": [
        {
          "target": "stdlib.shutil.audit",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.chown",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil._get_uid",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil._get_gid",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.LookupError",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.LookupError",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.format",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.format",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.shutil.copy",
      "name": "copy",
      "module": "shutil",
      "type": "function",
      "signature": "(src, dst, *, follow_symlinks=True)",
      "description": "Copy data and mode bits (\"cp src dst\"). Return the file's destination.\n\nThe destination may be a directory.\n\nIf follow_symlinks is false, symlinks won't be followed. This\nresembles GNU's \"cp -P src dst\".\n\nIf source and destination are the same file, a SameFileError will be\nraised.",
      "relationships": [
        {
          "target": "stdlib.shutil.isdir",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.copyfile",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.copymode",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.join",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.basename",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.shutil.copy2",
      "name": "copy2",
      "module": "shutil",
      "type": "function",
      "signature": "(src, dst, *, follow_symlinks=True)",
      "description": "Copy data and metadata. Return the file's destination.\n\nMetadata is copied with copystat(). Please see the copystat function\nfor more information.\n\nThe destination may be a directory.\n\nIf follow_symlinks is false, symlinks won't be followed. This\nresembles GNU's \"cp -P src dst\".",
      "relationships": [
        {
          "target": "stdlib.shutil.isdir",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.copyfile",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.copystat",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.join",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.basename",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.shutil.copyfile",
      "name": "copyfile",
      "module": "shutil",
      "type": "function",
      "signature": "(src, dst, *, follow_symlinks=True)",
      "description": "Copy data from src to dst in the most efficient way possible.\n\nIf follow_symlinks is not set and src is a symbolic link, a new\nsymlink will be created instead of copying the file it points to.",
      "relationships": [
        {
          "target": "stdlib.shutil.audit",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil._samefile",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.enumerate",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.SameFileError",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil._islink",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.symlink",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.format",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil._stat",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.S_ISFIFO",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.readlink",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.open",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.open",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.copyfileobj",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.SpecialFileError",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil._fastcopy_fcopyfile",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil._fastcopy_sendfile",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil._copyfileobj_readinto",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.min",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.shutil.copyfileobj",
      "name": "copyfileobj",
      "module": "shutil",
      "type": "function",
      "signature": "(fsrc, fdst, length=0)",
      "description": "copy data from file-like object fsrc to file-like object fdst",
      "relationships": [
        {
          "target": "stdlib.shutil.fsrc_read",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.fdst_write",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.shutil.copymode",
      "name": "copymode",
      "module": "shutil",
      "type": "function",
      "signature": "(src, dst, *, follow_symlinks=True)",
      "description": "Copy mode bits from src to dst.\n\nIf follow_symlinks is not set, symlinks aren't followed if and only\nif both `src` and `dst` are symlinks.  If `lchmod` isn't available\n(e.g. Linux) this method does nothing.",
      "relationships": [
        {
          "target": "stdlib.shutil.audit",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.stat_func",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.chmod_func",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil._islink",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.islink",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.hasattr",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.S_IMODE",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.shutil.copystat",
      "name": "copystat",
      "module": "shutil",
      "type": "function",
      "signature": "(src, dst, *, follow_symlinks=True)",
      "description": "Copy file metadata\n\nCopy the permission bits, last access time, last modification time, and\nflags from `src` to `dst`. On Linux, copystat() also copies the \"extended\nattributes\" where possible. The file contents, owner, and group are\nunaffected. `src` and `dst` are path-like objects or path names given as\nstrings.\n\nIf the optional flag `follow_symlinks` is not set, symlinks aren't\nfollowed if and only if both `src` and `dst` are symlinks.",
      "relationships": [
        {
          "target": "stdlib.shutil.audit",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.S_IMODE",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil._copyxattr",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.hasattr",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.stat",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.lookup",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.getattr",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.getattr",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.lookup",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.lookup",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil._islink",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.islink",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.lookup",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.hasattr",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.getattr",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.shutil.copytree",
      "name": "copytree",
      "module": "shutil",
      "type": "function",
      "signature": "(src, dst, symlinks=False, ignore=None, copy_function=<function copy2 at 0x108151160>, ignore_dangling_symlinks=False, dirs_exist_ok=False)",
      "description": "Recursively copy a directory tree and return the destination directory.\n\ndirs_exist_ok dictates whether to raise an exception in case dst or any\nmissing parent directory already exists.\n\nIf exception(s) occur, an Error is raised with a list of reasons.\n\nIf the optional symlinks flag is true, symbolic links in the\nsource tree result in symbolic links in the destination tree; if\nit is false, the contents of the files pointed to by symbolic\nlinks are copied. If the file pointed by the symlink doesn't\nexist, an exception will be added in the list of errors raised in\nan Error exception at the end of the copy process.\n\nYou can set the optional ignore_dangling_symlinks flag to true if you\nwant to silence this exception. Notice that this has no effect on\nplatforms that don't support os.symlink.\n\nThe optional ignore argument is a callable. If given, it\nis called with the `src` parameter, which is the directory\nbeing visited by copytree(), and `names` which is the list of\n`src` contents, as returned by os.listdir():\n\n    callable(src, names) -> ignored_names\n\nSince copytree() is called recursively, the callable will be\ncalled once for each directory that is copied. It returns a\nlist of names relative to the `src` directory that should\nnot be copied.\n\nThe optional copy_function argument is a callable that will be used\nto copy each file. It will be called with the source path and the\ndestination path as arguments. By default, copy2() is used, but any\nfunction that supports the same signature (like copy()) can be used.",
      "relationships": [
        {
          "target": "stdlib.shutil.audit",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil._copytree",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.scandir",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.list",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.shutil.disk_usage",
      "name": "disk_usage",
      "module": "shutil",
      "type": "function",
      "signature": "(path)",
      "description": "Return disk usage statistics about the given path.\n\nReturned value is a named tuple with attributes 'total', 'used' and\n'free', which are the amount of total, used and free space, in bytes.",
      "relationships": [
        {
          "target": "stdlib.shutil.statvfs",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil._ntuple_diskusage",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.shutil.get_archive_formats",
      "name": "get_archive_formats",
      "module": "shutil",
      "type": "function",
      "signature": "()",
      "description": "Returns a list of supported formats for archiving and unarchiving.\n\nEach element of the returned sequence is a tuple (name, description)",
      "relationships": [
        {
          "target": "stdlib.shutil.sort",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.items",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.shutil.get_terminal_size",
      "name": "get_terminal_size",
      "module": "shutil",
      "type": "function",
      "signature": "(fallback=(80, 24))",
      "description": "Get the size of the terminal window.\n\nFor each of the two dimensions, the environment variable, COLUMNS\nand LINES respectively, is checked. If the variable is defined and\nthe value is a positive integer, it is used.\n\nWhen COLUMNS or LINES is not defined, which is the common case,\nthe terminal connected to sys.__stdout__ is queried\nby invoking os.get_terminal_size.\n\nIf the terminal size cannot be successfully queried, either because\nthe system doesn't support querying, or because we are not\nconnected to a terminal, the value given in fallback parameter\nis used. Fallback defaults to (80, 24) which is the default\nsize used by many terminal emulators.\n\nThe value returned is a named tuple of type os.terminal_size.",
      "relationships": [
        {
          "target": "stdlib.shutil.terminal_size",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.int",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.int",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.get_terminal_size",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.fileno",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.terminal_size",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.shutil.get_unpack_formats",
      "name": "get_unpack_formats",
      "module": "shutil",
      "type": "function",
      "signature": "()",
      "description": "Returns a list of supported formats for unpacking.\n\nEach element of the returned sequence is a tuple\n(name, extensions, description)",
      "relationships": [
        {
          "target": "stdlib.shutil.sort",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.items",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.shutil.ignore_patterns",
      "name": "ignore_patterns",
      "module": "shutil",
      "type": "function",
      "signature": "(*patterns)",
      "description": "Function that can be used as copytree() ignore parameter.\n\nPatterns is a sequence of glob-style patterns\nthat are used to exclude files",
      "relationships": [
        {
          "target": "stdlib.shutil.set",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.extend",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.filter",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.shutil.make_archive",
      "name": "make_archive",
      "module": "shutil",
      "type": "function",
      "signature": "(base_name, format, root_dir=None, base_dir=None, verbose=0, dry_run=0, owner=None, group=None, logger=None)",
      "description": "Create an archive file (eg. zip or tar).\n\n'base_name' is the name of the file to create, minus any format-specific\nextension; 'format' is the archive format: one of \"zip\", \"tar\", \"gztar\",\n\"bztar\", or \"xztar\".  Or any other registered format.\n\n'root_dir' is a directory that will be the root directory of the\narchive; ie. we typically chdir into 'root_dir' before creating the\narchive.  'base_dir' is the directory where we start archiving from;\nie. 'base_dir' will be the common prefix of all files and\ndirectories in the archive.  'root_dir' and 'base_dir' both default\nto the current directory.  Returns the name of the archive file.\n\n'owner' and 'group' are used when creating a tar archive. By default,\nuses the current owner and group.",
      "relationships": [
        {
          "target": "stdlib.shutil.audit",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.getcwd",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.abspath",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.func",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.debug",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.chdir",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.chdir",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.debug",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.shutil.move",
      "name": "move",
      "module": "shutil",
      "type": "function",
      "signature": "(src, dst, copy_function=<function copy2 at 0x108151160>)",
      "description": "Recursively move a file or directory to another location. This is\nsimilar to the Unix \"mv\" command. Return the file or directory's\ndestination.\n\nIf the destination is a directory or a symlink to a directory, the source\nis moved inside the directory. The destination path must not already\nexist.\n\nIf the destination already exists but is not a directory, it may be\noverwritten depending on os.rename() semantics.\n\nIf the destination is on our current filesystem, then rename() is used.\nOtherwise, src is copied to the destination and then removed. Symlinks are\nrecreated under the new name if os.rename() fails because of cross\nfilesystem renames.\n\nThe optional `copy_function` argument is a callable that will be used\nto copy the source or it will be delegated to `copytree`.\nBy default, copy2() is used, but any function that supports the same\nsignature (like copy()) can be used.\n\nA lot more could be done here...  A look at a mv.c shows a lot of\nthe issues this implementation glosses over.",
      "relationships": [
        {
          "target": "stdlib.shutil.audit",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.isdir",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil._samefile",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.join",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.exists",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.rename",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.rename",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil._basename",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.Error",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.islink",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.readlink",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.symlink",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.unlink",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.isdir",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil._destinsrc",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.copytree",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.rmtree",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.copy_function",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.unlink",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.Error",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil._is_immutable",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.PermissionError",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.listdir",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.access",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.shutil.register_archive_format",
      "name": "register_archive_format",
      "module": "shutil",
      "type": "function",
      "signature": "(name, function, extra_args=None, description='')",
      "description": "Registers an archive format.\n\nname is the name of the format. function is the callable that will be\nused to create archives. If provided, extra_args is a sequence of\n(name, value) tuples that will be passed as arguments to the callable.\ndescription can be provided to describe the format, and will be returned\nby the get_archive_formats() function.",
      "relationships": [
        {
          "target": "stdlib.shutil.callable",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.len",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.shutil.register_unpack_format",
      "name": "register_unpack_format",
      "module": "shutil",
      "type": "function",
      "signature": "(name, extensions, function, extra_args=None, description='')",
      "description": "Registers an unpack format.\n\n`name` is the name of the format. `extensions` is a list of extensions\ncorresponding to the format.\n\n`function` is the callable that will be\nused to unpack archives. The callable will receive archives to unpack.\nIf it's unable to handle an archive, it needs to raise a ReadError\nexception.\n\nIf provided, `extra_args` is a sequence of\n(name, value) tuples that will be passed as arguments to the callable.\ndescription can be provided to describe the format, and will be returned\nby the get_unpack_formats() function.",
      "relationships": [
        {
          "target": "stdlib.shutil._check_unpack_options",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.shutil.rmtree",
      "name": "rmtree",
      "module": "shutil",
      "type": "function",
      "signature": "(path, ignore_errors=False, onerror=None)",
      "description": "Recursively delete a directory tree.\n\nIf ignore_errors is set, errors are ignored; otherwise, if onerror\nis set, it is called to handle the error with arguments (func,\npath, exc_info) where func is platform and implementation dependent;\npath is the argument to that function that caused it to fail; and\nexc_info is a tuple returned by sys.exc_info().  If ignore_errors\nis false and onerror is None, an exception is raised.",
      "relationships": [
        {
          "target": "stdlib.shutil.audit",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil._rmtree_unsafe",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.fsdecode",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.lstat",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.open",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.samestat",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.close",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil._rmtree_islink",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.onerror",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.onerror",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.fstat",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil._rmtree_safe_fd",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.OSError",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.onerror",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.exc_info",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.exc_info",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.rmdir",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.OSError",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.exc_info",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.onerror",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.onerror",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.exc_info",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.exc_info",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.shutil.unpack_archive",
      "name": "unpack_archive",
      "module": "shutil",
      "type": "function",
      "signature": "(filename, extract_dir=None, format=None)",
      "description": "Unpack an archive.\n\n`filename` is the name of the archive.\n\n`extract_dir` is the name of the target directory, where the archive\nis unpacked. If not provided, the current working directory is used.\n\n`format` is the archive format: one of \"zip\", \"tar\", \"gztar\", \"bztar\",\nor \"xztar\".  Or any other registered format.  If not provided,\nunpack_archive will use the filename extension and see if an unpacker\nwas registered for that extension.\n\nIn case none is found, a ValueError is raised.",
      "relationships": [
        {
          "target": "stdlib.shutil.audit",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.fspath",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.fspath",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.getcwd",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.func",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil._find_unpack_format",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.dict",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.func",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.ReadError",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.dict",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.format",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.format",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.shutil.unregister_archive_format",
      "name": "unregister_archive_format",
      "module": "shutil",
      "type": "function",
      "signature": "(name)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.shutil.unregister_unpack_format",
      "name": "unregister_unpack_format",
      "module": "shutil",
      "type": "function",
      "signature": "(name)",
      "description": "Removes the pack format from the registry.",
      "relationships": []
    },
    {
      "id": "stdlib.shutil.which",
      "name": "which",
      "module": "shutil",
      "type": "function",
      "signature": "(cmd, mode=1, path=None)",
      "description": "Given a command, mode, and a PATH string, return the path which\nconforms to the given mode on the PATH, or None if there is no such\nfile.\n\n`mode` defaults to os.F_OK | os.X_OK. `path` defaults to the result\nof os.environ.get(\"PATH\"), or can be overridden with a custom search\npath.",
      "relationships": [
        {
          "target": "stdlib.shutil.dirname",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.set",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil._access_check",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.get",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.fsencode",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.split",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.fsdecode",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.split",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.any",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.normcase",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.fsencode",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.fsencode",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.insert",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.getenv",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.add",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.confstr",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.split",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.fsencode",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.endswith",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.join",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil._access_check",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.lower",
          "type": "calls"
        },
        {
          "target": "stdlib.shutil.lower",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.signal.Handlers",
      "name": "Handlers",
      "module": "signal",
      "type": "class",
      "signature": "(value, names=None, *, module=None, qualname=None, type=None, start=1)",
      "description": "An enumeration.",
      "relationships": [
        {
          "target": "IntEnum",
          "type": "base_class"
        },
        {
          "target": "int",
          "type": "base_class"
        },
        {
          "target": "Enum",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.signal.Sigmasks",
      "name": "Sigmasks",
      "module": "signal",
      "type": "class",
      "signature": "(value, names=None, *, module=None, qualname=None, type=None, start=1)",
      "description": "An enumeration.",
      "relationships": [
        {
          "target": "IntEnum",
          "type": "base_class"
        },
        {
          "target": "int",
          "type": "base_class"
        },
        {
          "target": "Enum",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.signal.Signals",
      "name": "Signals",
      "module": "signal",
      "type": "class",
      "signature": "(value, names=None, *, module=None, qualname=None, type=None, start=1)",
      "description": "An enumeration.",
      "relationships": [
        {
          "target": "IntEnum",
          "type": "base_class"
        },
        {
          "target": "int",
          "type": "base_class"
        },
        {
          "target": "Enum",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.signal.getsignal",
      "name": "getsignal",
      "module": "signal",
      "type": "function",
      "signature": "(signalnum, /)",
      "description": "Return the current action for the given signal.\n\nThe return value can be:\n  SIG_IGN -- if the signal is being ignored\n  SIG_DFL -- if the default action for the signal is in effect\n  None    -- if an unknown handler is in effect\n  anything else -- the callable Python object used as a handler",
      "relationships": []
    },
    {
      "id": "stdlib.signal.pthread_sigmask",
      "name": "pthread_sigmask",
      "module": "signal",
      "type": "function",
      "signature": "(how, mask, /)",
      "description": "Fetch and/or change the signal mask of the calling thread.",
      "relationships": []
    },
    {
      "id": "stdlib.signal.signal",
      "name": "signal",
      "module": "signal",
      "type": "function",
      "signature": "(signalnum, handler, /)",
      "description": "Set the action for the given signal.\n\nThe action can be SIG_DFL, SIG_IGN, or a callable Python object.\nThe previous action is returned.  See getsignal() for possible return values.\n\n*** IMPORTANT NOTICE ***\nA signal handler function is called with two arguments:\nthe first is the signal number, the second is the interrupted stack frame.",
      "relationships": []
    },
    {
      "id": "stdlib.signal.sigpending",
      "name": "sigpending",
      "module": "signal",
      "type": "function",
      "signature": "()",
      "description": "Examine pending signals.\n\nReturns a set of signal numbers that are pending for delivery to\nthe calling thread.",
      "relationships": []
    },
    {
      "id": "stdlib.signal.sigwait",
      "name": "sigwait",
      "module": "signal",
      "type": "function",
      "signature": "(sigset, /)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.signal.valid_signals",
      "name": "valid_signals",
      "module": "signal",
      "type": "function",
      "signature": "()",
      "description": "Return a set of valid signal numbers on this platform.\n\nThe signal numbers returned by this function can be safely passed to\nfunctions like `pthread_sigmask`.",
      "relationships": []
    },
    {
      "id": "stdlib.site.abs_paths",
      "name": "abs_paths",
      "module": "site",
      "type": "function",
      "signature": "()",
      "description": "Set all module __file__ and __cached__ attributes to an absolute path",
      "relationships": [
        {
          "target": "stdlib.site.set",
          "type": "calls"
        },
        {
          "target": "stdlib.site.values",
          "type": "calls"
        },
        {
          "target": "stdlib.site.getattr",
          "type": "calls"
        },
        {
          "target": "stdlib.site.abspath",
          "type": "calls"
        },
        {
          "target": "stdlib.site.abspath",
          "type": "calls"
        },
        {
          "target": "stdlib.site.getattr",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.site.addpackage",
      "name": "addpackage",
      "module": "site",
      "type": "function",
      "signature": "(sitedir, name, known_paths)",
      "description": "Process a .pth file within the site-packages directory:\nFor each line in the file, either combine it with sitedir to a path\nand add that to known_paths, or execute it if it starts with 'import '.",
      "relationships": [
        {
          "target": "stdlib.site.join",
          "type": "calls"
        },
        {
          "target": "stdlib.site._init_pathinfo",
          "type": "calls"
        },
        {
          "target": "stdlib.site.TextIOWrapper",
          "type": "calls"
        },
        {
          "target": "stdlib.site.enumerate",
          "type": "calls"
        },
        {
          "target": "stdlib.site.open_code",
          "type": "calls"
        },
        {
          "target": "stdlib.site.startswith",
          "type": "calls"
        },
        {
          "target": "stdlib.site.startswith",
          "type": "calls"
        },
        {
          "target": "stdlib.site.rstrip",
          "type": "calls"
        },
        {
          "target": "stdlib.site.makepath",
          "type": "calls"
        },
        {
          "target": "stdlib.site.exec",
          "type": "calls"
        },
        {
          "target": "stdlib.site.exists",
          "type": "calls"
        },
        {
          "target": "stdlib.site.append",
          "type": "calls"
        },
        {
          "target": "stdlib.site.add",
          "type": "calls"
        },
        {
          "target": "stdlib.site.print",
          "type": "calls"
        },
        {
          "target": "stdlib.site.format_exception",
          "type": "calls"
        },
        {
          "target": "stdlib.site.print",
          "type": "calls"
        },
        {
          "target": "stdlib.site.format",
          "type": "calls"
        },
        {
          "target": "stdlib.site.splitlines",
          "type": "calls"
        },
        {
          "target": "stdlib.site.exc_info",
          "type": "calls"
        },
        {
          "target": "stdlib.site.print",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.site.addsitedir",
      "name": "addsitedir",
      "module": "site",
      "type": "function",
      "signature": "(sitedir, known_paths=None)",
      "description": "Add 'sitedir' argument to sys.path if missing and handle .pth files in\n'sitedir'",
      "relationships": [
        {
          "target": "stdlib.site.makepath",
          "type": "calls"
        },
        {
          "target": "stdlib.site.sorted",
          "type": "calls"
        },
        {
          "target": "stdlib.site._init_pathinfo",
          "type": "calls"
        },
        {
          "target": "stdlib.site.append",
          "type": "calls"
        },
        {
          "target": "stdlib.site.add",
          "type": "calls"
        },
        {
          "target": "stdlib.site.listdir",
          "type": "calls"
        },
        {
          "target": "stdlib.site.addpackage",
          "type": "calls"
        },
        {
          "target": "stdlib.site.endswith",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.site.addsitepackages",
      "name": "addsitepackages",
      "module": "site",
      "type": "function",
      "signature": "(known_paths, prefixes=None)",
      "description": "Add site-packages to sys.path",
      "relationships": [
        {
          "target": "stdlib.site.getsitepackages",
          "type": "calls"
        },
        {
          "target": "stdlib.site.isdir",
          "type": "calls"
        },
        {
          "target": "stdlib.site.addsitedir",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.site.addusersitepackages",
      "name": "addusersitepackages",
      "module": "site",
      "type": "function",
      "signature": "(known_paths)",
      "description": "Add a per user site-package to sys.path\n\nEach user has its own python directory with site-packages in the\nhome directory.",
      "relationships": [
        {
          "target": "stdlib.site.getusersitepackages",
          "type": "calls"
        },
        {
          "target": "stdlib.site.isdir",
          "type": "calls"
        },
        {
          "target": "stdlib.site.addsitedir",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.site.check_enableusersite",
      "name": "check_enableusersite",
      "module": "site",
      "type": "function",
      "signature": "()",
      "description": "Check if user site directory is safe for inclusion\n\nThe function tests for the command line flag (including environment var),\nprocess uid/gid equal to effective uid/gid.\n\nNone: Disabled for security reasons\nFalse: Disabled by user (command line option)\nTrue: Safe and enabled",
      "relationships": [
        {
          "target": "stdlib.site.hasattr",
          "type": "calls"
        },
        {
          "target": "stdlib.site.hasattr",
          "type": "calls"
        },
        {
          "target": "stdlib.site.hasattr",
          "type": "calls"
        },
        {
          "target": "stdlib.site.hasattr",
          "type": "calls"
        },
        {
          "target": "stdlib.site.geteuid",
          "type": "calls"
        },
        {
          "target": "stdlib.site.getuid",
          "type": "calls"
        },
        {
          "target": "stdlib.site.getegid",
          "type": "calls"
        },
        {
          "target": "stdlib.site.getgid",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.site.enablerlcompleter",
      "name": "enablerlcompleter",
      "module": "site",
      "type": "function",
      "signature": "()",
      "description": "Enable default readline configuration on interactive prompts, by\nregistering a sys.__interactivehook__.\n\nIf the readline module can be imported, the hook will set the Tab key\nas completion key and register ~/.python_history as history file.\nThis can be overridden in the sitecustomize or usercustomize module,\nor in a PYTHONSTARTUP file.",
      "relationships": [
        {
          "target": "stdlib.site.getattr",
          "type": "calls"
        },
        {
          "target": "stdlib.site.parse_and_bind",
          "type": "calls"
        },
        {
          "target": "stdlib.site.parse_and_bind",
          "type": "calls"
        },
        {
          "target": "stdlib.site.read_init_file",
          "type": "calls"
        },
        {
          "target": "stdlib.site.get_current_history_length",
          "type": "calls"
        },
        {
          "target": "stdlib.site.join",
          "type": "calls"
        },
        {
          "target": "stdlib.site.register",
          "type": "calls"
        },
        {
          "target": "stdlib.site.expanduser",
          "type": "calls"
        },
        {
          "target": "stdlib.site.read_history_file",
          "type": "calls"
        },
        {
          "target": "stdlib.site.write_history_file",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.site.execsitecustomize",
      "name": "execsitecustomize",
      "module": "site",
      "type": "function",
      "signature": "()",
      "description": "Run custom site specific code, if available.",
      "relationships": [
        {
          "target": "stdlib.site.excepthook",
          "type": "calls"
        },
        {
          "target": "stdlib.site.write",
          "type": "calls"
        },
        {
          "target": "stdlib.site.exc_info",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.site.execusercustomize",
      "name": "execusercustomize",
      "module": "site",
      "type": "function",
      "signature": "()",
      "description": "Run custom user specific code, if available.",
      "relationships": [
        {
          "target": "stdlib.site.excepthook",
          "type": "calls"
        },
        {
          "target": "stdlib.site.write",
          "type": "calls"
        },
        {
          "target": "stdlib.site.exc_info",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.site.getsitepackages",
      "name": "getsitepackages",
      "module": "site",
      "type": "function",
      "signature": "(prefixes=None)",
      "description": "Returns a list containing all global site-packages directories.\n\nFor each directory present in ``prefixes`` (or the global ``PREFIXES``),\nthis function will find its `site-packages` subdirectory depending on the\nsystem environment, and will return a list of full paths.",
      "relationships": [
        {
          "target": "stdlib.site.set",
          "type": "calls"
        },
        {
          "target": "stdlib.site.add",
          "type": "calls"
        },
        {
          "target": "stdlib.site.append",
          "type": "calls"
        },
        {
          "target": "stdlib.site.append",
          "type": "calls"
        },
        {
          "target": "stdlib.site.endswith",
          "type": "calls"
        },
        {
          "target": "stdlib.site.dirname",
          "type": "calls"
        },
        {
          "target": "stdlib.site.join",
          "type": "calls"
        },
        {
          "target": "stdlib.site.append",
          "type": "calls"
        },
        {
          "target": "stdlib.site.join",
          "type": "calls"
        },
        {
          "target": "stdlib.site.append",
          "type": "calls"
        },
        {
          "target": "stdlib.site.dirname",
          "type": "calls"
        },
        {
          "target": "stdlib.site.append",
          "type": "calls"
        },
        {
          "target": "stdlib.site.endswith",
          "type": "calls"
        },
        {
          "target": "stdlib.site.append",
          "type": "calls"
        },
        {
          "target": "stdlib.site.append",
          "type": "calls"
        },
        {
          "target": "stdlib.site.append",
          "type": "calls"
        },
        {
          "target": "stdlib.site.dirname",
          "type": "calls"
        },
        {
          "target": "stdlib.site.join",
          "type": "calls"
        },
        {
          "target": "stdlib.site.join",
          "type": "calls"
        },
        {
          "target": "stdlib.site.join",
          "type": "calls"
        },
        {
          "target": "stdlib.site.join",
          "type": "calls"
        },
        {
          "target": "stdlib.site.endswith",
          "type": "calls"
        },
        {
          "target": "stdlib.site.endswith",
          "type": "calls"
        },
        {
          "target": "stdlib.site.dirname",
          "type": "calls"
        },
        {
          "target": "stdlib.site.endswith",
          "type": "calls"
        },
        {
          "target": "stdlib.site.dirname",
          "type": "calls"
        },
        {
          "target": "stdlib.site.dirname",
          "type": "calls"
        },
        {
          "target": "stdlib.site.dirname",
          "type": "calls"
        },
        {
          "target": "stdlib.site.dirname",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.site.getuserbase",
      "name": "getuserbase",
      "module": "site",
      "type": "function",
      "signature": "()",
      "description": "Returns the `user base` directory path.\n\nThe `user base` directory can be used to store data. If the global\nvariable ``USER_BASE`` is not initialized yet, this function will also set\nit.",
      "relationships": [
        {
          "target": "stdlib.site._getuserbase",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.site.getusersitepackages",
      "name": "getusersitepackages",
      "module": "site",
      "type": "function",
      "signature": "()",
      "description": "Returns the user-specific site-packages directory path.\n\nIf the global variable ``USER_SITE`` is not initialized yet, this\nfunction will also set it.",
      "relationships": [
        {
          "target": "stdlib.site.getuserbase",
          "type": "calls"
        },
        {
          "target": "stdlib.site._get_path",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.site.main",
      "name": "main",
      "module": "site",
      "type": "function",
      "signature": "()",
      "description": "Add standard site-specific directories to the module search path.\n\nThis function is called automatically when this module is imported,\nunless the python interpreter was started with the -S flag.",
      "relationships": [
        {
          "target": "stdlib.site.removeduppaths",
          "type": "calls"
        },
        {
          "target": "stdlib.site.venv",
          "type": "calls"
        },
        {
          "target": "stdlib.site.addusersitepackages",
          "type": "calls"
        },
        {
          "target": "stdlib.site.addsitepackages",
          "type": "calls"
        },
        {
          "target": "stdlib.site.setquit",
          "type": "calls"
        },
        {
          "target": "stdlib.site.setcopyright",
          "type": "calls"
        },
        {
          "target": "stdlib.site.sethelper",
          "type": "calls"
        },
        {
          "target": "stdlib.site.execsitecustomize",
          "type": "calls"
        },
        {
          "target": "stdlib.site.abs_paths",
          "type": "calls"
        },
        {
          "target": "stdlib.site.check_enableusersite",
          "type": "calls"
        },
        {
          "target": "stdlib.site.enablerlcompleter",
          "type": "calls"
        },
        {
          "target": "stdlib.site.execusercustomize",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.site.makepath",
      "name": "makepath",
      "module": "site",
      "type": "function",
      "signature": "(*paths)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.site.join",
          "type": "calls"
        },
        {
          "target": "stdlib.site.abspath",
          "type": "calls"
        },
        {
          "target": "stdlib.site.normcase",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.site.removeduppaths",
      "name": "removeduppaths",
      "module": "site",
      "type": "function",
      "signature": "()",
      "description": "Remove duplicate entries from sys.path along with making them\nabsolute",
      "relationships": [
        {
          "target": "stdlib.site.set",
          "type": "calls"
        },
        {
          "target": "stdlib.site.makepath",
          "type": "calls"
        },
        {
          "target": "stdlib.site.append",
          "type": "calls"
        },
        {
          "target": "stdlib.site.add",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.site.setcopyright",
      "name": "setcopyright",
      "module": "site",
      "type": "function",
      "signature": "()",
      "description": "Set 'copyright' and 'credits' in builtins",
      "relationships": [
        {
          "target": "stdlib.site._Printer",
          "type": "calls"
        },
        {
          "target": "stdlib.site.hasattr",
          "type": "calls"
        },
        {
          "target": "stdlib.site._Printer",
          "type": "calls"
        },
        {
          "target": "stdlib.site._Printer",
          "type": "calls"
        },
        {
          "target": "stdlib.site._Printer",
          "type": "calls"
        },
        {
          "target": "stdlib.site.dirname",
          "type": "calls"
        },
        {
          "target": "stdlib.site.extend",
          "type": "calls"
        },
        {
          "target": "stdlib.site.extend",
          "type": "calls"
        },
        {
          "target": "stdlib.site.join",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.site.sethelper",
      "name": "sethelper",
      "module": "site",
      "type": "function",
      "signature": "()",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.site._Helper",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.site.setquit",
      "name": "setquit",
      "module": "site",
      "type": "function",
      "signature": "()",
      "description": "Define new builtins 'quit' and 'exit'.\n\nThese are objects which make the interpreter exit when called.\nThe repr of each object contains a hint at how it works.",
      "relationships": [
        {
          "target": "stdlib.site.Quitter",
          "type": "calls"
        },
        {
          "target": "stdlib.site.Quitter",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.site.venv",
      "name": "venv",
      "module": "site",
      "type": "function",
      "signature": "(known_paths)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.site.split",
          "type": "calls"
        },
        {
          "target": "stdlib.site.dirname",
          "type": "calls"
        },
        {
          "target": "stdlib.site.abspath",
          "type": "calls"
        },
        {
          "target": "stdlib.site.addsitepackages",
          "type": "calls"
        },
        {
          "target": "stdlib.site.isfile",
          "type": "calls"
        },
        {
          "target": "stdlib.site.open",
          "type": "calls"
        },
        {
          "target": "stdlib.site.insert",
          "type": "calls"
        },
        {
          "target": "stdlib.site.join",
          "type": "calls"
        },
        {
          "target": "stdlib.site.join",
          "type": "calls"
        },
        {
          "target": "stdlib.site.partition",
          "type": "calls"
        },
        {
          "target": "stdlib.site.lower",
          "type": "calls"
        },
        {
          "target": "stdlib.site.strip",
          "type": "calls"
        },
        {
          "target": "stdlib.site.lower",
          "type": "calls"
        },
        {
          "target": "stdlib.site.strip",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.smtpd.DebuggingServer",
      "name": "DebuggingServer",
      "module": "smtpd",
      "type": "class",
      "signature": "(localaddr, remoteaddr, data_size_limit=33554432, map=None, enable_SMTPUTF8=False, decode_data=False)",
      "description": "",
      "relationships": [
        {
          "target": "SMTPServer",
          "type": "base_class"
        },
        {
          "target": "dispatcher",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.smtpd.Devnull",
      "name": "Devnull",
      "module": "smtpd",
      "type": "class",
      "signature": "()",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.smtpd.MailmanProxy",
      "name": "MailmanProxy",
      "module": "smtpd",
      "type": "class",
      "signature": "(*args, **kwargs)",
      "description": "",
      "relationships": [
        {
          "target": "PureProxy",
          "type": "base_class"
        },
        {
          "target": "SMTPServer",
          "type": "base_class"
        },
        {
          "target": "dispatcher",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.smtpd.Options",
      "name": "Options",
      "module": "smtpd",
      "type": "class",
      "signature": "()",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.smtpd.PureProxy",
      "name": "PureProxy",
      "module": "smtpd",
      "type": "class",
      "signature": "(*args, **kwargs)",
      "description": "",
      "relationships": [
        {
          "target": "SMTPServer",
          "type": "base_class"
        },
        {
          "target": "dispatcher",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.smtpd.SMTPChannel",
      "name": "SMTPChannel",
      "module": "smtpd",
      "type": "class",
      "signature": "(server, conn, addr, data_size_limit=33554432, map=None, enable_SMTPUTF8=False, decode_data=False)",
      "description": "This is an abstract class.  You must derive from this class, and add\nthe two methods collect_incoming_data() and found_terminator()",
      "relationships": [
        {
          "target": "async_chat",
          "type": "base_class"
        },
        {
          "target": "dispatcher",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.smtpd.SMTPServer",
      "name": "SMTPServer",
      "module": "smtpd",
      "type": "class",
      "signature": "(localaddr, remoteaddr, data_size_limit=33554432, map=None, enable_SMTPUTF8=False, decode_data=False)",
      "description": "",
      "relationships": [
        {
          "target": "dispatcher",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.smtpd.get_addr_spec",
      "name": "get_addr_spec",
      "module": "smtpd",
      "type": "function",
      "signature": "(value)",
      "description": "addr-spec = local-part \"@\" domain\n\n    ",
      "relationships": [
        {
          "target": "stdlib.smtpd.AddrSpec",
          "type": "calls"
        },
        {
          "target": "stdlib.smtpd.get_local_part",
          "type": "calls"
        },
        {
          "target": "stdlib.smtpd.append",
          "type": "calls"
        },
        {
          "target": "stdlib.smtpd.append",
          "type": "calls"
        },
        {
          "target": "stdlib.smtpd.get_domain",
          "type": "calls"
        },
        {
          "target": "stdlib.smtpd.append",
          "type": "calls"
        },
        {
          "target": "stdlib.smtpd.append",
          "type": "calls"
        },
        {
          "target": "stdlib.smtpd.ValueTerminal",
          "type": "calls"
        },
        {
          "target": "stdlib.smtpd.InvalidHeaderDefect",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.smtpd.get_angle_addr",
      "name": "get_angle_addr",
      "module": "smtpd",
      "type": "function",
      "signature": "(value)",
      "description": "angle-addr = [CFWS] \"<\" addr-spec \">\" [CFWS] / obs-angle-addr\nobs-angle-addr = [CFWS] \"<\" obs-route addr-spec \">\" [CFWS]",
      "relationships": [
        {
          "target": "stdlib.smtpd.AngleAddr",
          "type": "calls"
        },
        {
          "target": "stdlib.smtpd.append",
          "type": "calls"
        },
        {
          "target": "stdlib.smtpd.append",
          "type": "calls"
        },
        {
          "target": "stdlib.smtpd.append",
          "type": "calls"
        },
        {
          "target": "stdlib.smtpd.get_cfws",
          "type": "calls"
        },
        {
          "target": "stdlib.smtpd.append",
          "type": "calls"
        },
        {
          "target": "stdlib.smtpd.HeaderParseError",
          "type": "calls"
        },
        {
          "target": "stdlib.smtpd.ValueTerminal",
          "type": "calls"
        },
        {
          "target": "stdlib.smtpd.append",
          "type": "calls"
        },
        {
          "target": "stdlib.smtpd.append",
          "type": "calls"
        },
        {
          "target": "stdlib.smtpd.get_addr_spec",
          "type": "calls"
        },
        {
          "target": "stdlib.smtpd.append",
          "type": "calls"
        },
        {
          "target": "stdlib.smtpd.ValueTerminal",
          "type": "calls"
        },
        {
          "target": "stdlib.smtpd.get_cfws",
          "type": "calls"
        },
        {
          "target": "stdlib.smtpd.append",
          "type": "calls"
        },
        {
          "target": "stdlib.smtpd.format",
          "type": "calls"
        },
        {
          "target": "stdlib.smtpd.ValueTerminal",
          "type": "calls"
        },
        {
          "target": "stdlib.smtpd.InvalidHeaderDefect",
          "type": "calls"
        },
        {
          "target": "stdlib.smtpd.append",
          "type": "calls"
        },
        {
          "target": "stdlib.smtpd.get_addr_spec",
          "type": "calls"
        },
        {
          "target": "stdlib.smtpd.InvalidHeaderDefect",
          "type": "calls"
        },
        {
          "target": "stdlib.smtpd.get_obs_route",
          "type": "calls"
        },
        {
          "target": "stdlib.smtpd.append",
          "type": "calls"
        },
        {
          "target": "stdlib.smtpd.ObsoleteHeaderDefect",
          "type": "calls"
        },
        {
          "target": "stdlib.smtpd.HeaderParseError",
          "type": "calls"
        },
        {
          "target": "stdlib.smtpd.format",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.smtpd.parseargs",
      "name": "parseargs",
      "module": "smtpd",
      "type": "function",
      "signature": "()",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.smtpd.Options",
          "type": "calls"
        },
        {
          "target": "stdlib.smtpd.find",
          "type": "calls"
        },
        {
          "target": "stdlib.smtpd.find",
          "type": "calls"
        },
        {
          "target": "stdlib.smtpd.getopt",
          "type": "calls"
        },
        {
          "target": "stdlib.smtpd.len",
          "type": "calls"
        },
        {
          "target": "stdlib.smtpd.usage",
          "type": "calls"
        },
        {
          "target": "stdlib.smtpd.int",
          "type": "calls"
        },
        {
          "target": "stdlib.smtpd.usage",
          "type": "calls"
        },
        {
          "target": "stdlib.smtpd.int",
          "type": "calls"
        },
        {
          "target": "stdlib.smtpd.usage",
          "type": "calls"
        },
        {
          "target": "stdlib.smtpd.usage",
          "type": "calls"
        },
        {
          "target": "stdlib.smtpd.len",
          "type": "calls"
        },
        {
          "target": "stdlib.smtpd.usage",
          "type": "calls"
        },
        {
          "target": "stdlib.smtpd.usage",
          "type": "calls"
        },
        {
          "target": "stdlib.smtpd.print",
          "type": "calls"
        },
        {
          "target": "stdlib.smtpd.exit",
          "type": "calls"
        },
        {
          "target": "stdlib.smtpd.len",
          "type": "calls"
        },
        {
          "target": "stdlib.smtpd.usage",
          "type": "calls"
        },
        {
          "target": "stdlib.smtpd.join",
          "type": "calls"
        },
        {
          "target": "stdlib.smtpd.int",
          "type": "calls"
        },
        {
          "target": "stdlib.smtpd.print",
          "type": "calls"
        },
        {
          "target": "stdlib.smtpd.exit",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.smtpd.usage",
      "name": "usage",
      "module": "smtpd",
      "type": "function",
      "signature": "(code, msg='')",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.smtpd.print",
          "type": "calls"
        },
        {
          "target": "stdlib.smtpd.exit",
          "type": "calls"
        },
        {
          "target": "stdlib.smtpd.print",
          "type": "calls"
        },
        {
          "target": "stdlib.smtpd.globals",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.smtplib.LMTP",
      "name": "LMTP",
      "module": "smtplib",
      "type": "class",
      "signature": "(host='', port=2003, local_hostname=None, source_address=None, timeout=<object object at 0x102f70e60>)",
      "description": "LMTP - Local Mail Transfer Protocol\n\nThe LMTP protocol, which is very similar to ESMTP, is heavily based\non the standard SMTP client. It's common to use Unix sockets for\nLMTP, so our connect() method must support that as well as a regular\nhost:port server.  local_hostname and source_address have the same\nmeaning as they do in the SMTP class.  To specify a Unix socket,\nyou must use an absolute path as the host, starting with a '/'.\n\nAuthentication is supported, using the regular SMTP mechanism. When\nusing a Unix socket, LMTP generally don't support or require any\nauthentication, but your mileage might vary.",
      "relationships": [
        {
          "target": "SMTP",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.smtplib.SMTP",
      "name": "SMTP",
      "module": "smtplib",
      "type": "class",
      "signature": "(host='', port=0, local_hostname=None, timeout=<object object at 0x102f70e60>, source_address=None)",
      "description": "This class manages a connection to an SMTP or ESMTP server.\nSMTP Objects:\n    SMTP objects have the following attributes:\n        helo_resp\n            This is the message given by the server in response to the\n            most recent HELO command.\n\n        ehlo_resp\n            This is the message given by the server in response to the\n            most recent EHLO command. This is usually multiline.\n\n        does_esmtp\n            This is a True value _after you do an EHLO command_, if the\n            server supports ESMTP.\n\n        esmtp_features\n            This is a dictionary, which, if the server supports ESMTP,\n            will _after you do an EHLO command_, contain the names of the\n            SMTP service extensions this server supports, and their\n            parameters (if any).\n\n            Note, all extension names are mapped to lower case in the\n            dictionary.\n\n    See each method's docstrings for details.  In general, there is a\n    method of the same name to perform each SMTP command.  There is also a\n    method called 'sendmail' that will do an entire mail transaction.\n    ",
      "relationships": []
    },
    {
      "id": "stdlib.smtplib.SMTPAuthenticationError",
      "name": "SMTPAuthenticationError",
      "module": "smtplib",
      "type": "class",
      "signature": "(code, msg)",
      "description": "Authentication error.\n\nMost probably the server didn't accept the username/password\ncombination provided.",
      "relationships": [
        {
          "target": "SMTPResponseException",
          "type": "base_class"
        },
        {
          "target": "SMTPException",
          "type": "base_class"
        },
        {
          "target": "OSError",
          "type": "base_class"
        },
        {
          "target": "Exception",
          "type": "base_class"
        },
        {
          "target": "BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.smtplib.SMTPConnectError",
      "name": "SMTPConnectError",
      "module": "smtplib",
      "type": "class",
      "signature": "(code, msg)",
      "description": "Error during connection establishment.",
      "relationships": [
        {
          "target": "SMTPResponseException",
          "type": "base_class"
        },
        {
          "target": "SMTPException",
          "type": "base_class"
        },
        {
          "target": "OSError",
          "type": "base_class"
        },
        {
          "target": "Exception",
          "type": "base_class"
        },
        {
          "target": "BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.smtplib.SMTPDataError",
      "name": "SMTPDataError",
      "module": "smtplib",
      "type": "class",
      "signature": "(code, msg)",
      "description": "The SMTP server didn't accept the data.",
      "relationships": [
        {
          "target": "SMTPResponseException",
          "type": "base_class"
        },
        {
          "target": "SMTPException",
          "type": "base_class"
        },
        {
          "target": "OSError",
          "type": "base_class"
        },
        {
          "target": "Exception",
          "type": "base_class"
        },
        {
          "target": "BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.smtplib.SMTPHeloError",
      "name": "SMTPHeloError",
      "module": "smtplib",
      "type": "class",
      "signature": "(code, msg)",
      "description": "The server refused our HELO reply.",
      "relationships": [
        {
          "target": "SMTPResponseException",
          "type": "base_class"
        },
        {
          "target": "SMTPException",
          "type": "base_class"
        },
        {
          "target": "OSError",
          "type": "base_class"
        },
        {
          "target": "Exception",
          "type": "base_class"
        },
        {
          "target": "BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.smtplib.SMTPRecipientsRefused",
      "name": "SMTPRecipientsRefused",
      "module": "smtplib",
      "type": "class",
      "signature": "(recipients)",
      "description": "All recipient addresses refused.\n\nThe errors for each recipient are accessible through the attribute\n'recipients', which is a dictionary of exactly the same sort as\nSMTP.sendmail() returns.",
      "relationships": [
        {
          "target": "SMTPException",
          "type": "base_class"
        },
        {
          "target": "OSError",
          "type": "base_class"
        },
        {
          "target": "Exception",
          "type": "base_class"
        },
        {
          "target": "BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.smtplib.SMTPResponseException",
      "name": "SMTPResponseException",
      "module": "smtplib",
      "type": "class",
      "signature": "(code, msg)",
      "description": "Base class for all exceptions that include an SMTP error code.\n\nThese exceptions are generated in some instances when the SMTP\nserver returns an error code.  The error code is stored in the\n`smtp_code' attribute of the error, and the `smtp_error' attribute\nis set to the error message.",
      "relationships": [
        {
          "target": "SMTPException",
          "type": "base_class"
        },
        {
          "target": "OSError",
          "type": "base_class"
        },
        {
          "target": "Exception",
          "type": "base_class"
        },
        {
          "target": "BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.smtplib.SMTPSenderRefused",
      "name": "SMTPSenderRefused",
      "module": "smtplib",
      "type": "class",
      "signature": "(code, msg, sender)",
      "description": "Sender address refused.\n\nIn addition to the attributes set by on all SMTPResponseException\nexceptions, this sets `sender' to the string that the SMTP refused.",
      "relationships": [
        {
          "target": "SMTPResponseException",
          "type": "base_class"
        },
        {
          "target": "SMTPException",
          "type": "base_class"
        },
        {
          "target": "OSError",
          "type": "base_class"
        },
        {
          "target": "Exception",
          "type": "base_class"
        },
        {
          "target": "BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.smtplib.SMTP_SSL",
      "name": "SMTP_SSL",
      "module": "smtplib",
      "type": "class",
      "signature": "(host='', port=0, local_hostname=None, keyfile=None, certfile=None, timeout=<object object at 0x102f70e60>, source_address=None, context=None)",
      "description": "This is a subclass derived from SMTP that connects over an SSL\nencrypted socket (to use this class you need a socket module that was\ncompiled with SSL support). If host is not specified, '' (the local\nhost) is used. If port is omitted, the standard SMTP-over-SSL port\n(465) is used.  local_hostname and source_address have the same meaning\nas they do in the SMTP class.  keyfile and certfile are also optional -\nthey can contain a PEM formatted private key and certificate chain file\nfor the SSL connection. context also optional, can contain a\nSSLContext, and is an alternative to keyfile and certfile; If it is\nspecified both keyfile and certfile must be None.",
      "relationships": [
        {
          "target": "SMTP",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.smtplib.encode_base64",
      "name": "encode_base64",
      "module": "smtplib",
      "type": "function",
      "signature": "(s, maxlinelen=76, eol='\\n')",
      "description": "Encode a string with base64.\n\nEach line will be wrapped at, at most, maxlinelen characters (defaults to\n76 characters).\n\nEach line of encoded text will end with eol, which defaults to \"\\n\".  Set\nthis to \"\\r\\n\" if you will be using the result of this function directly\nin an email.",
      "relationships": [
        {
          "target": "stdlib.smtplib.range",
          "type": "calls"
        },
        {
          "target": "stdlib.smtplib.join",
          "type": "calls"
        },
        {
          "target": "stdlib.smtplib.len",
          "type": "calls"
        },
        {
          "target": "stdlib.smtplib.decode",
          "type": "calls"
        },
        {
          "target": "stdlib.smtplib.append",
          "type": "calls"
        },
        {
          "target": "stdlib.smtplib.endswith",
          "type": "calls"
        },
        {
          "target": "stdlib.smtplib.b2a_base64",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.smtplib.quoteaddr",
      "name": "quoteaddr",
      "module": "smtplib",
      "type": "function",
      "signature": "(addrstring)",
      "description": "Quote a subset of the email addresses defined by RFC 821.\n\nShould be able to handle anything email.utils.parseaddr can handle.",
      "relationships": [
        {
          "target": "stdlib.smtplib.parseaddr",
          "type": "calls"
        },
        {
          "target": "stdlib.smtplib.startswith",
          "type": "calls"
        },
        {
          "target": "stdlib.smtplib.strip",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.smtplib.quotedata",
      "name": "quotedata",
      "module": "smtplib",
      "type": "function",
      "signature": "(data)",
      "description": "Quote data for email.\n\nDouble leading '.', and change Unix newline '\\n', or Mac '\\r' into\nInternet CRLF end-of-line.",
      "relationships": [
        {
          "target": "stdlib.smtplib.sub",
          "type": "calls"
        },
        {
          "target": "stdlib.smtplib.sub",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.sndhdr.SndHeaders",
      "name": "SndHeaders",
      "module": "sndhdr",
      "type": "class",
      "signature": "(filetype, framerate, nchannels, nframes, sampwidth)",
      "description": "SndHeaders(filetype, framerate, nchannels, nframes, sampwidth)",
      "relationships": [
        {
          "target": "tuple",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.sndhdr.get_long_be",
      "name": "get_long_be",
      "module": "sndhdr",
      "type": "function",
      "signature": "(b)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.sndhdr.get_long_le",
      "name": "get_long_le",
      "module": "sndhdr",
      "type": "function",
      "signature": "(b)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.sndhdr.get_short_be",
      "name": "get_short_be",
      "module": "sndhdr",
      "type": "function",
      "signature": "(b)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.sndhdr.get_short_le",
      "name": "get_short_le",
      "module": "sndhdr",
      "type": "function",
      "signature": "(b)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.sndhdr.namedtuple",
      "name": "namedtuple",
      "module": "sndhdr",
      "type": "function",
      "signature": "(typename, field_names, *, rename=False, defaults=None, module=None)",
      "description": "Returns a new subclass of tuple with named fields.\n\n>>> Point = namedtuple('Point', ['x', 'y'])\n>>> Point.__doc__                   # docstring for the new class\n'Point(x, y)'\n>>> p = Point(11, y=22)             # instantiate with positional args or keywords\n>>> p[0] + p[1]                     # indexable like a plain tuple\n33\n>>> x, y = p                        # unpack like a regular tuple\n>>> x, y\n(11, 22)\n>>> p.x + p.y                       # fields also accessible by name\n33\n>>> d = p._asdict()                 # convert to a dictionary\n>>> d['x']\n11\n>>> Point(**d)                      # convert from a dictionary\nPoint(x=11, y=22)\n>>> p._replace(x=100)               # _replace() is like str.replace() but targets named fields\nPoint(x=100, y=22)",
      "relationships": [
        {
          "target": "stdlib.sndhdr.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.list",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.intern",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.set",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.tuple",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.len",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.join",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.eval",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.enumerate",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.type",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.split",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.map",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.str",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.set",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.enumerate",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr._iskeyword",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.add",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.tuple",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.dict",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.map",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.tuple_new",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr._make",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr._dict",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr._tuple",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.intern",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr._tuplegetter",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.add",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.type",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.isidentifier",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.startswith",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.len",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.len",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.reversed",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.join",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr._len",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr._map",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr._zip",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.get",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.replace",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr._iskeyword",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.startswith",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.list",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.isidentifier",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.zip",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.reversed",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.reversed",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.len",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.list",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr._getframe",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.sndhdr.test",
      "name": "test",
      "module": "sndhdr",
      "type": "function",
      "signature": "()",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.sndhdr.testall",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.testall",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.write",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.exit",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.sndhdr.test_8svx",
      "name": "test_8svx",
      "module": "sndhdr",
      "type": "function",
      "signature": "(h, f)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.sndhdr.startswith",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.sndhdr.test_aifc",
      "name": "test_aifc",
      "module": "sndhdr",
      "type": "function",
      "signature": "(h, f)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.sndhdr.seek",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.startswith",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.open",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.getframerate",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.getnchannels",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.getnframes",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.getsampwidth",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.sndhdr.test_au",
      "name": "test_au",
      "module": "sndhdr",
      "type": "function",
      "signature": "(h, f)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.sndhdr.startswith",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.func",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.func",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.func",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.func",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.func",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.sndhdr.test_hcom",
      "name": "test_hcom",
      "module": "sndhdr",
      "type": "function",
      "signature": "(h, f)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.sndhdr.get_long_be",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.sndhdr.test_sndr",
      "name": "test_sndr",
      "module": "sndhdr",
      "type": "function",
      "signature": "(h, f)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.sndhdr.startswith",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.get_short_le",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.sndhdr.test_sndt",
      "name": "test_sndt",
      "module": "sndhdr",
      "type": "function",
      "signature": "(h, f)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.sndhdr.startswith",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.get_long_le",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.get_short_le",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.sndhdr.test_voc",
      "name": "test_voc",
      "module": "sndhdr",
      "type": "function",
      "signature": "(h, f)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.sndhdr.get_short_le",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.startswith",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.int",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.sndhdr.test_wav",
      "name": "test_wav",
      "module": "sndhdr",
      "type": "function",
      "signature": "(h, f)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.sndhdr.seek",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.open",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.getframerate",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.getnchannels",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.getnframes",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.startswith",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.getsampwidth",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.sndhdr.testall",
      "name": "testall",
      "module": "sndhdr",
      "type": "function",
      "signature": "(list, recursive, toplevel)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.sndhdr.isdir",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.print",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.print",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.flush",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.print",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.glob",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.testall",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.print",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.print",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.join",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.what",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.print",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.escape",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.sndhdr.what",
      "name": "what",
      "module": "sndhdr",
      "type": "function",
      "signature": "(filename)",
      "description": "Guess the type of a sound file.",
      "relationships": [
        {
          "target": "stdlib.sndhdr.whathdr",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.sndhdr.whathdr",
      "name": "whathdr",
      "module": "sndhdr",
      "type": "function",
      "signature": "(filename)",
      "description": "Recognize sound headers.",
      "relationships": [
        {
          "target": "stdlib.sndhdr.open",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.read",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.tf",
          "type": "calls"
        },
        {
          "target": "stdlib.sndhdr.SndHeaders",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.socket.AddressFamily",
      "name": "AddressFamily",
      "module": "socket",
      "type": "class",
      "signature": "(value, names=None, *, module=None, qualname=None, type=None, start=1)",
      "description": "An enumeration.",
      "relationships": [
        {
          "target": "IntEnum",
          "type": "base_class"
        },
        {
          "target": "int",
          "type": "base_class"
        },
        {
          "target": "Enum",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.socket.AddressInfo",
      "name": "AddressInfo",
      "module": "socket",
      "type": "class",
      "signature": "(value, names=None, *, module=None, qualname=None, type=None, start=1)",
      "description": "An enumeration.",
      "relationships": [
        {
          "target": "IntFlag",
          "type": "base_class"
        },
        {
          "target": "int",
          "type": "base_class"
        },
        {
          "target": "Flag",
          "type": "base_class"
        },
        {
          "target": "Enum",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.socket.IntEnum",
      "name": "IntEnum",
      "module": "socket",
      "type": "class",
      "signature": "(value, names=None, *, module=None, qualname=None, type=None, start=1)",
      "description": "Enum where members are also (and must be) ints",
      "relationships": [
        {
          "target": "int",
          "type": "base_class"
        },
        {
          "target": "Enum",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.socket.IntFlag",
      "name": "IntFlag",
      "module": "socket",
      "type": "class",
      "signature": "(value, names=None, *, module=None, qualname=None, type=None, start=1)",
      "description": "Support for integer-based Flags",
      "relationships": [
        {
          "target": "int",
          "type": "base_class"
        },
        {
          "target": "Flag",
          "type": "base_class"
        },
        {
          "target": "Enum",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.socket.MsgFlag",
      "name": "MsgFlag",
      "module": "socket",
      "type": "class",
      "signature": "(value, names=None, *, module=None, qualname=None, type=None, start=1)",
      "description": "An enumeration.",
      "relationships": [
        {
          "target": "IntFlag",
          "type": "base_class"
        },
        {
          "target": "int",
          "type": "base_class"
        },
        {
          "target": "Flag",
          "type": "base_class"
        },
        {
          "target": "Enum",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.socket.SocketIO",
      "name": "SocketIO",
      "module": "socket",
      "type": "class",
      "signature": "(sock, mode)",
      "description": "Raw I/O implementation for stream sockets.\n\nThis class supports the makefile() method on sockets.  It provides\nthe raw I/O interface on top of a socket object.",
      "relationships": [
        {
          "target": "RawIOBase",
          "type": "base_class"
        },
        {
          "target": "_RawIOBase",
          "type": "base_class"
        },
        {
          "target": "IOBase",
          "type": "base_class"
        },
        {
          "target": "_IOBase",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.socket.SocketKind",
      "name": "SocketKind",
      "module": "socket",
      "type": "class",
      "signature": "(value, names=None, *, module=None, qualname=None, type=None, start=1)",
      "description": "An enumeration.",
      "relationships": [
        {
          "target": "IntEnum",
          "type": "base_class"
        },
        {
          "target": "int",
          "type": "base_class"
        },
        {
          "target": "Enum",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.socket.create_connection",
      "name": "create_connection",
      "module": "socket",
      "type": "function",
      "signature": "(address, timeout=<object object at 0x102f70e60>, source_address=None)",
      "description": "Connect to *address* and return the socket object.\n\nConvenience function.  Connect to *address* (a 2-tuple ``(host,\nport)``) and return the socket object.  Passing the optional\n*timeout* parameter will set the timeout on the socket instance\nbefore attempting to connect.  If no *timeout* is supplied, the\nglobal default timeout setting returned by :func:`getdefaulttimeout`\nis used.  If *source_address* is set it must be a tuple of (host, port)\nfor the socket to bind as a source address before making the connection.\nA host of '' or port 0 tells the OS to use the default.",
      "relationships": [
        {
          "target": "stdlib.socket.getaddrinfo",
          "type": "calls"
        },
        {
          "target": "stdlib.socket.error",
          "type": "calls"
        },
        {
          "target": "stdlib.socket.socket",
          "type": "calls"
        },
        {
          "target": "stdlib.socket.connect",
          "type": "calls"
        },
        {
          "target": "stdlib.socket.settimeout",
          "type": "calls"
        },
        {
          "target": "stdlib.socket.bind",
          "type": "calls"
        },
        {
          "target": "stdlib.socket.close",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.socket.create_server",
      "name": "create_server",
      "module": "socket",
      "type": "function",
      "signature": "(address, *, family=<AddressFamily.AF_INET: 2>, backlog=None, reuse_port=False, dualstack_ipv6=False)",
      "description": "Convenience function which creates a SOCK_STREAM type socket\nbound to *address* (a 2-tuple (host, port)) and return the socket\nobject.\n\n*family* should be either AF_INET or AF_INET6.\n*backlog* is the queue size passed to socket.listen().\n*reuse_port* dictates whether to use the SO_REUSEPORT socket option.\n*dualstack_ipv6*: if true and the platform supports it, it will\ncreate an AF_INET6 socket able to accept both IPv4 or IPv6\nconnections. When false it will explicitly disable this option on\nplatforms that enable it by default (e.g. Linux).\n\n>>> with create_server(('', 8000)) as server:\n...     while True:\n...         conn, addr = server.accept()\n...         # handle new connection",
      "relationships": [
        {
          "target": "stdlib.socket.socket",
          "type": "calls"
        },
        {
          "target": "stdlib.socket.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.socket.hasattr",
          "type": "calls"
        },
        {
          "target": "stdlib.socket.has_dualstack_ipv6",
          "type": "calls"
        },
        {
          "target": "stdlib.socket.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.socket.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.socket.hasattr",
          "type": "calls"
        },
        {
          "target": "stdlib.socket.setsockopt",
          "type": "calls"
        },
        {
          "target": "stdlib.socket.bind",
          "type": "calls"
        },
        {
          "target": "stdlib.socket.listen",
          "type": "calls"
        },
        {
          "target": "stdlib.socket.listen",
          "type": "calls"
        },
        {
          "target": "stdlib.socket.close",
          "type": "calls"
        },
        {
          "target": "stdlib.socket.setsockopt",
          "type": "calls"
        },
        {
          "target": "stdlib.socket.setsockopt",
          "type": "calls"
        },
        {
          "target": "stdlib.socket.error",
          "type": "calls"
        },
        {
          "target": "stdlib.socket.hasattr",
          "type": "calls"
        },
        {
          "target": "stdlib.socket.hasattr",
          "type": "calls"
        },
        {
          "target": "stdlib.socket.setsockopt",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.socket.fromfd",
      "name": "fromfd",
      "module": "socket",
      "type": "function",
      "signature": "(fd, family, type, proto=0)",
      "description": "fromfd(fd, family, type[, proto]) -> socket object\n\nCreate a socket object from a duplicate of the given file\ndescriptor.  The remaining arguments are the same as for socket().",
      "relationships": [
        {
          "target": "stdlib.socket.dup",
          "type": "calls"
        },
        {
          "target": "stdlib.socket.socket",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.socket.getaddrinfo",
      "name": "getaddrinfo",
      "module": "socket",
      "type": "function",
      "signature": "(host, port, family=0, type=0, proto=0, flags=0)",
      "description": "Resolve host and port into list of address info entries.\n\nTranslate the host/port argument into a sequence of 5-tuples that contain\nall the necessary arguments for creating a socket connected to that service.\nhost is a domain name, a string representation of an IPv4/v6 address or\nNone. port is a string service name such as 'http', a numeric port number or\nNone. By passing None as the value of host and port, you can pass NULL to\nthe underlying C API.\n\nThe family, type and proto arguments can be optionally specified in order to\nnarrow the list of addresses returned. Passing zero as a value for each of\nthese arguments selects the full range of results.",
      "relationships": [
        {
          "target": "stdlib.socket.getaddrinfo",
          "type": "calls"
        },
        {
          "target": "stdlib.socket.append",
          "type": "calls"
        },
        {
          "target": "stdlib.socket._intenum_converter",
          "type": "calls"
        },
        {
          "target": "stdlib.socket._intenum_converter",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.socket.getfqdn",
      "name": "getfqdn",
      "module": "socket",
      "type": "function",
      "signature": "(name='')",
      "description": "Get fully qualified domain name from name.\n\nAn empty argument is interpreted as meaning the local host.\n\nFirst the hostname returned by gethostbyaddr() is checked, then\npossibly existing aliases. In case no FQDN is available, hostname\nfrom gethostname() is returned.",
      "relationships": [
        {
          "target": "stdlib.socket.strip",
          "type": "calls"
        },
        {
          "target": "stdlib.socket.gethostname",
          "type": "calls"
        },
        {
          "target": "stdlib.socket.gethostbyaddr",
          "type": "calls"
        },
        {
          "target": "stdlib.socket.insert",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.socket.has_dualstack_ipv6",
      "name": "has_dualstack_ipv6",
      "module": "socket",
      "type": "function",
      "signature": "()",
      "description": "Return True if the platform supports creating a SOCK_STREAM socket\nwhich can handle both AF_INET and AF_INET6 (IPv4 / IPv6) connections.",
      "relationships": [
        {
          "target": "stdlib.socket.hasattr",
          "type": "calls"
        },
        {
          "target": "stdlib.socket.hasattr",
          "type": "calls"
        },
        {
          "target": "stdlib.socket.socket",
          "type": "calls"
        },
        {
          "target": "stdlib.socket.setsockopt",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.socket.recv_fds",
      "name": "recv_fds",
      "module": "socket",
      "type": "function",
      "signature": "(sock, bufsize, maxfds, flags=0)",
      "description": "recv_fds(sock, bufsize, maxfds[, flags]) -> (data, list of file\ndescriptors, msg_flags, address)\n\nReceive up to maxfds file descriptors returning the message\ndata and a list containing the descriptors.",
      "relationships": [
        {
          "target": "stdlib.socket.array",
          "type": "calls"
        },
        {
          "target": "stdlib.socket.recvmsg",
          "type": "calls"
        },
        {
          "target": "stdlib.socket.CMSG_LEN",
          "type": "calls"
        },
        {
          "target": "stdlib.socket.list",
          "type": "calls"
        },
        {
          "target": "stdlib.socket.frombytes",
          "type": "calls"
        },
        {
          "target": "stdlib.socket.len",
          "type": "calls"
        },
        {
          "target": "stdlib.socket.len",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.socket.send_fds",
      "name": "send_fds",
      "module": "socket",
      "type": "function",
      "signature": "(sock, buffers, fds, flags=0, address=None)",
      "description": "send_fds(sock, buffers, fds[, flags[, address]]) -> integer\n\nSend the list of file descriptors fds over an AF_UNIX socket.",
      "relationships": [
        {
          "target": "stdlib.socket.sendmsg",
          "type": "calls"
        },
        {
          "target": "stdlib.socket.array",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.socket.socket",
      "name": "socket",
      "module": "socket",
      "type": "class",
      "signature": "(family=-1, type=-1, proto=-1, fileno=None)",
      "description": "A subclass of _socket.socket adding the makefile() method.",
      "relationships": [
        {
          "target": "socket",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.socket.socketpair",
      "name": "socketpair",
      "module": "socket",
      "type": "function",
      "signature": "(family=None, type=<SocketKind.SOCK_STREAM: 1>, proto=0)",
      "description": "socketpair([family[, type[, proto]]]) -> (socket object, socket object)\nCreate a pair of socket objects from the sockets returned by the platform\nsocketpair() function.\nThe arguments are the same as for socket() except the default family is AF_UNIX\nif defined on the platform; otherwise, the default is AF_INET.",
      "relationships": [
        {
          "target": "stdlib.socket.socketpair",
          "type": "calls"
        },
        {
          "target": "stdlib.socket.socket",
          "type": "calls"
        },
        {
          "target": "stdlib.socket.socket",
          "type": "calls"
        },
        {
          "target": "stdlib.socket.detach",
          "type": "calls"
        },
        {
          "target": "stdlib.socket.detach",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.socketserver.BaseRequestHandler",
      "name": "BaseRequestHandler",
      "module": "socketserver",
      "type": "class",
      "signature": "(request, client_address, server)",
      "description": "Base class for request handler classes.\n\nThis class is instantiated for each request to be handled.  The\nconstructor sets the instance variables request, client_address\nand server, and then calls the handle() method.  To implement a\nspecific service, all you need to do is to derive a class which\ndefines a handle() method.\n\nThe handle() method can find the request as self.request, the\nclient address as self.client_address, and the server (in case it\nneeds access to per-server information) as self.server.  Since a\nseparate instance is created for each request, the handle() method\ncan define other arbitrary instance variables.",
      "relationships": []
    },
    {
      "id": "stdlib.socketserver.BaseServer",
      "name": "BaseServer",
      "module": "socketserver",
      "type": "class",
      "signature": "(server_address, RequestHandlerClass)",
      "description": "Base class for server classes.\n\nMethods for the caller:\n\n- __init__(server_address, RequestHandlerClass)\n- serve_forever(poll_interval=0.5)\n- shutdown()\n- handle_request()  # if you do not use serve_forever()\n- fileno() -> int   # for selector\n\nMethods that may be overridden:\n\n- server_bind()\n- server_activate()\n- get_request() -> request, client_address\n- handle_timeout()\n- verify_request(request, client_address)\n- server_close()\n- process_request(request, client_address)\n- shutdown_request(request)\n- close_request(request)\n- service_actions()\n- handle_error()\n\nMethods for derived classes:\n\n- finish_request(request, client_address)\n\nClass variables that may be overridden by derived classes or\ninstances:\n\n- timeout\n- address_family\n- socket_type\n- allow_reuse_address\n\nInstance variables:\n\n- RequestHandlerClass\n- socket",
      "relationships": []
    },
    {
      "id": "stdlib.socketserver.DatagramRequestHandler",
      "name": "DatagramRequestHandler",
      "module": "socketserver",
      "type": "class",
      "signature": "(request, client_address, server)",
      "description": "Define self.rfile and self.wfile for datagram sockets.",
      "relationships": [
        {
          "target": "BaseRequestHandler",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.socketserver.ForkingMixIn",
      "name": "ForkingMixIn",
      "module": "socketserver",
      "type": "class",
      "signature": "()",
      "description": "Mix-in class to handle each request in a new process.",
      "relationships": []
    },
    {
      "id": "stdlib.socketserver.ForkingTCPServer",
      "name": "ForkingTCPServer",
      "module": "socketserver",
      "type": "class",
      "signature": "(server_address, RequestHandlerClass, bind_and_activate=True)",
      "description": "Mix-in class to handle each request in a new process.",
      "relationships": [
        {
          "target": "ForkingMixIn",
          "type": "base_class"
        },
        {
          "target": "TCPServer",
          "type": "base_class"
        },
        {
          "target": "BaseServer",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.socketserver.ForkingUDPServer",
      "name": "ForkingUDPServer",
      "module": "socketserver",
      "type": "class",
      "signature": "(server_address, RequestHandlerClass, bind_and_activate=True)",
      "description": "Mix-in class to handle each request in a new process.",
      "relationships": [
        {
          "target": "ForkingMixIn",
          "type": "base_class"
        },
        {
          "target": "UDPServer",
          "type": "base_class"
        },
        {
          "target": "TCPServer",
          "type": "base_class"
        },
        {
          "target": "BaseServer",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.socketserver.StreamRequestHandler",
      "name": "StreamRequestHandler",
      "module": "socketserver",
      "type": "class",
      "signature": "(request, client_address, server)",
      "description": "Define self.rfile and self.wfile for stream sockets.",
      "relationships": [
        {
          "target": "BaseRequestHandler",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.socketserver.TCPServer",
      "name": "TCPServer",
      "module": "socketserver",
      "type": "class",
      "signature": "(server_address, RequestHandlerClass, bind_and_activate=True)",
      "description": "Base class for various socket-based server classes.\n\nDefaults to synchronous IP stream (i.e., TCP).\n\nMethods for the caller:\n\n- __init__(server_address, RequestHandlerClass, bind_and_activate=True)\n- serve_forever(poll_interval=0.5)\n- shutdown()\n- handle_request()  # if you don't use serve_forever()\n- fileno() -> int   # for selector\n\nMethods that may be overridden:\n\n- server_bind()\n- server_activate()\n- get_request() -> request, client_address\n- handle_timeout()\n- verify_request(request, client_address)\n- process_request(request, client_address)\n- shutdown_request(request)\n- close_request(request)\n- handle_error()\n\nMethods for derived classes:\n\n- finish_request(request, client_address)\n\nClass variables that may be overridden by derived classes or\ninstances:\n\n- timeout\n- address_family\n- socket_type\n- request_queue_size (only for stream sockets)\n- allow_reuse_address\n\nInstance variables:\n\n- server_address\n- RequestHandlerClass\n- socket",
      "relationships": [
        {
          "target": "BaseServer",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.socketserver.ThreadingMixIn",
      "name": "ThreadingMixIn",
      "module": "socketserver",
      "type": "class",
      "signature": "()",
      "description": "Mix-in class to handle each request in a new thread.",
      "relationships": []
    },
    {
      "id": "stdlib.socketserver.ThreadingTCPServer",
      "name": "ThreadingTCPServer",
      "module": "socketserver",
      "type": "class",
      "signature": "(server_address, RequestHandlerClass, bind_and_activate=True)",
      "description": "Mix-in class to handle each request in a new thread.",
      "relationships": [
        {
          "target": "ThreadingMixIn",
          "type": "base_class"
        },
        {
          "target": "TCPServer",
          "type": "base_class"
        },
        {
          "target": "BaseServer",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.socketserver.ThreadingUDPServer",
      "name": "ThreadingUDPServer",
      "module": "socketserver",
      "type": "class",
      "signature": "(server_address, RequestHandlerClass, bind_and_activate=True)",
      "description": "Mix-in class to handle each request in a new thread.",
      "relationships": [
        {
          "target": "ThreadingMixIn",
          "type": "base_class"
        },
        {
          "target": "UDPServer",
          "type": "base_class"
        },
        {
          "target": "TCPServer",
          "type": "base_class"
        },
        {
          "target": "BaseServer",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.socketserver.ThreadingUnixDatagramServer",
      "name": "ThreadingUnixDatagramServer",
      "module": "socketserver",
      "type": "class",
      "signature": "(server_address, RequestHandlerClass, bind_and_activate=True)",
      "description": "Mix-in class to handle each request in a new thread.",
      "relationships": [
        {
          "target": "ThreadingMixIn",
          "type": "base_class"
        },
        {
          "target": "UnixDatagramServer",
          "type": "base_class"
        },
        {
          "target": "UDPServer",
          "type": "base_class"
        },
        {
          "target": "TCPServer",
          "type": "base_class"
        },
        {
          "target": "BaseServer",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.socketserver.ThreadingUnixStreamServer",
      "name": "ThreadingUnixStreamServer",
      "module": "socketserver",
      "type": "class",
      "signature": "(server_address, RequestHandlerClass, bind_and_activate=True)",
      "description": "Mix-in class to handle each request in a new thread.",
      "relationships": [
        {
          "target": "ThreadingMixIn",
          "type": "base_class"
        },
        {
          "target": "UnixStreamServer",
          "type": "base_class"
        },
        {
          "target": "TCPServer",
          "type": "base_class"
        },
        {
          "target": "BaseServer",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.socketserver.UDPServer",
      "name": "UDPServer",
      "module": "socketserver",
      "type": "class",
      "signature": "(server_address, RequestHandlerClass, bind_and_activate=True)",
      "description": "UDP server class.",
      "relationships": [
        {
          "target": "TCPServer",
          "type": "base_class"
        },
        {
          "target": "BaseServer",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.socketserver.UnixDatagramServer",
      "name": "UnixDatagramServer",
      "module": "socketserver",
      "type": "class",
      "signature": "(server_address, RequestHandlerClass, bind_and_activate=True)",
      "description": "UDP server class.",
      "relationships": [
        {
          "target": "UDPServer",
          "type": "base_class"
        },
        {
          "target": "TCPServer",
          "type": "base_class"
        },
        {
          "target": "BaseServer",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.socketserver.UnixStreamServer",
      "name": "UnixStreamServer",
      "module": "socketserver",
      "type": "class",
      "signature": "(server_address, RequestHandlerClass, bind_and_activate=True)",
      "description": "Base class for various socket-based server classes.\n\nDefaults to synchronous IP stream (i.e., TCP).\n\nMethods for the caller:\n\n- __init__(server_address, RequestHandlerClass, bind_and_activate=True)\n- serve_forever(poll_interval=0.5)\n- shutdown()\n- handle_request()  # if you don't use serve_forever()\n- fileno() -> int   # for selector\n\nMethods that may be overridden:\n\n- server_bind()\n- server_activate()\n- get_request() -> request, client_address\n- handle_timeout()\n- verify_request(request, client_address)\n- process_request(request, client_address)\n- shutdown_request(request)\n- close_request(request)\n- handle_error()\n\nMethods for derived classes:\n\n- finish_request(request, client_address)\n\nClass variables that may be overridden by derived classes or\ninstances:\n\n- timeout\n- address_family\n- socket_type\n- request_queue_size (only for stream sockets)\n- allow_reuse_address\n\nInstance variables:\n\n- server_address\n- RequestHandlerClass\n- socket",
      "relationships": [
        {
          "target": "TCPServer",
          "type": "base_class"
        },
        {
          "target": "BaseServer",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.sqlite3.Binary",
      "name": "Binary",
      "module": "sqlite3",
      "type": "class",
      "signature": "(object)",
      "description": "Create a new memoryview object which references the given object.",
      "relationships": []
    },
    {
      "id": "stdlib.sqlite3.DateFromTicks",
      "name": "DateFromTicks",
      "module": "sqlite3",
      "type": "function",
      "signature": "(ticks)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.sqlite3.Date",
          "type": "calls"
        },
        {
          "target": "stdlib.sqlite3.localtime",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.sqlite3.TimeFromTicks",
      "name": "TimeFromTicks",
      "module": "sqlite3",
      "type": "function",
      "signature": "(ticks)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.sqlite3.Time",
          "type": "calls"
        },
        {
          "target": "stdlib.sqlite3.localtime",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.sqlite3.TimestampFromTicks",
      "name": "TimestampFromTicks",
      "module": "sqlite3",
      "type": "function",
      "signature": "(ticks)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.sqlite3.Timestamp",
          "type": "calls"
        },
        {
          "target": "stdlib.sqlite3.localtime",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.sre_compile.compile",
      "name": "compile",
      "module": "sre_compile",
      "type": "function",
      "signature": "(p, flags=0)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.sre_compile.isstring",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_compile._code",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_compile.items",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_compile.compile",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_compile.parse",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_compile.print",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_compile.dis",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_compile.tuple",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.sre_compile.dis",
      "name": "dis",
      "module": "sre_compile",
      "type": "function",
      "signature": "(code)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.sre_compile.set",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_compile.len",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_compile.dis_",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_compile.str",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_compile.len",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_compile.print",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_compile.print",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_compile.print",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_compile.print",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_compile.len",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_compile.add",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_compile.print_",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_compile.print_",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_compile.str",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_compile.print_",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_compile.str",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_compile.print_",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_compile.chr",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_compile.print_",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_compile.dis_",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_compile.print_",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_compile.print_",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_compile._hex_code",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_compile.list",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_compile.print_",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_compile.range",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_compile.chr",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_compile.chr",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_compile.join",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_compile.print_2",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_compile.print_",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_compile._hex_code",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_compile.print_",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_compile.to_bytes",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_compile.print_",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_compile.dis_",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_compile.print_",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_compile.dis_",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_compile.print_",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_compile.print_",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_compile.print_",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_compile.print_",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_compile.dis_",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_compile.print_",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_compile.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_compile.bin",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_compile.print_2",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_compile.print_2",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_compile.print_2",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_compile.print_2",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_compile.dis_",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_compile.join",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_compile.join",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_compile.map",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.sre_compile.error",
      "name": "error",
      "module": "sre_compile",
      "type": "class",
      "signature": "(msg, pattern=None, pos=None)",
      "description": "Exception raised for invalid regular expressions.\n\nAttributes:\n\n    msg: The unformatted error message\n    pattern: The regular expression pattern\n    pos: The index in the pattern where compilation failed (may be None)\n    lineno: The line corresponding to pos (may be None)\n    colno: The column corresponding to pos (may be None)",
      "relationships": [
        {
          "target": "Exception",
          "type": "base_class"
        },
        {
          "target": "BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.sre_compile.isstring",
      "name": "isstring",
      "module": "sre_compile",
      "type": "function",
      "signature": "(obj)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.sre_compile.isinstance",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.sre_constants.error",
      "name": "error",
      "module": "sre_constants",
      "type": "class",
      "signature": "(msg, pattern=None, pos=None)",
      "description": "Exception raised for invalid regular expressions.\n\nAttributes:\n\n    msg: The unformatted error message\n    pattern: The regular expression pattern\n    pos: The index in the pattern where compilation failed (may be None)\n    lineno: The line corresponding to pos (may be None)\n    colno: The column corresponding to pos (may be None)",
      "relationships": [
        {
          "target": "Exception",
          "type": "base_class"
        },
        {
          "target": "BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.sre_parse.State",
      "name": "State",
      "module": "sre_parse",
      "type": "class",
      "signature": "()",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.sre_parse.SubPattern",
      "name": "SubPattern",
      "module": "sre_parse",
      "type": "class",
      "signature": "(state, data=None)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.sre_parse.Tokenizer",
      "name": "Tokenizer",
      "module": "sre_parse",
      "type": "class",
      "signature": "(string)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.sre_parse.error",
      "name": "error",
      "module": "sre_parse",
      "type": "class",
      "signature": "(msg, pattern=None, pos=None)",
      "description": "Exception raised for invalid regular expressions.\n\nAttributes:\n\n    msg: The unformatted error message\n    pattern: The regular expression pattern\n    pos: The index in the pattern where compilation failed (may be None)\n    lineno: The line corresponding to pos (may be None)\n    colno: The column corresponding to pos (may be None)",
      "relationships": [
        {
          "target": "Exception",
          "type": "base_class"
        },
        {
          "target": "BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.sre_parse.expand_template",
      "name": "expand_template",
      "module": "sre_parse",
      "type": "function",
      "signature": "(template, match)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.sre_parse.join",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_parse.error",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_parse.g",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.sre_parse.fix_flags",
      "name": "fix_flags",
      "module": "sre_parse",
      "type": "function",
      "signature": "(src, flags)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.sre_parse.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_parse.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_parse.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_parse.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_parse.ValueError",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.sre_parse.parse",
      "name": "parse",
      "module": "sre_parse",
      "type": "function",
      "signature": "(str, flags=0, state=None)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.sre_parse.Tokenizer",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_parse.fix_flags",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_parse.State",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_parse._parse_sub",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_parse.error",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_parse.dump",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_parse.State",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_parse.seek",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_parse._parse_sub",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.sre_parse.parse_template",
      "name": "parse_template",
      "module": "sre_parse",
      "type": "function",
      "signature": "(source, state)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.sre_parse.Tokenizer",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_parse.append",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_parse.append",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_parse.sget",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_parse.append",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_parse.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_parse.error",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_parse.append",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_parse.lappend",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_parse.join",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_parse.join",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_parse.len",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_parse.getuntil",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_parse.isidentifier",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_parse.addgroup",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_parse.encode",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_parse.match",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_parse.error",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_parse.lappend",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_parse.int",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_parse.error",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_parse.len",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_parse.sget",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_parse.chr",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_parse.lappend",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_parse.IndexError",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_parse.error",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_parse.sget",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_parse.sget",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_parse.addgroup",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_parse.chr",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_parse.len",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_parse.int",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_parse.sget",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_parse.int",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_parse.lappend",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_parse.int",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_parse.len",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_parse.error",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_parse.chr",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_parse.len",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_parse.error",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_parse.len",
          "type": "calls"
        },
        {
          "target": "stdlib.sre_parse.len",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ssl.AlertDescription",
      "name": "AlertDescription",
      "module": "ssl",
      "type": "class",
      "signature": "(value, names=None, *, module=None, qualname=None, type=None, start=1)",
      "description": "An enumeration.",
      "relationships": [
        {
          "target": "IntEnum",
          "type": "base_class"
        },
        {
          "target": "int",
          "type": "base_class"
        },
        {
          "target": "Enum",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.ssl.DER_cert_to_PEM_cert",
      "name": "DER_cert_to_PEM_cert",
      "module": "ssl",
      "type": "function",
      "signature": "(der_cert_bytes)",
      "description": "Takes a certificate in binary DER format and returns the\nPEM version of it as a string.",
      "relationships": [
        {
          "target": "stdlib.ssl.str",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.append",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.join",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.standard_b64encode",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.range",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.len",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ssl.DefaultVerifyPaths",
      "name": "DefaultVerifyPaths",
      "module": "ssl",
      "type": "class",
      "signature": "(cafile, capath, openssl_cafile_env, openssl_cafile, openssl_capath_env, openssl_capath)",
      "description": "DefaultVerifyPaths(cafile, capath, openssl_cafile_env, openssl_cafile, openssl_capath_env, openssl_capath)",
      "relationships": [
        {
          "target": "tuple",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.ssl.Options",
      "name": "Options",
      "module": "ssl",
      "type": "class",
      "signature": "(value, names=None, *, module=None, qualname=None, type=None, start=1)",
      "description": "An enumeration.",
      "relationships": [
        {
          "target": "IntFlag",
          "type": "base_class"
        },
        {
          "target": "int",
          "type": "base_class"
        },
        {
          "target": "Flag",
          "type": "base_class"
        },
        {
          "target": "Enum",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.ssl.PEM_cert_to_DER_cert",
      "name": "PEM_cert_to_DER_cert",
      "module": "ssl",
      "type": "function",
      "signature": "(pem_cert_string)",
      "description": "Takes a certificate in ASCII PEM format and returns the\nDER-encoded version of it as a byte sequence",
      "relationships": [
        {
          "target": "stdlib.ssl.decodebytes",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.startswith",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.endswith",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.strip",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.encode",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.len",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.strip",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.len",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ssl.Purpose",
      "name": "Purpose",
      "module": "ssl",
      "type": "class",
      "signature": "(value, names=None, *, module=None, qualname=None, type=None, start=1)",
      "description": "SSLContext purpose flags with X509v3 Extended Key Usage objects\n    ",
      "relationships": [
        {
          "target": "_ASN1Object",
          "type": "base_class"
        },
        {
          "target": "_ASN1Object",
          "type": "base_class"
        },
        {
          "target": "tuple",
          "type": "base_class"
        },
        {
          "target": "Enum",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.ssl.SSLContext",
      "name": "SSLContext",
      "module": "ssl",
      "type": "class",
      "signature": "(protocol=<_SSLMethod.PROTOCOL_TLS: 2>, *args, **kwargs)",
      "description": "An SSLContext holds various SSL-related configuration options and\ndata, such as certificates and possibly a private key.",
      "relationships": [
        {
          "target": "_SSLContext",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.ssl.SSLErrorNumber",
      "name": "SSLErrorNumber",
      "module": "ssl",
      "type": "class",
      "signature": "(value, names=None, *, module=None, qualname=None, type=None, start=1)",
      "description": "An enumeration.",
      "relationships": [
        {
          "target": "IntEnum",
          "type": "base_class"
        },
        {
          "target": "int",
          "type": "base_class"
        },
        {
          "target": "Enum",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.ssl.SSLObject",
      "name": "SSLObject",
      "module": "ssl",
      "type": "class",
      "signature": "(*args, **kwargs)",
      "description": "This class implements an interface on top of a low-level SSL object as\nimplemented by OpenSSL. This object captures the state of an SSL connection\nbut does not provide any network IO itself. IO needs to be performed\nthrough separate \"BIO\" objects which are OpenSSL's IO abstraction layer.\n\nThis class does not have a public constructor. Instances are returned by\n``SSLContext.wrap_bio``. This class is typically used by framework authors\nthat want to implement asynchronous IO for SSL through memory buffers.\n\nWhen compared to ``SSLSocket``, this object lacks the following features:\n\n * Any form of network IO, including methods such as ``recv`` and ``send``.\n * The ``do_handshake_on_connect`` and ``suppress_ragged_eofs`` machinery.",
      "relationships": []
    },
    {
      "id": "stdlib.ssl.SSLSession",
      "name": "SSLSession",
      "module": "ssl",
      "type": "class",
      "signature": "()",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.ssl.SSLSocket",
      "name": "SSLSocket",
      "module": "ssl",
      "type": "class",
      "signature": "(*args, **kwargs)",
      "description": "This class implements a subtype of socket.socket that wraps\nthe underlying OS socket in an SSL context when necessary, and\nprovides read and write methods over that channel. ",
      "relationships": [
        {
          "target": "socket",
          "type": "base_class"
        },
        {
          "target": "socket",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.ssl.TLSVersion",
      "name": "TLSVersion",
      "module": "ssl",
      "type": "class",
      "signature": "(value, names=None, *, module=None, qualname=None, type=None, start=1)",
      "description": "An enumeration.",
      "relationships": [
        {
          "target": "IntEnum",
          "type": "base_class"
        },
        {
          "target": "int",
          "type": "base_class"
        },
        {
          "target": "Enum",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.ssl.VerifyFlags",
      "name": "VerifyFlags",
      "module": "ssl",
      "type": "class",
      "signature": "(value, names=None, *, module=None, qualname=None, type=None, start=1)",
      "description": "An enumeration.",
      "relationships": [
        {
          "target": "IntFlag",
          "type": "base_class"
        },
        {
          "target": "int",
          "type": "base_class"
        },
        {
          "target": "Flag",
          "type": "base_class"
        },
        {
          "target": "Enum",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.ssl.VerifyMode",
      "name": "VerifyMode",
      "module": "ssl",
      "type": "class",
      "signature": "(value, names=None, *, module=None, qualname=None, type=None, start=1)",
      "description": "An enumeration.",
      "relationships": [
        {
          "target": "IntEnum",
          "type": "base_class"
        },
        {
          "target": "int",
          "type": "base_class"
        },
        {
          "target": "Enum",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.ssl.cert_time_to_seconds",
      "name": "cert_time_to_seconds",
      "module": "ssl",
      "type": "function",
      "signature": "(cert_time)",
      "description": "Return the time in seconds since the Epoch, given the timestring\nrepresenting the \"notBefore\" or \"notAfter\" date from a certificate\nin ``\"%b %d %H:%M:%S %Y %Z\"`` strptime format (C locale).\n\n\"notBefore\" or \"notAfter\" dates must use UTC (RFC 5280).\n\nMonth is one of: Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\nUTC should be specified as GMT (see ASN1_TIME_print())",
      "relationships": [
        {
          "target": "stdlib.ssl.strptime",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.timegm",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.index",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.title",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ssl.create_connection",
      "name": "create_connection",
      "module": "ssl",
      "type": "function",
      "signature": "(address, timeout=<object object at 0x102f70e60>, source_address=None)",
      "description": "Connect to *address* and return the socket object.\n\nConvenience function.  Connect to *address* (a 2-tuple ``(host,\nport)``) and return the socket object.  Passing the optional\n*timeout* parameter will set the timeout on the socket instance\nbefore attempting to connect.  If no *timeout* is supplied, the\nglobal default timeout setting returned by :func:`getdefaulttimeout`\nis used.  If *source_address* is set it must be a tuple of (host, port)\nfor the socket to bind as a source address before making the connection.\nA host of '' or port 0 tells the OS to use the default.",
      "relationships": [
        {
          "target": "stdlib.ssl.getaddrinfo",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.error",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.socket",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.connect",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.settimeout",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.bind",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.close",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ssl.create_default_context",
      "name": "create_default_context",
      "module": "ssl",
      "type": "function",
      "signature": "(purpose=<Purpose.SERVER_AUTH: _ASN1Object(nid=129, shortname='serverAuth', longname='TLS Web Server Authentication', oid='1.3.6.1.5.5.7.3.1')>, *, cafile=None, capath=None, cadata=None)",
      "description": "Create a SSLContext object with default settings.\n\nNOTE: The protocol and settings may change anytime without prior\n      deprecation. The values represent a fair balance between maximum\n      compatibility and security.",
      "relationships": [
        {
          "target": "stdlib.ssl.SSLContext",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.hasattr",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.load_verify_locations",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.get",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.load_default_certs",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ssl.get_default_verify_paths",
      "name": "get_default_verify_paths",
      "module": "ssl",
      "type": "function",
      "signature": "()",
      "description": "Return paths to default cafile and capath.\n    ",
      "relationships": [
        {
          "target": "stdlib.ssl.get_default_verify_paths",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.get",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.get",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.DefaultVerifyPaths",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.isfile",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.isdir",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ssl.get_protocol_name",
      "name": "get_protocol_name",
      "module": "ssl",
      "type": "function",
      "signature": "(protocol_code)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.ssl.get",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ssl.get_server_certificate",
      "name": "get_server_certificate",
      "module": "ssl",
      "type": "function",
      "signature": "(addr, ssl_version=<_SSLMethod.PROTOCOL_TLS: 2>, ca_certs=None)",
      "description": "Retrieve the certificate from the server at the specified address,\nand return it as a PEM-encoded string.\nIf 'ca_certs' is specified, validate the server cert against it.\nIf 'ssl_version' is specified, use it in the connection attempt.",
      "relationships": [
        {
          "target": "stdlib.ssl._create_stdlib_context",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.DER_cert_to_PEM_cert",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.create_connection",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.wrap_socket",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.getpeercert",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ssl.match_hostname",
      "name": "match_hostname",
      "module": "ssl",
      "type": "function",
      "signature": "(cert, hostname)",
      "description": "Verify that *cert* (in decoded format as returned by\nSSLSocket.getpeercert()) matches the *hostname*.  RFC 2818 and RFC 6125\nrules are followed.\n\nThe function matches IP addresses rather than dNSNames if hostname is a\nvalid ipaddress string. IPv4 addresses are supported on all platforms.\nIPv6 addresses are supported on platforms with IPv6 support (AF_INET6\nand inet_pton).\n\nCertificateError is raised on failure. On success, the function\nreturns nothing.",
      "relationships": [
        {
          "target": "stdlib.ssl.get",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl._inet_paton",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.get",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.len",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.CertificateError",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.append",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.len",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.CertificateError",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.CertificateError",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl._dnsname_match",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.append",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl._ipaddress_match",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl._dnsname_match",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.append",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.join",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.map",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ssl.namedtuple",
      "name": "namedtuple",
      "module": "ssl",
      "type": "function",
      "signature": "(typename, field_names, *, rename=False, defaults=None, module=None)",
      "description": "Returns a new subclass of tuple with named fields.\n\n>>> Point = namedtuple('Point', ['x', 'y'])\n>>> Point.__doc__                   # docstring for the new class\n'Point(x, y)'\n>>> p = Point(11, y=22)             # instantiate with positional args or keywords\n>>> p[0] + p[1]                     # indexable like a plain tuple\n33\n>>> x, y = p                        # unpack like a regular tuple\n>>> x, y\n(11, 22)\n>>> p.x + p.y                       # fields also accessible by name\n33\n>>> d = p._asdict()                 # convert to a dictionary\n>>> d['x']\n11\n>>> Point(**d)                      # convert from a dictionary\nPoint(x=11, y=22)\n>>> p._replace(x=100)               # _replace() is like str.replace() but targets named fields\nPoint(x=100, y=22)",
      "relationships": [
        {
          "target": "stdlib.ssl.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.list",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.intern",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.set",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.tuple",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.len",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.join",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.eval",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.enumerate",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.type",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.split",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.map",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.str",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.set",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.enumerate",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl._iskeyword",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.add",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.tuple",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.dict",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.map",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.tuple_new",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl._make",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl._dict",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl._tuple",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.intern",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl._tuplegetter",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.add",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.type",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.isidentifier",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.startswith",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.len",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.len",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.reversed",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.join",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl._len",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl._map",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl._zip",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.get",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.replace",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl._iskeyword",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.startswith",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.list",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.isidentifier",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.zip",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.reversed",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.reversed",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.len",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.list",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl._getframe",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.ssl.socket",
      "name": "socket",
      "module": "ssl",
      "type": "class",
      "signature": "(family=-1, type=-1, proto=-1, fileno=None)",
      "description": "A subclass of _socket.socket adding the makefile() method.",
      "relationships": [
        {
          "target": "socket",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.ssl.wrap_socket",
      "name": "wrap_socket",
      "module": "ssl",
      "type": "function",
      "signature": "(sock, keyfile=None, certfile=None, server_side=False, cert_reqs=<VerifyMode.CERT_NONE: 0>, ssl_version=<_SSLMethod.PROTOCOL_TLS: 2>, ca_certs=None, do_handshake_on_connect=True, suppress_ragged_eofs=True, ciphers=None)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.ssl.SSLContext",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.wrap_socket",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.load_verify_locations",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.load_cert_chain",
          "type": "calls"
        },
        {
          "target": "stdlib.ssl.set_ciphers",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.statistics.Counter",
      "name": "Counter",
      "module": "statistics",
      "type": "class",
      "signature": "(iterable=None, /, **kwds)",
      "description": "Dict subclass for counting hashable items.  Sometimes called a bag\nor multiset.  Elements are stored as dictionary keys and their counts\nare stored as dictionary values.\n\n>>> c = Counter('abcdeabcdabcaba')  # count elements from a string\n\n>>> c.most_common(3)                # three most common elements\n[('a', 5), ('b', 4), ('c', 3)]\n>>> sorted(c)                       # list all unique elements\n['a', 'b', 'c', 'd', 'e']\n>>> ''.join(sorted(c.elements()))   # list elements with repetitions\n'aaaaabbbbcccdde'\n>>> sum(c.values())                 # total of all counts\n15\n\n>>> c['a']                          # count of letter 'a'\n5\n>>> for elem in 'shazam':           # update counts from an iterable\n...     c[elem] += 1                # by adding 1 to each element's count\n>>> c['a']                          # now there are seven 'a'\n7\n>>> del c['b']                      # remove all 'b'\n>>> c['b']                          # now there are zero 'b'\n0\n\n>>> d = Counter('simsalabim')       # make another counter\n>>> c.update(d)                     # add in the second counter\n>>> c['a']                          # now there are nine 'a'\n9\n\n>>> c.clear()                       # empty the counter\n>>> c\nCounter()\n\nNote:  If a count is set to zero or reduced to zero, it will remain\nin the counter until the entry is deleted or the counter is cleared:\n\n>>> c = Counter('aaabbc')\n>>> c['b'] -= 2                     # reduce the count of 'b' by two\n>>> c.most_common()                 # 'b' is still in, but its count is zero\n[('a', 3), ('c', 1), ('b', 0)]",
      "relationships": [
        {
          "target": "dict",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.statistics.Decimal",
      "name": "Decimal",
      "module": "statistics",
      "type": "class",
      "signature": "(value='0', context=None)",
      "description": "Construct a new Decimal object. 'value' can be an integer, string, tuple,\nor another Decimal object. If no value is given, return Decimal('0'). The\ncontext does not affect the conversion and is only passed to determine if\nthe InvalidOperation trap is active.",
      "relationships": []
    },
    {
      "id": "stdlib.statistics.Fraction",
      "name": "Fraction",
      "module": "statistics",
      "type": "class",
      "signature": "(numerator=0, denominator=None, *, _normalize=True)",
      "description": "This class implements rational numbers.\n\nIn the two-argument form of the constructor, Fraction(8, 6) will\nproduce a rational number equivalent to 4/3. Both arguments must\nbe Rational. The numerator defaults to 0 and the denominator\ndefaults to 1 so that Fraction(3) == 3 and Fraction() == 0.\n\nFractions can also be constructed from:\n\n  - numeric strings similar to those accepted by the\n    float constructor (for example, '-2.3' or '1e10')\n\n  - strings of the form '123/456'\n\n  - float and Decimal instances\n\n  - other Rational instances (including integers)",
      "relationships": [
        {
          "target": "Rational",
          "type": "base_class"
        },
        {
          "target": "Real",
          "type": "base_class"
        },
        {
          "target": "Complex",
          "type": "base_class"
        },
        {
          "target": "Number",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.statistics.NormalDist",
      "name": "NormalDist",
      "module": "statistics",
      "type": "class",
      "signature": "(mu=0.0, sigma=1.0)",
      "description": "Normal distribution of a random variable",
      "relationships": []
    },
    {
      "id": "stdlib.statistics.fmean",
      "name": "fmean",
      "module": "statistics",
      "type": "function",
      "signature": "(data)",
      "description": "Convert data to floats and compute the arithmetic mean.\n\nThis runs faster than the mean() function and it always returns a float.\nIf the input dataset is empty, it raises a StatisticsError.\n\n>>> fmean([3.5, 4.0, 5.25])\n4.25",
      "relationships": [
        {
          "target": "stdlib.statistics.len",
          "type": "calls"
        },
        {
          "target": "stdlib.statistics.fsum",
          "type": "calls"
        },
        {
          "target": "stdlib.statistics.fsum",
          "type": "calls"
        },
        {
          "target": "stdlib.statistics.StatisticsError",
          "type": "calls"
        },
        {
          "target": "stdlib.statistics.enumerate",
          "type": "calls"
        },
        {
          "target": "stdlib.statistics.count",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.statistics.geometric_mean",
      "name": "geometric_mean",
      "module": "statistics",
      "type": "function",
      "signature": "(data)",
      "description": "Convert data to floats and compute the geometric mean.\n\nRaises a StatisticsError if the input dataset is empty,\nif it contains a zero, or if it contains a negative value.\n\nNo special efforts are made to achieve exact results.\n(However, this may change in the future.)\n\n>>> round(geometric_mean([54, 24, 36]), 9)\n36.0",
      "relationships": [
        {
          "target": "stdlib.statistics.exp",
          "type": "calls"
        },
        {
          "target": "stdlib.statistics.fmean",
          "type": "calls"
        },
        {
          "target": "stdlib.statistics.StatisticsError",
          "type": "calls"
        },
        {
          "target": "stdlib.statistics.map",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.statistics.groupby",
      "name": "groupby",
      "module": "statistics",
      "type": "class",
      "signature": "(iterable, key=None)",
      "description": "make an iterator that returns consecutive keys and groups from the iterable\n\niterable\n  Elements to divide into groups according to the key function.\nkey\n  A function for computing the group category for each element.\n  If the key function is not specified or is None, the element itself\n  is used for grouping.",
      "relationships": []
    },
    {
      "id": "stdlib.statistics.harmonic_mean",
      "name": "harmonic_mean",
      "module": "statistics",
      "type": "function",
      "signature": "(data)",
      "description": "Return the harmonic mean of data.\n\nThe harmonic mean, sometimes called the subcontrary mean, is the\nreciprocal of the arithmetic mean of the reciprocals of the data,\nand is often appropriate when averaging quantities which are rates\nor ratios, for example speeds. Example:\n\nSuppose an investor purchases an equal value of shares in each of\nthree companies, with P/E (price/earning) ratios of 2.5, 3 and 10.\nWhat is the average P/E ratio for the investor's portfolio?\n\n>>> harmonic_mean([2.5, 3, 10])  # For an equal investment portfolio.\n3.6\n\nUsing the arithmetic mean would give an average of about 5.167, which\nis too high.\n\nIf ``data`` is empty, or any element is less than zero,\n``harmonic_mean`` will raise ``StatisticsError``.",
      "relationships": [
        {
          "target": "stdlib.statistics.len",
          "type": "calls"
        },
        {
          "target": "stdlib.statistics._convert",
          "type": "calls"
        },
        {
          "target": "stdlib.statistics.iter",
          "type": "calls"
        },
        {
          "target": "stdlib.statistics.list",
          "type": "calls"
        },
        {
          "target": "stdlib.statistics.StatisticsError",
          "type": "calls"
        },
        {
          "target": "stdlib.statistics._sum",
          "type": "calls"
        },
        {
          "target": "stdlib.statistics.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.statistics.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.statistics.StatisticsError",
          "type": "calls"
        },
        {
          "target": "stdlib.statistics._fail_neg",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.statistics.mean",
      "name": "mean",
      "module": "statistics",
      "type": "function",
      "signature": "(data)",
      "description": "Return the sample arithmetic mean of data.\n\n>>> mean([1, 2, 3, 4, 4])\n2.8\n\n>>> from fractions import Fraction as F\n>>> mean([F(3, 7), F(1, 21), F(5, 3), F(1, 3)])\nFraction(13, 21)\n\n>>> from decimal import Decimal as D\n>>> mean([D(\"0.5\"), D(\"0.75\"), D(\"0.625\"), D(\"0.375\")])\nDecimal('0.5625')\n\nIf ``data`` is empty, StatisticsError will be raised.",
      "relationships": [
        {
          "target": "stdlib.statistics.len",
          "type": "calls"
        },
        {
          "target": "stdlib.statistics._sum",
          "type": "calls"
        },
        {
          "target": "stdlib.statistics._convert",
          "type": "calls"
        },
        {
          "target": "stdlib.statistics.iter",
          "type": "calls"
        },
        {
          "target": "stdlib.statistics.list",
          "type": "calls"
        },
        {
          "target": "stdlib.statistics.StatisticsError",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.statistics.median",
      "name": "median",
      "module": "statistics",
      "type": "function",
      "signature": "(data)",
      "description": "Return the median (middle value) of numeric data.\n\nWhen the number of data points is odd, return the middle data point.\nWhen the number of data points is even, the median is interpolated by\ntaking the average of the two middle values:\n\n>>> median([1, 3, 5])\n3\n>>> median([1, 3, 5, 7])\n4.0",
      "relationships": [
        {
          "target": "stdlib.statistics.sorted",
          "type": "calls"
        },
        {
          "target": "stdlib.statistics.len",
          "type": "calls"
        },
        {
          "target": "stdlib.statistics.StatisticsError",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.statistics.median_grouped",
      "name": "median_grouped",
      "module": "statistics",
      "type": "function",
      "signature": "(data, interval=1)",
      "description": "Return the 50th percentile (median) of grouped continuous data.\n\n>>> median_grouped([1, 2, 2, 3, 4, 4, 4, 4, 4, 5])\n3.7\n>>> median_grouped([52, 52, 53, 54])\n52.5\n\nThis calculates the median as the 50th percentile, and should be\nused when your data is continuous and grouped. In the above example,\nthe values 1, 2, 3, etc. actually represent the midpoint of classes\n0.5-1.5, 1.5-2.5, 2.5-3.5, etc. The middle value falls somewhere in\nclass 3.5-4.5, and interpolation is used to estimate it.\n\nOptional argument ``interval`` represents the class interval, and\ndefaults to 1. Changing the class interval naturally will change the\ninterpolated 50th percentile value:\n\n>>> median_grouped([1, 3, 3, 5, 7], interval=1)\n3.25\n>>> median_grouped([1, 3, 3, 5, 7], interval=2)\n3.5\n\nThis function does not check whether the data points are at least\n``interval`` apart.",
      "relationships": [
        {
          "target": "stdlib.statistics.sorted",
          "type": "calls"
        },
        {
          "target": "stdlib.statistics.len",
          "type": "calls"
        },
        {
          "target": "stdlib.statistics._find_lteq",
          "type": "calls"
        },
        {
          "target": "stdlib.statistics._find_rteq",
          "type": "calls"
        },
        {
          "target": "stdlib.statistics.StatisticsError",
          "type": "calls"
        },
        {
          "target": "stdlib.statistics.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.statistics.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.statistics.float",
          "type": "calls"
        },
        {
          "target": "stdlib.statistics.float",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.statistics.median_high",
      "name": "median_high",
      "module": "statistics",
      "type": "function",
      "signature": "(data)",
      "description": "Return the high median of data.\n\nWhen the number of data points is odd, the middle value is returned.\nWhen it is even, the larger of the two middle values is returned.\n\n>>> median_high([1, 3, 5])\n3\n>>> median_high([1, 3, 5, 7])\n5",
      "relationships": [
        {
          "target": "stdlib.statistics.sorted",
          "type": "calls"
        },
        {
          "target": "stdlib.statistics.len",
          "type": "calls"
        },
        {
          "target": "stdlib.statistics.StatisticsError",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.statistics.median_low",
      "name": "median_low",
      "module": "statistics",
      "type": "function",
      "signature": "(data)",
      "description": "Return the low median of numeric data.\n\nWhen the number of data points is odd, the middle value is returned.\nWhen it is even, the smaller of the two middle values is returned.\n\n>>> median_low([1, 3, 5])\n3\n>>> median_low([1, 3, 5, 7])\n3",
      "relationships": [
        {
          "target": "stdlib.statistics.sorted",
          "type": "calls"
        },
        {
          "target": "stdlib.statistics.len",
          "type": "calls"
        },
        {
          "target": "stdlib.statistics.StatisticsError",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.statistics.mode",
      "name": "mode",
      "module": "statistics",
      "type": "function",
      "signature": "(data)",
      "description": "Return the most common data point from discrete or nominal data.\n\n``mode`` assumes discrete data, and returns a single value. This is the\nstandard treatment of the mode as commonly taught in schools:\n\n    >>> mode([1, 1, 2, 3, 3, 3, 3, 4])\n    3\n\nThis also works with nominal (non-numeric) data:\n\n    >>> mode([\"red\", \"blue\", \"blue\", \"red\", \"green\", \"red\", \"red\"])\n    'red'\n\nIf there are multiple modes with same frequency, return the first one\nencountered:\n\n    >>> mode(['red', 'red', 'green', 'blue', 'blue'])\n    'red'\n\nIf *data* is empty, ``mode``, raises StatisticsError.",
      "relationships": [
        {
          "target": "stdlib.statistics.most_common",
          "type": "calls"
        },
        {
          "target": "stdlib.statistics.Counter",
          "type": "calls"
        },
        {
          "target": "stdlib.statistics.StatisticsError",
          "type": "calls"
        },
        {
          "target": "stdlib.statistics.iter",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.statistics.multimode",
      "name": "multimode",
      "module": "statistics",
      "type": "function",
      "signature": "(data)",
      "description": "Return a list of the most frequently occurring values.\n\nWill return more than one result if there are multiple modes\nor an empty list if *data* is empty.\n\n>>> multimode('aabbbbbbbbcc')\n['b']\n>>> multimode('aabbbbccddddeeffffgg')\n['b', 'd', 'f']\n>>> multimode('')\n[]",
      "relationships": [
        {
          "target": "stdlib.statistics.most_common",
          "type": "calls"
        },
        {
          "target": "stdlib.statistics.next",
          "type": "calls"
        },
        {
          "target": "stdlib.statistics.list",
          "type": "calls"
        },
        {
          "target": "stdlib.statistics.groupby",
          "type": "calls"
        },
        {
          "target": "stdlib.statistics.map",
          "type": "calls"
        },
        {
          "target": "stdlib.statistics.Counter",
          "type": "calls"
        },
        {
          "target": "stdlib.statistics.itemgetter",
          "type": "calls"
        },
        {
          "target": "stdlib.statistics.iter",
          "type": "calls"
        },
        {
          "target": "stdlib.statistics.itemgetter",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.statistics.pstdev",
      "name": "pstdev",
      "module": "statistics",
      "type": "function",
      "signature": "(data, mu=None)",
      "description": "Return the square root of the population variance.\n\nSee ``pvariance`` for arguments and other details.\n\n>>> pstdev([1.5, 2.5, 2.5, 2.75, 3.25, 4.75])\n0.986893273527251",
      "relationships": [
        {
          "target": "stdlib.statistics.pvariance",
          "type": "calls"
        },
        {
          "target": "stdlib.statistics.sqrt",
          "type": "calls"
        },
        {
          "target": "stdlib.statistics.sqrt",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.statistics.pvariance",
      "name": "pvariance",
      "module": "statistics",
      "type": "function",
      "signature": "(data, mu=None)",
      "description": "Return the population variance of ``data``.\n\ndata should be a sequence or iterable of Real-valued numbers, with at least one\nvalue. The optional argument mu, if given, should be the mean of\nthe data. If it is missing or None, the mean is automatically calculated.\n\nUse this function to calculate the variance from the entire population.\nTo estimate the variance from a sample, the ``variance`` function is\nusually a better choice.\n\nExamples:\n\n>>> data = [0.0, 0.25, 0.25, 1.25, 1.5, 1.75, 2.75, 3.25]\n>>> pvariance(data)\n1.25\n\nIf you have already calculated the mean of the data, you can pass it as\nthe optional second argument to avoid recalculating it:\n\n>>> mu = mean(data)\n>>> pvariance(data, mu)\n1.25\n\nDecimals and Fractions are supported:\n\n>>> from decimal import Decimal as D\n>>> pvariance([D(\"27.5\"), D(\"30.25\"), D(\"30.25\"), D(\"34.5\"), D(\"41.75\")])\nDecimal('24.815')\n\n>>> from fractions import Fraction as F\n>>> pvariance([F(1, 4), F(5, 4), F(1, 2)])\nFraction(13, 72)",
      "relationships": [
        {
          "target": "stdlib.statistics.len",
          "type": "calls"
        },
        {
          "target": "stdlib.statistics._ss",
          "type": "calls"
        },
        {
          "target": "stdlib.statistics._convert",
          "type": "calls"
        },
        {
          "target": "stdlib.statistics.iter",
          "type": "calls"
        },
        {
          "target": "stdlib.statistics.list",
          "type": "calls"
        },
        {
          "target": "stdlib.statistics.StatisticsError",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.statistics.quantiles",
      "name": "quantiles",
      "module": "statistics",
      "type": "function",
      "signature": "(data, *, n=4, method='exclusive')",
      "description": "Divide *data* into *n* continuous intervals with equal probability.\n\nReturns a list of (n - 1) cut points separating the intervals.\n\nSet *n* to 4 for quartiles (the default).  Set *n* to 10 for deciles.\nSet *n* to 100 for percentiles which gives the 99 cuts points that\nseparate *data* in to 100 equal sized groups.\n\nThe *data* can be any iterable containing sample.\nThe cut points are linearly interpolated between data points.\n\nIf *method* is set to *inclusive*, *data* is treated as population\ndata.  The minimum value is treated as the 0th percentile and the\nmaximum value is treated as the 100th percentile.",
      "relationships": [
        {
          "target": "stdlib.statistics.sorted",
          "type": "calls"
        },
        {
          "target": "stdlib.statistics.len",
          "type": "calls"
        },
        {
          "target": "stdlib.statistics.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.statistics.StatisticsError",
          "type": "calls"
        },
        {
          "target": "stdlib.statistics.StatisticsError",
          "type": "calls"
        },
        {
          "target": "stdlib.statistics.range",
          "type": "calls"
        },
        {
          "target": "stdlib.statistics.range",
          "type": "calls"
        },
        {
          "target": "stdlib.statistics.divmod",
          "type": "calls"
        },
        {
          "target": "stdlib.statistics.append",
          "type": "calls"
        },
        {
          "target": "stdlib.statistics.append",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.statistics.stdev",
      "name": "stdev",
      "module": "statistics",
      "type": "function",
      "signature": "(data, xbar=None)",
      "description": "Return the square root of the sample variance.\n\nSee ``variance`` for arguments and other details.\n\n>>> stdev([1.5, 2.5, 2.5, 2.75, 3.25, 4.75])\n1.0810874155219827",
      "relationships": [
        {
          "target": "stdlib.statistics.variance",
          "type": "calls"
        },
        {
          "target": "stdlib.statistics.sqrt",
          "type": "calls"
        },
        {
          "target": "stdlib.statistics.sqrt",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.statistics.variance",
      "name": "variance",
      "module": "statistics",
      "type": "function",
      "signature": "(data, xbar=None)",
      "description": "Return the sample variance of data.\n\ndata should be an iterable of Real-valued numbers, with at least two\nvalues. The optional argument xbar, if given, should be the mean of\nthe data. If it is missing or None, the mean is automatically calculated.\n\nUse this function when your data is a sample from a population. To\ncalculate the variance from the entire population, see ``pvariance``.\n\nExamples:\n\n>>> data = [2.75, 1.75, 1.25, 0.25, 0.5, 1.25, 3.5]\n>>> variance(data)\n1.3720238095238095\n\nIf you have already calculated the mean of your data, you can pass it as\nthe optional second argument ``xbar`` to avoid recalculating it:\n\n>>> m = mean(data)\n>>> variance(data, m)\n1.3720238095238095\n\nThis function does not check that ``xbar`` is actually the mean of\n``data``. Giving arbitrary values for ``xbar`` may lead to invalid or\nimpossible results.\n\nDecimals and Fractions are supported:\n\n>>> from decimal import Decimal as D\n>>> variance([D(\"27.5\"), D(\"30.25\"), D(\"30.25\"), D(\"34.5\"), D(\"41.75\")])\nDecimal('31.01875')\n\n>>> from fractions import Fraction as F\n>>> variance([F(1, 6), F(1, 2), F(5, 3)])\nFraction(67, 108)",
      "relationships": [
        {
          "target": "stdlib.statistics.len",
          "type": "calls"
        },
        {
          "target": "stdlib.statistics._ss",
          "type": "calls"
        },
        {
          "target": "stdlib.statistics._convert",
          "type": "calls"
        },
        {
          "target": "stdlib.statistics.iter",
          "type": "calls"
        },
        {
          "target": "stdlib.statistics.list",
          "type": "calls"
        },
        {
          "target": "stdlib.statistics.StatisticsError",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.string.Formatter",
      "name": "Formatter",
      "module": "string",
      "type": "class",
      "signature": "()",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.string.Template",
      "name": "Template",
      "module": "string",
      "type": "class",
      "signature": "(template)",
      "description": "A string class for supporting $-substitutions.",
      "relationships": []
    },
    {
      "id": "stdlib.string.capwords",
      "name": "capwords",
      "module": "string",
      "type": "function",
      "signature": "(s, sep=None)",
      "description": "capwords(s [,sep]) -> string\n\nSplit the argument into words using split, capitalize each\nword using capitalize, and join the capitalized words using\njoin.  If the optional second argument sep is absent or None,\nruns of whitespace characters are replaced by a single space\nand leading and trailing whitespace are removed, otherwise\nsep is used to split and join the words.",
      "relationships": [
        {
          "target": "stdlib.string.join",
          "type": "calls"
        },
        {
          "target": "stdlib.string.capitalize",
          "type": "calls"
        },
        {
          "target": "stdlib.string.split",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.stringprep.in_table_a1",
      "name": "in_table_a1",
      "module": "stringprep",
      "type": "function",
      "signature": "(code)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.stringprep.ord",
          "type": "calls"
        },
        {
          "target": "stdlib.stringprep.category",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.stringprep.in_table_b1",
      "name": "in_table_b1",
      "module": "stringprep",
      "type": "function",
      "signature": "(code)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.stringprep.ord",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.stringprep.in_table_c11",
      "name": "in_table_c11",
      "module": "stringprep",
      "type": "function",
      "signature": "(code)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.stringprep.in_table_c11_c12",
      "name": "in_table_c11_c12",
      "module": "stringprep",
      "type": "function",
      "signature": "(code)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.stringprep.category",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.stringprep.in_table_c12",
      "name": "in_table_c12",
      "module": "stringprep",
      "type": "function",
      "signature": "(code)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.stringprep.category",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.stringprep.in_table_c21",
      "name": "in_table_c21",
      "module": "stringprep",
      "type": "function",
      "signature": "(code)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.stringprep.ord",
          "type": "calls"
        },
        {
          "target": "stdlib.stringprep.category",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.stringprep.in_table_c21_c22",
      "name": "in_table_c21_c22",
      "module": "stringprep",
      "type": "function",
      "signature": "(code)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.stringprep.category",
          "type": "calls"
        },
        {
          "target": "stdlib.stringprep.ord",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.stringprep.in_table_c22",
      "name": "in_table_c22",
      "module": "stringprep",
      "type": "function",
      "signature": "(code)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.stringprep.ord",
          "type": "calls"
        },
        {
          "target": "stdlib.stringprep.category",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.stringprep.in_table_c3",
      "name": "in_table_c3",
      "module": "stringprep",
      "type": "function",
      "signature": "(code)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.stringprep.category",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.stringprep.in_table_c4",
      "name": "in_table_c4",
      "module": "stringprep",
      "type": "function",
      "signature": "(code)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.stringprep.ord",
          "type": "calls"
        },
        {
          "target": "stdlib.stringprep.ord",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.stringprep.in_table_c5",
      "name": "in_table_c5",
      "module": "stringprep",
      "type": "function",
      "signature": "(code)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.stringprep.category",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.stringprep.in_table_c6",
      "name": "in_table_c6",
      "module": "stringprep",
      "type": "function",
      "signature": "(code)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.stringprep.ord",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.stringprep.in_table_c7",
      "name": "in_table_c7",
      "module": "stringprep",
      "type": "function",
      "signature": "(code)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.stringprep.ord",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.stringprep.in_table_c8",
      "name": "in_table_c8",
      "module": "stringprep",
      "type": "function",
      "signature": "(code)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.stringprep.ord",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.stringprep.in_table_c9",
      "name": "in_table_c9",
      "module": "stringprep",
      "type": "function",
      "signature": "(code)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.stringprep.ord",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.stringprep.in_table_d1",
      "name": "in_table_d1",
      "module": "stringprep",
      "type": "function",
      "signature": "(code)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.stringprep.bidirectional",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.stringprep.in_table_d2",
      "name": "in_table_d2",
      "module": "stringprep",
      "type": "function",
      "signature": "(code)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.stringprep.bidirectional",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.stringprep.map_table_b2",
      "name": "map_table_b2",
      "module": "stringprep",
      "type": "function",
      "signature": "(a)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.stringprep.map_table_b3",
          "type": "calls"
        },
        {
          "target": "stdlib.stringprep.normalize",
          "type": "calls"
        },
        {
          "target": "stdlib.stringprep.join",
          "type": "calls"
        },
        {
          "target": "stdlib.stringprep.normalize",
          "type": "calls"
        },
        {
          "target": "stdlib.stringprep.map_table_b3",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.stringprep.map_table_b3",
      "name": "map_table_b3",
      "module": "stringprep",
      "type": "function",
      "signature": "(code)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.stringprep.get",
          "type": "calls"
        },
        {
          "target": "stdlib.stringprep.lower",
          "type": "calls"
        },
        {
          "target": "stdlib.stringprep.ord",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.subprocess.CalledProcessError",
      "name": "CalledProcessError",
      "module": "subprocess",
      "type": "class",
      "signature": "(returncode, cmd, output=None, stderr=None)",
      "description": "Raised when run() is called with check=True and the process\nreturns a non-zero exit status.\n\nAttributes:\n  cmd, returncode, stdout, stderr, output",
      "relationships": [
        {
          "target": "SubprocessError",
          "type": "base_class"
        },
        {
          "target": "Exception",
          "type": "base_class"
        },
        {
          "target": "BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.subprocess.CompletedProcess",
      "name": "CompletedProcess",
      "module": "subprocess",
      "type": "class",
      "signature": "(args, returncode, stdout=None, stderr=None)",
      "description": "A process that has finished running.\n\nThis is returned by run().\n\nAttributes:\n  args: The list or str args passed to run().\n  returncode: The exit code of the process, negative for signals.\n  stdout: The standard output (None if not captured).\n  stderr: The standard error (None if not captured).",
      "relationships": []
    },
    {
      "id": "stdlib.subprocess.Popen",
      "name": "Popen",
      "module": "subprocess",
      "type": "class",
      "signature": "(args, bufsize=-1, executable=None, stdin=None, stdout=None, stderr=None, preexec_fn=None, close_fds=True, shell=False, cwd=None, env=None, universal_newlines=None, startupinfo=None, creationflags=0, restore_signals=True, start_new_session=False, pass_fds=(), *, user=None, group=None, extra_groups=None, encoding=None, errors=None, text=None, umask=-1)",
      "description": "Execute a child program in a new process.\n\nFor a complete description of the arguments see the Python documentation.\n\nArguments:\n  args: A string, or a sequence of program arguments.\n\n  bufsize: supplied as the buffering argument to the open() function when\n      creating the stdin/stdout/stderr pipe file objects\n\n  executable: A replacement program to execute.\n\n  stdin, stdout and stderr: These specify the executed programs' standard\n      input, standard output and standard error file handles, respectively.\n\n  preexec_fn: (POSIX only) An object to be called in the child process\n      just before the child is executed.\n\n  close_fds: Controls closing or inheriting of file descriptors.\n\n  shell: If true, the command will be executed through the shell.\n\n  cwd: Sets the current directory before the child is executed.\n\n  env: Defines the environment variables for the new process.\n\n  text: If true, decode stdin, stdout and stderr using the given encoding\n      (if set) or the system default otherwise.\n\n  universal_newlines: Alias of text, provided for backwards compatibility.\n\n  startupinfo and creationflags (Windows only)\n\n  restore_signals (POSIX only)\n\n  start_new_session (POSIX only)\n\n  group (POSIX only)\n\n  extra_groups (POSIX only)\n\n  user (POSIX only)\n\n  umask (POSIX only)\n\n  pass_fds (POSIX only)\n\n  encoding and errors: Text mode encoding and error handling to use for\n      file objects stdin, stdout and stderr.\n\nAttributes:\n    stdin, stdout, stderr, pid, returncode",
      "relationships": []
    },
    {
      "id": "stdlib.subprocess.TimeoutExpired",
      "name": "TimeoutExpired",
      "module": "subprocess",
      "type": "class",
      "signature": "(cmd, timeout, output=None, stderr=None)",
      "description": "This exception is raised when the timeout expires while waiting for a\nchild process.\n\nAttributes:\n    cmd, output, stdout, stderr, timeout",
      "relationships": [
        {
          "target": "SubprocessError",
          "type": "base_class"
        },
        {
          "target": "Exception",
          "type": "base_class"
        },
        {
          "target": "BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.subprocess.call",
      "name": "call",
      "module": "subprocess",
      "type": "function",
      "signature": "(*popenargs, timeout=None, **kwargs)",
      "description": "Run command with arguments.  Wait for command to complete or\ntimeout, then return the returncode attribute.\n\nThe arguments are the same as for the Popen constructor.  Example:\n\nretcode = call([\"ls\", \"-l\"])",
      "relationships": [
        {
          "target": "stdlib.subprocess.Popen",
          "type": "calls"
        },
        {
          "target": "stdlib.subprocess.wait",
          "type": "calls"
        },
        {
          "target": "stdlib.subprocess.kill",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.subprocess.check_call",
      "name": "check_call",
      "module": "subprocess",
      "type": "function",
      "signature": "(*popenargs, **kwargs)",
      "description": "Run command with arguments.  Wait for command to complete.  If\nthe exit code was zero then return, otherwise raise\nCalledProcessError.  The CalledProcessError object will have the\nreturn code in the returncode attribute.\n\nThe arguments are the same as for the call function.  Example:\n\ncheck_call([\"ls\", \"-l\"])",
      "relationships": [
        {
          "target": "stdlib.subprocess.call",
          "type": "calls"
        },
        {
          "target": "stdlib.subprocess.get",
          "type": "calls"
        },
        {
          "target": "stdlib.subprocess.CalledProcessError",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.subprocess.check_output",
      "name": "check_output",
      "module": "subprocess",
      "type": "function",
      "signature": "(*popenargs, timeout=None, **kwargs)",
      "description": "Run command with arguments and return its output.\n\nIf the exit code was non-zero it raises a CalledProcessError.  The\nCalledProcessError object will have the return code in the returncode\nattribute and output in the output attribute.\n\nThe arguments are the same as for the Popen constructor.  Example:\n\n>>> check_output([\"ls\", \"-l\", \"/dev/null\"])\nb'crw-rw-rw- 1 root root 1, 3 Oct 18  2007 /dev/null\\n'\n\nThe stdout argument is not allowed as it is used internally.\nTo capture standard error in the result, use stderr=STDOUT.\n\n>>> check_output([\"/bin/sh\", \"-c\",\n...               \"ls -l non_existent_file ; exit 0\"],\n...              stderr=STDOUT)\nb'ls: non_existent_file: No such file or directory\\n'\n\nThere is an additional optional argument, \"input\", allowing you to\npass a string to the subprocess's stdin.  If you use this argument\nyou may not also use the Popen constructor's \"stdin\" argument, as\nit too will be used internally.  Example:\n\n>>> check_output([\"sed\", \"-e\", \"s/foo/bar/\"],\n...              input=b\"when in the course of fooman events\\n\")\nb'when in the course of barman events\\n'\n\nBy default, all communication is in bytes, and therefore any \"input\"\nshould be bytes, and the return value will be bytes.  If in text mode,\nany \"input\" should be a string, and the return value will be a string\ndecoded according to locale encoding, or by \"encoding\" if set. Text mode\nis triggered by setting any of text, encoding, errors or universal_newlines.",
      "relationships": [
        {
          "target": "stdlib.subprocess.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.subprocess.run",
          "type": "calls"
        },
        {
          "target": "stdlib.subprocess.get",
          "type": "calls"
        },
        {
          "target": "stdlib.subprocess.get",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.subprocess.getoutput",
      "name": "getoutput",
      "module": "subprocess",
      "type": "function",
      "signature": "(cmd)",
      "description": "Return output (stdout or stderr) of executing cmd in a shell.\n\nLike getstatusoutput(), except the exit status is ignored and the return\nvalue is a string containing the command's output.  Example:\n\n>>> import subprocess\n>>> subprocess.getoutput('ls /bin/ls')\n'/bin/ls'",
      "relationships": [
        {
          "target": "stdlib.subprocess.getstatusoutput",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.subprocess.getstatusoutput",
      "name": "getstatusoutput",
      "module": "subprocess",
      "type": "function",
      "signature": "(cmd)",
      "description": "Return (exitcode, output) of executing cmd in a shell.\n\nExecute the string 'cmd' in a shell with 'check_output' and\nreturn a 2-tuple (status, output). The locale encoding is used\nto decode the output and process newlines.\n\nA trailing newline is stripped from the output.\nThe exit status for the command can be interpreted\naccording to the rules for the function 'wait'. Example:\n\n>>> import subprocess\n>>> subprocess.getstatusoutput('ls /bin/ls')\n(0, '/bin/ls')\n>>> subprocess.getstatusoutput('cat /bin/junk')\n(1, 'cat: /bin/junk: No such file or directory')\n>>> subprocess.getstatusoutput('/bin/junk')\n(127, 'sh: /bin/junk: not found')\n>>> subprocess.getstatusoutput('/bin/kill $$')\n(-15, '')",
      "relationships": [
        {
          "target": "stdlib.subprocess.check_output",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.subprocess.list2cmdline",
      "name": "list2cmdline",
      "module": "subprocess",
      "type": "function",
      "signature": "(seq)",
      "description": "Translate a sequence of arguments into a command line\nstring, using the same rules as the MS C runtime:\n\n1) Arguments are delimited by white space, which is either a\n   space or a tab.\n\n2) A string surrounded by double quotation marks is\n   interpreted as a single argument, regardless of white space\n   contained within.  A quoted string can be embedded in an\n   argument.\n\n3) A double quotation mark preceded by a backslash is\n   interpreted as a literal double quotation mark.\n\n4) Backslashes are interpreted literally, unless they\n   immediately precede a double quotation mark.\n\n5) If backslashes immediately precede a double quotation mark,\n   every pair of backslashes is interpreted as a literal\n   backslash.  If the number of backslashes is odd, the last\n   backslash escapes the next double quotation mark as\n   described in rule 3.",
      "relationships": [
        {
          "target": "stdlib.subprocess.map",
          "type": "calls"
        },
        {
          "target": "stdlib.subprocess.join",
          "type": "calls"
        },
        {
          "target": "stdlib.subprocess.append",
          "type": "calls"
        },
        {
          "target": "stdlib.subprocess.append",
          "type": "calls"
        },
        {
          "target": "stdlib.subprocess.extend",
          "type": "calls"
        },
        {
          "target": "stdlib.subprocess.extend",
          "type": "calls"
        },
        {
          "target": "stdlib.subprocess.append",
          "type": "calls"
        },
        {
          "target": "stdlib.subprocess.append",
          "type": "calls"
        },
        {
          "target": "stdlib.subprocess.append",
          "type": "calls"
        },
        {
          "target": "stdlib.subprocess.append",
          "type": "calls"
        },
        {
          "target": "stdlib.subprocess.append",
          "type": "calls"
        },
        {
          "target": "stdlib.subprocess.extend",
          "type": "calls"
        },
        {
          "target": "stdlib.subprocess.len",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.subprocess.run",
      "name": "run",
      "module": "subprocess",
      "type": "function",
      "signature": "(*popenargs, input=None, capture_output=False, timeout=None, check=False, **kwargs)",
      "description": "Run command with arguments and return a CompletedProcess instance.\n\nThe returned instance will have attributes args, returncode, stdout and\nstderr. By default, stdout and stderr are not captured, and those attributes\nwill be None. Pass stdout=PIPE and/or stderr=PIPE in order to capture them.\n\nIf check is True and the exit code was non-zero, it raises a\nCalledProcessError. The CalledProcessError object will have the return code\nin the returncode attribute, and output & stderr attributes if those streams\nwere captured.\n\nIf timeout is given, and the process takes too long, a TimeoutExpired\nexception will be raised.\n\nThere is an optional argument \"input\", allowing you to\npass bytes or a string to the subprocess's stdin.  If you use this argument\nyou may not also use the Popen constructor's \"stdin\" argument, as\nit will be used internally.\n\nBy default, all communication is in bytes, and therefore any \"input\" should\nbe bytes, and the stdout and stderr will be bytes. If in text mode, any\n\"input\" should be a string, and stdout and stderr will be strings decoded\naccording to locale encoding, or by \"encoding\" if set. Text mode is\ntriggered by setting any of text, encoding, errors or universal_newlines.\n\nThe other arguments are the same as for the Popen constructor.",
      "relationships": [
        {
          "target": "stdlib.subprocess.CompletedProcess",
          "type": "calls"
        },
        {
          "target": "stdlib.subprocess.Popen",
          "type": "calls"
        },
        {
          "target": "stdlib.subprocess.poll",
          "type": "calls"
        },
        {
          "target": "stdlib.subprocess.get",
          "type": "calls"
        },
        {
          "target": "stdlib.subprocess.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.subprocess.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.subprocess.communicate",
          "type": "calls"
        },
        {
          "target": "stdlib.subprocess.CalledProcessError",
          "type": "calls"
        },
        {
          "target": "stdlib.subprocess.get",
          "type": "calls"
        },
        {
          "target": "stdlib.subprocess.get",
          "type": "calls"
        },
        {
          "target": "stdlib.subprocess.kill",
          "type": "calls"
        },
        {
          "target": "stdlib.subprocess.kill",
          "type": "calls"
        },
        {
          "target": "stdlib.subprocess.communicate",
          "type": "calls"
        },
        {
          "target": "stdlib.subprocess.wait",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.sunau.Au_read",
      "name": "Au_read",
      "module": "sunau",
      "type": "class",
      "signature": "(f)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.sunau.Au_write",
      "name": "Au_write",
      "module": "sunau",
      "type": "class",
      "signature": "(f)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.sunau.namedtuple",
      "name": "namedtuple",
      "module": "sunau",
      "type": "function",
      "signature": "(typename, field_names, *, rename=False, defaults=None, module=None)",
      "description": "Returns a new subclass of tuple with named fields.\n\n>>> Point = namedtuple('Point', ['x', 'y'])\n>>> Point.__doc__                   # docstring for the new class\n'Point(x, y)'\n>>> p = Point(11, y=22)             # instantiate with positional args or keywords\n>>> p[0] + p[1]                     # indexable like a plain tuple\n33\n>>> x, y = p                        # unpack like a regular tuple\n>>> x, y\n(11, 22)\n>>> p.x + p.y                       # fields also accessible by name\n33\n>>> d = p._asdict()                 # convert to a dictionary\n>>> d['x']\n11\n>>> Point(**d)                      # convert from a dictionary\nPoint(x=11, y=22)\n>>> p._replace(x=100)               # _replace() is like str.replace() but targets named fields\nPoint(x=100, y=22)",
      "relationships": [
        {
          "target": "stdlib.sunau.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.sunau.list",
          "type": "calls"
        },
        {
          "target": "stdlib.sunau.intern",
          "type": "calls"
        },
        {
          "target": "stdlib.sunau.set",
          "type": "calls"
        },
        {
          "target": "stdlib.sunau.tuple",
          "type": "calls"
        },
        {
          "target": "stdlib.sunau.len",
          "type": "calls"
        },
        {
          "target": "stdlib.sunau.join",
          "type": "calls"
        },
        {
          "target": "stdlib.sunau.eval",
          "type": "calls"
        },
        {
          "target": "stdlib.sunau.enumerate",
          "type": "calls"
        },
        {
          "target": "stdlib.sunau.type",
          "type": "calls"
        },
        {
          "target": "stdlib.sunau.split",
          "type": "calls"
        },
        {
          "target": "stdlib.sunau.map",
          "type": "calls"
        },
        {
          "target": "stdlib.sunau.str",
          "type": "calls"
        },
        {
          "target": "stdlib.sunau.set",
          "type": "calls"
        },
        {
          "target": "stdlib.sunau.enumerate",
          "type": "calls"
        },
        {
          "target": "stdlib.sunau._iskeyword",
          "type": "calls"
        },
        {
          "target": "stdlib.sunau.add",
          "type": "calls"
        },
        {
          "target": "stdlib.sunau.tuple",
          "type": "calls"
        },
        {
          "target": "stdlib.sunau.dict",
          "type": "calls"
        },
        {
          "target": "stdlib.sunau.map",
          "type": "calls"
        },
        {
          "target": "stdlib.sunau.tuple_new",
          "type": "calls"
        },
        {
          "target": "stdlib.sunau._make",
          "type": "calls"
        },
        {
          "target": "stdlib.sunau._dict",
          "type": "calls"
        },
        {
          "target": "stdlib.sunau._tuple",
          "type": "calls"
        },
        {
          "target": "stdlib.sunau.intern",
          "type": "calls"
        },
        {
          "target": "stdlib.sunau._tuplegetter",
          "type": "calls"
        },
        {
          "target": "stdlib.sunau.add",
          "type": "calls"
        },
        {
          "target": "stdlib.sunau.type",
          "type": "calls"
        },
        {
          "target": "stdlib.sunau.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.sunau.isidentifier",
          "type": "calls"
        },
        {
          "target": "stdlib.sunau.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.sunau.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.sunau.startswith",
          "type": "calls"
        },
        {
          "target": "stdlib.sunau.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.sunau.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.sunau.len",
          "type": "calls"
        },
        {
          "target": "stdlib.sunau.len",
          "type": "calls"
        },
        {
          "target": "stdlib.sunau.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.sunau.reversed",
          "type": "calls"
        },
        {
          "target": "stdlib.sunau.join",
          "type": "calls"
        },
        {
          "target": "stdlib.sunau._len",
          "type": "calls"
        },
        {
          "target": "stdlib.sunau.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.sunau._map",
          "type": "calls"
        },
        {
          "target": "stdlib.sunau.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.sunau._zip",
          "type": "calls"
        },
        {
          "target": "stdlib.sunau.get",
          "type": "calls"
        },
        {
          "target": "stdlib.sunau.replace",
          "type": "calls"
        },
        {
          "target": "stdlib.sunau._iskeyword",
          "type": "calls"
        },
        {
          "target": "stdlib.sunau.startswith",
          "type": "calls"
        },
        {
          "target": "stdlib.sunau.list",
          "type": "calls"
        },
        {
          "target": "stdlib.sunau.isidentifier",
          "type": "calls"
        },
        {
          "target": "stdlib.sunau.zip",
          "type": "calls"
        },
        {
          "target": "stdlib.sunau.reversed",
          "type": "calls"
        },
        {
          "target": "stdlib.sunau.reversed",
          "type": "calls"
        },
        {
          "target": "stdlib.sunau.len",
          "type": "calls"
        },
        {
          "target": "stdlib.sunau.list",
          "type": "calls"
        },
        {
          "target": "stdlib.sunau._getframe",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.sunau.open",
      "name": "open",
      "module": "sunau",
      "type": "function",
      "signature": "(f, mode=None)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.sunau.hasattr",
          "type": "calls"
        },
        {
          "target": "stdlib.sunau.Au_read",
          "type": "calls"
        },
        {
          "target": "stdlib.sunau.Au_write",
          "type": "calls"
        },
        {
          "target": "stdlib.sunau.Error",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.symtable.Class",
      "name": "Class",
      "module": "symtable",
      "type": "class",
      "signature": "(raw_table, filename)",
      "description": "",
      "relationships": [
        {
          "target": "SymbolTable",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.symtable.Function",
      "name": "Function",
      "module": "symtable",
      "type": "class",
      "signature": "(raw_table, filename)",
      "description": "",
      "relationships": [
        {
          "target": "SymbolTable",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.symtable.Symbol",
      "name": "Symbol",
      "module": "symtable",
      "type": "class",
      "signature": "(name, flags, namespaces=None, *, module_scope=False)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.symtable.SymbolTable",
      "name": "SymbolTable",
      "module": "symtable",
      "type": "class",
      "signature": "(raw_table, filename)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.symtable.SymbolTableFactory",
      "name": "SymbolTableFactory",
      "module": "symtable",
      "type": "class",
      "signature": "()",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.symtable.symtable",
      "name": "symtable",
      "module": "symtable",
      "type": "function",
      "signature": "(code, filename, compile_type)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.symtable.symtable",
          "type": "calls"
        },
        {
          "target": "stdlib.symtable._newSymbolTable",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.sysconfig.get_config_h_filename",
      "name": "get_config_h_filename",
      "module": "sysconfig",
      "type": "function",
      "signature": "()",
      "description": "Return the path of pyconfig.h.",
      "relationships": [
        {
          "target": "stdlib.sysconfig.join",
          "type": "calls"
        },
        {
          "target": "stdlib.sysconfig.get_path",
          "type": "calls"
        },
        {
          "target": "stdlib.sysconfig.join",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.sysconfig.get_config_var",
      "name": "get_config_var",
      "module": "sysconfig",
      "type": "function",
      "signature": "(name)",
      "description": "Return the value of a single variable using the dictionary returned by\n'get_config_vars()'.\n\nEquivalent to get_config_vars().get(name)",
      "relationships": [
        {
          "target": "stdlib.sysconfig.get",
          "type": "calls"
        },
        {
          "target": "stdlib.sysconfig.warn",
          "type": "calls"
        },
        {
          "target": "stdlib.sysconfig.get_config_vars",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.sysconfig.get_config_vars",
      "name": "get_config_vars",
      "module": "sysconfig",
      "type": "function",
      "signature": "(*args)",
      "description": "With no arguments, return a dictionary of all configuration\nvariables relevant for the current platform.\n\nOn Unix, this means every variable defined in Python's installed Makefile;\nOn Windows it's a much smaller set.\n\nWith arguments, return a list of values that result from looking up\neach argument in the configuration variable dictionary.",
      "relationships": [
        {
          "target": "stdlib.sysconfig.get",
          "type": "calls"
        },
        {
          "target": "stdlib.sysconfig._getuserbase",
          "type": "calls"
        },
        {
          "target": "stdlib.sysconfig.get",
          "type": "calls"
        },
        {
          "target": "stdlib.sysconfig._safe_realpath",
          "type": "calls"
        },
        {
          "target": "stdlib.sysconfig._init_non_posix",
          "type": "calls"
        },
        {
          "target": "stdlib.sysconfig._init_posix",
          "type": "calls"
        },
        {
          "target": "stdlib.sysconfig.customize_config_vars",
          "type": "calls"
        },
        {
          "target": "stdlib.sysconfig.append",
          "type": "calls"
        },
        {
          "target": "stdlib.sysconfig.dirname",
          "type": "calls"
        },
        {
          "target": "stdlib.sysconfig.join",
          "type": "calls"
        },
        {
          "target": "stdlib.sysconfig.dirname",
          "type": "calls"
        },
        {
          "target": "stdlib.sysconfig.get",
          "type": "calls"
        },
        {
          "target": "stdlib.sysconfig.get_makefile_filename",
          "type": "calls"
        },
        {
          "target": "stdlib.sysconfig.get_makefile_filename",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.sysconfig.get_makefile_filename",
      "name": "get_makefile_filename",
      "module": "sysconfig",
      "type": "function",
      "signature": "()",
      "description": "Return the path of the Makefile.",
      "relationships": [
        {
          "target": "stdlib.sysconfig.hasattr",
          "type": "calls"
        },
        {
          "target": "stdlib.sysconfig.hasattr",
          "type": "calls"
        },
        {
          "target": "stdlib.sysconfig.join",
          "type": "calls"
        },
        {
          "target": "stdlib.sysconfig.join",
          "type": "calls"
        },
        {
          "target": "stdlib.sysconfig.get_path",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.sysconfig.get_path",
      "name": "get_path",
      "module": "sysconfig",
      "type": "function",
      "signature": "(name, scheme='posix_prefix', vars=None, expand=True)",
      "description": "Return a path corresponding to the scheme.\n\n``scheme`` is the install scheme name.",
      "relationships": [
        {
          "target": "stdlib.sysconfig._get_default_scheme",
          "type": "calls"
        },
        {
          "target": "stdlib.sysconfig.get_paths",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.sysconfig.get_path_names",
      "name": "get_path_names",
      "module": "sysconfig",
      "type": "function",
      "signature": "()",
      "description": "Return a tuple containing the paths names.",
      "relationships": []
    },
    {
      "id": "stdlib.sysconfig.get_paths",
      "name": "get_paths",
      "module": "sysconfig",
      "type": "function",
      "signature": "(scheme='posix_prefix', vars=None, expand=True)",
      "description": "Return a mapping containing an install scheme.\n\n``scheme`` is the install scheme name. If not provided, it will\nreturn the default scheme for the current platform.",
      "relationships": [
        {
          "target": "stdlib.sysconfig._get_default_scheme",
          "type": "calls"
        },
        {
          "target": "stdlib.sysconfig._expand_vars",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.sysconfig.get_platform",
      "name": "get_platform",
      "module": "sysconfig",
      "type": "function",
      "signature": "()",
      "description": "Return a string that identifies the current platform.\n\nThis is used mainly to distinguish platform-specific build directories and\nplatform-specific built distributions.  Typically includes the OS name and\nversion and the architecture (as supplied by 'os.uname()'), although the\nexact information included depends on the OS; on Linux, the kernel version\nisn't particularly important.\n\nExamples of returned values:\n   linux-i586\n   linux-alpha (?)\n   solaris-2.6-sun4u\n\nWindows will return one of:\n   win-amd64 (64bit Windows on AMD64 (aka x86_64, Intel64, EM64T, etc)\n   win32 (all others - specifically, sys.platform is returned)\n\nFor other non-POSIX platforms, currently just returns 'sys.platform'.",
      "relationships": [
        {
          "target": "stdlib.sysconfig.get",
          "type": "calls"
        },
        {
          "target": "stdlib.sysconfig.uname",
          "type": "calls"
        },
        {
          "target": "stdlib.sysconfig.replace",
          "type": "calls"
        },
        {
          "target": "stdlib.sysconfig.replace",
          "type": "calls"
        },
        {
          "target": "stdlib.sysconfig.replace",
          "type": "calls"
        },
        {
          "target": "stdlib.sysconfig.lower",
          "type": "calls"
        },
        {
          "target": "stdlib.sysconfig.lower",
          "type": "calls"
        },
        {
          "target": "stdlib.sysconfig.lower",
          "type": "calls"
        },
        {
          "target": "stdlib.sysconfig.hasattr",
          "type": "calls"
        },
        {
          "target": "stdlib.sysconfig.lower",
          "type": "calls"
        },
        {
          "target": "stdlib.sysconfig.aix_platform",
          "type": "calls"
        },
        {
          "target": "stdlib.sysconfig.compile",
          "type": "calls"
        },
        {
          "target": "stdlib.sysconfig.match",
          "type": "calls"
        },
        {
          "target": "stdlib.sysconfig.group",
          "type": "calls"
        },
        {
          "target": "stdlib.sysconfig.get_platform_osx",
          "type": "calls"
        },
        {
          "target": "stdlib.sysconfig.int",
          "type": "calls"
        },
        {
          "target": "stdlib.sysconfig.get_config_vars",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.sysconfig.get_python_version",
      "name": "get_python_version",
      "module": "sysconfig",
      "type": "function",
      "signature": "()",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.sysconfig.get_scheme_names",
      "name": "get_scheme_names",
      "module": "sysconfig",
      "type": "function",
      "signature": "()",
      "description": "Return a tuple containing the schemes names.",
      "relationships": [
        {
          "target": "stdlib.sysconfig.tuple",
          "type": "calls"
        },
        {
          "target": "stdlib.sysconfig.sorted",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.sysconfig.is_python_build",
      "name": "is_python_build",
      "module": "sysconfig",
      "type": "function",
      "signature": "(check_home=False)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.sysconfig._is_python_source_dir",
          "type": "calls"
        },
        {
          "target": "stdlib.sysconfig._is_python_source_dir",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.sysconfig.parse_config_h",
      "name": "parse_config_h",
      "module": "sysconfig",
      "type": "function",
      "signature": "(fp, vars=None)",
      "description": "Parse a config.h-style file.\n\nA dictionary containing name/value pairs is returned.  If an\noptional dictionary is passed in as the second argument, it is\nused instead of a new dictionary.",
      "relationships": [
        {
          "target": "stdlib.sysconfig.compile",
          "type": "calls"
        },
        {
          "target": "stdlib.sysconfig.compile",
          "type": "calls"
        },
        {
          "target": "stdlib.sysconfig.readline",
          "type": "calls"
        },
        {
          "target": "stdlib.sysconfig.match",
          "type": "calls"
        },
        {
          "target": "stdlib.sysconfig.group",
          "type": "calls"
        },
        {
          "target": "stdlib.sysconfig.match",
          "type": "calls"
        },
        {
          "target": "stdlib.sysconfig.int",
          "type": "calls"
        },
        {
          "target": "stdlib.sysconfig.group",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.sysconfig.realpath",
      "name": "realpath",
      "module": "sysconfig",
      "type": "function",
      "signature": "(filename)",
      "description": "Return the canonical path of the specified filename, eliminating any\nsymbolic links encountered in the path.",
      "relationships": [
        {
          "target": "stdlib.sysconfig.fspath",
          "type": "calls"
        },
        {
          "target": "stdlib.sysconfig._joinrealpath",
          "type": "calls"
        },
        {
          "target": "stdlib.sysconfig.abspath",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.tabnanny.NannyNag",
      "name": "NannyNag",
      "module": "tabnanny",
      "type": "class",
      "signature": "(lineno, msg, line)",
      "description": "Raised by process_tokens() if detecting an ambiguous indent.\nCaptured and handled in check().",
      "relationships": [
        {
          "target": "Exception",
          "type": "base_class"
        },
        {
          "target": "BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.tabnanny.Whitespace",
      "name": "Whitespace",
      "module": "tabnanny",
      "type": "class",
      "signature": "(ws)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.tabnanny.check",
      "name": "check",
      "module": "tabnanny",
      "type": "function",
      "signature": "(file)",
      "description": "check(file_or_dir)\n\nIf file_or_dir is a directory and not a symbolic link, then recursively\ndescend the directory tree named by file_or_dir, checking all .py files\nalong the way. If file_or_dir is an ordinary Python source file, it is\nchecked for whitespace related problems. The diagnostic messages are\nwritten to standard output using the print statement.",
      "relationships": [
        {
          "target": "stdlib.tabnanny.isdir",
          "type": "calls"
        },
        {
          "target": "stdlib.tabnanny.listdir",
          "type": "calls"
        },
        {
          "target": "stdlib.tabnanny.open",
          "type": "calls"
        },
        {
          "target": "stdlib.tabnanny.print",
          "type": "calls"
        },
        {
          "target": "stdlib.tabnanny.process_tokens",
          "type": "calls"
        },
        {
          "target": "stdlib.tabnanny.close",
          "type": "calls"
        },
        {
          "target": "stdlib.tabnanny.print",
          "type": "calls"
        },
        {
          "target": "stdlib.tabnanny.islink",
          "type": "calls"
        },
        {
          "target": "stdlib.tabnanny.print",
          "type": "calls"
        },
        {
          "target": "stdlib.tabnanny.join",
          "type": "calls"
        },
        {
          "target": "stdlib.tabnanny.errprint",
          "type": "calls"
        },
        {
          "target": "stdlib.tabnanny.generate_tokens",
          "type": "calls"
        },
        {
          "target": "stdlib.tabnanny.errprint",
          "type": "calls"
        },
        {
          "target": "stdlib.tabnanny.errprint",
          "type": "calls"
        },
        {
          "target": "stdlib.tabnanny.get_lineno",
          "type": "calls"
        },
        {
          "target": "stdlib.tabnanny.get_line",
          "type": "calls"
        },
        {
          "target": "stdlib.tabnanny.check",
          "type": "calls"
        },
        {
          "target": "stdlib.tabnanny.print",
          "type": "calls"
        },
        {
          "target": "stdlib.tabnanny.print",
          "type": "calls"
        },
        {
          "target": "stdlib.tabnanny.print",
          "type": "calls"
        },
        {
          "target": "stdlib.tabnanny.isdir",
          "type": "calls"
        },
        {
          "target": "stdlib.tabnanny.normcase",
          "type": "calls"
        },
        {
          "target": "stdlib.tabnanny.get_msg",
          "type": "calls"
        },
        {
          "target": "stdlib.tabnanny.print",
          "type": "calls"
        },
        {
          "target": "stdlib.tabnanny.print",
          "type": "calls"
        },
        {
          "target": "stdlib.tabnanny.islink",
          "type": "calls"
        },
        {
          "target": "stdlib.tabnanny.repr",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.tabnanny.errprint",
      "name": "errprint",
      "module": "tabnanny",
      "type": "function",
      "signature": "(*args)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.tabnanny.write",
          "type": "calls"
        },
        {
          "target": "stdlib.tabnanny.write",
          "type": "calls"
        },
        {
          "target": "stdlib.tabnanny.str",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.tabnanny.format_witnesses",
      "name": "format_witnesses",
      "module": "tabnanny",
      "type": "function",
      "signature": "(w)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.tabnanny.str",
          "type": "calls"
        },
        {
          "target": "stdlib.tabnanny.len",
          "type": "calls"
        },
        {
          "target": "stdlib.tabnanny.join",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.tabnanny.main",
      "name": "main",
      "module": "tabnanny",
      "type": "function",
      "signature": "()",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.tabnanny.getopt",
          "type": "calls"
        },
        {
          "target": "stdlib.tabnanny.errprint",
          "type": "calls"
        },
        {
          "target": "stdlib.tabnanny.check",
          "type": "calls"
        },
        {
          "target": "stdlib.tabnanny.errprint",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.tabnanny.process_tokens",
      "name": "process_tokens",
      "module": "tabnanny",
      "type": "function",
      "signature": "(tokens)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.tabnanny.Whitespace",
          "type": "calls"
        },
        {
          "target": "stdlib.tabnanny.Whitespace",
          "type": "calls"
        },
        {
          "target": "stdlib.tabnanny.append",
          "type": "calls"
        },
        {
          "target": "stdlib.tabnanny.less",
          "type": "calls"
        },
        {
          "target": "stdlib.tabnanny.not_less_witness",
          "type": "calls"
        },
        {
          "target": "stdlib.tabnanny.NannyNag",
          "type": "calls"
        },
        {
          "target": "stdlib.tabnanny.format_witnesses",
          "type": "calls"
        },
        {
          "target": "stdlib.tabnanny.Whitespace",
          "type": "calls"
        },
        {
          "target": "stdlib.tabnanny.equal",
          "type": "calls"
        },
        {
          "target": "stdlib.tabnanny.not_equal_witness",
          "type": "calls"
        },
        {
          "target": "stdlib.tabnanny.NannyNag",
          "type": "calls"
        },
        {
          "target": "stdlib.tabnanny.format_witnesses",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.tarfile.ExFileObject",
      "name": "ExFileObject",
      "module": "tarfile",
      "type": "class",
      "signature": "(tarfile, tarinfo)",
      "description": "Create a new buffered reader using the given readable raw IO object.",
      "relationships": [
        {
          "target": "BufferedReader",
          "type": "base_class"
        },
        {
          "target": "_BufferedIOBase",
          "type": "base_class"
        },
        {
          "target": "_IOBase",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.tarfile.TarFile",
      "name": "TarFile",
      "module": "tarfile",
      "type": "class",
      "signature": "(name=None, mode='r', fileobj=None, format=None, tarinfo=None, dereference=None, ignore_zeros=None, encoding=None, errors='surrogateescape', pax_headers=None, debug=None, errorlevel=None, copybufsize=None)",
      "description": "The TarFile Class provides an interface to tar archives.\n    ",
      "relationships": []
    },
    {
      "id": "stdlib.tarfile.TarInfo",
      "name": "TarInfo",
      "module": "tarfile",
      "type": "class",
      "signature": "(name='')",
      "description": "Informational class which holds the details about an\narchive member given by a tar header block.\nTarInfo objects are returned by TarFile.getmember(),\nTarFile.getmembers() and TarFile.gettarinfo() and are\nusually created internally.",
      "relationships": []
    },
    {
      "id": "stdlib.tarfile.calc_chksums",
      "name": "calc_chksums",
      "module": "tarfile",
      "type": "function",
      "signature": "(buf)",
      "description": "Calculate the checksum for a member's header by summing up all\ncharacters except for the chksum field which is treated as if\nit was filled with spaces. According to the GNU tar sources,\nsome tars (Sun and NeXT) calculate chksum with signed char,\nwhich will be different if there are chars in the buffer with\nthe high bit set. So we calculate two checksums, unsigned and\nsigned.",
      "relationships": [
        {
          "target": "stdlib.tarfile.sum",
          "type": "calls"
        },
        {
          "target": "stdlib.tarfile.sum",
          "type": "calls"
        },
        {
          "target": "stdlib.tarfile.unpack_from",
          "type": "calls"
        },
        {
          "target": "stdlib.tarfile.unpack_from",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.tarfile.copyfileobj",
      "name": "copyfileobj",
      "module": "tarfile",
      "type": "function",
      "signature": "(src, dst, length=None, exception=<class 'OSError'>, bufsize=None)",
      "description": "Copy length bytes from fileobj src to fileobj dst.\nIf length is None, copy the entire content.",
      "relationships": [
        {
          "target": "stdlib.tarfile.divmod",
          "type": "calls"
        },
        {
          "target": "stdlib.tarfile.range",
          "type": "calls"
        },
        {
          "target": "stdlib.tarfile.copyfileobj",
          "type": "calls"
        },
        {
          "target": "stdlib.tarfile.read",
          "type": "calls"
        },
        {
          "target": "stdlib.tarfile.write",
          "type": "calls"
        },
        {
          "target": "stdlib.tarfile.read",
          "type": "calls"
        },
        {
          "target": "stdlib.tarfile.write",
          "type": "calls"
        },
        {
          "target": "stdlib.tarfile.len",
          "type": "calls"
        },
        {
          "target": "stdlib.tarfile.exception",
          "type": "calls"
        },
        {
          "target": "stdlib.tarfile.len",
          "type": "calls"
        },
        {
          "target": "stdlib.tarfile.exception",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.tarfile.is_tarfile",
      "name": "is_tarfile",
      "module": "tarfile",
      "type": "function",
      "signature": "(name)",
      "description": "Return True if name points to a tar archive that we\nare able to handle, else return False.\n\n'name' should be a string, file, or file-like object.",
      "relationships": [
        {
          "target": "stdlib.tarfile.hasattr",
          "type": "calls"
        },
        {
          "target": "stdlib.tarfile.close",
          "type": "calls"
        },
        {
          "target": "stdlib.tarfile.open",
          "type": "calls"
        },
        {
          "target": "stdlib.tarfile.open",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.tarfile.itn",
      "name": "itn",
      "module": "tarfile",
      "type": "function",
      "signature": "(n, digits=8, format=2)",
      "description": "Convert a python number to a number field.\n    ",
      "relationships": [
        {
          "target": "stdlib.tarfile.int",
          "type": "calls"
        },
        {
          "target": "stdlib.tarfile.bytes",
          "type": "calls"
        },
        {
          "target": "stdlib.tarfile.range",
          "type": "calls"
        },
        {
          "target": "stdlib.tarfile.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.tarfile.bytearray",
          "type": "calls"
        },
        {
          "target": "stdlib.tarfile.bytearray",
          "type": "calls"
        },
        {
          "target": "stdlib.tarfile.insert",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.tarfile.main",
      "name": "main",
      "module": "tarfile",
      "type": "function",
      "signature": "()",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.tarfile.ArgumentParser",
          "type": "calls"
        },
        {
          "target": "stdlib.tarfile.add_argument",
          "type": "calls"
        },
        {
          "target": "stdlib.tarfile.add_mutually_exclusive_group",
          "type": "calls"
        },
        {
          "target": "stdlib.tarfile.add_argument",
          "type": "calls"
        },
        {
          "target": "stdlib.tarfile.add_argument",
          "type": "calls"
        },
        {
          "target": "stdlib.tarfile.add_argument",
          "type": "calls"
        },
        {
          "target": "stdlib.tarfile.add_argument",
          "type": "calls"
        },
        {
          "target": "stdlib.tarfile.parse_args",
          "type": "calls"
        },
        {
          "target": "stdlib.tarfile.is_tarfile",
          "type": "calls"
        },
        {
          "target": "stdlib.tarfile.exit",
          "type": "calls"
        },
        {
          "target": "stdlib.tarfile.is_tarfile",
          "type": "calls"
        },
        {
          "target": "stdlib.tarfile.open",
          "type": "calls"
        },
        {
          "target": "stdlib.tarfile.getmembers",
          "type": "calls"
        },
        {
          "target": "stdlib.tarfile.print",
          "type": "calls"
        },
        {
          "target": "stdlib.tarfile.print",
          "type": "calls"
        },
        {
          "target": "stdlib.tarfile.format",
          "type": "calls"
        },
        {
          "target": "stdlib.tarfile.exit",
          "type": "calls"
        },
        {
          "target": "stdlib.tarfile.is_tarfile",
          "type": "calls"
        },
        {
          "target": "stdlib.tarfile.getmembers",
          "type": "calls"
        },
        {
          "target": "stdlib.tarfile.format",
          "type": "calls"
        },
        {
          "target": "stdlib.tarfile.open",
          "type": "calls"
        },
        {
          "target": "stdlib.tarfile.list",
          "type": "calls"
        },
        {
          "target": "stdlib.tarfile.format",
          "type": "calls"
        },
        {
          "target": "stdlib.tarfile.len",
          "type": "calls"
        },
        {
          "target": "stdlib.tarfile.exit",
          "type": "calls"
        },
        {
          "target": "stdlib.tarfile.pop",
          "type": "calls"
        },
        {
          "target": "stdlib.tarfile.splitext",
          "type": "calls"
        },
        {
          "target": "stdlib.tarfile.len",
          "type": "calls"
        },
        {
          "target": "stdlib.tarfile.exit",
          "type": "calls"
        },
        {
          "target": "stdlib.tarfile.open",
          "type": "calls"
        },
        {
          "target": "stdlib.tarfile.extractall",
          "type": "calls"
        },
        {
          "target": "stdlib.tarfile.print",
          "type": "calls"
        },
        {
          "target": "stdlib.tarfile.format",
          "type": "calls"
        },
        {
          "target": "stdlib.tarfile.open",
          "type": "calls"
        },
        {
          "target": "stdlib.tarfile.print",
          "type": "calls"
        },
        {
          "target": "stdlib.tarfile.format_help",
          "type": "calls"
        },
        {
          "target": "stdlib.tarfile.format",
          "type": "calls"
        },
        {
          "target": "stdlib.tarfile.format",
          "type": "calls"
        },
        {
          "target": "stdlib.tarfile.add",
          "type": "calls"
        },
        {
          "target": "stdlib.tarfile.format",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.tarfile.nti",
      "name": "nti",
      "module": "tarfile",
      "type": "function",
      "signature": "(s)",
      "description": "Convert a number field to a python number.\n    ",
      "relationships": [
        {
          "target": "stdlib.tarfile.range",
          "type": "calls"
        },
        {
          "target": "stdlib.tarfile.nts",
          "type": "calls"
        },
        {
          "target": "stdlib.tarfile.int",
          "type": "calls"
        },
        {
          "target": "stdlib.tarfile.len",
          "type": "calls"
        },
        {
          "target": "stdlib.tarfile.InvalidHeaderError",
          "type": "calls"
        },
        {
          "target": "stdlib.tarfile.strip",
          "type": "calls"
        },
        {
          "target": "stdlib.tarfile.len",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.tarfile.nts",
      "name": "nts",
      "module": "tarfile",
      "type": "function",
      "signature": "(s, encoding, errors)",
      "description": "Convert a null-terminated bytes object to a string.\n    ",
      "relationships": [
        {
          "target": "stdlib.tarfile.find",
          "type": "calls"
        },
        {
          "target": "stdlib.tarfile.decode",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.tarfile.stn",
      "name": "stn",
      "module": "tarfile",
      "type": "function",
      "signature": "(s, length, encoding, errors)",
      "description": "Convert a string to a null-terminated bytes object.\n    ",
      "relationships": [
        {
          "target": "stdlib.tarfile.encode",
          "type": "calls"
        },
        {
          "target": "stdlib.tarfile.len",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.telnetlib.Telnet",
      "name": "Telnet",
      "module": "telnetlib",
      "type": "class",
      "signature": "(host=None, port=0, timeout=<object object at 0x102f70e60>)",
      "description": "Telnet interface class.\n\nAn instance of this class represents a connection to a telnet\nserver.  The instance is initially not connected; the open()\nmethod must be used to establish a connection.  Alternatively, the\nhost name and optional port number can be passed to the\nconstructor, too.\n\nDon't try to reopen an already connected instance.\n\nThis class has many read_*() methods.  Note that some of them\nraise EOFError when the end of the connection is read, because\nthey can return an empty string for other reasons.  See the\nindividual doc strings.\n\nread_until(expected, [timeout])\n    Read until the expected string has been seen, or a timeout is\n    hit (default is no timeout); may block.\n\nread_all()\n    Read all data until EOF; may block.\n\nread_some()\n    Read at least one byte or EOF; may block.\n\nread_very_eager()\n    Read all data available already queued or on the socket,\n    without blocking.\n\nread_eager()\n    Read either data already queued or some data available on the\n    socket, without blocking.\n\nread_lazy()\n    Read all data in the raw queue (processing it first), without\n    doing any socket I/O.\n\nread_very_lazy()\n    Reads all data in the cooked queue, without doing any socket\n    I/O.\n\nread_sb_data()\n    Reads available data between SB ... SE sequence. Don't block.\n\nset_option_negotiation_callback(callback)\n    Each time a telnet option is read on the input flow, this callback\n    (if set) is called with the following parameters :\n    callback(telnet socket, command, option)\n        option will be chr(0) when there is no option.\n    No other action is done afterwards by telnetlib.",
      "relationships": []
    },
    {
      "id": "stdlib.telnetlib.test",
      "name": "test",
      "module": "telnetlib",
      "type": "function",
      "signature": "()",
      "description": "Test program for telnetlib.\n\nUsage: python telnetlib.py [-d] ... [host [port]]\n\nDefault host is localhost; default port is 23.",
      "relationships": [
        {
          "target": "stdlib.telnetlib.Telnet",
          "type": "calls"
        },
        {
          "target": "stdlib.telnetlib.set_debuglevel",
          "type": "calls"
        },
        {
          "target": "stdlib.telnetlib.open",
          "type": "calls"
        },
        {
          "target": "stdlib.telnetlib.interact",
          "type": "calls"
        },
        {
          "target": "stdlib.telnetlib.int",
          "type": "calls"
        },
        {
          "target": "stdlib.telnetlib.getservbyname",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.tempfile.NamedTemporaryFile",
      "name": "NamedTemporaryFile",
      "module": "tempfile",
      "type": "function",
      "signature": "(mode='w+b', buffering=-1, encoding=None, newline=None, suffix=None, prefix=None, dir=None, delete=True, *, errors=None)",
      "description": "Create and return a temporary file.\nArguments:\n'prefix', 'suffix', 'dir' -- as for mkstemp.\n'mode' -- the mode argument to io.open (default \"w+b\").\n'buffering' -- the buffer size argument to io.open (default -1).\n'encoding' -- the encoding argument to io.open (default None)\n'newline' -- the newline argument to io.open (default None)\n'delete' -- whether the file is deleted on close (default True).\n'errors' -- the errors argument to io.open (default None)\nThe file is created as mkstemp() would do it.\n\nReturns an object with a file-like interface; the name of the file\nis accessible as its 'name' attribute.  The file will be automatically\ndeleted when it is closed unless the 'delete' argument is set to False.",
      "relationships": [
        {
          "target": "stdlib.tempfile._sanitize_params",
          "type": "calls"
        },
        {
          "target": "stdlib.tempfile._mkstemp_inner",
          "type": "calls"
        },
        {
          "target": "stdlib.tempfile.open",
          "type": "calls"
        },
        {
          "target": "stdlib.tempfile._TemporaryFileWrapper",
          "type": "calls"
        },
        {
          "target": "stdlib.tempfile.unlink",
          "type": "calls"
        },
        {
          "target": "stdlib.tempfile.close",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.tempfile.SpooledTemporaryFile",
      "name": "SpooledTemporaryFile",
      "module": "tempfile",
      "type": "class",
      "signature": "(max_size=0, mode='w+b', buffering=-1, encoding=None, newline=None, suffix=None, prefix=None, dir=None, *, errors=None)",
      "description": "Temporary file wrapper, specialized to switch from BytesIO\nor StringIO to a real file when it exceeds a certain size or\nwhen a fileno is needed.",
      "relationships": []
    },
    {
      "id": "stdlib.tempfile.TemporaryDirectory",
      "name": "TemporaryDirectory",
      "module": "tempfile",
      "type": "class",
      "signature": "(suffix=None, prefix=None, dir=None)",
      "description": "Create and return a temporary directory.  This has the same\nbehavior as mkdtemp but can be used as a context manager.  For\nexample:\n\n    with TemporaryDirectory() as tmpdir:\n        ...\n\nUpon exiting the context, the directory and everything contained\nin it are removed.",
      "relationships": []
    },
    {
      "id": "stdlib.tempfile.TemporaryFile",
      "name": "TemporaryFile",
      "module": "tempfile",
      "type": "function",
      "signature": "(mode='w+b', buffering=-1, encoding=None, newline=None, suffix=None, prefix=None, dir=None, *, errors=None)",
      "description": "Create and return a temporary file.\nArguments:\n'prefix', 'suffix', 'dir' -- as for mkstemp.\n'mode' -- the mode argument to io.open (default \"w+b\").\n'buffering' -- the buffer size argument to io.open (default -1).\n'encoding' -- the encoding argument to io.open (default None)\n'newline' -- the newline argument to io.open (default None)\n'errors' -- the errors argument to io.open (default None)\nThe file is created as mkstemp() would do it.\n\nReturns an object with a file-like interface.  The file has no\nname, and will cease to exist when it is closed.",
      "relationships": [
        {
          "target": "stdlib.tempfile._sanitize_params",
          "type": "calls"
        },
        {
          "target": "stdlib.tempfile._mkstemp_inner",
          "type": "calls"
        },
        {
          "target": "stdlib.tempfile.unlink",
          "type": "calls"
        },
        {
          "target": "stdlib.tempfile.open",
          "type": "calls"
        },
        {
          "target": "stdlib.tempfile.open",
          "type": "calls"
        },
        {
          "target": "stdlib.tempfile.close",
          "type": "calls"
        },
        {
          "target": "stdlib.tempfile.open",
          "type": "calls"
        },
        {
          "target": "stdlib.tempfile.close",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.tempfile.gettempdir",
      "name": "gettempdir",
      "module": "tempfile",
      "type": "function",
      "signature": "()",
      "description": "Accessor for tempfile.tempdir.",
      "relationships": [
        {
          "target": "stdlib.tempfile.acquire",
          "type": "calls"
        },
        {
          "target": "stdlib.tempfile.release",
          "type": "calls"
        },
        {
          "target": "stdlib.tempfile._get_default_tempdir",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.tempfile.gettempdirb",
      "name": "gettempdirb",
      "module": "tempfile",
      "type": "function",
      "signature": "()",
      "description": "A bytes version of tempfile.gettempdir().",
      "relationships": [
        {
          "target": "stdlib.tempfile.fsencode",
          "type": "calls"
        },
        {
          "target": "stdlib.tempfile.gettempdir",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.tempfile.gettempprefix",
      "name": "gettempprefix",
      "module": "tempfile",
      "type": "function",
      "signature": "()",
      "description": "The default prefix for temporary directories.",
      "relationships": []
    },
    {
      "id": "stdlib.tempfile.gettempprefixb",
      "name": "gettempprefixb",
      "module": "tempfile",
      "type": "function",
      "signature": "()",
      "description": "The default prefix for temporary directories as bytes.",
      "relationships": [
        {
          "target": "stdlib.tempfile.fsencode",
          "type": "calls"
        },
        {
          "target": "stdlib.tempfile.gettempprefix",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.tempfile.mkdtemp",
      "name": "mkdtemp",
      "module": "tempfile",
      "type": "function",
      "signature": "(suffix=None, prefix=None, dir=None)",
      "description": "User-callable function to create and return a unique temporary\ndirectory.  The return value is the pathname of the directory.\n\nArguments are as for mkstemp, except that the 'text' argument is\nnot accepted.\n\nThe directory is readable, writable, and searchable only by the\ncreating user.\n\nCaller is responsible for deleting the directory when done with it.",
      "relationships": [
        {
          "target": "stdlib.tempfile._sanitize_params",
          "type": "calls"
        },
        {
          "target": "stdlib.tempfile._get_candidate_names",
          "type": "calls"
        },
        {
          "target": "stdlib.tempfile.range",
          "type": "calls"
        },
        {
          "target": "stdlib.tempfile.FileExistsError",
          "type": "calls"
        },
        {
          "target": "stdlib.tempfile.map",
          "type": "calls"
        },
        {
          "target": "stdlib.tempfile.next",
          "type": "calls"
        },
        {
          "target": "stdlib.tempfile.join",
          "type": "calls"
        },
        {
          "target": "stdlib.tempfile.audit",
          "type": "calls"
        },
        {
          "target": "stdlib.tempfile.mkdir",
          "type": "calls"
        },
        {
          "target": "stdlib.tempfile.isdir",
          "type": "calls"
        },
        {
          "target": "stdlib.tempfile.access",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.tempfile.mkstemp",
      "name": "mkstemp",
      "module": "tempfile",
      "type": "function",
      "signature": "(suffix=None, prefix=None, dir=None, text=False)",
      "description": "User-callable function to create and return a unique temporary\nfile.  The return value is a pair (fd, name) where fd is the\nfile descriptor returned by os.open, and name is the filename.\n\nIf 'suffix' is not None, the file name will end with that suffix,\notherwise there will be no suffix.\n\nIf 'prefix' is not None, the file name will begin with that prefix,\notherwise a default prefix is used.\n\nIf 'dir' is not None, the file will be created in that directory,\notherwise a default directory is used.\n\nIf 'text' is specified and true, the file is opened in text\nmode.  Else (the default) the file is opened in binary mode.\n\nIf any of 'suffix', 'prefix' and 'dir' are not None, they must be the\nsame type.  If they are bytes, the returned name will be bytes; str\notherwise.\n\nThe file is readable and writable only by the creating user ID.\nIf the operating system uses permission bits to indicate whether a\nfile is executable, the file is executable by no one. The file\ndescriptor is not inherited by children of this process.\n\nCaller is responsible for deleting the file when done with it.",
      "relationships": [
        {
          "target": "stdlib.tempfile._sanitize_params",
          "type": "calls"
        },
        {
          "target": "stdlib.tempfile._mkstemp_inner",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.tempfile.mktemp",
      "name": "mktemp",
      "module": "tempfile",
      "type": "function",
      "signature": "(suffix='', prefix='tmp', dir=None)",
      "description": "User-callable function to return a unique temporary file name.  The\nfile is not created.\n\nArguments are similar to mkstemp, except that the 'text' argument is\nnot accepted, and suffix=None, prefix=None and bytes file names are not\nsupported.\n\nTHIS FUNCTION IS UNSAFE AND SHOULD NOT BE USED.  The file name may\nrefer to a file that did not exist at some point, but by the time\nyou get around to creating it, someone else may have beaten you to\nthe punch.",
      "relationships": [
        {
          "target": "stdlib.tempfile._get_candidate_names",
          "type": "calls"
        },
        {
          "target": "stdlib.tempfile.range",
          "type": "calls"
        },
        {
          "target": "stdlib.tempfile.FileExistsError",
          "type": "calls"
        },
        {
          "target": "stdlib.tempfile.gettempdir",
          "type": "calls"
        },
        {
          "target": "stdlib.tempfile.next",
          "type": "calls"
        },
        {
          "target": "stdlib.tempfile.join",
          "type": "calls"
        },
        {
          "target": "stdlib.tempfile._exists",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.textwrap.TextWrapper",
      "name": "TextWrapper",
      "module": "textwrap",
      "type": "class",
      "signature": "(width=70, initial_indent='', subsequent_indent='', expand_tabs=True, replace_whitespace=True, fix_sentence_endings=False, break_long_words=True, drop_whitespace=True, break_on_hyphens=True, tabsize=8, *, max_lines=None, placeholder=' [...]')",
      "description": "Object for wrapping/filling text.  The public interface consists of\nthe wrap() and fill() methods; the other methods are just there for\nsubclasses to override in order to tweak the default behaviour.\nIf you want to completely replace the main wrapping algorithm,\nyou'll probably have to override _wrap_chunks().\n\nSeveral instance attributes control various aspects of wrapping:\n  width (default: 70)\n    the maximum width of wrapped lines (unless break_long_words\n    is false)\n  initial_indent (default: \"\")\n    string that will be prepended to the first line of wrapped\n    output.  Counts towards the line's width.\n  subsequent_indent (default: \"\")\n    string that will be prepended to all lines save the first\n    of wrapped output; also counts towards each line's width.\n  expand_tabs (default: true)\n    Expand tabs in input text to spaces before further processing.\n    Each tab will become 0 .. 'tabsize' spaces, depending on its position\n    in its line.  If false, each tab is treated as a single character.\n  tabsize (default: 8)\n    Expand tabs in input text to 0 .. 'tabsize' spaces, unless\n    'expand_tabs' is false.\n  replace_whitespace (default: true)\n    Replace all whitespace characters in the input text by spaces\n    after tab expansion.  Note that if expand_tabs is false and\n    replace_whitespace is true, every tab will be converted to a\n    single space!\n  fix_sentence_endings (default: false)\n    Ensure that sentence-ending punctuation is always followed\n    by two spaces.  Off by default because the algorithm is\n    (unavoidably) imperfect.\n  break_long_words (default: true)\n    Break words longer than 'width'.  If false, those words will not\n    be broken, and some lines might be longer than 'width'.\n  break_on_hyphens (default: true)\n    Allow breaking hyphenated words. If true, wrapping will occur\n    preferably on whitespaces and right after hyphens part of\n    compound words.\n  drop_whitespace (default: true)\n    Drop leading and trailing whitespace from lines.\n  max_lines (default: None)\n    Truncate wrapped lines.\n  placeholder (default: ' [...]')\n    Append to the last line of truncated text.",
      "relationships": []
    },
    {
      "id": "stdlib.textwrap.dedent",
      "name": "dedent",
      "module": "textwrap",
      "type": "function",
      "signature": "(text)",
      "description": "Remove any common leading whitespace from every line in `text`.\n\nThis can be used to make triple-quoted strings line up with the left\nedge of the display, while still presenting them in the source code\nin indented form.\n\nNote that tabs and spaces are both treated as whitespace, but they\nare not equal: the lines \"  hello\" and \"\\thello\" are\nconsidered to have no common leading whitespace.\n\nEntirely blank lines are normalized to a newline character.",
      "relationships": [
        {
          "target": "stdlib.textwrap.sub",
          "type": "calls"
        },
        {
          "target": "stdlib.textwrap.findall",
          "type": "calls"
        },
        {
          "target": "stdlib.textwrap.split",
          "type": "calls"
        },
        {
          "target": "stdlib.textwrap.sub",
          "type": "calls"
        },
        {
          "target": "stdlib.textwrap.startswith",
          "type": "calls"
        },
        {
          "target": "stdlib.textwrap.startswith",
          "type": "calls"
        },
        {
          "target": "stdlib.textwrap.startswith",
          "type": "calls"
        },
        {
          "target": "stdlib.textwrap.enumerate",
          "type": "calls"
        },
        {
          "target": "stdlib.textwrap.zip",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.textwrap.fill",
      "name": "fill",
      "module": "textwrap",
      "type": "function",
      "signature": "(text, width=70, **kwargs)",
      "description": "Fill a single paragraph of text, returning a new string.\n\nReformat the single paragraph in 'text' to fit in lines of no more\nthan 'width' columns, and return a new string containing the entire\nwrapped paragraph.  As with wrap(), tabs are expanded and other\nwhitespace characters converted to space.  See TextWrapper class for\navailable keyword args to customize wrapping behaviour.",
      "relationships": [
        {
          "target": "stdlib.textwrap.TextWrapper",
          "type": "calls"
        },
        {
          "target": "stdlib.textwrap.fill",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.textwrap.indent",
      "name": "indent",
      "module": "textwrap",
      "type": "function",
      "signature": "(text, prefix, predicate=None)",
      "description": "Adds 'prefix' to the beginning of selected lines in 'text'.\n\nIf 'predicate' is provided, 'prefix' will only be added to the lines\nwhere 'predicate(line)' is True. If 'predicate' is not provided,\nit will default to adding 'prefix' to all non-empty lines that do not\nconsist solely of whitespace characters.",
      "relationships": [
        {
          "target": "stdlib.textwrap.join",
          "type": "calls"
        },
        {
          "target": "stdlib.textwrap.splitlines",
          "type": "calls"
        },
        {
          "target": "stdlib.textwrap.prefixed_lines",
          "type": "calls"
        },
        {
          "target": "stdlib.textwrap.strip",
          "type": "calls"
        },
        {
          "target": "stdlib.textwrap.predicate",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.textwrap.shorten",
      "name": "shorten",
      "module": "textwrap",
      "type": "function",
      "signature": "(text, width, **kwargs)",
      "description": "Collapse and truncate the given text to fit in the given width.\n\nThe text first has its whitespace collapsed.  If it then fits in\nthe *width*, it is returned as is.  Otherwise, as many words\nas possible are joined and then the placeholder is appended::\n\n    >>> textwrap.shorten(\"Hello  world!\", width=12)\n    'Hello world!'\n    >>> textwrap.shorten(\"Hello  world!\", width=11)\n    'Hello [...]'",
      "relationships": [
        {
          "target": "stdlib.textwrap.TextWrapper",
          "type": "calls"
        },
        {
          "target": "stdlib.textwrap.fill",
          "type": "calls"
        },
        {
          "target": "stdlib.textwrap.join",
          "type": "calls"
        },
        {
          "target": "stdlib.textwrap.split",
          "type": "calls"
        },
        {
          "target": "stdlib.textwrap.strip",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.textwrap.wrap",
      "name": "wrap",
      "module": "textwrap",
      "type": "function",
      "signature": "(text, width=70, **kwargs)",
      "description": "Wrap a single paragraph of text, returning a list of wrapped lines.\n\nReformat the single paragraph in 'text' so it fits in lines of no\nmore than 'width' columns, and return a list of wrapped lines.  By\ndefault, tabs in 'text' are expanded with string.expandtabs(), and\nall other whitespace characters (including newline) are converted to\nspace.  See TextWrapper class for available keyword args to customize\nwrapping behaviour.",
      "relationships": [
        {
          "target": "stdlib.textwrap.TextWrapper",
          "type": "calls"
        },
        {
          "target": "stdlib.textwrap.wrap",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.threading.Barrier",
      "name": "Barrier",
      "module": "threading",
      "type": "class",
      "signature": "(parties, action=None, timeout=None)",
      "description": "Implements a Barrier.\n\nUseful for synchronizing a fixed number of threads at known synchronization\npoints.  Threads block on 'wait()' and are simultaneously awoken once they\nhave all made that call.",
      "relationships": []
    },
    {
      "id": "stdlib.threading.BoundedSemaphore",
      "name": "BoundedSemaphore",
      "module": "threading",
      "type": "class",
      "signature": "(value=1)",
      "description": "Implements a bounded semaphore.\n\nA bounded semaphore checks to make sure its current value doesn't exceed its\ninitial value. If it does, ValueError is raised. In most situations\nsemaphores are used to guard resources with limited capacity.\n\nIf the semaphore is released too many times it's a sign of a bug. If not\ngiven, value defaults to 1.\n\nLike regular semaphores, bounded semaphores manage a counter representing\nthe number of release() calls minus the number of acquire() calls, plus an\ninitial value. The acquire() method blocks if necessary until it can return\nwithout making the counter negative. If not given, value defaults to 1.",
      "relationships": [
        {
          "target": "Semaphore",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.threading.Condition",
      "name": "Condition",
      "module": "threading",
      "type": "class",
      "signature": "(lock=None)",
      "description": "Class that implements a condition variable.\n\nA condition variable allows one or more threads to wait until they are\nnotified by another thread.\n\nIf the lock argument is given and not None, it must be a Lock or RLock\nobject, and it is used as the underlying lock. Otherwise, a new RLock object\nis created and used as the underlying lock.",
      "relationships": []
    },
    {
      "id": "stdlib.threading.Event",
      "name": "Event",
      "module": "threading",
      "type": "class",
      "signature": "()",
      "description": "Class implementing event objects.\n\nEvents manage a flag that can be set to true with the set() method and reset\nto false with the clear() method. The wait() method blocks until the flag is\ntrue.  The flag is initially false.",
      "relationships": []
    },
    {
      "id": "stdlib.threading.ExceptHookArgs",
      "name": "ExceptHookArgs",
      "module": "threading",
      "type": "class",
      "signature": "(iterable=(), /)",
      "description": "ExceptHookArgs\n\nType used to pass arguments to threading.excepthook.",
      "relationships": [
        {
          "target": "tuple",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.threading.RLock",
      "name": "RLock",
      "module": "threading",
      "type": "function",
      "signature": "(*args, **kwargs)",
      "description": "Factory function that returns a new reentrant lock.\n\nA reentrant lock must be released by the thread that acquired it. Once a\nthread has acquired a reentrant lock, the same thread may acquire it again\nwithout blocking; the thread must release it once for each time it has\nacquired it.",
      "relationships": [
        {
          "target": "stdlib.threading._CRLock",
          "type": "calls"
        },
        {
          "target": "stdlib.threading._PyRLock",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.threading.Semaphore",
      "name": "Semaphore",
      "module": "threading",
      "type": "class",
      "signature": "(value=1)",
      "description": "This class implements semaphore objects.\n\nSemaphores manage a counter representing the number of release() calls minus\nthe number of acquire() calls, plus an initial value. The acquire() method\nblocks if necessary until it can return without making the counter\nnegative. If not given, value defaults to 1.",
      "relationships": []
    },
    {
      "id": "stdlib.threading.Thread",
      "name": "Thread",
      "module": "threading",
      "type": "class",
      "signature": "(group=None, target=None, name=None, args=(), kwargs=None, *, daemon=None)",
      "description": "A class that represents a thread of control.\n\nThis class can be safely subclassed in a limited fashion. There are two ways\nto specify the activity: by passing a callable object to the constructor, or\nby overriding the run() method in a subclass.",
      "relationships": []
    },
    {
      "id": "stdlib.threading.Timer",
      "name": "Timer",
      "module": "threading",
      "type": "class",
      "signature": "(interval, function, args=None, kwargs=None)",
      "description": "Call a function after a specified number of seconds:\n\nt = Timer(30.0, f, args=None, kwargs=None)\nt.start()\nt.cancel()     # stop the timer's action if it's still waiting",
      "relationships": [
        {
          "target": "Thread",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.threading.WeakSet",
      "name": "WeakSet",
      "module": "threading",
      "type": "class",
      "signature": "(data=None)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.threading.activeCount",
      "name": "activeCount",
      "module": "threading",
      "type": "function",
      "signature": "()",
      "description": "Return the number of Thread objects currently alive.\n\nThe returned count is equal to the length of the list returned by\nenumerate().",
      "relationships": [
        {
          "target": "stdlib.threading.len",
          "type": "calls"
        },
        {
          "target": "stdlib.threading.len",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.threading.active_count",
      "name": "active_count",
      "module": "threading",
      "type": "function",
      "signature": "()",
      "description": "Return the number of Thread objects currently alive.\n\nThe returned count is equal to the length of the list returned by\nenumerate().",
      "relationships": [
        {
          "target": "stdlib.threading.len",
          "type": "calls"
        },
        {
          "target": "stdlib.threading.len",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.threading.currentThread",
      "name": "currentThread",
      "module": "threading",
      "type": "function",
      "signature": "()",
      "description": "Return the current Thread object, corresponding to the caller's thread of control.\n\nIf the caller's thread of control was not created through the threading\nmodule, a dummy thread object with limited functionality is returned.",
      "relationships": [
        {
          "target": "stdlib.threading.get_ident",
          "type": "calls"
        },
        {
          "target": "stdlib.threading._DummyThread",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.threading.current_thread",
      "name": "current_thread",
      "module": "threading",
      "type": "function",
      "signature": "()",
      "description": "Return the current Thread object, corresponding to the caller's thread of control.\n\nIf the caller's thread of control was not created through the threading\nmodule, a dummy thread object with limited functionality is returned.",
      "relationships": [
        {
          "target": "stdlib.threading.get_ident",
          "type": "calls"
        },
        {
          "target": "stdlib.threading._DummyThread",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.threading.enumerate",
      "name": "enumerate",
      "module": "threading",
      "type": "function",
      "signature": "()",
      "description": "Return a list of all Thread objects currently alive.\n\nThe list includes daemonic threads, dummy thread objects created by\ncurrent_thread(), and the main thread. It excludes terminated threads and\nthreads that have not yet been started.",
      "relationships": [
        {
          "target": "stdlib.threading.list",
          "type": "calls"
        },
        {
          "target": "stdlib.threading.list",
          "type": "calls"
        },
        {
          "target": "stdlib.threading.values",
          "type": "calls"
        },
        {
          "target": "stdlib.threading.values",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.threading.main_thread",
      "name": "main_thread",
      "module": "threading",
      "type": "function",
      "signature": "()",
      "description": "Return the main thread object.\n\nIn normal conditions, the main thread is the thread from which the\nPython interpreter was started.",
      "relationships": []
    },
    {
      "id": "stdlib.threading.setprofile",
      "name": "setprofile",
      "module": "threading",
      "type": "function",
      "signature": "(func)",
      "description": "Set a profile function for all threads started from the threading module.\n\nThe func will be passed to sys.setprofile() for each thread, before its\nrun() method is called.",
      "relationships": []
    },
    {
      "id": "stdlib.threading.settrace",
      "name": "settrace",
      "module": "threading",
      "type": "function",
      "signature": "(func)",
      "description": "Set a trace function for all threads started from the threading module.\n\nThe func will be passed to sys.settrace() for each thread, before its run()\nmethod is called.",
      "relationships": []
    },
    {
      "id": "stdlib.timeit.Timer",
      "name": "Timer",
      "module": "timeit",
      "type": "class",
      "signature": "(stmt='pass', setup='pass', timer=<built-in function perf_counter>, globals=None)",
      "description": "Class for timing execution speed of small code snippets.\n\nThe constructor takes a statement to be timed, an additional\nstatement used for setup, and a timer function.  Both statements\ndefault to 'pass'; the timer function is platform-dependent (see\nmodule doc string).  If 'globals' is specified, the code will be\nexecuted within that namespace (as opposed to inside timeit's\nnamespace).\n\nTo measure the execution time of the first statement, use the\ntimeit() method.  The repeat() method is a convenience to call\ntimeit() multiple times and return a list of results.\n\nThe statements may contain newlines, as long as they don't contain\nmulti-line string literals.",
      "relationships": []
    },
    {
      "id": "stdlib.timeit.main",
      "name": "main",
      "module": "timeit",
      "type": "function",
      "signature": "(args=None, *, _wrap_timer=None)",
      "description": "Main program, used when run as a script.\n\nThe optional 'args' argument specifies the command line to be parsed,\ndefaulting to sys.argv[1:].\n\nThe return value is an exit code to be passed to sys.exit(); it\nmay be None to indicate success.\n\nWhen an exception happens during timing, a traceback is printed to\nstderr and the return value is 1.  Exceptions at other times\n(including the template compilation) are not caught.\n\n'_wrap_timer' is an internal interface used for unit testing.  If it\nis not None, it must be a callable that accepts a timer function\nand returns another timer function (used for unit testing).",
      "relationships": [
        {
          "target": "stdlib.timeit.insert",
          "type": "calls"
        },
        {
          "target": "stdlib.timeit.Timer",
          "type": "calls"
        },
        {
          "target": "stdlib.timeit.min",
          "type": "calls"
        },
        {
          "target": "stdlib.timeit.print",
          "type": "calls"
        },
        {
          "target": "stdlib.timeit.min",
          "type": "calls"
        },
        {
          "target": "stdlib.timeit.max",
          "type": "calls"
        },
        {
          "target": "stdlib.timeit.getopt",
          "type": "calls"
        },
        {
          "target": "stdlib.timeit.join",
          "type": "calls"
        },
        {
          "target": "stdlib.timeit.join",
          "type": "calls"
        },
        {
          "target": "stdlib.timeit._wrap_timer",
          "type": "calls"
        },
        {
          "target": "stdlib.timeit.repeat",
          "type": "calls"
        },
        {
          "target": "stdlib.timeit.print",
          "type": "calls"
        },
        {
          "target": "stdlib.timeit.print",
          "type": "calls"
        },
        {
          "target": "stdlib.timeit.warn_explicit",
          "type": "calls"
        },
        {
          "target": "stdlib.timeit.print",
          "type": "calls"
        },
        {
          "target": "stdlib.timeit.print",
          "type": "calls"
        },
        {
          "target": "stdlib.timeit.int",
          "type": "calls"
        },
        {
          "target": "stdlib.timeit.append",
          "type": "calls"
        },
        {
          "target": "stdlib.timeit.int",
          "type": "calls"
        },
        {
          "target": "stdlib.timeit.print",
          "type": "calls"
        },
        {
          "target": "stdlib.timeit.autorange",
          "type": "calls"
        },
        {
          "target": "stdlib.timeit.print",
          "type": "calls"
        },
        {
          "target": "stdlib.timeit.print_exc",
          "type": "calls"
        },
        {
          "target": "stdlib.timeit.sort",
          "type": "calls"
        },
        {
          "target": "stdlib.timeit.print",
          "type": "calls"
        },
        {
          "target": "stdlib.timeit.print",
          "type": "calls"
        },
        {
          "target": "stdlib.timeit.print_exc",
          "type": "calls"
        },
        {
          "target": "stdlib.timeit.join",
          "type": "calls"
        },
        {
          "target": "stdlib.timeit.format_time",
          "type": "calls"
        },
        {
          "target": "stdlib.timeit.format",
          "type": "calls"
        },
        {
          "target": "stdlib.timeit.items",
          "type": "calls"
        },
        {
          "target": "stdlib.timeit.map",
          "type": "calls"
        },
        {
          "target": "stdlib.timeit.format_time",
          "type": "calls"
        },
        {
          "target": "stdlib.timeit.format_time",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.timeit.reindent",
      "name": "reindent",
      "module": "timeit",
      "type": "function",
      "signature": "(src, indent)",
      "description": "Helper to reindent a multi-line statement.",
      "relationships": [
        {
          "target": "stdlib.timeit.replace",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.timeit.repeat",
      "name": "repeat",
      "module": "timeit",
      "type": "function",
      "signature": "(stmt='pass', setup='pass', timer=<built-in function perf_counter>, repeat=5, number=1000000, globals=None)",
      "description": "Convenience function to create Timer object and call repeat method.",
      "relationships": [
        {
          "target": "stdlib.timeit.repeat",
          "type": "calls"
        },
        {
          "target": "stdlib.timeit.Timer",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.timeit.timeit",
      "name": "timeit",
      "module": "timeit",
      "type": "function",
      "signature": "(stmt='pass', setup='pass', timer=<built-in function perf_counter>, number=1000000, globals=None)",
      "description": "Convenience function to create Timer object and call timeit method.",
      "relationships": [
        {
          "target": "stdlib.timeit.timeit",
          "type": "calls"
        },
        {
          "target": "stdlib.timeit.Timer",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.tkinter.BaseWidget",
      "name": "BaseWidget",
      "module": "tkinter",
      "type": "class",
      "signature": "(master, widgetName, cnf={}, kw={}, extra=())",
      "description": "Internal class.",
      "relationships": [
        {
          "target": "Misc",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.tkinter.BitmapImage",
      "name": "BitmapImage",
      "module": "tkinter",
      "type": "class",
      "signature": "(name=None, cnf={}, master=None, **kw)",
      "description": "Widget which can display images in XBM format.",
      "relationships": [
        {
          "target": "Image",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.tkinter.BooleanVar",
      "name": "BooleanVar",
      "module": "tkinter",
      "type": "class",
      "signature": "(master=None, value=None, name=None)",
      "description": "Value holder for boolean variables.",
      "relationships": [
        {
          "target": "Variable",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.tkinter.Button",
      "name": "Button",
      "module": "tkinter",
      "type": "class",
      "signature": "(master=None, cnf={}, **kw)",
      "description": "Button widget.",
      "relationships": [
        {
          "target": "Widget",
          "type": "base_class"
        },
        {
          "target": "BaseWidget",
          "type": "base_class"
        },
        {
          "target": "Misc",
          "type": "base_class"
        },
        {
          "target": "Pack",
          "type": "base_class"
        },
        {
          "target": "Place",
          "type": "base_class"
        },
        {
          "target": "Grid",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.tkinter.CallWrapper",
      "name": "CallWrapper",
      "module": "tkinter",
      "type": "class",
      "signature": "(func, subst, widget)",
      "description": "Internal class. Stores function to call when some user\ndefined Tcl function is called e.g. after an event occurred.",
      "relationships": []
    },
    {
      "id": "stdlib.tkinter.Canvas",
      "name": "Canvas",
      "module": "tkinter",
      "type": "class",
      "signature": "(master=None, cnf={}, **kw)",
      "description": "Canvas widget to display graphical elements like lines or text.",
      "relationships": [
        {
          "target": "Widget",
          "type": "base_class"
        },
        {
          "target": "BaseWidget",
          "type": "base_class"
        },
        {
          "target": "Misc",
          "type": "base_class"
        },
        {
          "target": "Pack",
          "type": "base_class"
        },
        {
          "target": "Place",
          "type": "base_class"
        },
        {
          "target": "Grid",
          "type": "base_class"
        },
        {
          "target": "XView",
          "type": "base_class"
        },
        {
          "target": "YView",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.tkinter.Checkbutton",
      "name": "Checkbutton",
      "module": "tkinter",
      "type": "class",
      "signature": "(master=None, cnf={}, **kw)",
      "description": "Checkbutton widget which is either in on- or off-state.",
      "relationships": [
        {
          "target": "Widget",
          "type": "base_class"
        },
        {
          "target": "BaseWidget",
          "type": "base_class"
        },
        {
          "target": "Misc",
          "type": "base_class"
        },
        {
          "target": "Pack",
          "type": "base_class"
        },
        {
          "target": "Place",
          "type": "base_class"
        },
        {
          "target": "Grid",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.tkinter.DoubleVar",
      "name": "DoubleVar",
      "module": "tkinter",
      "type": "class",
      "signature": "(master=None, value=None, name=None)",
      "description": "Value holder for float variables.",
      "relationships": [
        {
          "target": "Variable",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.tkinter.Entry",
      "name": "Entry",
      "module": "tkinter",
      "type": "class",
      "signature": "(master=None, cnf={}, **kw)",
      "description": "Entry widget which allows displaying simple text.",
      "relationships": [
        {
          "target": "Widget",
          "type": "base_class"
        },
        {
          "target": "BaseWidget",
          "type": "base_class"
        },
        {
          "target": "Misc",
          "type": "base_class"
        },
        {
          "target": "Pack",
          "type": "base_class"
        },
        {
          "target": "Place",
          "type": "base_class"
        },
        {
          "target": "Grid",
          "type": "base_class"
        },
        {
          "target": "XView",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.tkinter.Event",
      "name": "Event",
      "module": "tkinter",
      "type": "class",
      "signature": "()",
      "description": "Container for the properties of an event.\n\nInstances of this type are generated if one of the following events occurs:\n\nKeyPress, KeyRelease - for keyboard events\nButtonPress, ButtonRelease, Motion, Enter, Leave, MouseWheel - for mouse events\nVisibility, Unmap, Map, Expose, FocusIn, FocusOut, Circulate,\nColormap, Gravity, Reparent, Property, Destroy, Activate,\nDeactivate - for window events.\n\nIf a callback function for one of these events is registered\nusing bind, bind_all, bind_class, or tag_bind, the callback is\ncalled with an Event as first argument. It will have the\nfollowing attributes (in braces are the event types for which\nthe attribute is valid):\n\n    serial - serial number of event\nnum - mouse button pressed (ButtonPress, ButtonRelease)\nfocus - whether the window has the focus (Enter, Leave)\nheight - height of the exposed window (Configure, Expose)\nwidth - width of the exposed window (Configure, Expose)\nkeycode - keycode of the pressed key (KeyPress, KeyRelease)\nstate - state of the event as a number (ButtonPress, ButtonRelease,\n                        Enter, KeyPress, KeyRelease,\n                        Leave, Motion)\nstate - state as a string (Visibility)\ntime - when the event occurred\nx - x-position of the mouse\ny - y-position of the mouse\nx_root - x-position of the mouse on the screen\n         (ButtonPress, ButtonRelease, KeyPress, KeyRelease, Motion)\ny_root - y-position of the mouse on the screen\n         (ButtonPress, ButtonRelease, KeyPress, KeyRelease, Motion)\nchar - pressed character (KeyPress, KeyRelease)\nsend_event - see X/Windows documentation\nkeysym - keysym of the event as a string (KeyPress, KeyRelease)\nkeysym_num - keysym of the event as a number (KeyPress, KeyRelease)\ntype - type of the event as a number\nwidget - widget in which the event occurred\ndelta - delta of wheel movement (MouseWheel)",
      "relationships": []
    },
    {
      "id": "stdlib.tkinter.EventType",
      "name": "EventType",
      "module": "tkinter",
      "type": "class",
      "signature": "(value, names=None, *, module=None, qualname=None, type=None, start=1)",
      "description": "An enumeration.",
      "relationships": [
        {
          "target": "str",
          "type": "base_class"
        },
        {
          "target": "Enum",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.tkinter.Frame",
      "name": "Frame",
      "module": "tkinter",
      "type": "class",
      "signature": "(master=None, cnf={}, **kw)",
      "description": "Frame widget which may contain other widgets and can have a 3D border.",
      "relationships": [
        {
          "target": "Widget",
          "type": "base_class"
        },
        {
          "target": "BaseWidget",
          "type": "base_class"
        },
        {
          "target": "Misc",
          "type": "base_class"
        },
        {
          "target": "Pack",
          "type": "base_class"
        },
        {
          "target": "Place",
          "type": "base_class"
        },
        {
          "target": "Grid",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.tkinter.Grid",
      "name": "Grid",
      "module": "tkinter",
      "type": "class",
      "signature": "()",
      "description": "Geometry manager Grid.\n\nBase class to use the methods grid_* in every widget.",
      "relationships": []
    },
    {
      "id": "stdlib.tkinter.Image",
      "name": "Image",
      "module": "tkinter",
      "type": "class",
      "signature": "(imgtype, name=None, cnf={}, master=None, **kw)",
      "description": "Base class for images.",
      "relationships": []
    },
    {
      "id": "stdlib.tkinter.IntVar",
      "name": "IntVar",
      "module": "tkinter",
      "type": "class",
      "signature": "(master=None, value=None, name=None)",
      "description": "Value holder for integer variables.",
      "relationships": [
        {
          "target": "Variable",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.tkinter.Label",
      "name": "Label",
      "module": "tkinter",
      "type": "class",
      "signature": "(master=None, cnf={}, **kw)",
      "description": "Label widget which can display text and bitmaps.",
      "relationships": [
        {
          "target": "Widget",
          "type": "base_class"
        },
        {
          "target": "BaseWidget",
          "type": "base_class"
        },
        {
          "target": "Misc",
          "type": "base_class"
        },
        {
          "target": "Pack",
          "type": "base_class"
        },
        {
          "target": "Place",
          "type": "base_class"
        },
        {
          "target": "Grid",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.tkinter.LabelFrame",
      "name": "LabelFrame",
      "module": "tkinter",
      "type": "class",
      "signature": "(master=None, cnf={}, **kw)",
      "description": "labelframe widget.",
      "relationships": [
        {
          "target": "Widget",
          "type": "base_class"
        },
        {
          "target": "BaseWidget",
          "type": "base_class"
        },
        {
          "target": "Misc",
          "type": "base_class"
        },
        {
          "target": "Pack",
          "type": "base_class"
        },
        {
          "target": "Place",
          "type": "base_class"
        },
        {
          "target": "Grid",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.tkinter.Listbox",
      "name": "Listbox",
      "module": "tkinter",
      "type": "class",
      "signature": "(master=None, cnf={}, **kw)",
      "description": "Listbox widget which can display a list of strings.",
      "relationships": [
        {
          "target": "Widget",
          "type": "base_class"
        },
        {
          "target": "BaseWidget",
          "type": "base_class"
        },
        {
          "target": "Misc",
          "type": "base_class"
        },
        {
          "target": "Pack",
          "type": "base_class"
        },
        {
          "target": "Place",
          "type": "base_class"
        },
        {
          "target": "Grid",
          "type": "base_class"
        },
        {
          "target": "XView",
          "type": "base_class"
        },
        {
          "target": "YView",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.tkinter.Menu",
      "name": "Menu",
      "module": "tkinter",
      "type": "class",
      "signature": "(master=None, cnf={}, **kw)",
      "description": "Menu widget which allows displaying menu bars, pull-down menus and pop-up menus.",
      "relationships": [
        {
          "target": "Widget",
          "type": "base_class"
        },
        {
          "target": "BaseWidget",
          "type": "base_class"
        },
        {
          "target": "Misc",
          "type": "base_class"
        },
        {
          "target": "Pack",
          "type": "base_class"
        },
        {
          "target": "Place",
          "type": "base_class"
        },
        {
          "target": "Grid",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.tkinter.Menubutton",
      "name": "Menubutton",
      "module": "tkinter",
      "type": "class",
      "signature": "(master=None, cnf={}, **kw)",
      "description": "Menubutton widget, obsolete since Tk8.0.",
      "relationships": [
        {
          "target": "Widget",
          "type": "base_class"
        },
        {
          "target": "BaseWidget",
          "type": "base_class"
        },
        {
          "target": "Misc",
          "type": "base_class"
        },
        {
          "target": "Pack",
          "type": "base_class"
        },
        {
          "target": "Place",
          "type": "base_class"
        },
        {
          "target": "Grid",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.tkinter.Message",
      "name": "Message",
      "module": "tkinter",
      "type": "class",
      "signature": "(master=None, cnf={}, **kw)",
      "description": "Message widget to display multiline text. Obsolete since Label does it too.",
      "relationships": [
        {
          "target": "Widget",
          "type": "base_class"
        },
        {
          "target": "BaseWidget",
          "type": "base_class"
        },
        {
          "target": "Misc",
          "type": "base_class"
        },
        {
          "target": "Pack",
          "type": "base_class"
        },
        {
          "target": "Place",
          "type": "base_class"
        },
        {
          "target": "Grid",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.tkinter.Misc",
      "name": "Misc",
      "module": "tkinter",
      "type": "class",
      "signature": "()",
      "description": "Internal class.\n\nBase class which defines methods common for interior widgets.",
      "relationships": []
    },
    {
      "id": "stdlib.tkinter.NoDefaultRoot",
      "name": "NoDefaultRoot",
      "module": "tkinter",
      "type": "function",
      "signature": "()",
      "description": "Inhibit setting of default root window.\n\nCall this function to inhibit that the first instance of\nTk is used for windows without an explicit parent window.",
      "relationships": []
    },
    {
      "id": "stdlib.tkinter.OptionMenu",
      "name": "OptionMenu",
      "module": "tkinter",
      "type": "class",
      "signature": "(master, variable, value, *values, **kwargs)",
      "description": "OptionMenu which allows the user to select a value from a menu.",
      "relationships": [
        {
          "target": "Menubutton",
          "type": "base_class"
        },
        {
          "target": "Widget",
          "type": "base_class"
        },
        {
          "target": "BaseWidget",
          "type": "base_class"
        },
        {
          "target": "Misc",
          "type": "base_class"
        },
        {
          "target": "Pack",
          "type": "base_class"
        },
        {
          "target": "Place",
          "type": "base_class"
        },
        {
          "target": "Grid",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.tkinter.Pack",
      "name": "Pack",
      "module": "tkinter",
      "type": "class",
      "signature": "()",
      "description": "Geometry manager Pack.\n\nBase class to use the methods pack_* in every widget.",
      "relationships": []
    },
    {
      "id": "stdlib.tkinter.PanedWindow",
      "name": "PanedWindow",
      "module": "tkinter",
      "type": "class",
      "signature": "(master=None, cnf={}, **kw)",
      "description": "panedwindow widget.",
      "relationships": [
        {
          "target": "Widget",
          "type": "base_class"
        },
        {
          "target": "BaseWidget",
          "type": "base_class"
        },
        {
          "target": "Misc",
          "type": "base_class"
        },
        {
          "target": "Pack",
          "type": "base_class"
        },
        {
          "target": "Place",
          "type": "base_class"
        },
        {
          "target": "Grid",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.tkinter.PhotoImage",
      "name": "PhotoImage",
      "module": "tkinter",
      "type": "class",
      "signature": "(name=None, cnf={}, master=None, **kw)",
      "description": "Widget which can display images in PGM, PPM, GIF, PNG format.",
      "relationships": [
        {
          "target": "Image",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.tkinter.Place",
      "name": "Place",
      "module": "tkinter",
      "type": "class",
      "signature": "()",
      "description": "Geometry manager Place.\n\nBase class to use the methods place_* in every widget.",
      "relationships": []
    },
    {
      "id": "stdlib.tkinter.Radiobutton",
      "name": "Radiobutton",
      "module": "tkinter",
      "type": "class",
      "signature": "(master=None, cnf={}, **kw)",
      "description": "Radiobutton widget which shows only one of several buttons in on-state.",
      "relationships": [
        {
          "target": "Widget",
          "type": "base_class"
        },
        {
          "target": "BaseWidget",
          "type": "base_class"
        },
        {
          "target": "Misc",
          "type": "base_class"
        },
        {
          "target": "Pack",
          "type": "base_class"
        },
        {
          "target": "Place",
          "type": "base_class"
        },
        {
          "target": "Grid",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.tkinter.Scale",
      "name": "Scale",
      "module": "tkinter",
      "type": "class",
      "signature": "(master=None, cnf={}, **kw)",
      "description": "Scale widget which can display a numerical scale.",
      "relationships": [
        {
          "target": "Widget",
          "type": "base_class"
        },
        {
          "target": "BaseWidget",
          "type": "base_class"
        },
        {
          "target": "Misc",
          "type": "base_class"
        },
        {
          "target": "Pack",
          "type": "base_class"
        },
        {
          "target": "Place",
          "type": "base_class"
        },
        {
          "target": "Grid",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.tkinter.Scrollbar",
      "name": "Scrollbar",
      "module": "tkinter",
      "type": "class",
      "signature": "(master=None, cnf={}, **kw)",
      "description": "Scrollbar widget which displays a slider at a certain position.",
      "relationships": [
        {
          "target": "Widget",
          "type": "base_class"
        },
        {
          "target": "BaseWidget",
          "type": "base_class"
        },
        {
          "target": "Misc",
          "type": "base_class"
        },
        {
          "target": "Pack",
          "type": "base_class"
        },
        {
          "target": "Place",
          "type": "base_class"
        },
        {
          "target": "Grid",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.tkinter.Spinbox",
      "name": "Spinbox",
      "module": "tkinter",
      "type": "class",
      "signature": "(master=None, cnf={}, **kw)",
      "description": "spinbox widget.",
      "relationships": [
        {
          "target": "Widget",
          "type": "base_class"
        },
        {
          "target": "BaseWidget",
          "type": "base_class"
        },
        {
          "target": "Misc",
          "type": "base_class"
        },
        {
          "target": "Pack",
          "type": "base_class"
        },
        {
          "target": "Place",
          "type": "base_class"
        },
        {
          "target": "Grid",
          "type": "base_class"
        },
        {
          "target": "XView",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.tkinter.StringVar",
      "name": "StringVar",
      "module": "tkinter",
      "type": "class",
      "signature": "(master=None, value=None, name=None)",
      "description": "Value holder for strings variables.",
      "relationships": [
        {
          "target": "Variable",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.tkinter.Tcl",
      "name": "Tcl",
      "module": "tkinter",
      "type": "function",
      "signature": "(screenName=None, baseName=None, className='Tk', useTk=False)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.tkinter.Tk",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.tkinter.Text",
      "name": "Text",
      "module": "tkinter",
      "type": "class",
      "signature": "(master=None, cnf={}, **kw)",
      "description": "Text widget which can display text in various forms.",
      "relationships": [
        {
          "target": "Widget",
          "type": "base_class"
        },
        {
          "target": "BaseWidget",
          "type": "base_class"
        },
        {
          "target": "Misc",
          "type": "base_class"
        },
        {
          "target": "Pack",
          "type": "base_class"
        },
        {
          "target": "Place",
          "type": "base_class"
        },
        {
          "target": "Grid",
          "type": "base_class"
        },
        {
          "target": "XView",
          "type": "base_class"
        },
        {
          "target": "YView",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.tkinter.Tk",
      "name": "Tk",
      "module": "tkinter",
      "type": "class",
      "signature": "(screenName=None, baseName=None, className='Tk', useTk=True, sync=False, use=None)",
      "description": "Toplevel widget of Tk which represents mostly the main window\nof an application. It has an associated Tcl interpreter.",
      "relationships": [
        {
          "target": "Misc",
          "type": "base_class"
        },
        {
          "target": "Wm",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.tkinter.Toplevel",
      "name": "Toplevel",
      "module": "tkinter",
      "type": "class",
      "signature": "(master=None, cnf={}, **kw)",
      "description": "Toplevel widget, e.g. for dialogs.",
      "relationships": [
        {
          "target": "BaseWidget",
          "type": "base_class"
        },
        {
          "target": "Misc",
          "type": "base_class"
        },
        {
          "target": "Wm",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.tkinter.Variable",
      "name": "Variable",
      "module": "tkinter",
      "type": "class",
      "signature": "(master=None, value=None, name=None)",
      "description": "Class to define value holders for e.g. buttons.\n\nSubclasses StringVar, IntVar, DoubleVar, BooleanVar are specializations\nthat constrain the type of the value returned from get().",
      "relationships": []
    },
    {
      "id": "stdlib.tkinter.Widget",
      "name": "Widget",
      "module": "tkinter",
      "type": "class",
      "signature": "(master, widgetName, cnf={}, kw={}, extra=())",
      "description": "Internal class.\n\nBase class for a widget which can be positioned with the geometry managers\nPack, Place or Grid.",
      "relationships": [
        {
          "target": "BaseWidget",
          "type": "base_class"
        },
        {
          "target": "Misc",
          "type": "base_class"
        },
        {
          "target": "Pack",
          "type": "base_class"
        },
        {
          "target": "Place",
          "type": "base_class"
        },
        {
          "target": "Grid",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.tkinter.Wm",
      "name": "Wm",
      "module": "tkinter",
      "type": "class",
      "signature": "()",
      "description": "Provides functions for the communication with the window manager.",
      "relationships": []
    },
    {
      "id": "stdlib.tkinter.XView",
      "name": "XView",
      "module": "tkinter",
      "type": "class",
      "signature": "()",
      "description": "Mix-in class for querying and changing the horizontal position\nof a widget's window.",
      "relationships": []
    },
    {
      "id": "stdlib.tkinter.YView",
      "name": "YView",
      "module": "tkinter",
      "type": "class",
      "signature": "()",
      "description": "Mix-in class for querying and changing the vertical position\nof a widget's window.",
      "relationships": []
    },
    {
      "id": "stdlib.tkinter.getboolean",
      "name": "getboolean",
      "module": "tkinter",
      "type": "function",
      "signature": "(s)",
      "description": "Convert Tcl object to True or False.",
      "relationships": [
        {
          "target": "stdlib.tkinter.getboolean",
          "type": "calls"
        },
        {
          "target": "stdlib.tkinter.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.tkinter._get_default_root",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.tkinter.getdouble",
      "name": "getdouble",
      "module": "tkinter",
      "type": "class",
      "signature": "(x=0, /)",
      "description": "Convert a string or number to a floating point number, if possible.",
      "relationships": []
    },
    {
      "id": "stdlib.tkinter.image_names",
      "name": "image_names",
      "module": "tkinter",
      "type": "function",
      "signature": "()",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.tkinter.splitlist",
          "type": "calls"
        },
        {
          "target": "stdlib.tkinter._get_default_root",
          "type": "calls"
        },
        {
          "target": "stdlib.tkinter.call",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.tkinter.image_types",
      "name": "image_types",
      "module": "tkinter",
      "type": "function",
      "signature": "()",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.tkinter.splitlist",
          "type": "calls"
        },
        {
          "target": "stdlib.tkinter._get_default_root",
          "type": "calls"
        },
        {
          "target": "stdlib.tkinter.call",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.tkinter.mainloop",
      "name": "mainloop",
      "module": "tkinter",
      "type": "function",
      "signature": "(n=0)",
      "description": "Run the main loop of Tcl.",
      "relationships": [
        {
          "target": "stdlib.tkinter.mainloop",
          "type": "calls"
        },
        {
          "target": "stdlib.tkinter._get_default_root",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.token.ISEOF",
      "name": "ISEOF",
      "module": "token",
      "type": "function",
      "signature": "(x)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.token.ISNONTERMINAL",
      "name": "ISNONTERMINAL",
      "module": "token",
      "type": "function",
      "signature": "(x)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.token.ISTERMINAL",
      "name": "ISTERMINAL",
      "module": "token",
      "type": "function",
      "signature": "(x)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.tokenize.ISEOF",
      "name": "ISEOF",
      "module": "tokenize",
      "type": "function",
      "signature": "(x)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.tokenize.ISNONTERMINAL",
      "name": "ISNONTERMINAL",
      "module": "tokenize",
      "type": "function",
      "signature": "(x)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.tokenize.ISTERMINAL",
      "name": "ISTERMINAL",
      "module": "tokenize",
      "type": "function",
      "signature": "(x)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.tokenize.TextIOWrapper",
      "name": "TextIOWrapper",
      "module": "tokenize",
      "type": "class",
      "signature": "(buffer, encoding=None, errors=None, newline=None, line_buffering=False, write_through=False)",
      "description": "Character and line based layer over a BufferedIOBase object, buffer.\n\nencoding gives the name of the encoding that the stream will be\ndecoded or encoded with. It defaults to locale.getpreferredencoding(False).\n\nerrors determines the strictness of encoding and decoding (see\nhelp(codecs.Codec) or the documentation for codecs.register) and\ndefaults to \"strict\".\n\nnewline controls how line endings are handled. It can be None, '',\n'\\n', '\\r', and '\\r\\n'.  It works as follows:\n\n* On input, if newline is None, universal newlines mode is\n  enabled. Lines in the input can end in '\\n', '\\r', or '\\r\\n', and\n  these are translated into '\\n' before being returned to the\n  caller. If it is '', universal newline mode is enabled, but line\n  endings are returned to the caller untranslated. If it has any of\n  the other legal values, input lines are only terminated by the given\n  string, and the line ending is returned to the caller untranslated.\n\n* On output, if newline is None, any '\\n' characters written are\n  translated to the system default line separator, os.linesep. If\n  newline is '' or '\\n', no translation takes place. If newline is any\n  of the other legal values, any '\\n' characters written are translated\n  to the given string.\n\nIf line_buffering is True, a call to flush is implied when a call to\nwrite contains a newline character.",
      "relationships": [
        {
          "target": "_TextIOBase",
          "type": "base_class"
        },
        {
          "target": "_IOBase",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.tokenize.TokenInfo",
      "name": "TokenInfo",
      "module": "tokenize",
      "type": "class",
      "signature": "(type, string, start, end, line)",
      "description": "TokenInfo(type, string, start, end, line)",
      "relationships": [
        {
          "target": "TokenInfo",
          "type": "base_class"
        },
        {
          "target": "tuple",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.tokenize.Untokenizer",
      "name": "Untokenizer",
      "module": "tokenize",
      "type": "class",
      "signature": "()",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.tokenize.any",
      "name": "any",
      "module": "tokenize",
      "type": "function",
      "signature": "(*choices)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.tokenize.group",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.tokenize.detect_encoding",
      "name": "detect_encoding",
      "module": "tokenize",
      "type": "function",
      "signature": "(readline)",
      "description": "The detect_encoding() function is used to detect the encoding that should\nbe used to decode a Python source file.  It requires one argument, readline,\nin the same way as the tokenize() generator.\n\nIt will call readline a maximum of twice, and return the encoding used\n(as a string) and a list of any lines (left as bytes) it has read in.\n\nIt detects the encoding from the presence of a utf-8 bom or an encoding\ncookie as specified in pep-0263.  If both a bom and a cookie are present,\nbut disagree, a SyntaxError will be raised.  If the encoding cookie is an\ninvalid charset, raise a SyntaxError.  Note that if a utf-8 bom is found,\n'utf-8-sig' is returned.\n\nIf no encoding is specified, then the default of 'utf-8' will be returned.",
      "relationships": [
        {
          "target": "stdlib.tokenize.read_or_stop",
          "type": "calls"
        },
        {
          "target": "stdlib.tokenize.startswith",
          "type": "calls"
        },
        {
          "target": "stdlib.tokenize.find_cookie",
          "type": "calls"
        },
        {
          "target": "stdlib.tokenize.read_or_stop",
          "type": "calls"
        },
        {
          "target": "stdlib.tokenize.find_cookie",
          "type": "calls"
        },
        {
          "target": "stdlib.tokenize.match",
          "type": "calls"
        },
        {
          "target": "stdlib.tokenize._get_normal_name",
          "type": "calls"
        },
        {
          "target": "stdlib.tokenize.match",
          "type": "calls"
        },
        {
          "target": "stdlib.tokenize.readline",
          "type": "calls"
        },
        {
          "target": "stdlib.tokenize.decode",
          "type": "calls"
        },
        {
          "target": "stdlib.tokenize.group",
          "type": "calls"
        },
        {
          "target": "stdlib.tokenize.lookup",
          "type": "calls"
        },
        {
          "target": "stdlib.tokenize.SyntaxError",
          "type": "calls"
        },
        {
          "target": "stdlib.tokenize.SyntaxError",
          "type": "calls"
        },
        {
          "target": "stdlib.tokenize.SyntaxError",
          "type": "calls"
        },
        {
          "target": "stdlib.tokenize.format",
          "type": "calls"
        },
        {
          "target": "stdlib.tokenize.format",
          "type": "calls"
        },
        {
          "target": "stdlib.tokenize.format",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.tokenize.generate_tokens",
      "name": "generate_tokens",
      "module": "tokenize",
      "type": "function",
      "signature": "(readline)",
      "description": "Tokenize a source reading Python code as unicode strings.\n\nThis has the same API as tokenize(), except that it expects the *readline*\ncallable to return str objects instead of bytes.",
      "relationships": [
        {
          "target": "stdlib.tokenize._tokenize",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.tokenize.group",
      "name": "group",
      "module": "tokenize",
      "type": "function",
      "signature": "(*choices)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.tokenize.join",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.tokenize.main",
      "name": "main",
      "module": "tokenize",
      "type": "function",
      "signature": "()",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.tokenize.ArgumentParser",
          "type": "calls"
        },
        {
          "target": "stdlib.tokenize.add_argument",
          "type": "calls"
        },
        {
          "target": "stdlib.tokenize.add_argument",
          "type": "calls"
        },
        {
          "target": "stdlib.tokenize.parse_args",
          "type": "calls"
        },
        {
          "target": "stdlib.tokenize.write",
          "type": "calls"
        },
        {
          "target": "stdlib.tokenize.write",
          "type": "calls"
        },
        {
          "target": "stdlib.tokenize.exit",
          "type": "calls"
        },
        {
          "target": "stdlib.tokenize.perror",
          "type": "calls"
        },
        {
          "target": "stdlib.tokenize._tokenize",
          "type": "calls"
        },
        {
          "target": "stdlib.tokenize.print",
          "type": "calls"
        },
        {
          "target": "stdlib.tokenize.error",
          "type": "calls"
        },
        {
          "target": "stdlib.tokenize.error",
          "type": "calls"
        },
        {
          "target": "stdlib.tokenize.error",
          "type": "calls"
        },
        {
          "target": "stdlib.tokenize.error",
          "type": "calls"
        },
        {
          "target": "stdlib.tokenize.print",
          "type": "calls"
        },
        {
          "target": "stdlib.tokenize.perror",
          "type": "calls"
        },
        {
          "target": "stdlib.tokenize.perror",
          "type": "calls"
        },
        {
          "target": "stdlib.tokenize.perror",
          "type": "calls"
        },
        {
          "target": "stdlib.tokenize._builtin_open",
          "type": "calls"
        },
        {
          "target": "stdlib.tokenize.list",
          "type": "calls"
        },
        {
          "target": "stdlib.tokenize.tokenize",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.tokenize.maybe",
      "name": "maybe",
      "module": "tokenize",
      "type": "function",
      "signature": "(*choices)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.tokenize.group",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.tokenize.open",
      "name": "open",
      "module": "tokenize",
      "type": "function",
      "signature": "(filename)",
      "description": "Open a file in read only mode using the encoding detected by\ndetect_encoding().",
      "relationships": [
        {
          "target": "stdlib.tokenize._builtin_open",
          "type": "calls"
        },
        {
          "target": "stdlib.tokenize.detect_encoding",
          "type": "calls"
        },
        {
          "target": "stdlib.tokenize.seek",
          "type": "calls"
        },
        {
          "target": "stdlib.tokenize.TextIOWrapper",
          "type": "calls"
        },
        {
          "target": "stdlib.tokenize.close",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.tokenize.tokenize",
      "name": "tokenize",
      "module": "tokenize",
      "type": "function",
      "signature": "(readline)",
      "description": "The tokenize() generator requires one argument, readline, which\nmust be a callable object which provides the same interface as the\nreadline() method of built-in file objects.  Each call to the function\nshould return one line of input as bytes.  Alternatively, readline\ncan be a callable function terminating with StopIteration:\n    readline = open(myfile, 'rb').__next__  # Example of alternate readline\n\nThe generator produces 5-tuples with these members: the token type; the\ntoken string; a 2-tuple (srow, scol) of ints specifying the row and\ncolumn where the token begins in the source; a 2-tuple (erow, ecol) of\nints specifying the row and column where the token ends in the source;\nand the line on which the token was found.  The line passed is the\nphysical line.\n\nThe first token sequence will always be an ENCODING token\nwhich tells you which encoding was used to decode the bytes stream.",
      "relationships": [
        {
          "target": "stdlib.tokenize.detect_encoding",
          "type": "calls"
        },
        {
          "target": "stdlib.tokenize.repeat",
          "type": "calls"
        },
        {
          "target": "stdlib.tokenize.chain",
          "type": "calls"
        },
        {
          "target": "stdlib.tokenize._tokenize",
          "type": "calls"
        },
        {
          "target": "stdlib.tokenize.iter",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.tokenize.untokenize",
      "name": "untokenize",
      "module": "tokenize",
      "type": "function",
      "signature": "(iterable)",
      "description": "Transform tokens back into Python source code.\nIt returns a bytes object, encoded using the ENCODING\ntoken, which is the first token sequence output by tokenize.\n\nEach element returned by the iterable must be a token sequence\nwith at least two elements, a token number and token value.  If\nonly two tokens are passed, the resulting output is poor.\n\nRound-trip invariant for full input:\n    Untokenized source will match input source exactly\n\nRound-trip invariant for limited input:\n    # Output bytes will tokenize back to the input\n    t1 = [tok[:2] for tok in tokenize(f.readline)]\n    newcode = untokenize(t1)\n    readline = BytesIO(newcode).readline\n    t2 = [tok[:2] for tok in tokenize(readline)]\n    assert t1 == t2",
      "relationships": [
        {
          "target": "stdlib.tokenize.Untokenizer",
          "type": "calls"
        },
        {
          "target": "stdlib.tokenize.untokenize",
          "type": "calls"
        },
        {
          "target": "stdlib.tokenize.encode",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.trace.CoverageResults",
      "name": "CoverageResults",
      "module": "trace",
      "type": "class",
      "signature": "(counts=None, calledfuncs=None, infile=None, callers=None, outfile=None)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.trace.Trace",
      "name": "Trace",
      "module": "trace",
      "type": "class",
      "signature": "(count=1, trace=1, countfuncs=0, countcallers=0, ignoremods=(), ignoredirs=(), infile=None, outfile=None, timing=False)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.trace.main",
      "name": "main",
      "module": "trace",
      "type": "function",
      "signature": "()",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.trace.ArgumentParser",
          "type": "calls"
        },
        {
          "target": "stdlib.trace.add_argument",
          "type": "calls"
        },
        {
          "target": "stdlib.trace.add_argument_group",
          "type": "calls"
        },
        {
          "target": "stdlib.trace.add_argument",
          "type": "calls"
        },
        {
          "target": "stdlib.trace.add_argument",
          "type": "calls"
        },
        {
          "target": "stdlib.trace.add_argument",
          "type": "calls"
        },
        {
          "target": "stdlib.trace.add_argument",
          "type": "calls"
        },
        {
          "target": "stdlib.trace.add_argument_group",
          "type": "calls"
        },
        {
          "target": "stdlib.trace.add_mutually_exclusive_group",
          "type": "calls"
        },
        {
          "target": "stdlib.trace.add_argument",
          "type": "calls"
        },
        {
          "target": "stdlib.trace.add_argument",
          "type": "calls"
        },
        {
          "target": "stdlib.trace.add_argument",
          "type": "calls"
        },
        {
          "target": "stdlib.trace.add_argument",
          "type": "calls"
        },
        {
          "target": "stdlib.trace.add_argument",
          "type": "calls"
        },
        {
          "target": "stdlib.trace.add_argument",
          "type": "calls"
        },
        {
          "target": "stdlib.trace.add_argument",
          "type": "calls"
        },
        {
          "target": "stdlib.trace.add_argument_group",
          "type": "calls"
        },
        {
          "target": "stdlib.trace.add_argument",
          "type": "calls"
        },
        {
          "target": "stdlib.trace.add_argument",
          "type": "calls"
        },
        {
          "target": "stdlib.trace.add_argument",
          "type": "calls"
        },
        {
          "target": "stdlib.trace.add_argument",
          "type": "calls"
        },
        {
          "target": "stdlib.trace.add_argument",
          "type": "calls"
        },
        {
          "target": "stdlib.trace.parse_args",
          "type": "calls"
        },
        {
          "target": "stdlib.trace.Trace",
          "type": "calls"
        },
        {
          "target": "stdlib.trace.results",
          "type": "calls"
        },
        {
          "target": "stdlib.trace.get_path",
          "type": "calls"
        },
        {
          "target": "stdlib.trace.get_path",
          "type": "calls"
        },
        {
          "target": "stdlib.trace.expanduser",
          "type": "calls"
        },
        {
          "target": "stdlib.trace.replace",
          "type": "calls"
        },
        {
          "target": "stdlib.trace.normpath",
          "type": "calls"
        },
        {
          "target": "stdlib.trace.strip",
          "type": "calls"
        },
        {
          "target": "stdlib.trace.parse_ignore_dir",
          "type": "calls"
        },
        {
          "target": "stdlib.trace.CoverageResults",
          "type": "calls"
        },
        {
          "target": "stdlib.trace.write_results",
          "type": "calls"
        },
        {
          "target": "stdlib.trace.any",
          "type": "calls"
        },
        {
          "target": "stdlib.trace.error",
          "type": "calls"
        },
        {
          "target": "stdlib.trace.error",
          "type": "calls"
        },
        {
          "target": "stdlib.trace.error",
          "type": "calls"
        },
        {
          "target": "stdlib.trace.error",
          "type": "calls"
        },
        {
          "target": "stdlib.trace.runctx",
          "type": "calls"
        },
        {
          "target": "stdlib.trace.write_results",
          "type": "calls"
        },
        {
          "target": "stdlib.trace.expandvars",
          "type": "calls"
        },
        {
          "target": "stdlib.trace.split",
          "type": "calls"
        },
        {
          "target": "stdlib.trace.split",
          "type": "calls"
        },
        {
          "target": "stdlib.trace.error",
          "type": "calls"
        },
        {
          "target": "stdlib.trace._get_module_details",
          "type": "calls"
        },
        {
          "target": "stdlib.trace.dirname",
          "type": "calls"
        },
        {
          "target": "stdlib.trace.exit",
          "type": "calls"
        },
        {
          "target": "stdlib.trace.replace",
          "type": "calls"
        },
        {
          "target": "stdlib.trace.open",
          "type": "calls"
        },
        {
          "target": "stdlib.trace.compile",
          "type": "calls"
        },
        {
          "target": "stdlib.trace.read",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.traceback.FrameSummary",
      "name": "FrameSummary",
      "module": "traceback",
      "type": "class",
      "signature": "(filename, lineno, name, *, lookup_line=True, locals=None, line=None)",
      "description": "A single frame from a traceback.\n\n- :attr:`filename` The filename for the frame.\n- :attr:`lineno` The line within filename for the frame that was\n  active when the frame was captured.\n- :attr:`name` The name of the function or method that was executing\n  when the frame was captured.\n- :attr:`line` The text from the linecache module for the\n  of code that was running when the frame was captured.\n- :attr:`locals` Either None if locals were not supplied, or a dict\n  mapping the name to the repr() of the variable.",
      "relationships": []
    },
    {
      "id": "stdlib.traceback.StackSummary",
      "name": "StackSummary",
      "module": "traceback",
      "type": "class",
      "signature": "(iterable=(), /)",
      "description": "A stack of frames.",
      "relationships": [
        {
          "target": "list",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.traceback.TracebackException",
      "name": "TracebackException",
      "module": "traceback",
      "type": "class",
      "signature": "(exc_type, exc_value, exc_traceback, *, limit=None, lookup_lines=True, capture_locals=False, _seen=None)",
      "description": "An exception ready for rendering.\n\nThe traceback module captures enough attributes from the original exception\nto this intermediary form to ensure that no references are held, while\nstill being able to fully print or format it.\n\nUse `from_exception` to create TracebackException instances from exception\nobjects, or the constructor to create TracebackException instances from\nindividual components.\n\n- :attr:`__cause__` A TracebackException of the original *__cause__*.\n- :attr:`__context__` A TracebackException of the original *__context__*.\n- :attr:`__suppress_context__` The *__suppress_context__* value from the\n  original exception.\n- :attr:`stack` A `StackSummary` representing the traceback.\n- :attr:`exc_type` The class of the original traceback.\n- :attr:`filename` For syntax errors - the filename where the error\n  occurred.\n- :attr:`lineno` For syntax errors - the linenumber where the error\n  occurred.\n- :attr:`text` For syntax errors - the text where the error\n  occurred.\n- :attr:`offset` For syntax errors - the offset into the text where the\n  error occurred.\n- :attr:`msg` For syntax errors - the compiler error message.",
      "relationships": []
    },
    {
      "id": "stdlib.traceback.clear_frames",
      "name": "clear_frames",
      "module": "traceback",
      "type": "function",
      "signature": "(tb)",
      "description": "Clear all references to local variables in the frames of a traceback.",
      "relationships": [
        {
          "target": "stdlib.traceback.clear",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.traceback.extract_stack",
      "name": "extract_stack",
      "module": "traceback",
      "type": "function",
      "signature": "(f=None, limit=None)",
      "description": "Extract the raw traceback from the current stack frame.\n\nThe return value has the same format as for extract_tb().  The\noptional 'f' and 'limit' arguments have the same meaning as for\nprint_stack().  Each item in the list is a quadruple (filename,\nline number, function name, text), and the entries are in order\nfrom oldest to newest stack frame.",
      "relationships": [
        {
          "target": "stdlib.traceback.extract",
          "type": "calls"
        },
        {
          "target": "stdlib.traceback.reverse",
          "type": "calls"
        },
        {
          "target": "stdlib.traceback.walk_stack",
          "type": "calls"
        },
        {
          "target": "stdlib.traceback._getframe",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.traceback.extract_tb",
      "name": "extract_tb",
      "module": "traceback",
      "type": "function",
      "signature": "(tb, limit=None)",
      "description": "Return a StackSummary object representing a list of\npre-processed entries from traceback.\n\nThis is useful for alternate formatting of stack traces.  If\n'limit' is omitted or None, all entries are extracted.  A\npre-processed stack trace entry is a FrameSummary object\ncontaining attributes filename, lineno, name, and line\nrepresenting the information that is usually printed for a stack\ntrace.  The line is a string with leading and trailing\nwhitespace stripped; if the source is not available it is None.",
      "relationships": [
        {
          "target": "stdlib.traceback.extract",
          "type": "calls"
        },
        {
          "target": "stdlib.traceback.walk_tb",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.traceback.format_exc",
      "name": "format_exc",
      "module": "traceback",
      "type": "function",
      "signature": "(limit=None, chain=True)",
      "description": "Like print_exc() but return a string.",
      "relationships": [
        {
          "target": "stdlib.traceback.join",
          "type": "calls"
        },
        {
          "target": "stdlib.traceback.format_exception",
          "type": "calls"
        },
        {
          "target": "stdlib.traceback.exc_info",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.traceback.format_exception",
      "name": "format_exception",
      "module": "traceback",
      "type": "function",
      "signature": "(etype, value, tb, limit=None, chain=True)",
      "description": "Format a stack trace and the exception information.\n\nThe arguments have the same meaning as the corresponding arguments\nto print_exception().  The return value is a list of strings, each\nending in a newline and some containing internal newlines.  When\nthese lines are concatenated and printed, exactly the same text is\nprinted as does print_exception().",
      "relationships": [
        {
          "target": "stdlib.traceback.list",
          "type": "calls"
        },
        {
          "target": "stdlib.traceback.format",
          "type": "calls"
        },
        {
          "target": "stdlib.traceback.TracebackException",
          "type": "calls"
        },
        {
          "target": "stdlib.traceback.type",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.traceback.format_exception_only",
      "name": "format_exception_only",
      "module": "traceback",
      "type": "function",
      "signature": "(etype, value)",
      "description": "Format the exception part of a traceback.\n\nThe arguments are the exception type and value such as given by\nsys.last_type and sys.last_value. The return value is a list of\nstrings, each ending in a newline.\n\nNormally, the list contains a single string; however, for\nSyntaxError exceptions, it contains several lines that (when\nprinted) display detailed information about where the syntax\nerror occurred.\n\nThe message indicating which exception occurred is always the last\nstring in the list.",
      "relationships": [
        {
          "target": "stdlib.traceback.list",
          "type": "calls"
        },
        {
          "target": "stdlib.traceback.format_exception_only",
          "type": "calls"
        },
        {
          "target": "stdlib.traceback.TracebackException",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.traceback.format_list",
      "name": "format_list",
      "module": "traceback",
      "type": "function",
      "signature": "(extracted_list)",
      "description": "Format a list of tuples or FrameSummary objects for printing.\n\nGiven a list of tuples or FrameSummary objects as returned by\nextract_tb() or extract_stack(), return a list of strings ready\nfor printing.\n\nEach string in the resulting list corresponds to the item with the\nsame index in the argument list.  Each string ends in a newline;\nthe strings may contain internal newlines as well, for those items\nwhose source text line is not None.",
      "relationships": [
        {
          "target": "stdlib.traceback.format",
          "type": "calls"
        },
        {
          "target": "stdlib.traceback.from_list",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.traceback.format_stack",
      "name": "format_stack",
      "module": "traceback",
      "type": "function",
      "signature": "(f=None, limit=None)",
      "description": "Shorthand for 'format_list(extract_stack(f, limit))'.",
      "relationships": [
        {
          "target": "stdlib.traceback.format_list",
          "type": "calls"
        },
        {
          "target": "stdlib.traceback.extract_stack",
          "type": "calls"
        },
        {
          "target": "stdlib.traceback._getframe",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.traceback.format_tb",
      "name": "format_tb",
      "module": "traceback",
      "type": "function",
      "signature": "(tb, limit=None)",
      "description": "A shorthand for 'format_list(extract_tb(tb, limit))'.",
      "relationships": [
        {
          "target": "stdlib.traceback.format",
          "type": "calls"
        },
        {
          "target": "stdlib.traceback.extract_tb",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.traceback.print_exc",
      "name": "print_exc",
      "module": "traceback",
      "type": "function",
      "signature": "(limit=None, file=None, chain=True)",
      "description": "Shorthand for 'print_exception(*sys.exc_info(), limit, file)'.",
      "relationships": [
        {
          "target": "stdlib.traceback.print_exception",
          "type": "calls"
        },
        {
          "target": "stdlib.traceback.exc_info",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.traceback.print_exception",
      "name": "print_exception",
      "module": "traceback",
      "type": "function",
      "signature": "(etype, value, tb, limit=None, file=None, chain=True)",
      "description": "Print exception up to 'limit' stack trace entries from 'tb' to 'file'.\n\nThis differs from print_tb() in the following ways: (1) if\ntraceback is not None, it prints a header \"Traceback (most recent\ncall last):\"; (2) it prints the exception type and value after the\nstack trace; (3) if type is SyntaxError and value has the\nappropriate format, it prints the line where the syntax error\noccurred with a caret on the next line indicating the approximate\nposition of the error.",
      "relationships": [
        {
          "target": "stdlib.traceback.format",
          "type": "calls"
        },
        {
          "target": "stdlib.traceback.print",
          "type": "calls"
        },
        {
          "target": "stdlib.traceback.TracebackException",
          "type": "calls"
        },
        {
          "target": "stdlib.traceback.type",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.traceback.print_last",
      "name": "print_last",
      "module": "traceback",
      "type": "function",
      "signature": "(limit=None, file=None, chain=True)",
      "description": "This is a shorthand for 'print_exception(sys.last_type,\nsys.last_value, sys.last_traceback, limit, file)'.",
      "relationships": [
        {
          "target": "stdlib.traceback.print_exception",
          "type": "calls"
        },
        {
          "target": "stdlib.traceback.hasattr",
          "type": "calls"
        },
        {
          "target": "stdlib.traceback.ValueError",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.traceback.print_list",
      "name": "print_list",
      "module": "traceback",
      "type": "function",
      "signature": "(extracted_list, file=None)",
      "description": "Print the list of tuples as returned by extract_tb() or\nextract_stack() as a formatted stack trace to the given file.",
      "relationships": [
        {
          "target": "stdlib.traceback.format",
          "type": "calls"
        },
        {
          "target": "stdlib.traceback.print",
          "type": "calls"
        },
        {
          "target": "stdlib.traceback.from_list",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.traceback.print_stack",
      "name": "print_stack",
      "module": "traceback",
      "type": "function",
      "signature": "(f=None, limit=None, file=None)",
      "description": "Print a stack trace from its invocation point.\n\nThe optional 'f' argument can be used to specify an alternate\nstack frame at which to start. The optional 'limit' and 'file'\narguments have the same meaning as for print_exception().",
      "relationships": [
        {
          "target": "stdlib.traceback.print_list",
          "type": "calls"
        },
        {
          "target": "stdlib.traceback.extract_stack",
          "type": "calls"
        },
        {
          "target": "stdlib.traceback._getframe",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.traceback.print_tb",
      "name": "print_tb",
      "module": "traceback",
      "type": "function",
      "signature": "(tb, limit=None, file=None)",
      "description": "Print up to 'limit' stack trace entries from the traceback 'tb'.\n\nIf 'limit' is omitted or None, all entries are printed.  If 'file'\nis omitted or None, the output goes to sys.stderr; otherwise\n'file' should be an open file or file-like object with a write()\nmethod.",
      "relationships": [
        {
          "target": "stdlib.traceback.print_list",
          "type": "calls"
        },
        {
          "target": "stdlib.traceback.extract_tb",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.traceback.walk_stack",
      "name": "walk_stack",
      "module": "traceback",
      "type": "function",
      "signature": "(f)",
      "description": "Walk a stack yielding the frame and line number for each frame.\n\nThis will follow f.f_back from the given frame. If no frame is given, the\ncurrent stack is used. Usually used with StackSummary.extract.",
      "relationships": [
        {
          "target": "stdlib.traceback._getframe",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.traceback.walk_tb",
      "name": "walk_tb",
      "module": "traceback",
      "type": "function",
      "signature": "(tb)",
      "description": "Walk a traceback yielding the frame and line number for each frame.\n\nThis will follow tb.tb_next (and thus is in the opposite order to\nwalk_stack). Usually used with StackSummary.extract.",
      "relationships": []
    },
    {
      "id": "stdlib.tracemalloc.BaseFilter",
      "name": "BaseFilter",
      "module": "tracemalloc",
      "type": "class",
      "signature": "(inclusive)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.tracemalloc.DomainFilter",
      "name": "DomainFilter",
      "module": "tracemalloc",
      "type": "class",
      "signature": "(inclusive, domain)",
      "description": "",
      "relationships": [
        {
          "target": "BaseFilter",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.tracemalloc.Filter",
      "name": "Filter",
      "module": "tracemalloc",
      "type": "class",
      "signature": "(inclusive, filename_pattern, lineno=None, all_frames=False, domain=None)",
      "description": "",
      "relationships": [
        {
          "target": "BaseFilter",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.tracemalloc.Frame",
      "name": "Frame",
      "module": "tracemalloc",
      "type": "class",
      "signature": "(frame)",
      "description": "Frame of a traceback.",
      "relationships": []
    },
    {
      "id": "stdlib.tracemalloc.Iterable",
      "name": "Iterable",
      "module": "tracemalloc",
      "type": "class",
      "signature": "()",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.tracemalloc.Sequence",
      "name": "Sequence",
      "module": "tracemalloc",
      "type": "class",
      "signature": "()",
      "description": "All the operations on a read-only sequence.\n\nConcrete subclasses must override __new__ or __init__,\n__getitem__, and __len__.",
      "relationships": [
        {
          "target": "Reversible",
          "type": "base_class"
        },
        {
          "target": "Collection",
          "type": "base_class"
        },
        {
          "target": "Sized",
          "type": "base_class"
        },
        {
          "target": "Iterable",
          "type": "base_class"
        },
        {
          "target": "Container",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.tracemalloc.Snapshot",
      "name": "Snapshot",
      "module": "tracemalloc",
      "type": "class",
      "signature": "(traces, traceback_limit)",
      "description": "Snapshot of traces of memory blocks allocated by Python.",
      "relationships": []
    },
    {
      "id": "stdlib.tracemalloc.Statistic",
      "name": "Statistic",
      "module": "tracemalloc",
      "type": "class",
      "signature": "(traceback, size, count)",
      "description": "Statistic difference on memory allocations between two Snapshot instance.",
      "relationships": []
    },
    {
      "id": "stdlib.tracemalloc.StatisticDiff",
      "name": "StatisticDiff",
      "module": "tracemalloc",
      "type": "class",
      "signature": "(traceback, size, size_diff, count, count_diff)",
      "description": "Statistic difference on memory allocations between an old and a new\nSnapshot instance.",
      "relationships": []
    },
    {
      "id": "stdlib.tracemalloc.Trace",
      "name": "Trace",
      "module": "tracemalloc",
      "type": "class",
      "signature": "(trace)",
      "description": "Trace of a memory block.",
      "relationships": []
    },
    {
      "id": "stdlib.tracemalloc.Traceback",
      "name": "Traceback",
      "module": "tracemalloc",
      "type": "class",
      "signature": "(frames, total_nframe=None)",
      "description": "Sequence of Frame instances sorted from the oldest frame\nto the most recent frame.",
      "relationships": [
        {
          "target": "Sequence",
          "type": "base_class"
        },
        {
          "target": "Reversible",
          "type": "base_class"
        },
        {
          "target": "Collection",
          "type": "base_class"
        },
        {
          "target": "Sized",
          "type": "base_class"
        },
        {
          "target": "Iterable",
          "type": "base_class"
        },
        {
          "target": "Container",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.tracemalloc.get_object_traceback",
      "name": "get_object_traceback",
      "module": "tracemalloc",
      "type": "function",
      "signature": "(obj)",
      "description": "Get the traceback where the Python object *obj* was allocated.\nReturn a Traceback instance.\n\nReturn None if the tracemalloc module is not tracing memory allocations or\ndid not trace the allocation of the object.",
      "relationships": [
        {
          "target": "stdlib.tracemalloc._get_object_traceback",
          "type": "calls"
        },
        {
          "target": "stdlib.tracemalloc.Traceback",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.tracemalloc.take_snapshot",
      "name": "take_snapshot",
      "module": "tracemalloc",
      "type": "function",
      "signature": "()",
      "description": "Take a snapshot of traces of memory blocks allocated by Python.",
      "relationships": [
        {
          "target": "stdlib.tracemalloc._get_traces",
          "type": "calls"
        },
        {
          "target": "stdlib.tracemalloc.get_traceback_limit",
          "type": "calls"
        },
        {
          "target": "stdlib.tracemalloc.Snapshot",
          "type": "calls"
        },
        {
          "target": "stdlib.tracemalloc.is_tracing",
          "type": "calls"
        },
        {
          "target": "stdlib.tracemalloc.RuntimeError",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.tracemalloc.total_ordering",
      "name": "total_ordering",
      "module": "tracemalloc",
      "type": "function",
      "signature": "(cls)",
      "description": "Class decorator that fills in missing ordering methods",
      "relationships": [
        {
          "target": "stdlib.tracemalloc.max",
          "type": "calls"
        },
        {
          "target": "stdlib.tracemalloc.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.tracemalloc.setattr",
          "type": "calls"
        },
        {
          "target": "stdlib.tracemalloc.getattr",
          "type": "calls"
        },
        {
          "target": "stdlib.tracemalloc.getattr",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.tty.setcbreak",
      "name": "setcbreak",
      "module": "tty",
      "type": "function",
      "signature": "(fd, when=2)",
      "description": "Put terminal into a cbreak mode.",
      "relationships": [
        {
          "target": "stdlib.tty.tcgetattr",
          "type": "calls"
        },
        {
          "target": "stdlib.tty.tcsetattr",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.tty.setraw",
      "name": "setraw",
      "module": "tty",
      "type": "function",
      "signature": "(fd, when=2)",
      "description": "Put terminal into a raw mode.",
      "relationships": [
        {
          "target": "stdlib.tty.tcgetattr",
          "type": "calls"
        },
        {
          "target": "stdlib.tty.tcsetattr",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.turtle.Canvas",
      "name": "Canvas",
      "module": "turtle",
      "type": "class",
      "signature": "(master=None, cnf={}, **kw)",
      "description": "Canvas widget to display graphical elements like lines or text.",
      "relationships": [
        {
          "target": "Widget",
          "type": "base_class"
        },
        {
          "target": "BaseWidget",
          "type": "base_class"
        },
        {
          "target": "Misc",
          "type": "base_class"
        },
        {
          "target": "Pack",
          "type": "base_class"
        },
        {
          "target": "Place",
          "type": "base_class"
        },
        {
          "target": "Grid",
          "type": "base_class"
        },
        {
          "target": "XView",
          "type": "base_class"
        },
        {
          "target": "YView",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.turtle.Pen",
      "name": "Pen",
      "module": "turtle",
      "type": "class",
      "signature": "(shape='classic', undobuffersize=1000, visible=True)",
      "description": "RawTurtle auto-creating (scrolled) canvas.\n\nWhen a Turtle object is created or a function derived from some\nTurtle method is called a TurtleScreen object is automatically created.",
      "relationships": [
        {
          "target": "RawTurtle",
          "type": "base_class"
        },
        {
          "target": "TPen",
          "type": "base_class"
        },
        {
          "target": "TNavigator",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.turtle.RawPen",
      "name": "RawPen",
      "module": "turtle",
      "type": "class",
      "signature": "(canvas=None, shape='classic', undobuffersize=1000, visible=True)",
      "description": "Animation part of the RawTurtle.\nPuts RawTurtle upon a TurtleScreen and provides tools for\nits animation.",
      "relationships": [
        {
          "target": "TPen",
          "type": "base_class"
        },
        {
          "target": "TNavigator",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.turtle.RawTurtle",
      "name": "RawTurtle",
      "module": "turtle",
      "type": "class",
      "signature": "(canvas=None, shape='classic', undobuffersize=1000, visible=True)",
      "description": "Animation part of the RawTurtle.\nPuts RawTurtle upon a TurtleScreen and provides tools for\nits animation.",
      "relationships": [
        {
          "target": "TPen",
          "type": "base_class"
        },
        {
          "target": "TNavigator",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.turtle.Screen",
      "name": "Screen",
      "module": "turtle",
      "type": "function",
      "signature": "()",
      "description": "Return the singleton screen object.\nIf none exists at the moment, create a new one and return it,\nelse return the existing one.",
      "relationships": [
        {
          "target": "stdlib.turtle._Screen",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.turtle.ScrolledCanvas",
      "name": "ScrolledCanvas",
      "module": "turtle",
      "type": "class",
      "signature": "(master, width=500, height=350, canvwidth=600, canvheight=500)",
      "description": "Modeled after the scrolled canvas class from Grayons's Tkinter book.\n\nUsed as the default canvas, which pops up automatically when\nusing turtle graphics functions or the Turtle class.",
      "relationships": [
        {
          "target": "Frame",
          "type": "base_class"
        },
        {
          "target": "Widget",
          "type": "base_class"
        },
        {
          "target": "BaseWidget",
          "type": "base_class"
        },
        {
          "target": "Misc",
          "type": "base_class"
        },
        {
          "target": "Pack",
          "type": "base_class"
        },
        {
          "target": "Place",
          "type": "base_class"
        },
        {
          "target": "Grid",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.turtle.Shape",
      "name": "Shape",
      "module": "turtle",
      "type": "class",
      "signature": "(type_, data=None)",
      "description": "Data structure modeling shapes.\n\nattribute _type is one of \"polygon\", \"image\", \"compound\"\nattribute _data is - depending on _type a poygon-tuple,\nan image or a list constructed using the addcomponent method.",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.TNavigator",
      "name": "TNavigator",
      "module": "turtle",
      "type": "class",
      "signature": "(mode='standard')",
      "description": "Navigation part of the RawTurtle.\nImplements methods for turtle movement.",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.TPen",
      "name": "TPen",
      "module": "turtle",
      "type": "class",
      "signature": "(resizemode='noresize')",
      "description": "Drawing part of the RawTurtle.\nImplements drawing properties.",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.Tbuffer",
      "name": "Tbuffer",
      "module": "turtle",
      "type": "class",
      "signature": "(bufsize=10)",
      "description": "Ring buffer used as undobuffer for RawTurtle objects.",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.Turtle",
      "name": "Turtle",
      "module": "turtle",
      "type": "class",
      "signature": "(shape='classic', undobuffersize=1000, visible=True)",
      "description": "RawTurtle auto-creating (scrolled) canvas.\n\nWhen a Turtle object is created or a function derived from some\nTurtle method is called a TurtleScreen object is automatically created.",
      "relationships": [
        {
          "target": "RawTurtle",
          "type": "base_class"
        },
        {
          "target": "TPen",
          "type": "base_class"
        },
        {
          "target": "TNavigator",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.turtle.TurtleScreen",
      "name": "TurtleScreen",
      "module": "turtle",
      "type": "class",
      "signature": "(cv, mode='standard', colormode=1.0, delay=10)",
      "description": "Provides screen oriented methods like setbg etc.\n\nOnly relies upon the methods of TurtleScreenBase and NOT\nupon components of the underlying graphics toolkit -\nwhich is Tkinter in this case.",
      "relationships": [
        {
          "target": "TurtleScreenBase",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.turtle.TurtleScreenBase",
      "name": "TurtleScreenBase",
      "module": "turtle",
      "type": "class",
      "signature": "(cv)",
      "description": "Provide the basic graphics functionality.\nInterface between Tkinter and turtle.py.\n\nTo port turtle.py to some different graphics toolkit\na corresponding TurtleScreenBase class has to be implemented.",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.Vec2D",
      "name": "Vec2D",
      "module": "turtle",
      "type": "class",
      "signature": "(x, y)",
      "description": "A 2 dimensional vector class, used as a helper class\nfor implementing turtle graphics.\nMay be useful for turtle graphics programs also.\nDerived from tuple, so a vector is a tuple!\n\nProvides (for a, b vectors, k number):\n   a+b vector addition\n   a-b vector subtraction\n   a*b inner product\n   k*a and a*k multiplication with scalar\n   |a| absolute value of a\n   a.rotate(angle) rotation",
      "relationships": [
        {
          "target": "tuple",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.turtle.addshape",
      "name": "addshape",
      "module": "turtle",
      "type": "function",
      "signature": "(name, shape=None)",
      "description": "Adds a turtle shape to TurtleScreen's shapelist.\n\nArguments:\n(1) name is the name of a gif-file and shape is None.\n    Installs the corresponding image shape.\n    !! Image-shapes DO NOT rotate when turning the turtle,\n    !! so they do not display the heading of the turtle!\n(2) name is an arbitrary string and shape is a tuple\n    of pairs of coordinates. Installs the corresponding\n    polygon shape\n(3) name is an arbitrary string and shape is a\n    (compound) Shape object. Installs the corresponding\n    compound shape.\nTo use a shape, you have to issue the command shape(shapename).\n\ncall: register_shape(\"turtle.gif\")\n--or: register_shape(\"tri\", ((0,0), (10,10), (-10,10)))\n\nExample:\n>>> register_shape(\"triangle\", ((5,-3),(0,5),(-5,-3)))",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.back",
      "name": "back",
      "module": "turtle",
      "type": "function",
      "signature": "(distance)",
      "description": "Move the turtle backward by distance.\n\nAliases: back | backward | bk\n\nArgument:\ndistance -- a number\n\nMove the turtle backward by distance, opposite to the direction the\nturtle is headed. Do not change the turtle's heading.\n\nExample:\n>>> position()\n(0.00, 0.00)\n>>> backward(30)\n>>> position()\n(-30.00, 0.00)",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.backward",
      "name": "backward",
      "module": "turtle",
      "type": "function",
      "signature": "(distance)",
      "description": "Move the turtle backward by distance.\n\nAliases: back | backward | bk\n\nArgument:\ndistance -- a number\n\nMove the turtle backward by distance, opposite to the direction the\nturtle is headed. Do not change the turtle's heading.\n\nExample:\n>>> position()\n(0.00, 0.00)\n>>> backward(30)\n>>> position()\n(-30.00, 0.00)",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.begin_fill",
      "name": "begin_fill",
      "module": "turtle",
      "type": "function",
      "signature": "()",
      "description": "Called just before drawing a shape to be filled.\n\nNo argument.\n\nExample:\n>>> color(\"black\", \"red\")\n>>> begin_fill()\n>>> circle(60)\n>>> end_fill()",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.begin_poly",
      "name": "begin_poly",
      "module": "turtle",
      "type": "function",
      "signature": "()",
      "description": "Start recording the vertices of a polygon.\n\nNo argument.\n\nStart recording the vertices of a polygon. Current turtle position\nis first point of polygon.\n\nExample:\n>>> begin_poly()",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.bgcolor",
      "name": "bgcolor",
      "module": "turtle",
      "type": "function",
      "signature": "(*args)",
      "description": "Set or return backgroundcolor of the TurtleScreen.\n\nArguments (if given): a color string or three numbers\nin the range 0..colormode or a 3-tuple of such numbers.\n\nExample:\n>>> bgcolor(\"orange\")\n>>> bgcolor()\n'orange'\n>>> bgcolor(0.5,0,0.5)\n>>> bgcolor()\n'#800080'",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.bgpic",
      "name": "bgpic",
      "module": "turtle",
      "type": "function",
      "signature": "(picname=None)",
      "description": "Set background image or return name of current backgroundimage.\n\nOptional argument:\npicname -- a string, name of a gif-file or \"nopic\".\n\nIf picname is a filename, set the corresponding image as background.\nIf picname is \"nopic\", delete backgroundimage, if present.\nIf picname is None, return the filename of the current backgroundimage.\n\nExample:\n>>> bgpic()\n'nopic'\n>>> bgpic(\"landscape.gif\")\n>>> bgpic()\n'landscape.gif'",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.bk",
      "name": "bk",
      "module": "turtle",
      "type": "function",
      "signature": "(distance)",
      "description": "Move the turtle backward by distance.\n\nAliases: back | backward | bk\n\nArgument:\ndistance -- a number\n\nMove the turtle backward by distance, opposite to the direction the\nturtle is headed. Do not change the turtle's heading.\n\nExample:\n>>> position()\n(0.00, 0.00)\n>>> backward(30)\n>>> position()\n(-30.00, 0.00)",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.bye",
      "name": "bye",
      "module": "turtle",
      "type": "function",
      "signature": "()",
      "description": "Shut the turtlegraphics window.\n\nExample:\n>>> bye()",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.circle",
      "name": "circle",
      "module": "turtle",
      "type": "function",
      "signature": "(radius, extent=None, steps=None)",
      "description": "Draw a circle with given radius.\n\nArguments:\nradius -- a number\nextent (optional) -- a number\nsteps (optional) -- an integer\n\nDraw a circle with given radius. The center is radius units left\nof the turtle; extent - an angle - determines which part of the\ncircle is drawn. If extent is not given, draw the entire circle.\nIf extent is not a full circle, one endpoint of the arc is the\ncurrent pen position. Draw the arc in counterclockwise direction\nif radius is positive, otherwise in clockwise direction. Finally\nthe direction of the turtle is changed by the amount of extent.\n\nAs the circle is approximated by an inscribed regular polygon,\nsteps determines the number of steps to use. If not given,\nit will be calculated automatically. Maybe used to draw regular\npolygons.\n\ncall: circle(radius)                  # full circle\n--or: circle(radius, extent)          # arc\n--or: circle(radius, extent, steps)\n--or: circle(radius, steps=6)         # 6-sided polygon\n\nExample:\n>>> circle(50)\n>>> circle(120, 180)  # semicircle",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.clear",
      "name": "clear",
      "module": "turtle",
      "type": "function",
      "signature": "()",
      "description": "Delete the turtle's drawings from the screen. Do not move \n\nNo arguments.\n\nDelete the turtle's drawings from the screen. Do not move \nState and position of the turtle as well as drawings of other\nturtles are not affected.\n\nExamples:\n>>> clear()",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.clearscreen",
      "name": "clearscreen",
      "module": "turtle",
      "type": "function",
      "signature": "()",
      "description": "Delete all drawings and all turtles from the TurtleScreen.\n\nNo argument.\n\nReset empty TurtleScreen to its initial state: white background,\nno backgroundimage, no eventbindings and tracing on.\n\nExample:\n>>> clear()\n\nNote: this method is not available as function.",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.clearstamp",
      "name": "clearstamp",
      "module": "turtle",
      "type": "function",
      "signature": "(stampid)",
      "description": "Delete stamp with given stampid\n\nArgument:\nstampid - an integer, must be return value of previous stamp() call.\n\nExample:\n>>> color(\"blue\")\n>>> astamp = stamp()\n>>> fd(50)\n>>> clearstamp(astamp)",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.clearstamps",
      "name": "clearstamps",
      "module": "turtle",
      "type": "function",
      "signature": "(n=None)",
      "description": "Delete all or first/last n of turtle's stamps.\n\nOptional argument:\nn -- an integer\n\nIf n is None, delete all of pen's stamps,\nelse if n > 0 delete first n stamps\nelse if n < 0 delete last n stamps.\n\nExample:\n>>> for i in range(8):\n...     stamp(); fd(30)\n...\n>>> clearstamps(2)\n>>> clearstamps(-2)\n>>> clearstamps()",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.clone",
      "name": "clone",
      "module": "turtle",
      "type": "function",
      "signature": "()",
      "description": "Create and return a clone of the \n\nNo argument.\n\nCreate and return a clone of the turtle with same position, heading\nand turtle properties.\n\nExample (for a Turtle instance named mick):\nmick = Turtle()\njoe = mick.clone()",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.color",
      "name": "color",
      "module": "turtle",
      "type": "function",
      "signature": "(*args)",
      "description": "Return or set the pencolor and fillcolor.\n\nArguments:\nSeveral input formats are allowed.\nThey use 0, 1, 2, or 3 arguments as follows:\n\ncolor()\n    Return the current pencolor and the current fillcolor\n    as a pair of color specification strings as are returned\n    by pencolor and fillcolor.\ncolor(colorstring), color((r,g,b)), color(r,g,b)\n    inputs as in pencolor, set both, fillcolor and pencolor,\n    to the given value.\ncolor(colorstring1, colorstring2),\ncolor((r1,g1,b1), (r2,g2,b2))\n    equivalent to pencolor(colorstring1) and fillcolor(colorstring2)\n    and analogously, if the other input format is used.\n\nIf turtleshape is a polygon, outline and interior of that polygon\nis drawn with the newly set colors.\nFor more info see: pencolor, fillcolor\n\nExample:\n>>> color('red', 'green')\n>>> color()\n('red', 'green')\n>>> colormode(255)\n>>> color((40, 80, 120), (160, 200, 240))\n>>> color()\n('#285078', '#a0c8f0')",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.colormode",
      "name": "colormode",
      "module": "turtle",
      "type": "function",
      "signature": "(cmode=None)",
      "description": "Return the colormode or set it to 1.0 or 255.\n\nOptional argument:\ncmode -- one of the values 1.0 or 255\n\nr, g, b values of colortriples have to be in range 0..cmode.\n\nExample:\n>>> colormode()\n1.0\n>>> colormode(255)\n>>> pencolor(240,160,80)",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.config_dict",
      "name": "config_dict",
      "module": "turtle",
      "type": "function",
      "signature": "(filename)",
      "description": "Convert content of config-file into dictionary.",
      "relationships": [
        {
          "target": "stdlib.turtle.open",
          "type": "calls"
        },
        {
          "target": "stdlib.turtle.readlines",
          "type": "calls"
        },
        {
          "target": "stdlib.turtle.strip",
          "type": "calls"
        },
        {
          "target": "stdlib.turtle.strip",
          "type": "calls"
        },
        {
          "target": "stdlib.turtle.strip",
          "type": "calls"
        },
        {
          "target": "stdlib.turtle.startswith",
          "type": "calls"
        },
        {
          "target": "stdlib.turtle.split",
          "type": "calls"
        },
        {
          "target": "stdlib.turtle.eval",
          "type": "calls"
        },
        {
          "target": "stdlib.turtle.print",
          "type": "calls"
        },
        {
          "target": "stdlib.turtle.float",
          "type": "calls"
        },
        {
          "target": "stdlib.turtle.int",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.turtle.deepcopy",
      "name": "deepcopy",
      "module": "turtle",
      "type": "function",
      "signature": "(x, memo=None, _nil=[])",
      "description": "Deep copy operation on arbitrary Python objects.\n\nSee the module's __doc__ string for more info.",
      "relationships": [
        {
          "target": "stdlib.turtle.id",
          "type": "calls"
        },
        {
          "target": "stdlib.turtle.get",
          "type": "calls"
        },
        {
          "target": "stdlib.turtle.type",
          "type": "calls"
        },
        {
          "target": "stdlib.turtle.get",
          "type": "calls"
        },
        {
          "target": "stdlib.turtle.copier",
          "type": "calls"
        },
        {
          "target": "stdlib.turtle.issubclass",
          "type": "calls"
        },
        {
          "target": "stdlib.turtle._keep_alive",
          "type": "calls"
        },
        {
          "target": "stdlib.turtle._deepcopy_atomic",
          "type": "calls"
        },
        {
          "target": "stdlib.turtle.getattr",
          "type": "calls"
        },
        {
          "target": "stdlib.turtle.copier",
          "type": "calls"
        },
        {
          "target": "stdlib.turtle.get",
          "type": "calls"
        },
        {
          "target": "stdlib.turtle.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.turtle.reductor",
          "type": "calls"
        },
        {
          "target": "stdlib.turtle.getattr",
          "type": "calls"
        },
        {
          "target": "stdlib.turtle._reconstruct",
          "type": "calls"
        },
        {
          "target": "stdlib.turtle.reductor",
          "type": "calls"
        },
        {
          "target": "stdlib.turtle.getattr",
          "type": "calls"
        },
        {
          "target": "stdlib.turtle.reductor",
          "type": "calls"
        },
        {
          "target": "stdlib.turtle.Error",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.turtle.degrees",
      "name": "degrees",
      "module": "turtle",
      "type": "function",
      "signature": "(fullcircle=360.0)",
      "description": "Set angle measurement units to degrees.\n\nOptional argument:\nfullcircle -  a number\n\nSet angle measurement units, i. e. set number\nof 'degrees' for a full circle. Default value is\n360 degrees.\n\nExample:\n>>> left(90)\n>>> heading()\n90\n\nChange angle measurement unit to grad (also known as gon,\ngrade, or gradian and equals 1/100-th of the right angle.)\n>>> degrees(400.0)\n>>> heading()\n100",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.delay",
      "name": "delay",
      "module": "turtle",
      "type": "function",
      "signature": "(delay=None)",
      "description": "Return or set the drawing delay in milliseconds.\n\nOptional argument:\ndelay -- positive integer\n\nExample:\n>>> delay(15)\n>>> delay()\n15",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.distance",
      "name": "distance",
      "module": "turtle",
      "type": "function",
      "signature": "(x, y=None)",
      "description": "Return the distance from the turtle to (x,y) in turtle step units.\n\nArguments:\nx -- a number   or  a pair/vector of numbers   or   a turtle instance\ny -- a number       None                            None\n\ncall: distance(x, y)         # two coordinates\n--or: distance((x, y))       # a pair (tuple) of coordinates\n--or: distance(vec)          # e.g. as returned by pos()\n--or: distance(mypen)        # where mypen is another turtle\n\nExample:\n>>> pos()\n(0.00, 0.00)\n>>> distance(30,40)\n50.0\n>>> pen = Turtle()\n>>> pen.forward(77)\n>>> distance(pen)\n77.0",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.done",
      "name": "done",
      "module": "turtle",
      "type": "function",
      "signature": "()",
      "description": "Starts event loop - calling Tkinter's mainloop function.\n\nNo argument.\n\nMust be last statement in a turtle graphics program.\nMust NOT be used if a script is run from within IDLE in -n mode\n(No subprocess) - for interactive use of turtle graphics.\n\nExample:\n>>> mainloop()",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.dot",
      "name": "dot",
      "module": "turtle",
      "type": "function",
      "signature": "(size=None, *color)",
      "description": "Draw a dot with diameter size, using color.\n\nOptional arguments:\nsize -- an integer >= 1 (if given)\ncolor -- a colorstring or a numeric color tuple\n\nDraw a circular dot with diameter size, using color.\nIf size is not given, the maximum of pensize+4 and 2*pensize is used.\n\nExample:\n>>> dot()\n>>> fd(50); dot(20, \"blue\"); fd(50)",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.down",
      "name": "down",
      "module": "turtle",
      "type": "function",
      "signature": "()",
      "description": "Pull the pen down -- drawing when moving.\n\nAliases: pendown | pd | down\n\nNo argument.\n\nExample:\n>>> pendown()",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.end_fill",
      "name": "end_fill",
      "module": "turtle",
      "type": "function",
      "signature": "()",
      "description": "Fill the shape drawn after the call begin_fill().\n\nNo argument.\n\nExample:\n>>> color(\"black\", \"red\")\n>>> begin_fill()\n>>> circle(60)\n>>> end_fill()",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.end_poly",
      "name": "end_poly",
      "module": "turtle",
      "type": "function",
      "signature": "()",
      "description": "Stop recording the vertices of a polygon.\n\nNo argument.\n\nStop recording the vertices of a polygon. Current turtle position is\nlast point of polygon. This will be connected with the first point.\n\nExample:\n>>> end_poly()",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.exitonclick",
      "name": "exitonclick",
      "module": "turtle",
      "type": "function",
      "signature": "()",
      "description": "Go into mainloop until the mouse is clicked.\n\nNo arguments.\n\nBind bye() method to mouseclick on TurtleScreen.\nIf \"using_IDLE\" - value in configuration dictionary is False\n(default value), enter mainloop.\nIf IDLE with -n switch (no subprocess) is used, this value should be\nset to True in turtle.cfg. In this case IDLE's mainloop\nis active also for the client script.\n\nThis is a method of the Screen-class and not available for\nTurtleScreen instances.\n\nExample:\n>>> exitonclick()",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.fd",
      "name": "fd",
      "module": "turtle",
      "type": "function",
      "signature": "(distance)",
      "description": "Move the turtle forward by the specified distance.\n\nAliases: forward | fd\n\nArgument:\ndistance -- a number (integer or float)\n\nMove the turtle forward by the specified distance, in the direction\nthe turtle is headed.\n\nExample:\n>>> position()\n(0.00, 0.00)\n>>> forward(25)\n>>> position()\n(25.00,0.00)\n>>> forward(-75)\n>>> position()\n(-50.00,0.00)",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.fillcolor",
      "name": "fillcolor",
      "module": "turtle",
      "type": "function",
      "signature": "(*args)",
      "description": "Return or set the fillcolor.\n\nArguments:\nFour input formats are allowed:\n  - fillcolor()\n    Return the current fillcolor as color specification string,\n    possibly in hex-number format (see example).\n    May be used as input to another color/pencolor/fillcolor call.\n  - fillcolor(colorstring)\n    s is a Tk color specification string, such as \"red\" or \"yellow\"\n  - fillcolor((r, g, b))\n    *a tuple* of r, g, and b, which represent, an RGB color,\n    and each of r, g, and b are in the range 0..colormode,\n    where colormode is either 1.0 or 255\n  - fillcolor(r, g, b)\n    r, g, and b represent an RGB color, and each of r, g, and b\n    are in the range 0..colormode\n\nIf turtleshape is a polygon, the interior of that polygon is drawn\nwith the newly set fillcolor.\n\nExample:\n>>> fillcolor('violet')\n>>> col = pencolor()\n>>> fillcolor(col)\n>>> fillcolor(0, .5, 0)",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.filling",
      "name": "filling",
      "module": "turtle",
      "type": "function",
      "signature": "()",
      "description": "Return fillstate (True if filling, False else).\n\nNo argument.\n\nExample:\n>>> begin_fill()\n>>> if filling():\n...     pensize(5)\n... else:\n...     pensize(3)",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.forward",
      "name": "forward",
      "module": "turtle",
      "type": "function",
      "signature": "(distance)",
      "description": "Move the turtle forward by the specified distance.\n\nAliases: forward | fd\n\nArgument:\ndistance -- a number (integer or float)\n\nMove the turtle forward by the specified distance, in the direction\nthe turtle is headed.\n\nExample:\n>>> position()\n(0.00, 0.00)\n>>> forward(25)\n>>> position()\n(25.00,0.00)\n>>> forward(-75)\n>>> position()\n(-50.00,0.00)",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.get_poly",
      "name": "get_poly",
      "module": "turtle",
      "type": "function",
      "signature": "()",
      "description": "Return the lastly recorded polygon.\n\nNo argument.\n\nExample:\n>>> p = get_poly()\n>>> register_shape(\"myFavouriteShape\", p)",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.get_shapepoly",
      "name": "get_shapepoly",
      "module": "turtle",
      "type": "function",
      "signature": "()",
      "description": "Return the current shape polygon as tuple of coordinate pairs.\n\nNo argument.\n\nExamples:\n>>> shape(\"square\")\n>>> shapetransform(4, -1, 0, 2)\n>>> get_shapepoly()\n((50, -20), (30, 20), (-50, 20), (-30, -20))",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.getcanvas",
      "name": "getcanvas",
      "module": "turtle",
      "type": "function",
      "signature": "()",
      "description": "Return the Canvas of this TurtleScreen.\n\nNo argument.\n\nExample:\n>>> cv = getcanvas()\n>>> cv\n<turtle.ScrolledCanvas instance at 0x010742D8>",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.getmethparlist",
      "name": "getmethparlist",
      "module": "turtle",
      "type": "function",
      "signature": "(ob)",
      "description": "Get strings describing the arguments for the given object\n\nReturns a pair of strings representing function parameter lists\nincluding parenthesis.  The first string is suitable for use in\nfunction definition and the second is suitable for use in function\ncall.  The \"self\" parameter is not included.",
      "relationships": [
        {
          "target": "stdlib.turtle.getargs",
          "type": "calls"
        },
        {
          "target": "stdlib.turtle.join",
          "type": "calls"
        },
        {
          "target": "stdlib.turtle.join",
          "type": "calls"
        },
        {
          "target": "stdlib.turtle.append",
          "type": "calls"
        },
        {
          "target": "stdlib.turtle.append",
          "type": "calls"
        },
        {
          "target": "stdlib.turtle.append",
          "type": "calls"
        },
        {
          "target": "stdlib.turtle.append",
          "type": "calls"
        },
        {
          "target": "stdlib.turtle.zip",
          "type": "calls"
        },
        {
          "target": "stdlib.turtle.len",
          "type": "calls"
        },
        {
          "target": "stdlib.turtle.len",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.turtle.getpen",
      "name": "getpen",
      "module": "turtle",
      "type": "function",
      "signature": "()",
      "description": "Return the Turtleobject itself.\n\nNo argument.\n\nOnly reasonable use: as a function to return the 'anonymous turtle':\n\nExample:\n>>> pet = getturtle()\n>>> pet.fd(50)\n>>> pet\n<Turtle object at 0x0187D810>\n>>> turtles()\n[<Turtle object at 0x0187D810>]",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.getscreen",
      "name": "getscreen",
      "module": "turtle",
      "type": "function",
      "signature": "()",
      "description": "Return the TurtleScreen object, the turtle is drawing  on.\n\nNo argument.\n\nReturn the TurtleScreen object, the turtle is drawing  on.\nSo TurtleScreen-methods can be called for that object.\n\nExample:\n>>> ts = getscreen()\n>>> ts\n<TurtleScreen object at 0x0106B770>\n>>> ts.bgcolor(\"pink\")",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.getshapes",
      "name": "getshapes",
      "module": "turtle",
      "type": "function",
      "signature": "()",
      "description": "Return a list of names of all currently available turtle shapes.\n\nNo argument.\n\nExample:\n>>> getshapes()\n['arrow', 'blank', 'circle', ... , 'turtle']",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.getturtle",
      "name": "getturtle",
      "module": "turtle",
      "type": "function",
      "signature": "()",
      "description": "Return the Turtleobject itself.\n\nNo argument.\n\nOnly reasonable use: as a function to return the 'anonymous turtle':\n\nExample:\n>>> pet = getturtle()\n>>> pet.fd(50)\n>>> pet\n<Turtle object at 0x0187D810>\n>>> turtles()\n[<Turtle object at 0x0187D810>]",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.goto",
      "name": "goto",
      "module": "turtle",
      "type": "function",
      "signature": "(x, y=None)",
      "description": "Move turtle to an absolute position.\n\nAliases: setpos | setposition | goto:\n\nArguments:\nx -- a number      or     a pair/vector of numbers\ny -- a number             None\n\ncall: goto(x, y)         # two coordinates\n--or: goto((x, y))       # a pair (tuple) of coordinates\n--or: goto(vec)          # e.g. as returned by pos()\n\nMove turtle to an absolute position. If the pen is down,\na line will be drawn. The turtle's orientation does not change.\n\nExample:\n>>> tp = pos()\n>>> tp\n(0.00, 0.00)\n>>> setpos(60,30)\n>>> pos()\n(60.00,30.00)\n>>> setpos((20,80))\n>>> pos()\n(20.00,80.00)\n>>> setpos(tp)\n>>> pos()\n(0.00,0.00)",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.heading",
      "name": "heading",
      "module": "turtle",
      "type": "function",
      "signature": "()",
      "description": "Return the turtle's current heading.\n\nNo arguments.\n\nExample:\n>>> left(67)\n>>> heading()\n67.0",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.hideturtle",
      "name": "hideturtle",
      "module": "turtle",
      "type": "function",
      "signature": "()",
      "description": "Makes the turtle invisible.\n\nAliases: hideturtle | ht\n\nNo argument.\n\nIt's a good idea to do this while you're in the\nmiddle of a complicated drawing, because hiding\nthe turtle speeds up the drawing observably.\n\nExample:\n>>> hideturtle()",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.home",
      "name": "home",
      "module": "turtle",
      "type": "function",
      "signature": "()",
      "description": "Move turtle to the origin - coordinates (0,0).\n\nNo arguments.\n\nMove turtle to the origin - coordinates (0,0) and set its\nheading to its start-orientation (which depends on mode).\n\nExample:\n>>> home()",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.ht",
      "name": "ht",
      "module": "turtle",
      "type": "function",
      "signature": "()",
      "description": "Makes the turtle invisible.\n\nAliases: hideturtle | ht\n\nNo argument.\n\nIt's a good idea to do this while you're in the\nmiddle of a complicated drawing, because hiding\nthe turtle speeds up the drawing observably.\n\nExample:\n>>> hideturtle()",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.isdown",
      "name": "isdown",
      "module": "turtle",
      "type": "function",
      "signature": "()",
      "description": "Return True if pen is down, False if it's up.\n\nNo argument.\n\nExample:\n>>> penup()\n>>> isdown()\nFalse\n>>> pendown()\n>>> isdown()\nTrue",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.isfile",
      "name": "isfile",
      "module": "turtle",
      "type": "function",
      "signature": "(path)",
      "description": "Test whether a path is a regular file",
      "relationships": [
        {
          "target": "stdlib.turtle.S_ISREG",
          "type": "calls"
        },
        {
          "target": "stdlib.turtle.stat",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.turtle.isvisible",
      "name": "isvisible",
      "module": "turtle",
      "type": "function",
      "signature": "()",
      "description": "Return True if the Turtle is shown, False if it's hidden.\n\nNo argument.\n\nExample:\n>>> hideturtle()\n>>> print isvisible():\nFalse",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.join",
      "name": "join",
      "module": "turtle",
      "type": "function",
      "signature": "(a, *p)",
      "description": "Join two or more pathname components, inserting '/' as needed.\nIf any component is an absolute path, all previous path components\nwill be discarded.  An empty last part will result in a path that\nends with a separator.",
      "relationships": [
        {
          "target": "stdlib.turtle.fspath",
          "type": "calls"
        },
        {
          "target": "stdlib.turtle._get_sep",
          "type": "calls"
        },
        {
          "target": "stdlib.turtle.map",
          "type": "calls"
        },
        {
          "target": "stdlib.turtle.startswith",
          "type": "calls"
        },
        {
          "target": "stdlib.turtle._check_arg_types",
          "type": "calls"
        },
        {
          "target": "stdlib.turtle.endswith",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.turtle.left",
      "name": "left",
      "module": "turtle",
      "type": "function",
      "signature": "(angle)",
      "description": "Turn turtle left by angle units.\n\nAliases: left | lt\n\nArgument:\nangle -- a number (integer or float)\n\nTurn turtle left by angle units. (Units are by default degrees,\nbut can be set via the degrees() and radians() functions.)\nAngle orientation depends on mode. (See this.)\n\nExample:\n>>> heading()\n22.0\n>>> left(45)\n>>> heading()\n67.0",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.listen",
      "name": "listen",
      "module": "turtle",
      "type": "function",
      "signature": "(xdummy=None, ydummy=None)",
      "description": "Set focus on TurtleScreen (in order to collect key-events)\n\nNo arguments.\nDummy arguments are provided in order\nto be able to pass listen to the onclick method.\n\nExample:\n>>> listen()",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.lt",
      "name": "lt",
      "module": "turtle",
      "type": "function",
      "signature": "(angle)",
      "description": "Turn turtle left by angle units.\n\nAliases: left | lt\n\nArgument:\nangle -- a number (integer or float)\n\nTurn turtle left by angle units. (Units are by default degrees,\nbut can be set via the degrees() and radians() functions.)\nAngle orientation depends on mode. (See this.)\n\nExample:\n>>> heading()\n22.0\n>>> left(45)\n>>> heading()\n67.0",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.mainloop",
      "name": "mainloop",
      "module": "turtle",
      "type": "function",
      "signature": "()",
      "description": "Starts event loop - calling Tkinter's mainloop function.\n\nNo argument.\n\nMust be last statement in a turtle graphics program.\nMust NOT be used if a script is run from within IDLE in -n mode\n(No subprocess) - for interactive use of turtle graphics.\n\nExample:\n>>> mainloop()",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.mode",
      "name": "mode",
      "module": "turtle",
      "type": "function",
      "signature": "(mode=None)",
      "description": "Set turtle-mode ('standard', 'logo' or 'world') and perform reset.\n\nOptional argument:\nmode -- one of the strings 'standard', 'logo' or 'world'\n\nMode 'standard' is compatible with turtle.py.\nMode 'logo' is compatible with most Logo-Turtle-Graphics.\nMode 'world' uses userdefined 'worldcoordinates'. *Attention*: in\nthis mode angles appear distorted if x/y unit-ratio doesn't equal 1.\nIf mode is not given, return the current mode.\n\n     Mode      Initial turtle heading     positive angles\n ------------|-------------------------|-------------------\n  'standard'    to the right (east)       counterclockwise\n    'logo'        upward    (north)         clockwise\n\nExamples:\n>>> mode('logo')   # resets turtle heading to north\n>>> mode()\n'logo'",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.numinput",
      "name": "numinput",
      "module": "turtle",
      "type": "function",
      "signature": "(title, prompt, default=None, minval=None, maxval=None)",
      "description": "Pop up a dialog window for input of a number.\n\nArguments: title is the title of the dialog window,\nprompt is a text mostly describing what numerical information to input.\ndefault: default value\nminval: minimum value for input\nmaxval: maximum value for input\n\nThe number input must be in the range minval .. maxval if these are\ngiven. If not, a hint is issued and the dialog remains open for\ncorrection. Return the number input.\nIf the dialog is canceled,  return None.\n\nExample:\n>>> numinput(\"Poker\", \"Your stakes:\", 1000, minval=10, maxval=10000)",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.onclick",
      "name": "onclick",
      "module": "turtle",
      "type": "function",
      "signature": "(fun, btn=1, add=None)",
      "description": "Bind fun to mouse-click event on this turtle on canvas.\n\nArguments:\nfun --  a function with two arguments, to which will be assigned\n        the coordinates of the clicked point on the canvas.\nbtn --  number of the mouse-button defaults to 1 (left mouse button).\nadd --  True or False. If True, new binding will be added, otherwise\n        it will replace a former binding.\n\nExample for the anonymous turtle, i. e. the procedural way:\n\n>>> def turn(x, y):\n...     left(360)\n...\n>>> onclick(turn)  # Now clicking into the turtle will turn it.\n>>> onclick(None)  # event-binding will be removed",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.ondrag",
      "name": "ondrag",
      "module": "turtle",
      "type": "function",
      "signature": "(fun, btn=1, add=None)",
      "description": "Bind fun to mouse-move event on this turtle on canvas.\n\nArguments:\nfun -- a function with two arguments, to which will be assigned\n       the coordinates of the clicked point on the canvas.\nbtn -- number of the mouse-button defaults to 1 (left mouse button).\n\nEvery sequence of mouse-move-events on a turtle is preceded by a\nmouse-click event on that \n\nExample:\n>>> ondrag(goto)\n\nSubsequently clicking and dragging a Turtle will move it\nacross the screen thereby producing handdrawings (if pen is\ndown).",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.onkey",
      "name": "onkey",
      "module": "turtle",
      "type": "function",
      "signature": "(fun, key)",
      "description": "Bind fun to key-release event of key.\n\nArguments:\nfun -- a function with no arguments\nkey -- a string: key (e.g. \"a\") or key-symbol (e.g. \"space\")\n\nIn order to be able to register key-events, TurtleScreen\nmust have focus. (See method listen.)\n\nExample:\n\n>>> def f():\n...     fd(50)\n...     lt(60)\n...\n>>> onkey(f, \"Up\")\n>>> listen()\n\nSubsequently the turtle can be moved by repeatedly pressing\nthe up-arrow key, consequently drawing a hexagon",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.onkeypress",
      "name": "onkeypress",
      "module": "turtle",
      "type": "function",
      "signature": "(fun, key=None)",
      "description": "Bind fun to key-press event of key if key is given,\nor to any key-press-event if no key is given.\n\nArguments:\nfun -- a function with no arguments\nkey -- a string: key (e.g. \"a\") or key-symbol (e.g. \"space\")\n\nIn order to be able to register key-events, TurtleScreen\nmust have focus. (See method listen.)\n\nExample (for a TurtleScreen instance named screen\nand a Turtle instance named turtle):\n\n>>> def f():\n...     fd(50)\n...     lt(60)\n...\n>>> onkeypress(f, \"Up\")\n>>> listen()\n\nSubsequently the turtle can be moved by repeatedly pressing\nthe up-arrow key, or by keeping pressed the up-arrow key.\nconsequently drawing a hexagon.",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.onkeyrelease",
      "name": "onkeyrelease",
      "module": "turtle",
      "type": "function",
      "signature": "(fun, key)",
      "description": "Bind fun to key-release event of key.\n\nArguments:\nfun -- a function with no arguments\nkey -- a string: key (e.g. \"a\") or key-symbol (e.g. \"space\")\n\nIn order to be able to register key-events, TurtleScreen\nmust have focus. (See method listen.)\n\nExample:\n\n>>> def f():\n...     fd(50)\n...     lt(60)\n...\n>>> onkey(f, \"Up\")\n>>> listen()\n\nSubsequently the turtle can be moved by repeatedly pressing\nthe up-arrow key, consequently drawing a hexagon",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.onrelease",
      "name": "onrelease",
      "module": "turtle",
      "type": "function",
      "signature": "(fun, btn=1, add=None)",
      "description": "Bind fun to mouse-button-release event on this turtle on canvas.\n\nArguments:\nfun -- a function with two arguments, to which will be assigned\n        the coordinates of the clicked point on the canvas.\nbtn --  number of the mouse-button defaults to 1 (left mouse button).\n\nExample (for a MyTurtle instance named joe):\n>>> class MyTurtle(Turtle):\n...     def glow(self,x,y):\n...             self.fillcolor(\"red\")\n...     def unglow(self,x,y):\n...             self.fillcolor(\"\")\n...\n>>> joe = MyTurtle()\n>>> joe.onclick(joe.glow)\n>>> joe.onrelease(joe.unglow)\n\nClicking on joe turns fillcolor red, unclicking turns it to\ntransparent.",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.onscreenclick",
      "name": "onscreenclick",
      "module": "turtle",
      "type": "function",
      "signature": "(fun, btn=1, add=None)",
      "description": "Bind fun to mouse-click event on canvas.\n\nArguments:\nfun -- a function with two arguments, the coordinates of the\n       clicked point on the canvas.\nbtn -- the number of the mouse-button, defaults to 1\n\nExample (for a TurtleScreen instance named screen)\n\n>>> onclick(goto)\n>>> # Subsequently clicking into the TurtleScreen will\n>>> # make the turtle move to the clicked point.\n>>> onclick(None)",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.ontimer",
      "name": "ontimer",
      "module": "turtle",
      "type": "function",
      "signature": "(fun, t=0)",
      "description": "Install a timer, which calls fun after t milliseconds.\n\nArguments:\nfun -- a function with no arguments.\nt -- a number >= 0\n\nExample:\n\n>>> running = True\n>>> def f():\n...     if running:\n...             fd(50)\n...             lt(60)\n...             ontimer(f, 250)\n...\n>>> f()   # makes the turtle marching around\n>>> running = False",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.pd",
      "name": "pd",
      "module": "turtle",
      "type": "function",
      "signature": "()",
      "description": "Pull the pen down -- drawing when moving.\n\nAliases: pendown | pd | down\n\nNo argument.\n\nExample:\n>>> pendown()",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.pen",
      "name": "pen",
      "module": "turtle",
      "type": "function",
      "signature": "(pen=None, **pendict)",
      "description": "Return or set the pen's attributes.\n\nArguments:\n    pen -- a dictionary with some or all of the below listed keys.\n    **pendict -- one or more keyword-arguments with the below\n                 listed keys as keywords.\n\nReturn or set the pen's attributes in a 'pen-dictionary'\nwith the following key/value pairs:\n   \"shown\"      :   True/False\n   \"pendown\"    :   True/False\n   \"pencolor\"   :   color-string or color-tuple\n   \"fillcolor\"  :   color-string or color-tuple\n   \"pensize\"    :   positive number\n   \"speed\"      :   number in range 0..10\n   \"resizemode\" :   \"auto\" or \"user\" or \"noresize\"\n   \"stretchfactor\": (positive number, positive number)\n   \"shearfactor\":   number\n   \"outline\"    :   positive number\n   \"tilt\"       :   number\n\nThis dictionary can be used as argument for a subsequent\npen()-call to restore the former pen-state. Moreover one\nor more of these attributes can be provided as keyword-arguments.\nThis can be used to set several pen attributes in one statement.\n\n\nExamples:\n>>> pen(fillcolor=\"black\", pencolor=\"red\", pensize=10)\n>>> pen()\n{'pensize': 10, 'shown': True, 'resizemode': 'auto', 'outline': 1,\n'pencolor': 'red', 'pendown': True, 'fillcolor': 'black',\n'stretchfactor': (1,1), 'speed': 3, 'shearfactor': 0.0}\n>>> penstate=pen()\n>>> color(\"yellow\",\"\")\n>>> penup()\n>>> pen()\n{'pensize': 10, 'shown': True, 'resizemode': 'auto', 'outline': 1,\n'pencolor': 'yellow', 'pendown': False, 'fillcolor': '',\n'stretchfactor': (1,1), 'speed': 3, 'shearfactor': 0.0}\n>>> p.pen(penstate, fillcolor=\"green\")\n>>> p.pen()\n{'pensize': 10, 'shown': True, 'resizemode': 'auto', 'outline': 1,\n'pencolor': 'red', 'pendown': True, 'fillcolor': 'green',\n'stretchfactor': (1,1), 'speed': 3, 'shearfactor': 0.0}",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.pencolor",
      "name": "pencolor",
      "module": "turtle",
      "type": "function",
      "signature": "(*args)",
      "description": "Return or set the pencolor.\n\nArguments:\nFour input formats are allowed:\n  - pencolor()\n    Return the current pencolor as color specification string,\n    possibly in hex-number format (see example).\n    May be used as input to another color/pencolor/fillcolor call.\n  - pencolor(colorstring)\n    s is a Tk color specification string, such as \"red\" or \"yellow\"\n  - pencolor((r, g, b))\n    *a tuple* of r, g, and b, which represent, an RGB color,\n    and each of r, g, and b are in the range 0..colormode,\n    where colormode is either 1.0 or 255\n  - pencolor(r, g, b)\n    r, g, and b represent an RGB color, and each of r, g, and b\n    are in the range 0..colormode\n\nIf turtleshape is a polygon, the outline of that polygon is drawn\nwith the newly set pencolor.\n\nExample:\n>>> pencolor('brown')\n>>> tup = (0.2, 0.8, 0.55)\n>>> pencolor(tup)\n>>> pencolor()\n'#33cc8c'",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.pendown",
      "name": "pendown",
      "module": "turtle",
      "type": "function",
      "signature": "()",
      "description": "Pull the pen down -- drawing when moving.\n\nAliases: pendown | pd | down\n\nNo argument.\n\nExample:\n>>> pendown()",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.pensize",
      "name": "pensize",
      "module": "turtle",
      "type": "function",
      "signature": "(width=None)",
      "description": "Set or return the line thickness.\n\nAliases:  pensize | width\n\nArgument:\nwidth -- positive number\n\nSet the line thickness to width or return it. If resizemode is set\nto \"auto\" and turtleshape is a polygon, that polygon is drawn with\nthe same line thickness. If no argument is given, current pensize\nis returned.\n\nExample:\n>>> pensize()\n1\n>>> pensize(10)   # from here on lines of width 10 are drawn",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.penup",
      "name": "penup",
      "module": "turtle",
      "type": "function",
      "signature": "()",
      "description": "Pull the pen up -- no drawing when moving.\n\nAliases: penup | pu | up\n\nNo argument\n\nExample:\n>>> penup()",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.pos",
      "name": "pos",
      "module": "turtle",
      "type": "function",
      "signature": "()",
      "description": "Return the turtle's current location (x,y), as a Vec2D-vector.\n\nAliases: pos | position\n\nNo arguments.\n\nExample:\n>>> pos()\n(0.00, 240.00)",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.position",
      "name": "position",
      "module": "turtle",
      "type": "function",
      "signature": "()",
      "description": "Return the turtle's current location (x,y), as a Vec2D-vector.\n\nAliases: pos | position\n\nNo arguments.\n\nExample:\n>>> pos()\n(0.00, 240.00)",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.pu",
      "name": "pu",
      "module": "turtle",
      "type": "function",
      "signature": "()",
      "description": "Pull the pen up -- no drawing when moving.\n\nAliases: penup | pu | up\n\nNo argument\n\nExample:\n>>> penup()",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.radians",
      "name": "radians",
      "module": "turtle",
      "type": "function",
      "signature": "()",
      "description": "Set the angle measurement units to radians.\n\nNo arguments.\n\nExample:\n>>> heading()\n90\n>>> radians()\n>>> heading()\n1.5707963267948966",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.read_docstrings",
      "name": "read_docstrings",
      "module": "turtle",
      "type": "function",
      "signature": "(lang)",
      "description": "Read in docstrings from lang-specific docstring dictionary.\n\nTransfer docstrings, translated to lang, from a dictionary-file\nto the methods of classes Screen and Turtle and - in revised form -\nto the corresponding functions.",
      "relationships": [
        {
          "target": "stdlib.turtle.__import__",
          "type": "calls"
        },
        {
          "target": "stdlib.turtle.lower",
          "type": "calls"
        },
        {
          "target": "stdlib.turtle.eval",
          "type": "calls"
        },
        {
          "target": "stdlib.turtle.print",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.turtle.readconfig",
      "name": "readconfig",
      "module": "turtle",
      "type": "function",
      "signature": "(cfgdict)",
      "description": "Read config-files, change configuration-dict accordingly.\n\nIf there is a turtle.cfg file in the current working directory,\nread it from there. If this contains an importconfig-value,\nsay 'myway', construct filename turtle_mayway.cfg else use\nturtle.cfg and read it from the import-directory, where\nturtle.py is located.\nUpdate configuration dictionary first according to config-file,\nin the import directory, then according to config-file in the\ncurrent working directory.\nIf no config-file is found, the default configuration is used.",
      "relationships": [
        {
          "target": "stdlib.turtle.isfile",
          "type": "calls"
        },
        {
          "target": "stdlib.turtle.isfile",
          "type": "calls"
        },
        {
          "target": "stdlib.turtle.update",
          "type": "calls"
        },
        {
          "target": "stdlib.turtle.update",
          "type": "calls"
        },
        {
          "target": "stdlib.turtle.config_dict",
          "type": "calls"
        },
        {
          "target": "stdlib.turtle.split",
          "type": "calls"
        },
        {
          "target": "stdlib.turtle.join",
          "type": "calls"
        },
        {
          "target": "stdlib.turtle.config_dict",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.turtle.register_shape",
      "name": "register_shape",
      "module": "turtle",
      "type": "function",
      "signature": "(name, shape=None)",
      "description": "Adds a turtle shape to TurtleScreen's shapelist.\n\nArguments:\n(1) name is the name of a gif-file and shape is None.\n    Installs the corresponding image shape.\n    !! Image-shapes DO NOT rotate when turning the turtle,\n    !! so they do not display the heading of the turtle!\n(2) name is an arbitrary string and shape is a tuple\n    of pairs of coordinates. Installs the corresponding\n    polygon shape\n(3) name is an arbitrary string and shape is a\n    (compound) Shape object. Installs the corresponding\n    compound shape.\nTo use a shape, you have to issue the command shape(shapename).\n\ncall: register_shape(\"turtle.gif\")\n--or: register_shape(\"tri\", ((0,0), (10,10), (-10,10)))\n\nExample:\n>>> register_shape(\"triangle\", ((5,-3),(0,5),(-5,-3)))",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.reset",
      "name": "reset",
      "module": "turtle",
      "type": "function",
      "signature": "()",
      "description": "Delete the turtle's drawings and restore its default values.\n\nNo argument.\n\nDelete the turtle's drawings from the screen, re-center the turtle\nand set variables to the default values.\n\nExample:\n>>> position()\n(0.00,-22.00)\n>>> heading()\n100.0\n>>> reset()\n>>> position()\n(0.00,0.00)\n>>> heading()\n0.0",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.resetscreen",
      "name": "resetscreen",
      "module": "turtle",
      "type": "function",
      "signature": "()",
      "description": "Reset all Turtles on the Screen to their initial state.\n\nNo argument.\n\nExample:\n>>> reset()",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.resizemode",
      "name": "resizemode",
      "module": "turtle",
      "type": "function",
      "signature": "(rmode=None)",
      "description": "Set resizemode to one of the values: \"auto\", \"user\", \"noresize\".\n\n(Optional) Argument:\nrmode -- one of the strings \"auto\", \"user\", \"noresize\"\n\nDifferent resizemodes have the following effects:\n  - \"auto\" adapts the appearance of the turtle\n           corresponding to the value of pensize.\n  - \"user\" adapts the appearance of the turtle according to the\n           values of stretchfactor and outlinewidth (outline),\n           which are set by shapesize()\n  - \"noresize\" no adaption of the turtle's appearance takes place.\nIf no argument is given, return current resizemode.\nresizemode(\"user\") is called by a call of shapesize with arguments.\n\n\nExamples:\n>>> resizemode(\"noresize\")\n>>> resizemode()\n'noresize'",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.right",
      "name": "right",
      "module": "turtle",
      "type": "function",
      "signature": "(angle)",
      "description": "Turn turtle right by angle units.\n\nAliases: right | rt\n\nArgument:\nangle -- a number (integer or float)\n\nTurn turtle right by angle units. (Units are by default degrees,\nbut can be set via the degrees() and radians() functions.)\nAngle orientation depends on mode. (See this.)\n\nExample:\n>>> heading()\n22.0\n>>> right(45)\n>>> heading()\n337.0",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.rt",
      "name": "rt",
      "module": "turtle",
      "type": "function",
      "signature": "(angle)",
      "description": "Turn turtle right by angle units.\n\nAliases: right | rt\n\nArgument:\nangle -- a number (integer or float)\n\nTurn turtle right by angle units. (Units are by default degrees,\nbut can be set via the degrees() and radians() functions.)\nAngle orientation depends on mode. (See this.)\n\nExample:\n>>> heading()\n22.0\n>>> right(45)\n>>> heading()\n337.0",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.screensize",
      "name": "screensize",
      "module": "turtle",
      "type": "function",
      "signature": "(canvwidth=None, canvheight=None, bg=None)",
      "description": "Resize the canvas the turtles are drawing on.\n\nOptional arguments:\ncanvwidth -- positive integer, new width of canvas in pixels\ncanvheight --  positive integer, new height of canvas in pixels\nbg -- colorstring or color-tuple, new backgroundcolor\nIf no arguments are given, return current (canvaswidth, canvasheight)\n\nDo not alter the drawing window. To observe hidden parts of\nthe canvas use the scrollbars. (Can make visible those parts\nof a drawing, which were outside the canvas before!)\n\nExample (for a Turtle instance named turtle):\n>>> turtle.screensize(2000,1500)\n>>> # e.g. to search for an erroneously escaped turtle ;-)",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.seth",
      "name": "seth",
      "module": "turtle",
      "type": "function",
      "signature": "(to_angle)",
      "description": "Set the orientation of the turtle to to_angle.\n\nAliases:  setheading | seth\n\nArgument:\nto_angle -- a number (integer or float)\n\nSet the orientation of the turtle to to_angle.\nHere are some common directions in degrees:\n\n standard - mode:          logo-mode:\n-------------------|--------------------\n   0 - east                0 - north\n  90 - north              90 - east\n 180 - west              180 - south\n 270 - south             270 - west\n\nExample:\n>>> setheading(90)\n>>> heading()\n90",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.setheading",
      "name": "setheading",
      "module": "turtle",
      "type": "function",
      "signature": "(to_angle)",
      "description": "Set the orientation of the turtle to to_angle.\n\nAliases:  setheading | seth\n\nArgument:\nto_angle -- a number (integer or float)\n\nSet the orientation of the turtle to to_angle.\nHere are some common directions in degrees:\n\n standard - mode:          logo-mode:\n-------------------|--------------------\n   0 - east                0 - north\n  90 - north              90 - east\n 180 - west              180 - south\n 270 - south             270 - west\n\nExample:\n>>> setheading(90)\n>>> heading()\n90",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.setpos",
      "name": "setpos",
      "module": "turtle",
      "type": "function",
      "signature": "(x, y=None)",
      "description": "Move turtle to an absolute position.\n\nAliases: setpos | setposition | goto:\n\nArguments:\nx -- a number      or     a pair/vector of numbers\ny -- a number             None\n\ncall: goto(x, y)         # two coordinates\n--or: goto((x, y))       # a pair (tuple) of coordinates\n--or: goto(vec)          # e.g. as returned by pos()\n\nMove turtle to an absolute position. If the pen is down,\na line will be drawn. The turtle's orientation does not change.\n\nExample:\n>>> tp = pos()\n>>> tp\n(0.00, 0.00)\n>>> setpos(60,30)\n>>> pos()\n(60.00,30.00)\n>>> setpos((20,80))\n>>> pos()\n(20.00,80.00)\n>>> setpos(tp)\n>>> pos()\n(0.00,0.00)",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.setposition",
      "name": "setposition",
      "module": "turtle",
      "type": "function",
      "signature": "(x, y=None)",
      "description": "Move turtle to an absolute position.\n\nAliases: setpos | setposition | goto:\n\nArguments:\nx -- a number      or     a pair/vector of numbers\ny -- a number             None\n\ncall: goto(x, y)         # two coordinates\n--or: goto((x, y))       # a pair (tuple) of coordinates\n--or: goto(vec)          # e.g. as returned by pos()\n\nMove turtle to an absolute position. If the pen is down,\na line will be drawn. The turtle's orientation does not change.\n\nExample:\n>>> tp = pos()\n>>> tp\n(0.00, 0.00)\n>>> setpos(60,30)\n>>> pos()\n(60.00,30.00)\n>>> setpos((20,80))\n>>> pos()\n(20.00,80.00)\n>>> setpos(tp)\n>>> pos()\n(0.00,0.00)",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.settiltangle",
      "name": "settiltangle",
      "module": "turtle",
      "type": "function",
      "signature": "(angle)",
      "description": "Rotate the turtleshape to point in the specified direction\n\nArgument: angle -- number\n\nRotate the turtleshape to point in the direction specified by angle,\nregardless of its current tilt-angle. DO NOT change the turtle's\nheading (direction of movement).\n\n\nExamples:\n>>> shape(\"circle\")\n>>> shapesize(5,2)\n>>> settiltangle(45)\n>>> stamp()\n>>> fd(50)\n>>> settiltangle(-45)\n>>> stamp()\n>>> fd(50)",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.setundobuffer",
      "name": "setundobuffer",
      "module": "turtle",
      "type": "function",
      "signature": "(size)",
      "description": "Set or disable undobuffer.\n\nArgument:\nsize -- an integer or None\n\nIf size is an integer an empty undobuffer of given size is installed.\nSize gives the maximum number of turtle-actions that can be undone\nby the undo() function.\nIf size is None, no undobuffer is present.\n\nExample:\n>>> setundobuffer(42)",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.setup",
      "name": "setup",
      "module": "turtle",
      "type": "function",
      "signature": "(width=0.5, height=0.75, startx=None, starty=None)",
      "description": "Set the size and position of the main window.\n\nArguments:\nwidth: as integer a size in pixels, as float a fraction of the \n  Default is 50% of \nheight: as integer the height in pixels, as float a fraction of the\n   Default is 75% of \nstartx: if positive, starting position in pixels from the left\n  edge of the screen, if negative from the right edge\n  Default, startx=None is to center window horizontally.\nstarty: if positive, starting position in pixels from the top\n  edge of the screen, if negative from the bottom edge\n  Default, starty=None is to center window vertically.\n\nExamples:\n>>> setup (width=200, height=200, startx=0, starty=0)\n\nsets window to 200x200 pixels, in upper left of screen\n\n>>> setup(width=.75, height=0.5, startx=None, starty=None)\n\nsets window to 75% of screen by 50% of screen and centers",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.setworldcoordinates",
      "name": "setworldcoordinates",
      "module": "turtle",
      "type": "function",
      "signature": "(llx, lly, urx, ury)",
      "description": "Set up a user defined coordinate-system.\n\nArguments:\nllx -- a number, x-coordinate of lower left corner of canvas\nlly -- a number, y-coordinate of lower left corner of canvas\nurx -- a number, x-coordinate of upper right corner of canvas\nury -- a number, y-coordinate of upper right corner of canvas\n\nSet up user coodinat-system and switch to mode 'world' if necessary.\nThis performs a reset. If mode 'world' is already active,\nall drawings are redrawn according to the new coordinates.\n\nBut ATTENTION: in user-defined coordinatesystems angles may appear\ndistorted. (see Screen.mode())\n\nExample:\n>>> setworldcoordinates(-10,-0.5,50,1.5)\n>>> for _ in range(36):\n...     left(10)\n...     forward(0.5)",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.setx",
      "name": "setx",
      "module": "turtle",
      "type": "function",
      "signature": "(x)",
      "description": "Set the turtle's first coordinate to x\n\nArgument:\nx -- a number (integer or float)\n\nSet the turtle's first coordinate to x, leave second coordinate\nunchanged.\n\nExample:\n>>> position()\n(0.00, 240.00)\n>>> setx(10)\n>>> position()\n(10.00, 240.00)",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.sety",
      "name": "sety",
      "module": "turtle",
      "type": "function",
      "signature": "(y)",
      "description": "Set the turtle's second coordinate to y\n\nArgument:\ny -- a number (integer or float)\n\nSet the turtle's first coordinate to x, second coordinate remains\nunchanged.\n\nExample:\n>>> position()\n(0.00, 40.00)\n>>> sety(-10)\n>>> position()\n(0.00, -10.00)",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.shape",
      "name": "shape",
      "module": "turtle",
      "type": "function",
      "signature": "(name=None)",
      "description": "Set turtle shape to shape with given name / return current shapename.\n\nOptional argument:\nname -- a string, which is a valid shapename\n\nSet turtle shape to shape with given name or, if name is not given,\nreturn name of current shape.\nShape with name must exist in the TurtleScreen's shape dictionary.\nInitially there are the following polygon shapes:\n'arrow', 'turtle', 'circle', 'square', 'triangle', 'classic'.\nTo learn about how to deal with shapes see Screen-method register_shape.\n\nExample:\n>>> shape()\n'arrow'\n>>> shape(\"turtle\")\n>>> shape()\n'turtle'",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.shapesize",
      "name": "shapesize",
      "module": "turtle",
      "type": "function",
      "signature": "(stretch_wid=None, stretch_len=None, outline=None)",
      "description": "Set/return turtle's stretchfactors/outline. Set resizemode to \"user\".\n\nOptional arguments:\n   stretch_wid : positive number\n   stretch_len : positive number\n   outline  : positive number\n\nReturn or set the pen's attributes x/y-stretchfactors and/or outline.\nSet resizemode to \"user\".\nIf and only if resizemode is set to \"user\", the turtle will be displayed\nstretched according to its stretchfactors:\nstretch_wid is stretchfactor perpendicular to orientation\nstretch_len is stretchfactor in direction of turtles orientation.\noutline determines the width of the shapes's outline.\n\nExamples:\n>>> resizemode(\"user\")\n>>> shapesize(5, 5, 12)\n>>> shapesize(outline=8)",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.shapetransform",
      "name": "shapetransform",
      "module": "turtle",
      "type": "function",
      "signature": "(t11=None, t12=None, t21=None, t22=None)",
      "description": "Set or return the current transformation matrix of the turtle shape.\n\nOptional arguments: t11, t12, t21, t22 -- numbers.\n\nIf none of the matrix elements are given, return the transformation\nmatrix.\nOtherwise set the given elements and transform the turtleshape\naccording to the matrix consisting of first row t11, t12 and\nsecond row t21, 22.\nModify stretchfactor, shearfactor and tiltangle according to the\ngiven matrix.\n\nExamples:\n>>> shape(\"square\")\n>>> shapesize(4,2)\n>>> shearfactor(-0.5)\n>>> shapetransform()\n(4.0, -1.0, -0.0, 2.0)",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.shearfactor",
      "name": "shearfactor",
      "module": "turtle",
      "type": "function",
      "signature": "(shear=None)",
      "description": "Set or return the current shearfactor.\n\nOptional argument: shear -- number, tangent of the shear angle\n\nShear the turtleshape according to the given shearfactor shear,\nwhich is the tangent of the shear angle. DO NOT change the\nturtle's heading (direction of movement).\nIf shear is not given: return the current shearfactor, i. e. the\ntangent of the shear angle, by which lines parallel to the\nheading of the turtle are sheared.\n\nExamples:\n>>> shape(\"circle\")\n>>> shapesize(5,2)\n>>> shearfactor(0.5)\n>>> shearfactor()\n>>> 0.5",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.showturtle",
      "name": "showturtle",
      "module": "turtle",
      "type": "function",
      "signature": "()",
      "description": "Makes the turtle visible.\n\nAliases: showturtle | st\n\nNo argument.\n\nExample:\n>>> hideturtle()\n>>> showturtle()",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.speed",
      "name": "speed",
      "module": "turtle",
      "type": "function",
      "signature": "(speed=None)",
      "description": "Return or set the turtle's speed.\n\nOptional argument:\nspeed -- an integer in the range 0..10 or a speedstring (see below)\n\nSet the turtle's speed to an integer value in the range 0 .. 10.\nIf no argument is given: return current speed.\n\nIf input is a number greater than 10 or smaller than 0.5,\nspeed is set to 0.\nSpeedstrings  are mapped to speedvalues in the following way:\n    'fastest' :  0\n    'fast'    :  10\n    'normal'  :  6\n    'slow'    :  3\n    'slowest' :  1\nspeeds from 1 to 10 enforce increasingly faster animation of\nline drawing and turtle turning.\n\nAttention:\nspeed = 0 : *no* animation takes place. forward/back makes turtle jump\nand likewise left/right make the turtle turn instantly.\n\nExample:\n>>> speed(3)",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.split",
      "name": "split",
      "module": "turtle",
      "type": "function",
      "signature": "(p)",
      "description": "Split a pathname.  Returns tuple \"(head, tail)\" where \"tail\" is\neverything after the final slash.  Either part may be empty.",
      "relationships": [
        {
          "target": "stdlib.turtle.fspath",
          "type": "calls"
        },
        {
          "target": "stdlib.turtle._get_sep",
          "type": "calls"
        },
        {
          "target": "stdlib.turtle.rfind",
          "type": "calls"
        },
        {
          "target": "stdlib.turtle.rstrip",
          "type": "calls"
        },
        {
          "target": "stdlib.turtle.len",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.turtle.st",
      "name": "st",
      "module": "turtle",
      "type": "function",
      "signature": "()",
      "description": "Makes the turtle visible.\n\nAliases: showturtle | st\n\nNo argument.\n\nExample:\n>>> hideturtle()\n>>> showturtle()",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.stamp",
      "name": "stamp",
      "module": "turtle",
      "type": "function",
      "signature": "()",
      "description": "Stamp a copy of the turtleshape onto the canvas and return its id.\n\nNo argument.\n\nStamp a copy of the turtle shape onto the canvas at the current\nturtle position. Return a stamp_id for that stamp, which can be\nused to delete it by calling clearstamp(stamp_id).\n\nExample:\n>>> color(\"blue\")\n>>> stamp()\n13\n>>> fd(50)",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.textinput",
      "name": "textinput",
      "module": "turtle",
      "type": "function",
      "signature": "(title, prompt)",
      "description": "Pop up a dialog window for input of a string.\n\nArguments: title is the title of the dialog window,\nprompt is a text mostly describing what information to input.\n\nReturn the string input\nIf the dialog is canceled, return None.\n\nExample:\n>>> textinput(\"NIM\", \"Name of first player:\")",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.tilt",
      "name": "tilt",
      "module": "turtle",
      "type": "function",
      "signature": "(angle)",
      "description": "Rotate the turtleshape by angle.\n\nArgument:\nangle - a number\n\nRotate the turtleshape by angle from its current tilt-angle,\nbut do NOT change the turtle's heading (direction of movement).\n\nExamples:\n>>> shape(\"circle\")\n>>> shapesize(5,2)\n>>> tilt(30)\n>>> fd(50)\n>>> tilt(30)\n>>> fd(50)",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.tiltangle",
      "name": "tiltangle",
      "module": "turtle",
      "type": "function",
      "signature": "(angle=None)",
      "description": "Set or return the current tilt-angle.\n\nOptional argument: angle -- number\n\nRotate the turtleshape to point in the direction specified by angle,\nregardless of its current tilt-angle. DO NOT change the turtle's\nheading (direction of movement).\nIf angle is not given: return the current tilt-angle, i. e. the angle\nbetween the orientation of the turtleshape and the heading of the\nturtle (its direction of movement).\n\nDeprecated since Python 3.1\n\nExamples:\n>>> shape(\"circle\")\n>>> shapesize(5,2)\n>>> tilt(45)\n>>> tiltangle()",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.title",
      "name": "title",
      "module": "turtle",
      "type": "function",
      "signature": "(titlestring)",
      "description": "Set title of turtle-window\n\nArgument:\ntitlestring -- a string, to appear in the titlebar of the\n               turtle graphics window.\n\nThis is a method of Screen-class. Not available for TurtleScreen-\nobjects.\n\nExample:\n>>> title(\"Welcome to the turtle-zoo!\")",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.towards",
      "name": "towards",
      "module": "turtle",
      "type": "function",
      "signature": "(x, y=None)",
      "description": "Return the angle of the line from the turtle's position to (x, y).\n\nArguments:\nx -- a number   or  a pair/vector of numbers   or   a turtle instance\ny -- a number       None                            None\n\ncall: distance(x, y)         # two coordinates\n--or: distance((x, y))       # a pair (tuple) of coordinates\n--or: distance(vec)          # e.g. as returned by pos()\n--or: distance(mypen)        # where mypen is another turtle\n\nReturn the angle, between the line from turtle-position to position\nspecified by x, y and the turtle's start orientation. (Depends on\nmodes - \"standard\" or \"logo\")\n\nExample:\n>>> pos()\n(10.00, 10.00)\n>>> towards(0,0)\n225.0",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.tracer",
      "name": "tracer",
      "module": "turtle",
      "type": "function",
      "signature": "(n=None, delay=None)",
      "description": "Turns turtle animation on/off and set delay for update drawings.\n\nOptional arguments:\nn -- nonnegative  integer\ndelay -- nonnegative  integer\n\nIf n is given, only each n-th regular screen update is really performed.\n(Can be used to accelerate the drawing of complex graphics.)\nSecond arguments sets delay value (see RawTurtle.delay())\n\nExample:\n>>> tracer(8, 25)\n>>> dist = 2\n>>> for i in range(200):\n...     fd(dist)\n...     rt(90)\n...     dist += 2",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.turtles",
      "name": "turtles",
      "module": "turtle",
      "type": "function",
      "signature": "()",
      "description": "Return the list of turtles on the \n\nExample:\n>>> turtles()\n[<turtle.Turtle object at 0x00E11FB0>]",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.turtlesize",
      "name": "turtlesize",
      "module": "turtle",
      "type": "function",
      "signature": "(stretch_wid=None, stretch_len=None, outline=None)",
      "description": "Set/return turtle's stretchfactors/outline. Set resizemode to \"user\".\n\nOptional arguments:\n   stretch_wid : positive number\n   stretch_len : positive number\n   outline  : positive number\n\nReturn or set the pen's attributes x/y-stretchfactors and/or outline.\nSet resizemode to \"user\".\nIf and only if resizemode is set to \"user\", the turtle will be displayed\nstretched according to its stretchfactors:\nstretch_wid is stretchfactor perpendicular to orientation\nstretch_len is stretchfactor in direction of turtles orientation.\noutline determines the width of the shapes's outline.\n\nExamples:\n>>> resizemode(\"user\")\n>>> shapesize(5, 5, 12)\n>>> shapesize(outline=8)",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.undo",
      "name": "undo",
      "module": "turtle",
      "type": "function",
      "signature": "()",
      "description": "undo (repeatedly) the last turtle action.\n\nNo argument.\n\nundo (repeatedly) the last turtle action.\nNumber of available undo actions is determined by the size of\nthe undobuffer.\n\nExample:\n>>> for i in range(4):\n...     fd(50); lt(80)\n...\n>>> for i in range(8):\n...     undo()\n...",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.undobufferentries",
      "name": "undobufferentries",
      "module": "turtle",
      "type": "function",
      "signature": "()",
      "description": "Return count of entries in the undobuffer.\n\nNo argument.\n\nExample:\n>>> while undobufferentries():\n...     undo()",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.up",
      "name": "up",
      "module": "turtle",
      "type": "function",
      "signature": "()",
      "description": "Pull the pen up -- no drawing when moving.\n\nAliases: penup | pu | up\n\nNo argument\n\nExample:\n>>> penup()",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.update",
      "name": "update",
      "module": "turtle",
      "type": "function",
      "signature": "()",
      "description": "Perform a TurtleScreen update.\n        ",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.width",
      "name": "width",
      "module": "turtle",
      "type": "function",
      "signature": "(width=None)",
      "description": "Set or return the line thickness.\n\nAliases:  pensize | width\n\nArgument:\nwidth -- positive number\n\nSet the line thickness to width or return it. If resizemode is set\nto \"auto\" and turtleshape is a polygon, that polygon is drawn with\nthe same line thickness. If no argument is given, current pensize\nis returned.\n\nExample:\n>>> pensize()\n1\n>>> pensize(10)   # from here on lines of width 10 are drawn",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.window_height",
      "name": "window_height",
      "module": "turtle",
      "type": "function",
      "signature": "()",
      "description": "Return the height of the turtle window.\n\nExample:\n>>> window_height()\n480",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.window_width",
      "name": "window_width",
      "module": "turtle",
      "type": "function",
      "signature": "()",
      "description": "Return the width of the turtle window.\n\nExample:\n>>> window_width()\n640",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.write",
      "name": "write",
      "module": "turtle",
      "type": "function",
      "signature": "(arg, move=False, align='left', font=('Arial', 8, 'normal'))",
      "description": "Write text at the current turtle position.\n\nArguments:\narg -- info, which is to be written to the TurtleScreen\nmove (optional) -- True/False\nalign (optional) -- one of the strings \"left\", \"center\" or right\"\nfont (optional) -- a triple (fontname, fontsize, fonttype)\n\nWrite text - the string representation of arg - at the current\nturtle position according to align (\"left\", \"center\" or right\")\nand with the given font.\nIf move is True, the pen is moved to the bottom-right corner\nof the text. By default, move is False.\n\nExample:\n>>> write('Home = ', True, align=\"center\")\n>>> write((0,0), True)",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.write_docstringdict",
      "name": "write_docstringdict",
      "module": "turtle",
      "type": "function",
      "signature": "(filename='turtle_docstringdict')",
      "description": "Create and write docstring-dictionary to file.\n\nOptional argument:\nfilename -- a string, used as filename\n            default value is turtle_docstringdict\n\nHas to be called explicitly, (not used by the turtle-graphics classes)\nThe docstring dictionary will be written to the Python script <filname>.py\nIt is intended to serve as a template for translation of the docstrings\ninto different languages.",
      "relationships": [
        {
          "target": "stdlib.turtle.open",
          "type": "calls"
        },
        {
          "target": "stdlib.turtle.sorted",
          "type": "calls"
        },
        {
          "target": "stdlib.turtle.write",
          "type": "calls"
        },
        {
          "target": "stdlib.turtle.write",
          "type": "calls"
        },
        {
          "target": "stdlib.turtle.write",
          "type": "calls"
        },
        {
          "target": "stdlib.turtle.write",
          "type": "calls"
        },
        {
          "target": "stdlib.turtle.close",
          "type": "calls"
        },
        {
          "target": "stdlib.turtle.eval",
          "type": "calls"
        },
        {
          "target": "stdlib.turtle.eval",
          "type": "calls"
        },
        {
          "target": "stdlib.turtle.write",
          "type": "calls"
        },
        {
          "target": "stdlib.turtle.write",
          "type": "calls"
        },
        {
          "target": "stdlib.turtle.repr",
          "type": "calls"
        },
        {
          "target": "stdlib.turtle.repr",
          "type": "calls"
        },
        {
          "target": "stdlib.turtle.split",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.turtle.xcor",
      "name": "xcor",
      "module": "turtle",
      "type": "function",
      "signature": "()",
      "description": "Return the turtle's x coordinate.\n\nNo arguments.\n\nExample:\n>>> reset()\n>>> left(60)\n>>> forward(100)\n>>> print xcor()\n50.0",
      "relationships": []
    },
    {
      "id": "stdlib.turtle.ycor",
      "name": "ycor",
      "module": "turtle",
      "type": "function",
      "signature": "()",
      "description": "Return the turtle's y coordinate\n---\nNo arguments.\n\nExample:\n>>> reset()\n>>> left(60)\n>>> forward(100)\n>>> print ycor()\n86.6025403784",
      "relationships": []
    },
    {
      "id": "stdlib.types.AsyncGeneratorType",
      "name": "AsyncGeneratorType",
      "module": "types",
      "type": "class",
      "signature": "()",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.types.BuiltinFunctionType",
      "name": "BuiltinFunctionType",
      "module": "types",
      "type": "class",
      "signature": "()",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.types.BuiltinMethodType",
      "name": "BuiltinMethodType",
      "module": "types",
      "type": "class",
      "signature": "()",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.types.ClassMethodDescriptorType",
      "name": "ClassMethodDescriptorType",
      "module": "types",
      "type": "class",
      "signature": "()",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.types.CoroutineType",
      "name": "CoroutineType",
      "module": "types",
      "type": "class",
      "signature": "()",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.types.DynamicClassAttribute",
      "name": "DynamicClassAttribute",
      "module": "types",
      "type": "class",
      "signature": "(fget=None, fset=None, fdel=None, doc=None)",
      "description": "Route attribute access on a class to __getattr__.\n\nThis is a descriptor, used to define attributes that act differently when\naccessed through an instance and through a class.  Instance access remains\nnormal, but access to an attribute through a class will be routed to the\nclass's __getattr__ method; this is done by raising AttributeError.\n\nThis allows one to have properties active on an instance, and have virtual\nattributes on the class with the same name (see Enum for an example).",
      "relationships": []
    },
    {
      "id": "stdlib.types.FrameType",
      "name": "FrameType",
      "module": "types",
      "type": "class",
      "signature": "()",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.types.FunctionType",
      "name": "FunctionType",
      "module": "types",
      "type": "class",
      "signature": "(code, globals, name=None, argdefs=None, closure=None)",
      "description": "Create a function object.\n\ncode\n  a code object\nglobals\n  the globals dictionary\nname\n  a string that overrides the name from the code object\nargdefs\n  a tuple that specifies the default argument values\nclosure\n  a tuple that supplies the bindings for free variables",
      "relationships": []
    },
    {
      "id": "stdlib.types.GeneratorType",
      "name": "GeneratorType",
      "module": "types",
      "type": "class",
      "signature": "()",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.types.GetSetDescriptorType",
      "name": "GetSetDescriptorType",
      "module": "types",
      "type": "class",
      "signature": "()",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.types.LambdaType",
      "name": "LambdaType",
      "module": "types",
      "type": "class",
      "signature": "(code, globals, name=None, argdefs=None, closure=None)",
      "description": "Create a function object.\n\ncode\n  a code object\nglobals\n  the globals dictionary\nname\n  a string that overrides the name from the code object\nargdefs\n  a tuple that specifies the default argument values\nclosure\n  a tuple that supplies the bindings for free variables",
      "relationships": []
    },
    {
      "id": "stdlib.types.MemberDescriptorType",
      "name": "MemberDescriptorType",
      "module": "types",
      "type": "class",
      "signature": "()",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.types.MethodDescriptorType",
      "name": "MethodDescriptorType",
      "module": "types",
      "type": "class",
      "signature": "()",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.types.MethodWrapperType",
      "name": "MethodWrapperType",
      "module": "types",
      "type": "class",
      "signature": "()",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.types.ModuleType",
      "name": "ModuleType",
      "module": "types",
      "type": "class",
      "signature": "(name, doc=None)",
      "description": "Create a module object.\n\nThe name must be a string; the optional doc argument can have any type.",
      "relationships": []
    },
    {
      "id": "stdlib.types.WrapperDescriptorType",
      "name": "WrapperDescriptorType",
      "module": "types",
      "type": "class",
      "signature": "()",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.types.coroutine",
      "name": "coroutine",
      "module": "types",
      "type": "function",
      "signature": "(func)",
      "description": "Convert regular generator function to a coroutine.",
      "relationships": [
        {
          "target": "stdlib.types.wraps",
          "type": "calls"
        },
        {
          "target": "stdlib.types.callable",
          "type": "calls"
        },
        {
          "target": "stdlib.types.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.types.func",
          "type": "calls"
        },
        {
          "target": "stdlib.types.replace",
          "type": "calls"
        },
        {
          "target": "stdlib.types.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.types._GeneratorWrapper",
          "type": "calls"
        },
        {
          "target": "stdlib.types.getattr",
          "type": "calls"
        },
        {
          "target": "stdlib.types.isinstance",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.types.new_class",
      "name": "new_class",
      "module": "types",
      "type": "function",
      "signature": "(name, bases=(), kwds=None, exec_body=None)",
      "description": "Create a class object dynamically using the appropriate metaclass.",
      "relationships": [
        {
          "target": "stdlib.types.resolve_bases",
          "type": "calls"
        },
        {
          "target": "stdlib.types.prepare_class",
          "type": "calls"
        },
        {
          "target": "stdlib.types.meta",
          "type": "calls"
        },
        {
          "target": "stdlib.types.exec_body",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.types.prepare_class",
      "name": "prepare_class",
      "module": "types",
      "type": "function",
      "signature": "(name, bases=(), kwds=None)",
      "description": "Call the __prepare__ method of the appropriate metaclass.\n\nReturns (metaclass, namespace, kwds) as a 3-tuple\n\n*metaclass* is the appropriate metaclass\n*namespace* is the prepared class namespace\n*kwds* is an updated copy of the passed in kwds argument with any\n'metaclass' entry removed. If no kwds argument is passed in, this will\nbe an empty dict.",
      "relationships": [
        {
          "target": "stdlib.types.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.types.hasattr",
          "type": "calls"
        },
        {
          "target": "stdlib.types.dict",
          "type": "calls"
        },
        {
          "target": "stdlib.types.pop",
          "type": "calls"
        },
        {
          "target": "stdlib.types._calculate_meta",
          "type": "calls"
        },
        {
          "target": "stdlib.types.__prepare__",
          "type": "calls"
        },
        {
          "target": "stdlib.types.type",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.types.resolve_bases",
      "name": "resolve_bases",
      "module": "types",
      "type": "function",
      "signature": "(bases)",
      "description": "Resolve MRO entries dynamically as specified by PEP 560.",
      "relationships": [
        {
          "target": "stdlib.types.list",
          "type": "calls"
        },
        {
          "target": "stdlib.types.enumerate",
          "type": "calls"
        },
        {
          "target": "stdlib.types.tuple",
          "type": "calls"
        },
        {
          "target": "stdlib.types.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.types.__mro_entries__",
          "type": "calls"
        },
        {
          "target": "stdlib.types.hasattr",
          "type": "calls"
        },
        {
          "target": "stdlib.types.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.types.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.types.len",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.typing.ABCMeta",
      "name": "ABCMeta",
      "module": "typing",
      "type": "class",
      "signature": "(name, bases, namespace, **kwargs)",
      "description": "Metaclass for defining Abstract Base Classes (ABCs).\n\nUse this metaclass to create an ABC.  An ABC can be subclassed\ndirectly, and then acts as a mix-in class.  You can also register\nunrelated concrete classes (even built-in classes) and unrelated\nABCs as 'virtual subclasses' -- these and their descendants will\nbe considered subclasses of the registering ABC by the built-in\nissubclass() function, but the registering ABC won't show up in\ntheir MRO (Method Resolution Order) nor will method\nimplementations defined by the registering ABC be callable (not\neven via super()).",
      "relationships": [
        {
          "target": "type",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.typing.Annotated",
      "name": "Annotated",
      "module": "typing",
      "type": "class",
      "signature": "(*args, **kwargs)",
      "description": "Add context specific metadata to a type.\n\nExample: Annotated[int, runtime_check.Unsigned] indicates to the\nhypothetical runtime_check module that this type is an unsigned int.\nEvery other consumer of this type can ignore this metadata and treat\nthis type as int.\n\nThe first argument to Annotated must be a valid type.\n\nDetails:\n\n- It's an error to call `Annotated` with less than two arguments.\n- Nested Annotated are flattened::\n\n    Annotated[Annotated[T, Ann1, Ann2], Ann3] == Annotated[T, Ann1, Ann2, Ann3]\n\n- Instantiating an annotated type is equivalent to instantiating the\nunderlying type::\n\n    Annotated[C, Ann1](5) == C(5)\n\n- Annotated can be used as a generic type alias::\n\n    Optimized = Annotated[T, runtime.Optimize()]\n    Optimized[int] == Annotated[int, runtime.Optimize()]\n\n    OptimizedList = Annotated[List[T], runtime.Optimize()]\n    OptimizedList[int] == Annotated[List[int], runtime.Optimize()]",
      "relationships": []
    },
    {
      "id": "stdlib.typing.BinaryIO",
      "name": "BinaryIO",
      "module": "typing",
      "type": "class",
      "signature": "()",
      "description": "Typed version of the return of open() in binary mode.",
      "relationships": [
        {
          "target": "IO",
          "type": "base_class"
        },
        {
          "target": "Generic",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.typing.ForwardRef",
      "name": "ForwardRef",
      "module": "typing",
      "type": "class",
      "signature": "(arg, is_argument=True)",
      "description": "Internal wrapper to hold a forward reference.",
      "relationships": [
        {
          "target": "_Final",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.typing.Generic",
      "name": "Generic",
      "module": "typing",
      "type": "class",
      "signature": "()",
      "description": "Abstract base class for generic types.\n\nA generic type is typically declared by inheriting from\nthis class parameterized with one or more type variables.\nFor example, a generic mapping type might be defined as::\n\n  class Mapping(Generic[KT, VT]):\n      def __getitem__(self, key: KT) -> VT:\n          ...\n      # Etc.\n\nThis class can then be used as follows::\n\n  def lookup_name(mapping: Mapping[KT, VT], key: KT, default: VT) -> VT:\n      try:\n          return mapping[key]\n      except KeyError:\n          return default",
      "relationships": []
    },
    {
      "id": "stdlib.typing.IO",
      "name": "IO",
      "module": "typing",
      "type": "class",
      "signature": "()",
      "description": "Generic base class for TextIO and BinaryIO.\n\nThis is an abstract, generic version of the return of open().\n\nNOTE: This does not distinguish between the different possible\nclasses (text vs. binary, read vs. write vs. read/write,\nappend-only, unbuffered).  The TextIO and BinaryIO subclasses\nbelow capture the distinctions between text vs. binary, which is\npervasive in the interface; however we currently do not offer a\nway to track the other distinctions in the type system.",
      "relationships": [
        {
          "target": "Generic",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.typing.MethodDescriptorType",
      "name": "MethodDescriptorType",
      "module": "typing",
      "type": "class",
      "signature": "()",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.typing.MethodWrapperType",
      "name": "MethodWrapperType",
      "module": "typing",
      "type": "class",
      "signature": "()",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.typing.NamedTuple",
      "name": "NamedTuple",
      "module": "typing",
      "type": "function",
      "signature": "(typename, fields=None, /, **kwargs)",
      "description": "Typed version of namedtuple.\n\nUsage in Python versions >= 3.6::\n\n    class Employee(NamedTuple):\n        name: str\n        id: int\n\nThis is equivalent to::\n\n    Employee = collections.namedtuple('Employee', ['name', 'id'])\n\nThe resulting class has an extra __annotations__ attribute, giving a\ndict that maps field names to types.  (The field names are also in\nthe _fields attribute, which is part of the namedtuple API.)\nAlternative equivalent keyword syntax is also accepted::\n\n    Employee = NamedTuple('Employee', name=str, id=int)\n\nIn Python versions <= 3.5 use::\n\n    Employee = NamedTuple('Employee', [('name', str), ('id', int)])",
      "relationships": [
        {
          "target": "stdlib.typing._make_nmtuple",
          "type": "calls"
        },
        {
          "target": "stdlib.typing.items",
          "type": "calls"
        },
        {
          "target": "stdlib.typing.get",
          "type": "calls"
        },
        {
          "target": "stdlib.typing.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.typing._getframe",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.typing.NamedTupleMeta",
      "name": "NamedTupleMeta",
      "module": "typing",
      "type": "class",
      "signature": "(typename, bases, ns)",
      "description": "type(object_or_name, bases, dict)\ntype(object) -> the object's type\ntype(name, bases, dict) -> a new type",
      "relationships": [
        {
          "target": "type",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.typing.NewType",
      "name": "NewType",
      "module": "typing",
      "type": "function",
      "signature": "(name, tp)",
      "description": "NewType creates simple unique types with almost zero\nruntime overhead. NewType(name, tp) is considered a subtype of tp\nby static type checkers. At runtime, NewType(name, tp) returns\na dummy function that simply returns its argument. Usage::\n\n    UserId = NewType('UserId', int)\n\n    def name_by_id(user_id: UserId) -> str:\n        ...\n\n    UserId('user')          # Fails type check\n\n    name_by_id(42)          # Fails type check\n    name_by_id(UserId(42))  # OK\n\n    num = UserId(5) + 1     # type: int",
      "relationships": []
    },
    {
      "id": "stdlib.typing.Protocol",
      "name": "Protocol",
      "module": "typing",
      "type": "class",
      "signature": "()",
      "description": "Base class for protocol classes.\n\nProtocol classes are defined as::\n\n    class Proto(Protocol):\n        def meth(self) -> int:\n            ...\n\nSuch classes are primarily used with static type checkers that recognize\nstructural subtyping (static duck-typing), for example::\n\n    class C:\n        def meth(self) -> int:\n            return 0\n\n    def func(x: Proto) -> int:\n        return x.meth()\n\n    func(C())  # Passes static type check\n\nSee PEP 544 for details. Protocol classes decorated with\n@typing.runtime_checkable act as simple-minded runtime protocols that check\nonly the presence of given attributes, ignoring their type signatures.\nProtocol classes can be generic, they are defined as::\n\n    class GenProto(Protocol[T]):\n        def meth(self) -> T:\n            ...",
      "relationships": [
        {
          "target": "Generic",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.typing.SupportsAbs",
      "name": "SupportsAbs",
      "module": "typing",
      "type": "class",
      "signature": "(*args, **kwargs)",
      "description": "An ABC with one abstract method __abs__ that is covariant in its return type.",
      "relationships": [
        {
          "target": "Protocol",
          "type": "base_class"
        },
        {
          "target": "Generic",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.typing.SupportsBytes",
      "name": "SupportsBytes",
      "module": "typing",
      "type": "class",
      "signature": "(*args, **kwargs)",
      "description": "An ABC with one abstract method __bytes__.",
      "relationships": [
        {
          "target": "Protocol",
          "type": "base_class"
        },
        {
          "target": "Generic",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.typing.SupportsComplex",
      "name": "SupportsComplex",
      "module": "typing",
      "type": "class",
      "signature": "(*args, **kwargs)",
      "description": "An ABC with one abstract method __complex__.",
      "relationships": [
        {
          "target": "Protocol",
          "type": "base_class"
        },
        {
          "target": "Generic",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.typing.SupportsFloat",
      "name": "SupportsFloat",
      "module": "typing",
      "type": "class",
      "signature": "(*args, **kwargs)",
      "description": "An ABC with one abstract method __float__.",
      "relationships": [
        {
          "target": "Protocol",
          "type": "base_class"
        },
        {
          "target": "Generic",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.typing.SupportsIndex",
      "name": "SupportsIndex",
      "module": "typing",
      "type": "class",
      "signature": "(*args, **kwargs)",
      "description": "An ABC with one abstract method __index__.",
      "relationships": [
        {
          "target": "Protocol",
          "type": "base_class"
        },
        {
          "target": "Generic",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.typing.SupportsInt",
      "name": "SupportsInt",
      "module": "typing",
      "type": "class",
      "signature": "(*args, **kwargs)",
      "description": "An ABC with one abstract method __int__.",
      "relationships": [
        {
          "target": "Protocol",
          "type": "base_class"
        },
        {
          "target": "Generic",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.typing.SupportsRound",
      "name": "SupportsRound",
      "module": "typing",
      "type": "class",
      "signature": "(*args, **kwargs)",
      "description": "An ABC with one abstract method __round__ that is covariant in its return type.",
      "relationships": [
        {
          "target": "Protocol",
          "type": "base_class"
        },
        {
          "target": "Generic",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.typing.TextIO",
      "name": "TextIO",
      "module": "typing",
      "type": "class",
      "signature": "()",
      "description": "Typed version of the return of open() in text mode.",
      "relationships": [
        {
          "target": "IO",
          "type": "base_class"
        },
        {
          "target": "Generic",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.typing.TypeVar",
      "name": "TypeVar",
      "module": "typing",
      "type": "class",
      "signature": "(name, *constraints, bound=None, covariant=False, contravariant=False)",
      "description": "Type variable.\n\nUsage::\n\n  T = TypeVar('T')  # Can be anything\n  A = TypeVar('A', str, bytes)  # Must be str or bytes\n\nType variables exist primarily for the benefit of static type\ncheckers.  They serve as the parameters for generic types as well\nas for generic function definitions.  See class Generic for more\ninformation on generic types.  Generic functions work as follows:\n\n  def repeat(x: T, n: int) -> List[T]:\n      '''Return a list containing n references to x.'''\n      return [x]*n\n\n  def longest(x: A, y: A) -> A:\n      '''Return the longest of two strings.'''\n      return x if len(x) >= len(y) else y\n\nThe latter example's signature is essentially the overloading\nof (str, str) -> str and (bytes, bytes) -> bytes.  Also note\nthat if the arguments are instances of some subclass of str,\nthe return type is still plain str.\n\nAt runtime, isinstance(x, T) and issubclass(C, T) will raise TypeError.\n\nType variables defined with covariant=True or contravariant=True\ncan be used to declare covariant or contravariant generic types.\nSee PEP 484 for more details. By default generic types are invariant\nin all type variables.\n\nType variables can be introspected. e.g.:\n\n  T.__name__ == 'T'\n  T.__constraints__ == ()\n  T.__covariant__ == False\n  T.__contravariant__ = False\n  A.__constraints__ == (str, bytes)\n\nNote that only type variables defined in global scope can be pickled.",
      "relationships": [
        {
          "target": "_Final",
          "type": "base_class"
        },
        {
          "target": "_Immutable",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.typing.TypedDict",
      "name": "TypedDict",
      "module": "typing",
      "type": "function",
      "signature": "(typename, fields=None, /, *, total=True, **kwargs)",
      "description": "A simple typed namespace. At runtime it is equivalent to a plain dict.\n\nTypedDict creates a dictionary type that expects all of its\ninstances to have a certain set of keys, where each key is\nassociated with a value of a consistent type. This expectation\nis not checked at runtime but is only enforced by type checkers.\nUsage::\n\n    class Point2D(TypedDict):\n        x: int\n        y: int\n        label: str\n\n    a: Point2D = {'x': 1, 'y': 2, 'label': 'good'}  # OK\n    b: Point2D = {'z': 3, 'label': 'bad'}           # Fails type check\n\n    assert Point2D(x=1, y=2, label='first') == dict(x=1, y=2, label='first')\n\nThe type info can be accessed via the Point2D.__annotations__ dict, and\nthe Point2D.__required_keys__ and Point2D.__optional_keys__ frozensets.\nTypedDict supports two additional equivalent forms::\n\n    Point2D = TypedDict('Point2D', x=int, y=int, label=str)\n    Point2D = TypedDict('Point2D', {'x': int, 'y': int, 'label': str})\n\nBy default, all keys must be present in a TypedDict. It is possible\nto override this by specifying totality.\nUsage::\n\n    class point2D(TypedDict, total=False):\n        x: int\n        y: int\n\nThis means that a point2D TypedDict can have any of the keys omitted.A type\nchecker is only expected to support a literal False or True as the value of\nthe total argument. True is the default, and makes all items defined in the\nclass body be required.\n\nThe class syntax is only supported in Python 3.6+, while two other\nsyntax forms work for Python 2.7 and 3.2+",
      "relationships": [
        {
          "target": "stdlib.typing._TypedDictMeta",
          "type": "calls"
        },
        {
          "target": "stdlib.typing.dict",
          "type": "calls"
        },
        {
          "target": "stdlib.typing.get",
          "type": "calls"
        },
        {
          "target": "stdlib.typing.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.typing._getframe",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.typing.WrapperDescriptorType",
      "name": "WrapperDescriptorType",
      "module": "typing",
      "type": "class",
      "signature": "()",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.typing.abstractmethod",
      "name": "abstractmethod",
      "module": "typing",
      "type": "function",
      "signature": "(funcobj)",
      "description": "A decorator indicating abstract methods.\n\nRequires that the metaclass is ABCMeta or derived from it.  A\nclass that has a metaclass derived from ABCMeta cannot be\ninstantiated unless all of its abstract methods are overridden.\nThe abstract methods can be called using any of the normal\n'super' call mechanisms.  abstractmethod() may be used to declare\nabstract methods for properties and descriptors.\n\nUsage:\n\n    class C(metaclass=ABCMeta):\n        @abstractmethod\n        def my_abstract_method(self, ...):\n            ...",
      "relationships": []
    },
    {
      "id": "stdlib.typing.cast",
      "name": "cast",
      "module": "typing",
      "type": "function",
      "signature": "(typ, val)",
      "description": "Cast a value to a type.\n\nThis returns the value unchanged.  To the type checker this\nsignals that the return value has the designated type, but at\nruntime we intentionally don't check anything (we want this\nto be as fast as possible).",
      "relationships": []
    },
    {
      "id": "stdlib.typing.final",
      "name": "final",
      "module": "typing",
      "type": "function",
      "signature": "(f)",
      "description": "A decorator to indicate final methods and final classes.\n\nUse this decorator to indicate to type checkers that the decorated\nmethod cannot be overridden, and decorated class cannot be subclassed.\nFor example:\n\n  class Base:\n      @final\n      def done(self) -> None:\n          ...\n  class Sub(Base):\n      def done(self) -> None:  # Error reported by type checker\n            ...\n\n  @final\n  class Leaf:\n      ...\n  class Other(Leaf):  # Error reported by type checker\n      ...\n\nThere is no runtime checking of these properties.",
      "relationships": []
    },
    {
      "id": "stdlib.typing.get_args",
      "name": "get_args",
      "module": "typing",
      "type": "function",
      "signature": "(tp)",
      "description": "Get type arguments with all substitutions performed.\n\nFor unions, basic simplifications used by Union constructor are performed.\nExamples::\n    get_args(Dict[str, int]) == (str, int)\n    get_args(int) == ()\n    get_args(Union[int, Union[T, int], str][int]) == (int, str)\n    get_args(Union[int, Tuple[T, int]][str]) == (int, Tuple[str, int])\n    get_args(Callable[[], T][int]) == ([], int)",
      "relationships": [
        {
          "target": "stdlib.typing.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.typing.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.typing.list",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.typing.get_origin",
      "name": "get_origin",
      "module": "typing",
      "type": "function",
      "signature": "(tp)",
      "description": "Get the unsubscripted version of a type.\n\nThis supports generic types, Callable, Tuple, Union, Literal, Final, ClassVar\nand Annotated. Return None for unsupported types. Examples::\n\n    get_origin(Literal[42]) is Literal\n    get_origin(int) is None\n    get_origin(ClassVar[int]) is ClassVar\n    get_origin(Generic) is Generic\n    get_origin(Generic[T]) is Generic\n    get_origin(Union[T, int]) is Union\n    get_origin(List[Tuple[T, T]][int]) == list",
      "relationships": [
        {
          "target": "stdlib.typing.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.typing.isinstance",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.typing.get_type_hints",
      "name": "get_type_hints",
      "module": "typing",
      "type": "function",
      "signature": "(obj, globalns=None, localns=None, include_extras=False)",
      "description": "Return type hints for an object.\n\nThis is often the same as obj.__annotations__, but it handles\nforward references encoded as string literals, adds Optional[t] if a\ndefault value equal to None is set and recursively replaces all\n'Annotated[T, ...]' with 'T' (unless 'include_extras=True').\n\nThe argument may be a module, class, method, or function. The annotations\nare returned as a dictionary. For classes, annotations include also\ninherited members.\n\nTypeError is raised if the argument is not of a type that can contain\nannotations, and an empty dictionary is returned if no annotations are\npresent.\n\nBEWARE -- the behavior of globalns and localns is counterintuitive\n(unless you are familiar with how eval() and exec() work).  The\nsearch order is locals first, then globals.\n\n- If no dict arguments are passed, an attempt is made to use the\n  globals from obj (or the respective module's globals for classes),\n  and these are also used as the locals.  If the object does not appear\n  to have globals, an empty dictionary is used.\n\n- If one dict argument is passed, it is used for both globals and\n  locals.\n\n- If two dict arguments are passed, they specify globals and\n  locals, respectively.",
      "relationships": [
        {
          "target": "stdlib.typing.getattr",
          "type": "calls"
        },
        {
          "target": "stdlib.typing.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.typing.getattr",
          "type": "calls"
        },
        {
          "target": "stdlib.typing._get_defaults",
          "type": "calls"
        },
        {
          "target": "stdlib.typing.dict",
          "type": "calls"
        },
        {
          "target": "stdlib.typing.items",
          "type": "calls"
        },
        {
          "target": "stdlib.typing.reversed",
          "type": "calls"
        },
        {
          "target": "stdlib.typing.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.typing.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.typing.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.typing._eval_type",
          "type": "calls"
        },
        {
          "target": "stdlib.typing.get",
          "type": "calls"
        },
        {
          "target": "stdlib.typing.items",
          "type": "calls"
        },
        {
          "target": "stdlib.typing.hasattr",
          "type": "calls"
        },
        {
          "target": "stdlib.typing.getattr",
          "type": "calls"
        },
        {
          "target": "stdlib.typing.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.typing.type",
          "type": "calls"
        },
        {
          "target": "stdlib.typing.ForwardRef",
          "type": "calls"
        },
        {
          "target": "stdlib.typing._strip_annotations",
          "type": "calls"
        },
        {
          "target": "stdlib.typing.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.typing._eval_type",
          "type": "calls"
        },
        {
          "target": "stdlib.typing._strip_annotations",
          "type": "calls"
        },
        {
          "target": "stdlib.typing.format",
          "type": "calls"
        },
        {
          "target": "stdlib.typing.items",
          "type": "calls"
        },
        {
          "target": "stdlib.typing.type",
          "type": "calls"
        },
        {
          "target": "stdlib.typing.ForwardRef",
          "type": "calls"
        },
        {
          "target": "stdlib.typing.items",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.typing.io",
      "name": "io",
      "module": "typing",
      "type": "class",
      "signature": "()",
      "description": "Wrapper namespace for IO generic classes.",
      "relationships": []
    },
    {
      "id": "stdlib.typing.no_type_check",
      "name": "no_type_check",
      "module": "typing",
      "type": "function",
      "signature": "(arg)",
      "description": "Decorator to indicate that annotations are not type hints.\n\nThe argument must be a class or function; if it is a class, it\napplies recursively to all methods and classes defined in that class\n(but not to methods defined in its superclasses or subclasses).\n\nThis mutates the function(s) or class(es) in place.",
      "relationships": [
        {
          "target": "stdlib.typing.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.typing.copy",
          "type": "calls"
        },
        {
          "target": "stdlib.typing.items",
          "type": "calls"
        },
        {
          "target": "stdlib.typing.values",
          "type": "calls"
        },
        {
          "target": "stdlib.typing.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.typing.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.typing.pop",
          "type": "calls"
        },
        {
          "target": "stdlib.typing.no_type_check",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.typing.no_type_check_decorator",
      "name": "no_type_check_decorator",
      "module": "typing",
      "type": "function",
      "signature": "(decorator)",
      "description": "Decorator to give another decorator the @no_type_check effect.\n\nThis wraps the decorator with something that wraps the decorated\nfunction in @no_type_check.",
      "relationships": [
        {
          "target": "stdlib.typing.wraps",
          "type": "calls"
        },
        {
          "target": "stdlib.typing.decorator",
          "type": "calls"
        },
        {
          "target": "stdlib.typing.no_type_check",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.typing.overload",
      "name": "overload",
      "module": "typing",
      "type": "function",
      "signature": "(func)",
      "description": "Decorator for overloaded functions/methods.\n\nIn a stub file, place two or more stub definitions for the same\nfunction in a row, each decorated with @overload.  For example:\n\n  @overload\n  def utf8(value: None) -> None: ...\n  @overload\n  def utf8(value: bytes) -> bytes: ...\n  @overload\n  def utf8(value: str) -> bytes: ...\n\nIn a non-stub file (i.e. a regular .py file), do the same but\nfollow it with an implementation.  The implementation should *not*\nbe decorated with @overload.  For example:\n\n  @overload\n  def utf8(value: None) -> None: ...\n  @overload\n  def utf8(value: bytes) -> bytes: ...\n  @overload\n  def utf8(value: str) -> bytes: ...\n  def utf8(value):\n      # implementation goes here",
      "relationships": []
    },
    {
      "id": "stdlib.typing.re",
      "name": "re",
      "module": "typing",
      "type": "class",
      "signature": "()",
      "description": "Wrapper namespace for re type aliases.",
      "relationships": []
    },
    {
      "id": "stdlib.typing.runtime_checkable",
      "name": "runtime_checkable",
      "module": "typing",
      "type": "function",
      "signature": "(cls)",
      "description": "Mark a protocol class as a runtime protocol.\n\nSuch protocol can be used with isinstance() and issubclass().\nRaise TypeError if applied to a non-protocol class.\nThis allows a simple-minded structural check very similar to\none trick ponies in collections.abc such as Iterable.\nFor example::\n\n    @runtime_checkable\n    class Closable(Protocol):\n        def close(self): ...\n\n    assert isinstance(open('/some/file'), Closable)\n\nWarning: this will check only the presence of the required methods,\nnot their type signatures!",
      "relationships": [
        {
          "target": "stdlib.typing.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.typing.issubclass",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.unittest.BaseTestSuite",
      "name": "BaseTestSuite",
      "module": "unittest",
      "type": "class",
      "signature": "(tests=())",
      "description": "A simple test suite that doesn't provide class or module shared fixtures.\n    ",
      "relationships": []
    },
    {
      "id": "stdlib.unittest.FunctionTestCase",
      "name": "FunctionTestCase",
      "module": "unittest",
      "type": "class",
      "signature": "(testFunc, setUp=None, tearDown=None, description=None)",
      "description": "A test case that wraps a test function.\n\nThis is useful for slipping pre-existing test functions into the\nunittest framework. Optionally, set-up and tidy-up functions can be\nsupplied. As with TestCase, the tidy-up ('tearDown') function will\nalways be called if the set-up ('setUp') function ran successfully.",
      "relationships": [
        {
          "target": "TestCase",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.unittest.IsolatedAsyncioTestCase",
      "name": "IsolatedAsyncioTestCase",
      "module": "unittest",
      "type": "class",
      "signature": "(methodName='runTest')",
      "description": "A class whose instances are single test cases.\n\nBy default, the test code itself should be placed in a method named\n'runTest'.\n\nIf the fixture may be used for many test cases, create as\nmany test methods as are needed. When instantiating such a TestCase\nsubclass, specify in the constructor arguments the name of the test method\nthat the instance is to execute.\n\nTest authors should subclass TestCase for their own tests. Construction\nand deconstruction of the test's environment ('fixture') can be\nimplemented by overriding the 'setUp' and 'tearDown' methods respectively.\n\nIf it is necessary to override the __init__ method, the base class\n__init__ method must always be called. It is important that subclasses\nshould not change the signature of their __init__ method, since instances\nof the classes are instantiated automatically by parts of the framework\nin order to be run.\n\nWhen subclassing TestCase, you can set these attributes:\n* failureException: determines which exception will be raised when\n    the instance's assertion methods fail; test methods raising this\n    exception will be deemed to have 'failed' rather than 'errored'.\n* longMessage: determines whether long messages (including repr of\n    objects used in assert methods) will be printed on failure in *addition*\n    to any explicit message passed.\n* maxDiff: sets the maximum length of a diff in failure messages\n    by assert methods using difflib. It is looked up as an instance\n    attribute so can be configured by individual tests if required.",
      "relationships": [
        {
          "target": "TestCase",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.unittest.TestCase",
      "name": "TestCase",
      "module": "unittest",
      "type": "class",
      "signature": "(methodName='runTest')",
      "description": "A class whose instances are single test cases.\n\nBy default, the test code itself should be placed in a method named\n'runTest'.\n\nIf the fixture may be used for many test cases, create as\nmany test methods as are needed. When instantiating such a TestCase\nsubclass, specify in the constructor arguments the name of the test method\nthat the instance is to execute.\n\nTest authors should subclass TestCase for their own tests. Construction\nand deconstruction of the test's environment ('fixture') can be\nimplemented by overriding the 'setUp' and 'tearDown' methods respectively.\n\nIf it is necessary to override the __init__ method, the base class\n__init__ method must always be called. It is important that subclasses\nshould not change the signature of their __init__ method, since instances\nof the classes are instantiated automatically by parts of the framework\nin order to be run.\n\nWhen subclassing TestCase, you can set these attributes:\n* failureException: determines which exception will be raised when\n    the instance's assertion methods fail; test methods raising this\n    exception will be deemed to have 'failed' rather than 'errored'.\n* longMessage: determines whether long messages (including repr of\n    objects used in assert methods) will be printed on failure in *addition*\n    to any explicit message passed.\n* maxDiff: sets the maximum length of a diff in failure messages\n    by assert methods using difflib. It is looked up as an instance\n    attribute so can be configured by individual tests if required.",
      "relationships": []
    },
    {
      "id": "stdlib.unittest.TestLoader",
      "name": "TestLoader",
      "module": "unittest",
      "type": "class",
      "signature": "()",
      "description": "This class is responsible for loading tests according to various criteria\nand returning them wrapped in a TestSuite",
      "relationships": []
    },
    {
      "id": "stdlib.unittest.TestProgram",
      "name": "TestProgram",
      "module": "unittest",
      "type": "class",
      "signature": "(module='__main__', defaultTest=None, argv=None, testRunner=None, testLoader=<unittest.loader.TestLoader object at 0x108b81eb0>, exit=True, verbosity=1, failfast=None, catchbreak=None, buffer=None, warnings=None, *, tb_locals=False)",
      "description": "A command-line program that runs a set of tests; this is primarily\nfor making test modules conveniently executable.",
      "relationships": []
    },
    {
      "id": "stdlib.unittest.TestResult",
      "name": "TestResult",
      "module": "unittest",
      "type": "class",
      "signature": "(stream=None, descriptions=None, verbosity=None)",
      "description": "Holder for test result information.\n\nTest results are automatically managed by the TestCase and TestSuite\nclasses, and do not need to be explicitly manipulated by writers of tests.\n\nEach instance holds the total number of tests run, and collections of\nfailures and errors that occurred among those test runs. The collections\ncontain tuples of (testcase, exceptioninfo), where exceptioninfo is the\nformatted traceback of the error that occurred.",
      "relationships": []
    },
    {
      "id": "stdlib.unittest.TestSuite",
      "name": "TestSuite",
      "module": "unittest",
      "type": "class",
      "signature": "(tests=())",
      "description": "A test suite is a composite test consisting of a number of TestCases.\n\nFor use, create an instance of TestSuite, then add test case instances.\nWhen all tests have been added, the suite can be passed to a test\nrunner, such as TextTestRunner. It will run the individual test cases\nin the order in which they were added, aggregating the results. When\nsubclassing, do not forget to call the base class constructor.",
      "relationships": [
        {
          "target": "BaseTestSuite",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.unittest.TextTestResult",
      "name": "TextTestResult",
      "module": "unittest",
      "type": "class",
      "signature": "(stream, descriptions, verbosity)",
      "description": "A test result class that can print formatted text results to a stream.\n\nUsed by TextTestRunner.",
      "relationships": [
        {
          "target": "TestResult",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.unittest.TextTestRunner",
      "name": "TextTestRunner",
      "module": "unittest",
      "type": "class",
      "signature": "(stream=None, descriptions=True, verbosity=1, failfast=False, buffer=False, resultclass=None, warnings=None, *, tb_locals=False)",
      "description": "A test runner class that displays results in textual form.\n\nIt prints out the names of tests as they are run, errors as they\noccur, and a summary of the results at the end of the test run.",
      "relationships": []
    },
    {
      "id": "stdlib.unittest.addModuleCleanup",
      "name": "addModuleCleanup",
      "module": "unittest",
      "type": "function",
      "signature": "(function, /, *args, **kwargs)",
      "description": "Same as addCleanup, except the cleanup items are called even if\nsetUpModule fails (unlike tearDownModule).",
      "relationships": [
        {
          "target": "stdlib.unittest.append",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.unittest.expectedFailure",
      "name": "expectedFailure",
      "module": "unittest",
      "type": "function",
      "signature": "(test_item)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.unittest.findTestCases",
      "name": "findTestCases",
      "module": "unittest",
      "type": "function",
      "signature": "(module, prefix='test', sortUsing=<function three_way_cmp at 0x108b53a60>, suiteClass=<class 'unittest.suite.TestSuite'>)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.unittest.loadTestsFromModule",
          "type": "calls"
        },
        {
          "target": "stdlib.unittest._makeLoader",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.unittest.getTestCaseNames",
      "name": "getTestCaseNames",
      "module": "unittest",
      "type": "function",
      "signature": "(testCaseClass, prefix, sortUsing=<function three_way_cmp at 0x108b53a60>, testNamePatterns=None)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.unittest.getTestCaseNames",
          "type": "calls"
        },
        {
          "target": "stdlib.unittest._makeLoader",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.unittest.installHandler",
      "name": "installHandler",
      "module": "unittest",
      "type": "function",
      "signature": "()",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.unittest.getsignal",
          "type": "calls"
        },
        {
          "target": "stdlib.unittest._InterruptHandler",
          "type": "calls"
        },
        {
          "target": "stdlib.unittest.signal",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.unittest.load_tests",
      "name": "load_tests",
      "module": "unittest",
      "type": "function",
      "signature": "(loader, tests, pattern)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.unittest.dirname",
          "type": "calls"
        },
        {
          "target": "stdlib.unittest.discover",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.unittest.main",
      "name": "main",
      "module": "unittest",
      "type": "class",
      "signature": "(module='__main__', defaultTest=None, argv=None, testRunner=None, testLoader=<unittest.loader.TestLoader object at 0x108b81eb0>, exit=True, verbosity=1, failfast=None, catchbreak=None, buffer=None, warnings=None, *, tb_locals=False)",
      "description": "A command-line program that runs a set of tests; this is primarily\nfor making test modules conveniently executable.",
      "relationships": []
    },
    {
      "id": "stdlib.unittest.makeSuite",
      "name": "makeSuite",
      "module": "unittest",
      "type": "function",
      "signature": "(testCaseClass, prefix='test', sortUsing=<function three_way_cmp at 0x108b53a60>, suiteClass=<class 'unittest.suite.TestSuite'>)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.unittest.loadTestsFromTestCase",
          "type": "calls"
        },
        {
          "target": "stdlib.unittest._makeLoader",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.unittest.registerResult",
      "name": "registerResult",
      "module": "unittest",
      "type": "function",
      "signature": "(result)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.unittest.removeHandler",
      "name": "removeHandler",
      "module": "unittest",
      "type": "function",
      "signature": "(method=None)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.unittest.wraps",
          "type": "calls"
        },
        {
          "target": "stdlib.unittest.signal",
          "type": "calls"
        },
        {
          "target": "stdlib.unittest.getsignal",
          "type": "calls"
        },
        {
          "target": "stdlib.unittest.removeHandler",
          "type": "calls"
        },
        {
          "target": "stdlib.unittest.method",
          "type": "calls"
        },
        {
          "target": "stdlib.unittest.signal",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.unittest.removeResult",
      "name": "removeResult",
      "module": "unittest",
      "type": "function",
      "signature": "(result)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.unittest.bool",
          "type": "calls"
        },
        {
          "target": "stdlib.unittest.pop",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.unittest.skip",
      "name": "skip",
      "module": "unittest",
      "type": "function",
      "signature": "(reason)",
      "description": "Unconditionally skip a test.",
      "relationships": [
        {
          "target": "stdlib.unittest.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.unittest.decorator",
          "type": "calls"
        },
        {
          "target": "stdlib.unittest.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.unittest.wraps",
          "type": "calls"
        },
        {
          "target": "stdlib.unittest.SkipTest",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.unittest.skipIf",
      "name": "skipIf",
      "module": "unittest",
      "type": "function",
      "signature": "(condition, reason)",
      "description": "Skip a test if the condition is true.",
      "relationships": [
        {
          "target": "stdlib.unittest.skip",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.unittest.skipUnless",
      "name": "skipUnless",
      "module": "unittest",
      "type": "function",
      "signature": "(condition, reason)",
      "description": "Skip a test unless the condition is true.",
      "relationships": [
        {
          "target": "stdlib.unittest.skip",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.uu.decode",
      "name": "decode",
      "module": "uu",
      "type": "function",
      "signature": "(in_file, out_file=None, mode=None, quiet=False)",
      "description": "Decode uuencoded file",
      "relationships": [
        {
          "target": "stdlib.uu.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.uu.readline",
          "type": "calls"
        },
        {
          "target": "stdlib.uu.open",
          "type": "calls"
        },
        {
          "target": "stdlib.uu.append",
          "type": "calls"
        },
        {
          "target": "stdlib.uu.readline",
          "type": "calls"
        },
        {
          "target": "stdlib.uu.split",
          "type": "calls"
        },
        {
          "target": "stdlib.uu.decode",
          "type": "calls"
        },
        {
          "target": "stdlib.uu.exists",
          "type": "calls"
        },
        {
          "target": "stdlib.uu.int",
          "type": "calls"
        },
        {
          "target": "stdlib.uu.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.uu.write",
          "type": "calls"
        },
        {
          "target": "stdlib.uu.readline",
          "type": "calls"
        },
        {
          "target": "stdlib.uu.Error",
          "type": "calls"
        },
        {
          "target": "stdlib.uu.close",
          "type": "calls"
        },
        {
          "target": "stdlib.uu.Error",
          "type": "calls"
        },
        {
          "target": "stdlib.uu.startswith",
          "type": "calls"
        },
        {
          "target": "stdlib.uu.Error",
          "type": "calls"
        },
        {
          "target": "stdlib.uu.open",
          "type": "calls"
        },
        {
          "target": "stdlib.uu.chmod",
          "type": "calls"
        },
        {
          "target": "stdlib.uu.append",
          "type": "calls"
        },
        {
          "target": "stdlib.uu.strip",
          "type": "calls"
        },
        {
          "target": "stdlib.uu.a2b_uu",
          "type": "calls"
        },
        {
          "target": "stdlib.uu.len",
          "type": "calls"
        },
        {
          "target": "stdlib.uu.int",
          "type": "calls"
        },
        {
          "target": "stdlib.uu.rstrip",
          "type": "calls"
        },
        {
          "target": "stdlib.uu.a2b_uu",
          "type": "calls"
        },
        {
          "target": "stdlib.uu.write",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.uu.encode",
      "name": "encode",
      "module": "uu",
      "type": "function",
      "signature": "(in_file, out_file, name=None, mode=None, *, backtick=False)",
      "description": "Uuencode file",
      "relationships": [
        {
          "target": "stdlib.uu.replace",
          "type": "calls"
        },
        {
          "target": "stdlib.uu.replace",
          "type": "calls"
        },
        {
          "target": "stdlib.uu.write",
          "type": "calls"
        },
        {
          "target": "stdlib.uu.read",
          "type": "calls"
        },
        {
          "target": "stdlib.uu.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.uu.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.uu.encode",
          "type": "calls"
        },
        {
          "target": "stdlib.uu.len",
          "type": "calls"
        },
        {
          "target": "stdlib.uu.write",
          "type": "calls"
        },
        {
          "target": "stdlib.uu.read",
          "type": "calls"
        },
        {
          "target": "stdlib.uu.write",
          "type": "calls"
        },
        {
          "target": "stdlib.uu.write",
          "type": "calls"
        },
        {
          "target": "stdlib.uu.close",
          "type": "calls"
        },
        {
          "target": "stdlib.uu.open",
          "type": "calls"
        },
        {
          "target": "stdlib.uu.append",
          "type": "calls"
        },
        {
          "target": "stdlib.uu.open",
          "type": "calls"
        },
        {
          "target": "stdlib.uu.append",
          "type": "calls"
        },
        {
          "target": "stdlib.uu.b2a_uu",
          "type": "calls"
        },
        {
          "target": "stdlib.uu.basename",
          "type": "calls"
        },
        {
          "target": "stdlib.uu.stat",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.uu.test",
      "name": "test",
      "module": "uu",
      "type": "function",
      "signature": "()",
      "description": "uuencode/uudecode main program",
      "relationships": [
        {
          "target": "stdlib.uu.OptionParser",
          "type": "calls"
        },
        {
          "target": "stdlib.uu.add_option",
          "type": "calls"
        },
        {
          "target": "stdlib.uu.add_option",
          "type": "calls"
        },
        {
          "target": "stdlib.uu.parse_args",
          "type": "calls"
        },
        {
          "target": "stdlib.uu.len",
          "type": "calls"
        },
        {
          "target": "stdlib.uu.error",
          "type": "calls"
        },
        {
          "target": "stdlib.uu.exit",
          "type": "calls"
        },
        {
          "target": "stdlib.uu.len",
          "type": "calls"
        },
        {
          "target": "stdlib.uu.len",
          "type": "calls"
        },
        {
          "target": "stdlib.uu.decode",
          "type": "calls"
        },
        {
          "target": "stdlib.uu.encode",
          "type": "calls"
        },
        {
          "target": "stdlib.uu.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.uu.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.uu.open",
          "type": "calls"
        },
        {
          "target": "stdlib.uu.print",
          "type": "calls"
        },
        {
          "target": "stdlib.uu.exit",
          "type": "calls"
        },
        {
          "target": "stdlib.uu.open",
          "type": "calls"
        },
        {
          "target": "stdlib.uu.print",
          "type": "calls"
        },
        {
          "target": "stdlib.uu.exit",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.uuid.Enum",
      "name": "Enum",
      "module": "uuid",
      "type": "class",
      "signature": "(value, names=None, *, module=None, qualname=None, type=None, start=1)",
      "description": "Generic enumeration.\n\nDerive from this class to define new enumerations.",
      "relationships": []
    },
    {
      "id": "stdlib.uuid.SafeUUID",
      "name": "SafeUUID",
      "module": "uuid",
      "type": "class",
      "signature": "(value, names=None, *, module=None, qualname=None, type=None, start=1)",
      "description": "An enumeration.",
      "relationships": [
        {
          "target": "Enum",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.uuid.UUID",
      "name": "UUID",
      "module": "uuid",
      "type": "class",
      "signature": "(hex=None, bytes=None, bytes_le=None, fields=None, int=None, version=None, *, is_safe=<SafeUUID.unknown: None>)",
      "description": "Instances of the UUID class represent UUIDs as specified in RFC 4122.\nUUID objects are immutable, hashable, and usable as dictionary keys.\nConverting a UUID to a string with str() yields something in the form\n'12345678-1234-1234-1234-123456789abc'.  The UUID constructor accepts\nfive possible forms: a similar string of hexadecimal digits, or a tuple\nof six integer fields (with 32-bit, 16-bit, 16-bit, 8-bit, 8-bit, and\n48-bit values respectively) as an argument named 'fields', or a string\nof 16 bytes (with all the integer fields in big-endian order) as an\nargument named 'bytes', or a string of 16 bytes (with the first three\nfields in little-endian order) as an argument named 'bytes_le', or a\nsingle 128-bit integer as an argument named 'int'.\n\nUUIDs have these read-only attributes:\n\n    bytes       the UUID as a 16-byte string (containing the six\n                integer fields in big-endian byte order)\n\n    bytes_le    the UUID as a 16-byte string (with time_low, time_mid,\n                and time_hi_version in little-endian byte order)\n\n    fields      a tuple of the six integer fields of the UUID,\n                which are also available as six individual attributes\n                and two derived attributes:\n\n        time_low                the first 32 bits of the UUID\n        time_mid                the next 16 bits of the UUID\n        time_hi_version         the next 16 bits of the UUID\n        clock_seq_hi_variant    the next 8 bits of the UUID\n        clock_seq_low           the next 8 bits of the UUID\n        node                    the last 48 bits of the UUID\n\n        time                    the 60-bit timestamp\n        clock_seq               the 14-bit sequence number\n\n    hex         the UUID as a 32-character hexadecimal string\n\n    int         the UUID as a 128-bit integer\n\n    urn         the UUID as a URN as specified in RFC 4122\n\n    variant     the UUID variant (one of the constants RESERVED_NCS,\n                RFC_4122, RESERVED_MICROSOFT, or RESERVED_FUTURE)\n\n    version     the UUID version number (1 through 5, meaningful only\n                when the variant is RFC_4122)\n\n    is_safe     An enum indicating whether the UUID has been generated in\n                a way that is safe for multiprocessing applications, via\n                uuid_generate_time_safe(3).",
      "relationships": []
    },
    {
      "id": "stdlib.uuid.getnode",
      "name": "getnode",
      "module": "uuid",
      "type": "function",
      "signature": "()",
      "description": "Get the hardware address as a 48-bit positive integer.\n\nThe first time this runs, it may launch a separate program, which could\nbe quite slow.  If all attempts to obtain the hardware address fail, we\nchoose a random 48-bit number with its eighth bit set to 1 as recommended\nin RFC 4122.",
      "relationships": [
        {
          "target": "stdlib.uuid.format",
          "type": "calls"
        },
        {
          "target": "stdlib.uuid.getter",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.uuid.uuid1",
      "name": "uuid1",
      "module": "uuid",
      "type": "function",
      "signature": "(node=None, clock_seq=None)",
      "description": "Generate a UUID from a host ID, sequence number, and the current time.\nIf 'node' is not given, getnode() is used to obtain the hardware\naddress.  If 'clock_seq' is given, it is used as the sequence number;\notherwise a random 14-bit sequence number is chosen.",
      "relationships": [
        {
          "target": "stdlib.uuid.time_ns",
          "type": "calls"
        },
        {
          "target": "stdlib.uuid.UUID",
          "type": "calls"
        },
        {
          "target": "stdlib.uuid._generate_time_safe",
          "type": "calls"
        },
        {
          "target": "stdlib.uuid.UUID",
          "type": "calls"
        },
        {
          "target": "stdlib.uuid.getrandbits",
          "type": "calls"
        },
        {
          "target": "stdlib.uuid.getnode",
          "type": "calls"
        },
        {
          "target": "stdlib.uuid.SafeUUID",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.uuid.uuid3",
      "name": "uuid3",
      "module": "uuid",
      "type": "function",
      "signature": "(namespace, name)",
      "description": "Generate a UUID from the MD5 hash of a namespace UUID and a name.",
      "relationships": [
        {
          "target": "stdlib.uuid.digest",
          "type": "calls"
        },
        {
          "target": "stdlib.uuid.UUID",
          "type": "calls"
        },
        {
          "target": "stdlib.uuid.md5",
          "type": "calls"
        },
        {
          "target": "stdlib.uuid.bytes",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.uuid.uuid4",
      "name": "uuid4",
      "module": "uuid",
      "type": "function",
      "signature": "()",
      "description": "Generate a random UUID.",
      "relationships": [
        {
          "target": "stdlib.uuid.UUID",
          "type": "calls"
        },
        {
          "target": "stdlib.uuid.urandom",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.uuid.uuid5",
      "name": "uuid5",
      "module": "uuid",
      "type": "function",
      "signature": "(namespace, name)",
      "description": "Generate a UUID from the SHA-1 hash of a namespace UUID and a name.",
      "relationships": [
        {
          "target": "stdlib.uuid.digest",
          "type": "calls"
        },
        {
          "target": "stdlib.uuid.UUID",
          "type": "calls"
        },
        {
          "target": "stdlib.uuid.sha1",
          "type": "calls"
        },
        {
          "target": "stdlib.uuid.bytes",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.venv.EnvBuilder",
      "name": "EnvBuilder",
      "module": "venv",
      "type": "class",
      "signature": "(system_site_packages=False, clear=False, symlinks=None, upgrade=False, with_pip=False, prompt=None, upgrade_deps=False)",
      "description": "This class exists to allow virtual environment creation to be\ncustomized. The constructor parameters determine the builder's\nbehaviour when called upon to create a virtual environment.\n\nBy default, the builder makes the system (global) site-packages dir\n*un*available to the created environment.\n\nIf invoked using the Python -m option, the default is to use copying\non Windows platforms but symlinks elsewhere. If instantiated some\nother way, the default is to *not* use symlinks.\n\n:param system_site_packages: If True, the system (global) site-packages\n                             dir is available to created environments.\n:param clear: If True, delete the contents of the environment directory if\n              it already exists, before environment creation.\n:param symlinks: If True, attempt to symlink rather than copy files into\n                 virtual environment.\n:param upgrade: If True, upgrade an existing virtual environment.\n:param with_pip: If True, ensure pip is installed in the virtual\n                 environment\n:param prompt: Alternative terminal prefix for the environment.\n:param upgrade_deps: Update the base venv modules to the latest on PyPI",
      "relationships": []
    },
    {
      "id": "stdlib.venv.create",
      "name": "create",
      "module": "venv",
      "type": "function",
      "signature": "(env_dir, system_site_packages=False, clear=False, symlinks=None, with_pip=False, prompt=None, upgrade_deps=False)",
      "description": "Create a virtual environment in a directory.",
      "relationships": [
        {
          "target": "stdlib.venv.EnvBuilder",
          "type": "calls"
        },
        {
          "target": "stdlib.venv.create",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.venv.main",
      "name": "main",
      "module": "venv",
      "type": "function",
      "signature": "(args=None)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.venv.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.venv.ArgumentParser",
          "type": "calls"
        },
        {
          "target": "stdlib.venv.add_argument",
          "type": "calls"
        },
        {
          "target": "stdlib.venv.add_argument",
          "type": "calls"
        },
        {
          "target": "stdlib.venv.add_mutually_exclusive_group",
          "type": "calls"
        },
        {
          "target": "stdlib.venv.add_argument",
          "type": "calls"
        },
        {
          "target": "stdlib.venv.add_argument",
          "type": "calls"
        },
        {
          "target": "stdlib.venv.add_argument",
          "type": "calls"
        },
        {
          "target": "stdlib.venv.add_argument",
          "type": "calls"
        },
        {
          "target": "stdlib.venv.add_argument",
          "type": "calls"
        },
        {
          "target": "stdlib.venv.add_argument",
          "type": "calls"
        },
        {
          "target": "stdlib.venv.add_argument",
          "type": "calls"
        },
        {
          "target": "stdlib.venv.parse_args",
          "type": "calls"
        },
        {
          "target": "stdlib.venv.EnvBuilder",
          "type": "calls"
        },
        {
          "target": "stdlib.venv.hasattr",
          "type": "calls"
        },
        {
          "target": "stdlib.venv.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.venv.create",
          "type": "calls"
        },
        {
          "target": "stdlib.venv.format",
          "type": "calls"
        },
        {
          "target": "stdlib.venv.join",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.venv.should_use_symlinks",
      "name": "should_use_symlinks",
      "module": "venv",
      "type": "function",
      "signature": "(symlinks=None)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.venv.get_config_var",
          "type": "calls"
        },
        {
          "target": "stdlib.venv.Exception",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.warnings.WarningMessage",
      "name": "WarningMessage",
      "module": "warnings",
      "type": "class",
      "signature": "(message, category, filename, lineno, file=None, line=None, source=None)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.warnings.catch_warnings",
      "name": "catch_warnings",
      "module": "warnings",
      "type": "class",
      "signature": "(*, record=False, module=None)",
      "description": "A context manager that copies and restores the warnings filter upon\nexiting the context.\n\nThe 'record' argument specifies whether warnings should be captured by a\ncustom implementation of warnings.showwarning() and be appended to a list\nreturned by the context manager. Otherwise None is returned by the context\nmanager. The objects appended to the list are arguments whose attributes\nmirror the arguments to showwarning().\n\nThe 'module' argument is to specify an alternative module to the module\nnamed 'warnings' and imported under that name. This argument is only useful\nwhen testing the warnings module itself.",
      "relationships": []
    },
    {
      "id": "stdlib.warnings.filterwarnings",
      "name": "filterwarnings",
      "module": "warnings",
      "type": "function",
      "signature": "(action, message='', category=<class 'Warning'>, module='', lineno=0, append=False)",
      "description": "Insert an entry into the list of warnings filters (at the front).\n\n'action' -- one of \"error\", \"ignore\", \"always\", \"default\", \"module\",\n            or \"once\"\n'message' -- a regex that the warning message must match\n'category' -- a class that the warning must be a subclass of\n'module' -- a regex that the module name must match\n'lineno' -- an integer line number, 0 matches all warnings\n'append' -- if true, append to the list of filters",
      "relationships": [
        {
          "target": "stdlib.warnings.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.warnings.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.warnings.issubclass",
          "type": "calls"
        },
        {
          "target": "stdlib.warnings.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.warnings._add_filter",
          "type": "calls"
        },
        {
          "target": "stdlib.warnings.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.warnings.compile",
          "type": "calls"
        },
        {
          "target": "stdlib.warnings.compile",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.warnings.formatwarning",
      "name": "formatwarning",
      "module": "warnings",
      "type": "function",
      "signature": "(message, category, filename, lineno, line=None)",
      "description": "Function to format a warning the standard way.",
      "relationships": [
        {
          "target": "stdlib.warnings.WarningMessage",
          "type": "calls"
        },
        {
          "target": "stdlib.warnings._formatwarnmsg_impl",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.warnings.resetwarnings",
      "name": "resetwarnings",
      "module": "warnings",
      "type": "function",
      "signature": "()",
      "description": "Clear the list of warning filters, so that no filters are active.",
      "relationships": [
        {
          "target": "stdlib.warnings._filters_mutated",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.warnings.showwarning",
      "name": "showwarning",
      "module": "warnings",
      "type": "function",
      "signature": "(message, category, filename, lineno, file=None, line=None)",
      "description": "Hook to write a warning to a file; replace if you like.",
      "relationships": [
        {
          "target": "stdlib.warnings.WarningMessage",
          "type": "calls"
        },
        {
          "target": "stdlib.warnings._showwarnmsg_impl",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.warnings.simplefilter",
      "name": "simplefilter",
      "module": "warnings",
      "type": "function",
      "signature": "(action, category=<class 'Warning'>, lineno=0, append=False)",
      "description": "Insert a simple entry into the list of warnings filters (at the front).\n\nA simple filter matches all modules and messages.\n'action' -- one of \"error\", \"ignore\", \"always\", \"default\", \"module\",\n            or \"once\"\n'category' -- a class that the warning must be a subclass of\n'lineno' -- an integer line number, 0 matches all warnings\n'append' -- if true, append to the list of filters",
      "relationships": [
        {
          "target": "stdlib.warnings._add_filter",
          "type": "calls"
        },
        {
          "target": "stdlib.warnings.isinstance",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.wave.Chunk",
      "name": "Chunk",
      "module": "wave",
      "type": "class",
      "signature": "(file, align=True, bigendian=True, inclheader=False)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.wave.Wave_read",
      "name": "Wave_read",
      "module": "wave",
      "type": "class",
      "signature": "(f)",
      "description": "Variables used in this class:\n\nThese variables are available to the user though appropriate\nmethods of this class:\n_file -- the open file with methods read(), close(), and seek()\n          set through the __init__() method\n_nchannels -- the number of audio channels\n          available through the getnchannels() method\n_nframes -- the number of audio frames\n          available through the getnframes() method\n_sampwidth -- the number of bytes per audio sample\n          available through the getsampwidth() method\n_framerate -- the sampling frequency\n          available through the getframerate() method\n_comptype -- the AIFF-C compression type ('NONE' if AIFF)\n          available through the getcomptype() method\n_compname -- the human-readable AIFF-C compression type\n          available through the getcomptype() method\n_soundpos -- the position in the audio stream\n          available through the tell() method, set through the\n          setpos() method\n\nThese variables are used internally only:\n_fmt_chunk_read -- 1 iff the FMT chunk has been read\n_data_seek_needed -- 1 iff positioned correctly in audio\n          file for readframes()\n_data_chunk -- instantiation of a chunk class for the DATA chunk\n_framesize -- size of one frame in the file",
      "relationships": []
    },
    {
      "id": "stdlib.wave.Wave_write",
      "name": "Wave_write",
      "module": "wave",
      "type": "class",
      "signature": "(f)",
      "description": "Variables used in this class:\n\nThese variables are user settable through appropriate methods\nof this class:\n_file -- the open file with methods write(), close(), tell(), seek()\n          set through the __init__() method\n_comptype -- the AIFF-C compression type ('NONE' in AIFF)\n          set through the setcomptype() or setparams() method\n_compname -- the human-readable AIFF-C compression type\n          set through the setcomptype() or setparams() method\n_nchannels -- the number of audio channels\n          set through the setnchannels() or setparams() method\n_sampwidth -- the number of bytes per audio sample\n          set through the setsampwidth() or setparams() method\n_framerate -- the sampling frequency\n          set through the setframerate() or setparams() method\n_nframes -- the number of audio frames written to the header\n          set through the setnframes() or setparams() method\n\nThese variables are used internally only:\n_datalength -- the size of the audio samples written to the header\n_nframeswritten -- the number of frames actually written\n_datawritten -- the size of the audio samples actually written",
      "relationships": []
    },
    {
      "id": "stdlib.wave.namedtuple",
      "name": "namedtuple",
      "module": "wave",
      "type": "function",
      "signature": "(typename, field_names, *, rename=False, defaults=None, module=None)",
      "description": "Returns a new subclass of tuple with named fields.\n\n>>> Point = namedtuple('Point', ['x', 'y'])\n>>> Point.__doc__                   # docstring for the new class\n'Point(x, y)'\n>>> p = Point(11, y=22)             # instantiate with positional args or keywords\n>>> p[0] + p[1]                     # indexable like a plain tuple\n33\n>>> x, y = p                        # unpack like a regular tuple\n>>> x, y\n(11, 22)\n>>> p.x + p.y                       # fields also accessible by name\n33\n>>> d = p._asdict()                 # convert to a dictionary\n>>> d['x']\n11\n>>> Point(**d)                      # convert from a dictionary\nPoint(x=11, y=22)\n>>> p._replace(x=100)               # _replace() is like str.replace() but targets named fields\nPoint(x=100, y=22)",
      "relationships": [
        {
          "target": "stdlib.wave.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.wave.list",
          "type": "calls"
        },
        {
          "target": "stdlib.wave.intern",
          "type": "calls"
        },
        {
          "target": "stdlib.wave.set",
          "type": "calls"
        },
        {
          "target": "stdlib.wave.tuple",
          "type": "calls"
        },
        {
          "target": "stdlib.wave.len",
          "type": "calls"
        },
        {
          "target": "stdlib.wave.join",
          "type": "calls"
        },
        {
          "target": "stdlib.wave.eval",
          "type": "calls"
        },
        {
          "target": "stdlib.wave.enumerate",
          "type": "calls"
        },
        {
          "target": "stdlib.wave.type",
          "type": "calls"
        },
        {
          "target": "stdlib.wave.split",
          "type": "calls"
        },
        {
          "target": "stdlib.wave.map",
          "type": "calls"
        },
        {
          "target": "stdlib.wave.str",
          "type": "calls"
        },
        {
          "target": "stdlib.wave.set",
          "type": "calls"
        },
        {
          "target": "stdlib.wave.enumerate",
          "type": "calls"
        },
        {
          "target": "stdlib.wave._iskeyword",
          "type": "calls"
        },
        {
          "target": "stdlib.wave.add",
          "type": "calls"
        },
        {
          "target": "stdlib.wave.tuple",
          "type": "calls"
        },
        {
          "target": "stdlib.wave.dict",
          "type": "calls"
        },
        {
          "target": "stdlib.wave.map",
          "type": "calls"
        },
        {
          "target": "stdlib.wave.tuple_new",
          "type": "calls"
        },
        {
          "target": "stdlib.wave._make",
          "type": "calls"
        },
        {
          "target": "stdlib.wave._dict",
          "type": "calls"
        },
        {
          "target": "stdlib.wave._tuple",
          "type": "calls"
        },
        {
          "target": "stdlib.wave.intern",
          "type": "calls"
        },
        {
          "target": "stdlib.wave._tuplegetter",
          "type": "calls"
        },
        {
          "target": "stdlib.wave.add",
          "type": "calls"
        },
        {
          "target": "stdlib.wave.type",
          "type": "calls"
        },
        {
          "target": "stdlib.wave.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.wave.isidentifier",
          "type": "calls"
        },
        {
          "target": "stdlib.wave.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.wave.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.wave.startswith",
          "type": "calls"
        },
        {
          "target": "stdlib.wave.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.wave.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.wave.len",
          "type": "calls"
        },
        {
          "target": "stdlib.wave.len",
          "type": "calls"
        },
        {
          "target": "stdlib.wave.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.wave.reversed",
          "type": "calls"
        },
        {
          "target": "stdlib.wave.join",
          "type": "calls"
        },
        {
          "target": "stdlib.wave._len",
          "type": "calls"
        },
        {
          "target": "stdlib.wave.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.wave._map",
          "type": "calls"
        },
        {
          "target": "stdlib.wave.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.wave._zip",
          "type": "calls"
        },
        {
          "target": "stdlib.wave.get",
          "type": "calls"
        },
        {
          "target": "stdlib.wave.replace",
          "type": "calls"
        },
        {
          "target": "stdlib.wave._iskeyword",
          "type": "calls"
        },
        {
          "target": "stdlib.wave.startswith",
          "type": "calls"
        },
        {
          "target": "stdlib.wave.list",
          "type": "calls"
        },
        {
          "target": "stdlib.wave.isidentifier",
          "type": "calls"
        },
        {
          "target": "stdlib.wave.zip",
          "type": "calls"
        },
        {
          "target": "stdlib.wave.reversed",
          "type": "calls"
        },
        {
          "target": "stdlib.wave.reversed",
          "type": "calls"
        },
        {
          "target": "stdlib.wave.len",
          "type": "calls"
        },
        {
          "target": "stdlib.wave.list",
          "type": "calls"
        },
        {
          "target": "stdlib.wave._getframe",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.wave.open",
      "name": "open",
      "module": "wave",
      "type": "function",
      "signature": "(f, mode=None)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.wave.hasattr",
          "type": "calls"
        },
        {
          "target": "stdlib.wave.Wave_read",
          "type": "calls"
        },
        {
          "target": "stdlib.wave.Wave_write",
          "type": "calls"
        },
        {
          "target": "stdlib.wave.Error",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.weakref.CallableProxyType",
      "name": "CallableProxyType",
      "module": "weakref",
      "type": "class",
      "signature": "()",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.weakref.KeyedRef",
      "name": "KeyedRef",
      "module": "weakref",
      "type": "class",
      "signature": "(ob, callback, key)",
      "description": "Specialized reference that includes a key corresponding to the value.\n\nThis is used in the WeakValueDictionary to avoid having to create\na function object for each key stored in the mapping.  A shared\ncallback object can use the 'key' attribute of a KeyedRef instead\nof getting a reference to the key from an enclosing scope.",
      "relationships": [
        {
          "target": "weakref",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.weakref.ProxyType",
      "name": "ProxyType",
      "module": "weakref",
      "type": "class",
      "signature": "()",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.weakref.WeakKeyDictionary",
      "name": "WeakKeyDictionary",
      "module": "weakref",
      "type": "class",
      "signature": "(dict=None)",
      "description": "Mapping class that references keys weakly.\n\nEntries in the dictionary will be discarded when there is no\nlonger a strong reference to the key. This can be used to\nassociate additional data with an object owned by other parts of\nan application without adding attributes to those objects. This\ncan be especially useful with objects that override attribute\naccesses.",
      "relationships": [
        {
          "target": "MutableMapping",
          "type": "base_class"
        },
        {
          "target": "Mapping",
          "type": "base_class"
        },
        {
          "target": "Collection",
          "type": "base_class"
        },
        {
          "target": "Sized",
          "type": "base_class"
        },
        {
          "target": "Iterable",
          "type": "base_class"
        },
        {
          "target": "Container",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.weakref.WeakMethod",
      "name": "WeakMethod",
      "module": "weakref",
      "type": "class",
      "signature": "(meth, callback=None)",
      "description": "A custom `weakref.ref` subclass which simulates a weak reference to\na bound method, working around the lifetime problem of bound methods.",
      "relationships": [
        {
          "target": "weakref",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.weakref.WeakSet",
      "name": "WeakSet",
      "module": "weakref",
      "type": "class",
      "signature": "(data=None)",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.weakref.WeakValueDictionary",
      "name": "WeakValueDictionary",
      "module": "weakref",
      "type": "class",
      "signature": "(other=(), /, **kw)",
      "description": "Mapping class that references values weakly.\n\nEntries in the dictionary will be discarded when no strong\nreference to the value exists anymore",
      "relationships": [
        {
          "target": "MutableMapping",
          "type": "base_class"
        },
        {
          "target": "Mapping",
          "type": "base_class"
        },
        {
          "target": "Collection",
          "type": "base_class"
        },
        {
          "target": "Sized",
          "type": "base_class"
        },
        {
          "target": "Iterable",
          "type": "base_class"
        },
        {
          "target": "Container",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.weakref.finalize",
      "name": "finalize",
      "module": "weakref",
      "type": "class",
      "signature": "(obj, func, /, *args, **kwargs)",
      "description": "Class for finalization of weakrefable objects\n\nfinalize(obj, func, *args, **kwargs) returns a callable finalizer\nobject which will be called when obj is garbage collected. The\nfirst time the finalizer is called it evaluates func(*arg, **kwargs)\nand returns the result. After this the finalizer is dead, and\ncalling it just returns None.\n\nWhen the program exits any remaining finalizers for which the\natexit attribute is true will be run in reverse order of creation.\nBy default atexit is true.",
      "relationships": []
    },
    {
      "id": "stdlib.webbrowser.BackgroundBrowser",
      "name": "BackgroundBrowser",
      "module": "webbrowser",
      "type": "class",
      "signature": "(name)",
      "description": "Class for all browsers which are to be started in the\nbackground.",
      "relationships": [
        {
          "target": "GenericBrowser",
          "type": "base_class"
        },
        {
          "target": "BaseBrowser",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.webbrowser.BaseBrowser",
      "name": "BaseBrowser",
      "module": "webbrowser",
      "type": "class",
      "signature": "(name='')",
      "description": "Parent class for all browsers. Do not use directly.",
      "relationships": []
    },
    {
      "id": "stdlib.webbrowser.Chrome",
      "name": "Chrome",
      "module": "webbrowser",
      "type": "class",
      "signature": "(name='')",
      "description": "Launcher class for Google Chrome browser.",
      "relationships": [
        {
          "target": "UnixBrowser",
          "type": "base_class"
        },
        {
          "target": "BaseBrowser",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.webbrowser.Chromium",
      "name": "Chromium",
      "module": "webbrowser",
      "type": "class",
      "signature": "(name='')",
      "description": "Launcher class for Google Chrome browser.",
      "relationships": [
        {
          "target": "UnixBrowser",
          "type": "base_class"
        },
        {
          "target": "BaseBrowser",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.webbrowser.Elinks",
      "name": "Elinks",
      "module": "webbrowser",
      "type": "class",
      "signature": "(name='')",
      "description": "Launcher class for Elinks browsers.",
      "relationships": [
        {
          "target": "UnixBrowser",
          "type": "base_class"
        },
        {
          "target": "BaseBrowser",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.webbrowser.Galeon",
      "name": "Galeon",
      "module": "webbrowser",
      "type": "class",
      "signature": "(name='')",
      "description": "Launcher class for Galeon/Epiphany browsers.",
      "relationships": [
        {
          "target": "UnixBrowser",
          "type": "base_class"
        },
        {
          "target": "BaseBrowser",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.webbrowser.GenericBrowser",
      "name": "GenericBrowser",
      "module": "webbrowser",
      "type": "class",
      "signature": "(name)",
      "description": "Class for all browsers started with a command\nand without remote functionality.",
      "relationships": [
        {
          "target": "BaseBrowser",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.webbrowser.Grail",
      "name": "Grail",
      "module": "webbrowser",
      "type": "class",
      "signature": "(name='')",
      "description": "Parent class for all browsers. Do not use directly.",
      "relationships": [
        {
          "target": "BaseBrowser",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.webbrowser.Konqueror",
      "name": "Konqueror",
      "module": "webbrowser",
      "type": "class",
      "signature": "(name='')",
      "description": "Controller for the KDE File Manager (kfm, or Konqueror).\n\nSee the output of ``kfmclient --commands``\nfor more information on the Konqueror remote-control interface.",
      "relationships": [
        {
          "target": "BaseBrowser",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.webbrowser.MacOSX",
      "name": "MacOSX",
      "module": "webbrowser",
      "type": "class",
      "signature": "(name)",
      "description": "Launcher class for Aqua browsers on Mac OS X\n\nOptionally specify a browser name on instantiation.  Note that this\nwill not work for Aqua browsers if the user has moved the application\npackage after installation.\n\nIf no browser is specified, the default browser, as specified in the\nInternet System Preferences panel, will be used.",
      "relationships": [
        {
          "target": "BaseBrowser",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.webbrowser.MacOSXOSAScript",
      "name": "MacOSXOSAScript",
      "module": "webbrowser",
      "type": "class",
      "signature": "(name)",
      "description": "Parent class for all browsers. Do not use directly.",
      "relationships": [
        {
          "target": "BaseBrowser",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.webbrowser.Mozilla",
      "name": "Mozilla",
      "module": "webbrowser",
      "type": "class",
      "signature": "(name='')",
      "description": "Launcher class for Mozilla browsers.",
      "relationships": [
        {
          "target": "UnixBrowser",
          "type": "base_class"
        },
        {
          "target": "BaseBrowser",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.webbrowser.Netscape",
      "name": "Netscape",
      "module": "webbrowser",
      "type": "class",
      "signature": "(name='')",
      "description": "Launcher class for Netscape browser.",
      "relationships": [
        {
          "target": "UnixBrowser",
          "type": "base_class"
        },
        {
          "target": "BaseBrowser",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.webbrowser.Opera",
      "name": "Opera",
      "module": "webbrowser",
      "type": "class",
      "signature": "(name='')",
      "description": "Launcher class for Opera browser.",
      "relationships": [
        {
          "target": "UnixBrowser",
          "type": "base_class"
        },
        {
          "target": "BaseBrowser",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.webbrowser.UnixBrowser",
      "name": "UnixBrowser",
      "module": "webbrowser",
      "type": "class",
      "signature": "(name='')",
      "description": "Parent class for all Unix browsers with remote functionality.",
      "relationships": [
        {
          "target": "BaseBrowser",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.webbrowser.get",
      "name": "get",
      "module": "webbrowser",
      "type": "function",
      "signature": "(using=None)",
      "description": "Return a browser launcher instance appropriate for the environment.",
      "relationships": [
        {
          "target": "stdlib.webbrowser.Error",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.split",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.register_standard_browsers",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.BackgroundBrowser",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.GenericBrowser",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.lower",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser._synthesize",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.webbrowser.main",
      "name": "main",
      "module": "webbrowser",
      "type": "function",
      "signature": "()",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.webbrowser.open",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.print",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.getopt",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.len",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.print",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.exit",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.print",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.print",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.exit",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.webbrowser.open",
      "name": "open",
      "module": "webbrowser",
      "type": "function",
      "signature": "(url, new=0, autoraise=True)",
      "description": "Display url using the default browser.\n\nIf possible, open url in a location determined by new.\n- 0: the same browser window (the default).\n- 1: a new browser window.\n- 2: a new browser page (\"tab\").\nIf possible, autoraise raises the window (the default) or not.",
      "relationships": [
        {
          "target": "stdlib.webbrowser.get",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.open",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.register_standard_browsers",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.webbrowser.open_new",
      "name": "open_new",
      "module": "webbrowser",
      "type": "function",
      "signature": "(url)",
      "description": "Open url in a new window of the default browser.\n\nIf not possible, then open url in the only browser window.",
      "relationships": [
        {
          "target": "stdlib.webbrowser.open",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.webbrowser.open_new_tab",
      "name": "open_new_tab",
      "module": "webbrowser",
      "type": "function",
      "signature": "(url)",
      "description": "Open url in a new page (\"tab\") of the default browser.\n\nIf not possible, then the behavior becomes equivalent to open_new().",
      "relationships": [
        {
          "target": "stdlib.webbrowser.open",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.webbrowser.register",
      "name": "register",
      "module": "webbrowser",
      "type": "function",
      "signature": "(name, klass, instance=None, *, preferred=False)",
      "description": "Register a browser connector.",
      "relationships": [
        {
          "target": "stdlib.webbrowser.register_standard_browsers",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.lower",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.insert",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.append",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.webbrowser.register_X_browsers",
      "name": "register_X_browsers",
      "module": "webbrowser",
      "type": "function",
      "signature": "()",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.webbrowser.which",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.which",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.which",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.which",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.which",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.which",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.which",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.register",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.which",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.register",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.which",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.register",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.which",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.register",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.register",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.which",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.which",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.register",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.which",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.which",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.register",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.which",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.register",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.register",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.register",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.BackgroundBrowser",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.BackgroundBrowser",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.BackgroundBrowser",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.Konqueror",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.BackgroundBrowser",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.register",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.register",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.Konqueror",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.register",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.register",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.BackgroundBrowser",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.register",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.Opera",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.BackgroundBrowser",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.Mozilla",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.Netscape",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.Konqueror",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.Galeon",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.Chrome",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.webbrowser.register_standard_browsers",
      "name": "register_standard_browsers",
      "module": "webbrowser",
      "type": "function",
      "signature": "()",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.webbrowser.register",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.register",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.register",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.register",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.register",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.join",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.get",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.split",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.reverse",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.MacOSXOSAScript",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.MacOSXOSAScript",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.MacOSXOSAScript",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.MacOSXOSAScript",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.get",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.which",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.get",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.get",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.register_X_browsers",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.which",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.which",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.which",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.which",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.which",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.register",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.split",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.check_output",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.strip",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.register",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.register",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.register",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.register",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.register",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser._synthesize",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.BackgroundBrowser",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.GenericBrowser",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.GenericBrowser",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.Elinks",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.GenericBrowser",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.GenericBrowser",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.register",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.decode",
          "type": "calls"
        },
        {
          "target": "stdlib.webbrowser.GenericBrowser",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.xdrlib.BytesIO",
      "name": "BytesIO",
      "module": "xdrlib",
      "type": "class",
      "signature": "(initial_bytes=b'')",
      "description": "Buffered I/O implementation using an in-memory bytes buffer.",
      "relationships": [
        {
          "target": "_BufferedIOBase",
          "type": "base_class"
        },
        {
          "target": "_IOBase",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.xdrlib.ConversionError",
      "name": "ConversionError",
      "module": "xdrlib",
      "type": "class",
      "signature": "(msg)",
      "description": "Exception class for this module. Use:\n\nexcept xdrlib.Error as var:\n    # var has the Error instance for the exception\n\nPublic ivars:\n    msg -- contains the message",
      "relationships": [
        {
          "target": "Error",
          "type": "base_class"
        },
        {
          "target": "Exception",
          "type": "base_class"
        },
        {
          "target": "BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.xdrlib.Error",
      "name": "Error",
      "module": "xdrlib",
      "type": "class",
      "signature": "(msg)",
      "description": "Exception class for this module. Use:\n\nexcept xdrlib.Error as var:\n    # var has the Error instance for the exception\n\nPublic ivars:\n    msg -- contains the message",
      "relationships": [
        {
          "target": "Exception",
          "type": "base_class"
        },
        {
          "target": "BaseException",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.xdrlib.Packer",
      "name": "Packer",
      "module": "xdrlib",
      "type": "class",
      "signature": "()",
      "description": "Pack various data representations into a buffer.",
      "relationships": []
    },
    {
      "id": "stdlib.xdrlib.Unpacker",
      "name": "Unpacker",
      "module": "xdrlib",
      "type": "class",
      "signature": "(data)",
      "description": "Unpacks various data representations from the given buffer.",
      "relationships": []
    },
    {
      "id": "stdlib.xdrlib.raise_conversion_error",
      "name": "raise_conversion_error",
      "module": "xdrlib",
      "type": "function",
      "signature": "(function)",
      "description": "Wrap any raised struct.errors in a ConversionError. ",
      "relationships": [
        {
          "target": "stdlib.xdrlib.wraps",
          "type": "calls"
        },
        {
          "target": "stdlib.xdrlib.function",
          "type": "calls"
        },
        {
          "target": "stdlib.xdrlib.ConversionError",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.xdrlib.wraps",
      "name": "wraps",
      "module": "xdrlib",
      "type": "function",
      "signature": "(wrapped, assigned=('__module__', '__name__', '__qualname__', '__doc__', '__annotations__'), updated=('__dict__',))",
      "description": "Decorator factory to apply update_wrapper() to a wrapper function\n\nReturns a decorator that invokes update_wrapper() with the decorated\nfunction as the wrapper argument and the arguments to wraps() as the\nremaining arguments. Default arguments are as for update_wrapper().\nThis is a convenience function to simplify applying partial() to\nupdate_wrapper().",
      "relationships": [
        {
          "target": "stdlib.xdrlib.partial",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.zipapp.create_archive",
      "name": "create_archive",
      "module": "zipapp",
      "type": "function",
      "signature": "(source, target=None, interpreter=None, main=None, filter=None, compressed=False)",
      "description": "Create an application archive from SOURCE.\n\nThe SOURCE can be the name of a directory, or a filename or a file-like\nobject referring to an existing archive.\n\nThe content of SOURCE is packed into an application archive in TARGET,\nwhich can be a filename or a file-like object.  If SOURCE is a directory,\nTARGET can be omitted and will default to the name of SOURCE with .pyz\nappended.\n\nThe created application archive will have a shebang line specifying\nthat it should run with INTERPRETER (there will be no shebang line if\nINTERPRETER is None), and a __main__.py which runs MAIN (if MAIN is\nnot specified, an existing __main__.py will be used).  It is an error\nto specify MAIN for anything other than a directory source with no\n__main__.py, and it is an error to omit MAIN if the directory has no\n__main__.py.",
      "relationships": [
        {
          "target": "stdlib.zipapp.is_file",
          "type": "calls"
        },
        {
          "target": "stdlib.zipapp.hasattr",
          "type": "calls"
        },
        {
          "target": "stdlib.zipapp.hasattr",
          "type": "calls"
        },
        {
          "target": "stdlib.zipapp.Path",
          "type": "calls"
        },
        {
          "target": "stdlib.zipapp.is_file",
          "type": "calls"
        },
        {
          "target": "stdlib.zipapp._copy_archive",
          "type": "calls"
        },
        {
          "target": "stdlib.zipapp.exists",
          "type": "calls"
        },
        {
          "target": "stdlib.zipapp.ZipAppError",
          "type": "calls"
        },
        {
          "target": "stdlib.zipapp.ZipAppError",
          "type": "calls"
        },
        {
          "target": "stdlib.zipapp.ZipAppError",
          "type": "calls"
        },
        {
          "target": "stdlib.zipapp.partition",
          "type": "calls"
        },
        {
          "target": "stdlib.zipapp.all",
          "type": "calls"
        },
        {
          "target": "stdlib.zipapp.all",
          "type": "calls"
        },
        {
          "target": "stdlib.zipapp.format",
          "type": "calls"
        },
        {
          "target": "stdlib.zipapp.with_suffix",
          "type": "calls"
        },
        {
          "target": "stdlib.zipapp._maybe_open",
          "type": "calls"
        },
        {
          "target": "stdlib.zipapp._write_file_prefix",
          "type": "calls"
        },
        {
          "target": "stdlib.zipapp.chmod",
          "type": "calls"
        },
        {
          "target": "stdlib.zipapp.ZipAppError",
          "type": "calls"
        },
        {
          "target": "stdlib.zipapp.hasattr",
          "type": "calls"
        },
        {
          "target": "stdlib.zipapp.Path",
          "type": "calls"
        },
        {
          "target": "stdlib.zipapp.ZipFile",
          "type": "calls"
        },
        {
          "target": "stdlib.zipapp.rglob",
          "type": "calls"
        },
        {
          "target": "stdlib.zipapp.hasattr",
          "type": "calls"
        },
        {
          "target": "stdlib.zipapp.isidentifier",
          "type": "calls"
        },
        {
          "target": "stdlib.zipapp.isidentifier",
          "type": "calls"
        },
        {
          "target": "stdlib.zipapp.relative_to",
          "type": "calls"
        },
        {
          "target": "stdlib.zipapp.writestr",
          "type": "calls"
        },
        {
          "target": "stdlib.zipapp.split",
          "type": "calls"
        },
        {
          "target": "stdlib.zipapp.split",
          "type": "calls"
        },
        {
          "target": "stdlib.zipapp.filter",
          "type": "calls"
        },
        {
          "target": "stdlib.zipapp.write",
          "type": "calls"
        },
        {
          "target": "stdlib.zipapp.encode",
          "type": "calls"
        },
        {
          "target": "stdlib.zipapp.stat",
          "type": "calls"
        },
        {
          "target": "stdlib.zipapp.as_posix",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.zipapp.get_interpreter",
      "name": "get_interpreter",
      "module": "zipapp",
      "type": "function",
      "signature": "(archive)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.zipapp._maybe_open",
          "type": "calls"
        },
        {
          "target": "stdlib.zipapp.read",
          "type": "calls"
        },
        {
          "target": "stdlib.zipapp.decode",
          "type": "calls"
        },
        {
          "target": "stdlib.zipapp.strip",
          "type": "calls"
        },
        {
          "target": "stdlib.zipapp.readline",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.zipapp.main",
      "name": "main",
      "module": "zipapp",
      "type": "function",
      "signature": "(args=None)",
      "description": "Run the zipapp command line interface.\n\nThe ARGS parameter lets you specify the argument list directly.\nOmitting ARGS (or setting it to None) works as for argparse, using\nsys.argv[1:] as the argument list.",
      "relationships": [
        {
          "target": "stdlib.zipapp.ArgumentParser",
          "type": "calls"
        },
        {
          "target": "stdlib.zipapp.add_argument",
          "type": "calls"
        },
        {
          "target": "stdlib.zipapp.add_argument",
          "type": "calls"
        },
        {
          "target": "stdlib.zipapp.add_argument",
          "type": "calls"
        },
        {
          "target": "stdlib.zipapp.add_argument",
          "type": "calls"
        },
        {
          "target": "stdlib.zipapp.add_argument",
          "type": "calls"
        },
        {
          "target": "stdlib.zipapp.add_argument",
          "type": "calls"
        },
        {
          "target": "stdlib.zipapp.parse_args",
          "type": "calls"
        },
        {
          "target": "stdlib.zipapp.isfile",
          "type": "calls"
        },
        {
          "target": "stdlib.zipapp.create_archive",
          "type": "calls"
        },
        {
          "target": "stdlib.zipapp.get_interpreter",
          "type": "calls"
        },
        {
          "target": "stdlib.zipapp.print",
          "type": "calls"
        },
        {
          "target": "stdlib.zipapp.exit",
          "type": "calls"
        },
        {
          "target": "stdlib.zipapp.isfile",
          "type": "calls"
        },
        {
          "target": "stdlib.zipapp.SystemExit",
          "type": "calls"
        },
        {
          "target": "stdlib.zipapp.format",
          "type": "calls"
        },
        {
          "target": "stdlib.zipapp.SystemExit",
          "type": "calls"
        },
        {
          "target": "stdlib.zipapp.SystemExit",
          "type": "calls"
        },
        {
          "target": "stdlib.zipapp.exists",
          "type": "calls"
        },
        {
          "target": "stdlib.zipapp.samefile",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.zipfile.CompleteDirs",
      "name": "CompleteDirs",
      "module": "zipfile",
      "type": "class",
      "signature": "(file, mode='r', compression=0, allowZip64=True, compresslevel=None, *, strict_timestamps=True)",
      "description": "A ZipFile subclass that ensures that implied directories\nare always included in the namelist.",
      "relationships": [
        {
          "target": "ZipFile",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.zipfile.FastLookup",
      "name": "FastLookup",
      "module": "zipfile",
      "type": "class",
      "signature": "(file, mode='r', compression=0, allowZip64=True, compresslevel=None, *, strict_timestamps=True)",
      "description": "ZipFile subclass to ensure implicit\ndirs exist and are resolved rapidly.",
      "relationships": [
        {
          "target": "CompleteDirs",
          "type": "base_class"
        },
        {
          "target": "ZipFile",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.zipfile.LZMACompressor",
      "name": "LZMACompressor",
      "module": "zipfile",
      "type": "class",
      "signature": "()",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.zipfile.LZMADecompressor",
      "name": "LZMADecompressor",
      "module": "zipfile",
      "type": "class",
      "signature": "()",
      "description": "",
      "relationships": []
    },
    {
      "id": "stdlib.zipfile.Path",
      "name": "Path",
      "module": "zipfile",
      "type": "class",
      "signature": "(root, at='')",
      "description": "A pathlib-compatible interface for zip files.\n\nConsider a zip file with this structure::\n\n    .\n    \u251c\u2500\u2500 a.txt\n    \u2514\u2500\u2500 b\n        \u251c\u2500\u2500 c.txt\n        \u2514\u2500\u2500 d\n            \u2514\u2500\u2500 e.txt\n\n>>> data = io.BytesIO()\n>>> zf = ZipFile(data, 'w')\n>>> zf.writestr('a.txt', 'content of a')\n>>> zf.writestr('b/c.txt', 'content of c')\n>>> zf.writestr('b/d/e.txt', 'content of e')\n>>> zf.filename = 'abcde.zip'\n\nPath accepts the zipfile object itself or a filename\n\n>>> root = Path(zf)\n\nFrom there, several path operations are available.\n\nDirectory iteration (including the zip file itself):\n\n>>> a, b = root.iterdir()\n>>> a\nPath('abcde.zip', 'a.txt')\n>>> b\nPath('abcde.zip', 'b/')\n\nname property:\n\n>>> b.name\n'b'\n\njoin with divide operator:\n\n>>> c = b / 'c.txt'\n>>> c\nPath('abcde.zip', 'b/c.txt')\n>>> c.name\n'c.txt'\n\nRead text:\n\n>>> c.read_text()\n'content of c'\n\nexistence:\n\n>>> c.exists()\nTrue\n>>> (b / 'missing.txt').exists()\nFalse\n\nCoercion to string:\n\n>>> str(c)\n'abcde.zip/b/c.txt'",
      "relationships": []
    },
    {
      "id": "stdlib.zipfile.PyZipFile",
      "name": "PyZipFile",
      "module": "zipfile",
      "type": "class",
      "signature": "(file, mode='r', compression=0, allowZip64=True, optimize=-1)",
      "description": "Class to create ZIP archives with Python library files and packages.",
      "relationships": [
        {
          "target": "ZipFile",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.zipfile.ZipExtFile",
      "name": "ZipExtFile",
      "module": "zipfile",
      "type": "class",
      "signature": "(fileobj, mode, zipinfo, pwd=None, close_fileobj=False)",
      "description": "File-like object for reading an archive member.\nIs returned by ZipFile.open().",
      "relationships": [
        {
          "target": "BufferedIOBase",
          "type": "base_class"
        },
        {
          "target": "_BufferedIOBase",
          "type": "base_class"
        },
        {
          "target": "IOBase",
          "type": "base_class"
        },
        {
          "target": "_IOBase",
          "type": "base_class"
        }
      ]
    },
    {
      "id": "stdlib.zipfile.ZipFile",
      "name": "ZipFile",
      "module": "zipfile",
      "type": "class",
      "signature": "(file, mode='r', compression=0, allowZip64=True, compresslevel=None, *, strict_timestamps=True)",
      "description": "Class with methods to open, read, write, close, list zip files.\n\nz = ZipFile(file, mode=\"r\", compression=ZIP_STORED, allowZip64=True,\n            compresslevel=None)\n\nfile: Either the path to the file, or a file-like object.\n      If it is a path, the file will be opened and closed by ZipFile.\nmode: The mode can be either read 'r', write 'w', exclusive create 'x',\n      or append 'a'.\ncompression: ZIP_STORED (no compression), ZIP_DEFLATED (requires zlib),\n             ZIP_BZIP2 (requires bz2) or ZIP_LZMA (requires lzma).\nallowZip64: if True ZipFile will create files with ZIP64 extensions when\n            needed, otherwise it will raise an exception when this would\n            be necessary.\ncompresslevel: None (default for the given compression type) or an integer\n               specifying the level to pass to the compressor.\n               When using ZIP_STORED or ZIP_LZMA this keyword has no effect.\n               When using ZIP_DEFLATED integers 0 through 9 are accepted.\n               When using ZIP_BZIP2 integers 1 through 9 are accepted.",
      "relationships": []
    },
    {
      "id": "stdlib.zipfile.ZipInfo",
      "name": "ZipInfo",
      "module": "zipfile",
      "type": "class",
      "signature": "(filename='NoName', date_time=(1980, 1, 1, 0, 0, 0))",
      "description": "Class with attributes describing each file in the ZIP archive.",
      "relationships": []
    },
    {
      "id": "stdlib.zipfile.is_zipfile",
      "name": "is_zipfile",
      "module": "zipfile",
      "type": "function",
      "signature": "(filename)",
      "description": "Quickly see if a file is a ZIP file by checking the magic number.\n\nThe filename argument may be a file or file-like object too.",
      "relationships": [
        {
          "target": "stdlib.zipfile.hasattr",
          "type": "calls"
        },
        {
          "target": "stdlib.zipfile._check_zipfile",
          "type": "calls"
        },
        {
          "target": "stdlib.zipfile.open",
          "type": "calls"
        },
        {
          "target": "stdlib.zipfile._check_zipfile",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.zipfile.main",
      "name": "main",
      "module": "zipfile",
      "type": "function",
      "signature": "(args=None)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.zipfile.ArgumentParser",
          "type": "calls"
        },
        {
          "target": "stdlib.zipfile.add_mutually_exclusive_group",
          "type": "calls"
        },
        {
          "target": "stdlib.zipfile.add_argument",
          "type": "calls"
        },
        {
          "target": "stdlib.zipfile.add_argument",
          "type": "calls"
        },
        {
          "target": "stdlib.zipfile.add_argument",
          "type": "calls"
        },
        {
          "target": "stdlib.zipfile.add_argument",
          "type": "calls"
        },
        {
          "target": "stdlib.zipfile.parse_args",
          "type": "calls"
        },
        {
          "target": "stdlib.zipfile.print",
          "type": "calls"
        },
        {
          "target": "stdlib.zipfile.ZipFile",
          "type": "calls"
        },
        {
          "target": "stdlib.zipfile.testzip",
          "type": "calls"
        },
        {
          "target": "stdlib.zipfile.print",
          "type": "calls"
        },
        {
          "target": "stdlib.zipfile.format",
          "type": "calls"
        },
        {
          "target": "stdlib.zipfile.ZipFile",
          "type": "calls"
        },
        {
          "target": "stdlib.zipfile.printdir",
          "type": "calls"
        },
        {
          "target": "stdlib.zipfile.ZipFile",
          "type": "calls"
        },
        {
          "target": "stdlib.zipfile.extractall",
          "type": "calls"
        },
        {
          "target": "stdlib.zipfile.pop",
          "type": "calls"
        },
        {
          "target": "stdlib.zipfile.isfile",
          "type": "calls"
        },
        {
          "target": "stdlib.zipfile.ZipFile",
          "type": "calls"
        },
        {
          "target": "stdlib.zipfile.write",
          "type": "calls"
        },
        {
          "target": "stdlib.zipfile.isdir",
          "type": "calls"
        },
        {
          "target": "stdlib.zipfile.basename",
          "type": "calls"
        },
        {
          "target": "stdlib.zipfile.addToZip",
          "type": "calls"
        },
        {
          "target": "stdlib.zipfile.sorted",
          "type": "calls"
        },
        {
          "target": "stdlib.zipfile.basename",
          "type": "calls"
        },
        {
          "target": "stdlib.zipfile.write",
          "type": "calls"
        },
        {
          "target": "stdlib.zipfile.listdir",
          "type": "calls"
        },
        {
          "target": "stdlib.zipfile.addToZip",
          "type": "calls"
        },
        {
          "target": "stdlib.zipfile.dirname",
          "type": "calls"
        },
        {
          "target": "stdlib.zipfile.join",
          "type": "calls"
        },
        {
          "target": "stdlib.zipfile.join",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.zipimport.zipimporter",
      "name": "zipimporter",
      "module": "zipimport",
      "type": "class",
      "signature": "(path)",
      "description": "zipimporter(archivepath) -> zipimporter object\n\nCreate a new zipimporter instance. 'archivepath' must be a path to\na zipfile, or to a specific path inside a zipfile. For example, it can be\n'/tmp/myimport.zip', or '/tmp/myimport.zip/mydirectory', if mydirectory is a\nvalid directory inside the archive.\n\n'ZipImportError is raised if 'archivepath' doesn't point to a valid Zip\narchive.\n\nThe 'archive' attribute of zipimporter objects contains the name of the\nzipfile targeted.",
      "relationships": []
    },
    {
      "id": "stdlib.zoneinfo.available_timezones",
      "name": "available_timezones",
      "module": "zoneinfo",
      "type": "function",
      "signature": "()",
      "description": "Returns a set containing all available time zones.\n\n.. caution::\n\n    This may attempt to open a large number of files, since the best way to\n    determine if a given file on the time zone search path is to open it\n    and check for the \"magic string\" at the beginning.",
      "relationships": [
        {
          "target": "stdlib.zoneinfo.set",
          "type": "calls"
        },
        {
          "target": "stdlib.zoneinfo.walk",
          "type": "calls"
        },
        {
          "target": "stdlib.zoneinfo.remove",
          "type": "calls"
        },
        {
          "target": "stdlib.zoneinfo.open_text",
          "type": "calls"
        },
        {
          "target": "stdlib.zoneinfo.exists",
          "type": "calls"
        },
        {
          "target": "stdlib.zoneinfo.strip",
          "type": "calls"
        },
        {
          "target": "stdlib.zoneinfo.open",
          "type": "calls"
        },
        {
          "target": "stdlib.zoneinfo.join",
          "type": "calls"
        },
        {
          "target": "stdlib.zoneinfo.relpath",
          "type": "calls"
        },
        {
          "target": "stdlib.zoneinfo.valid_key",
          "type": "calls"
        },
        {
          "target": "stdlib.zoneinfo.add",
          "type": "calls"
        },
        {
          "target": "stdlib.zoneinfo.read",
          "type": "calls"
        },
        {
          "target": "stdlib.zoneinfo.remove",
          "type": "calls"
        },
        {
          "target": "stdlib.zoneinfo.remove",
          "type": "calls"
        },
        {
          "target": "stdlib.zoneinfo.replace",
          "type": "calls"
        },
        {
          "target": "stdlib.zoneinfo.add",
          "type": "calls"
        }
      ]
    },
    {
      "id": "stdlib.zoneinfo.reset_tzpath",
      "name": "reset_tzpath",
      "module": "zoneinfo",
      "type": "function",
      "signature": "(to=None)",
      "description": "",
      "relationships": [
        {
          "target": "stdlib.zoneinfo.tuple",
          "type": "calls"
        },
        {
          "target": "stdlib.zoneinfo.isinstance",
          "type": "calls"
        },
        {
          "target": "stdlib.zoneinfo.get",
          "type": "calls"
        },
        {
          "target": "stdlib.zoneinfo.TypeError",
          "type": "calls"
        },
        {
          "target": "stdlib.zoneinfo.all",
          "type": "calls"
        },
        {
          "target": "stdlib.zoneinfo.ValueError",
          "type": "calls"
        },
        {
          "target": "stdlib.zoneinfo._parse_python_tzpath",
          "type": "calls"
        },
        {
          "target": "stdlib.zoneinfo._parse_python_tzpath",
          "type": "calls"
        },
        {
          "target": "stdlib.zoneinfo.map",
          "type": "calls"
        },
        {
          "target": "stdlib.zoneinfo._get_invalid_paths_message",
          "type": "calls"
        },
        {
          "target": "stdlib.zoneinfo.get_config_var",
          "type": "calls"
        },
        {
          "target": "stdlib.zoneinfo.type",
          "type": "calls"
        }
      ]
    }
  ]
}